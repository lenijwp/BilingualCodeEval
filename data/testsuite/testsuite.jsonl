{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "zh_prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements", "rules": "def rules(n):\n    import numpy\n    import random\n    import copy\n\n    def takeSecond(elem):\n        return elem[1]\n    def swap(t1,t2):\n        return t2,t1\n\n    numbers = random.sample(range(0, n), n)\n    numbers = [x*0.01 for x in numbers]\n\n    tmp_ = copy.deepcopy(numbers)\n    tmp_.sort()\n\n\n    abs_list = []\n    for i in range(n-1):\n        abs_list.append([i,abs(tmp_[i+1] - tmp_[i])])\n    abs_list.sort(key=takeSecond)\n    \n    threshold = random.uniform(0,abs_list[1][1])\n    \n    for i in range(int(n/2)):\n        if (numbers[i] == tmp_[abs_list[0][0]]) or numbers[i] == (tmp_[abs_list[0][0]+1]):\n            numbers[i], numbers[n-i] = swap(numbers[i], numbers[n-i])\n\n    return {\n        'numbers' : numbers,\n        'threshold' : threshold\n    }", "max_n": "10000"}
{"task_id": "HumanEval/7", "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "zh_prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "canonical_solution": "    return [x for x in strings if substring in x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring", "rules": "def rules(n):\n    import random\n    \n    base_str ='aaaaaabbbbbccccdddeeefghig'\n    length =len(base_str) -1\n    str_list = []\n    for i in range(n):\n        m = random.randint(3, 10)\n        random_str =''\n        for j in range(m):\n            random_str +=base_str[random.randint(0, length)]\n        str_list.append(random_str)\n    \n    if random.randint(0,1)==0:\n        tar = ''\n        for j in range(random.randint(1, 5)):\n            tar +=base_str[random.randint(0, length)]\n    else:\n        tar = str_list[random.randint(0, n-1)]\n        tar = tar[0:random.randint(1, len(tar)-1)]\n    \n    return {\n        'strings': str_list,\n        'substring': tar\n    }", "max_n": "50000"}
{"task_id": "HumanEval/16", "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n", "zh_prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n", "canonical_solution": "    return len(set(string.lower()))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters", "rules": "def rules(n):\n    import random\n    \n    base_str ='ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz'\n    length =len(base_str) -1\n    random_str = ''\n    for i in range(n):\n        random_str +=base_str[random.randint(0, length)]\n    \n    return {\n        'string': random_str\n    }", "max_n": "100000"}
{"task_id": "HumanEval/18", "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n", "zh_prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n", "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times", "rules": "def rules(n):\n    import random\n    \n    base_str ='aaabbccdefghigk'\n    length =len(base_str) -1\n    random_str = ''\n    for i in range(n):\n        random_str +=base_str[random.randint(0, length)]\n    \n    substring = ''\n    for i in range(random.randint(1, min(5,n))):\n        substring +=base_str[random.randint(0, length)]\n    \n    return {\n        'string': random_str,\n        'substring': substring\n    }", "max_n": "10000"}
{"task_id": "HumanEval/24", "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n", "zh_prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n", "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor", "rules": "def rules(n):\n    import random\n\n    res = random.randint(int(0.99*n), int(1.01*n))\n    \n    return {\n        'n': res\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/25", "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n", "zh_prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n", "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize", "rules": "def rules(n):\n    import random\n\n    res = random.randint(int(0.99*n), int(1.01*n))\n    \n    return {\n        'n': res\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/26", "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n", "zh_prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n", "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates", "rules": "def rules(n):\n    import random\n\n    res= []\n\n    for i in range(n):\n        res.append(random.randint(0, min(0.6*n, 10000)))\n    \n    return {\n        'numbers': res\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/31", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "zh_prompt": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime", "rules": "def rules(n):\n    import random\n    def sieve_eratosthenes(N):\n        is_prime = [True] * (N + 1)\n        is_prime[0] = is_prime[1] = False\n        p = 2\n\n        while p * p <= N:\n            if is_prime[p]:\n                for i in range(p * p, N + 1, p):\n                    is_prime[i] = False\n            p += 1\n\n        primes = []\n        for i in range(N):\n            if i>2 and i>int(0.99*n) and i<int(1.01*n) and is_prime[i]==True:\n                primes.append(i)\n        return primes\n    N = random.randint(int(0.99*n), int(1.01*n))\n    pris = sieve_eratosthenes(N)\n    if random.randint(0,2)!=0 or len(pris)==0:\n        res=random.randint(int(0.99*n), int(1.01*n))\n    else:\n        res = pris[random.randint(0, len(pris)-1)]\n    \n    return {\n        'n': res\n    }", "max_n": "50000"}
{"task_id": "HumanEval/34", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "zh_prompt": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "canonical_solution": "    return sorted(list(set(l)))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique", "rules": "def rules(n):\n    import random\n\n    res= []\n\n    for i in range(n):\n        res.append(random.randint(0, min(0.6*n, 2000)))\n    \n    return {\n        'numbers': res\n    }", "max_n": "30000"}
{"task_id": "HumanEval/35", "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n", "zh_prompt": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n", "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element", "rules": "def rules(n):\n    import random\n    res= []\n    for i in range(n):\n        if random.randint(0,1)==0:\n            flag=-1\n        else:\n            flag=1\n        res.append(random.randint(0, min(0.6*n, 2000))*flag)\n    return {\n        'l': res\n    }", "max_n": "30000"}
{"task_id": "HumanEval/36", "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n", "zh_prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n", "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz", "rules": "def rules(n):\n    import random\n\n    res = random.randint(int(0.99*n), int(1.01*n))\n    \n    return {\n        'n': res\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/43", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "zh_prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero", "rules": "def rules(n):\n    import random\n\n    res= []\n\n    for i in range(n):\n        if random.randint(0,1)==0:\n            flag=-1\n        else:\n            flag=1\n        \n        res.append(random.randint(0, max(0.5*n, 200))*flag)\n    \n    return {\n        'l': res\n    }", "max_n": "30000"}
{"task_id": "HumanEval/52", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "zh_prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold", "rules": "def rules(n):\n    import random\n\n    res= []\n\n    for i in range(n):\n        if random.randint(0,1)==0:\n            flag=-1\n        else:\n            flag=1\n        \n        res.append(random.randint(0, 0.7*n)*flag)\n    \n    t = random.randint(0, n-1)\n    \n    return {\n        'l': res,\n        't': t\n    }", "max_n": "100000"}
{"task_id": "HumanEval/54", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "zh_prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "canonical_solution": "    return set(s0) == set(s1)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars", "rules": "def rules(n):\n    import random\n    \n    base_str ='ZXCVBNMASDFGHJKLPOIUYTRREWQ1234567890qwertyuiopasdfghjklmnbvcxz'\n    length =len(base_str) -1\n    s1 = ''\n    for i in range(n):\n        s1 +=base_str[random.randint(0, length)]\n    \n    s2 = ''\n    for i in range(n):\n        s2 +=base_str[random.randint(0, length)]\n    \n    return {\n        's0': s1,\n        's1': s2\n    }", "max_n": "30000"}
{"task_id": "HumanEval/58", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "zh_prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common", "rules": "def rules(n):\n    import random\n    \n    l1=[]\n    l2=[]\n    for i in range(n):\n        l1.append(random.randint(0, n))\n        l2.append(random.randint(0, n))\n    \n    return {\n        'l1': l1,\n        's2': l2\n    }", "max_n": "30000"}
{"task_id": "HumanEval/59", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "zh_prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor", "rules": "def rules(n):\n    import random\n\n    res = random.randint(int(0.99*n), int(1.01*n))\n    \n    return {\n        'n': res\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/60", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "zh_prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "canonical_solution": "    return sum(range(n + 1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n", "rules": "def rules(n):\n    import random\n\n    res = random.randint(int(0.99*n), int(1.01*n))\n    \n    return {\n        'n': res\n    }", "max_n": "10000000"}
{"task_id": "HumanEval/70", "prompt": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n", "zh_prompt": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n", "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list", "rules": "def rules(n):\n    import random\n    res= []\n    for i in range(n):\n        if random.randint(0,1)==0:\n            flag=-1\n        else:\n            flag=1\n        \n        res.append(random.randint(0, 0.7*n)*flag)\n    \n    return {\n        'lst':res\n    }", "max_n": "100000"}
{"task_id": "HumanEval/73", "prompt": "\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n", "zh_prompt": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n", "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change", "rules": "def rules(n):\n    import random\n    import numpy\n    res= []\n    for i in range(n):\n        res.append(random.randint(0, int(0.1*n)))\n    \n    return {\n        'arr': res\n    }", "max_n": "100000"}
{"task_id": "HumanEval/82", "prompt": "\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "zh_prompt": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length", "rules": "def rules(n):\n    import random\n    \n    base_str ='ZXCVBNMASDF'\n    length =len(base_str) -1\n    s1 = ''\n    for i in range(n):\n        s1 +=base_str[random.randint(0, length)]\n    return {\n        'string':s1\n    }", "max_n": "1000000"}
{"task_id": "HumanEval/90", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "zh_prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest", "rules": "def rules(n):\n    import random\n    lst = []\n    for i in range(n):\n        lst.append(random.randint(0, n))\n    return {\n        'lst':lst\n    }", "max_n": "10000"}
{"task_id": "HumanEval/94", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "zh_prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd", "rules": "def rules(n):\n    import random\n    lst = []\n    def sieve_eratosthenes(n):\n        is_prime = [True] * (n + 1)\n        is_prime[0] = is_prime[1] = False\n        p = 2\n\n        while p * p <= n:\n            if is_prime[p]:\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n\n        primes = [i for i, prime in enumerate(is_prime) if prime]\n        return primes\n    pris = sieve_eratosthenes(n)\n    for i in range(n):\n        if random.randint(0,1)==0:\n            lst.append(random.randint(0, n))\n        else:\n            lst.append(pris[random.randint(0, len(pris)-1)]\n    return {\n        'lst':lst\n    }", "max_n": "50000"}
{"task_id": "HumanEval/103", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "zh_prompt": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg", "rules": "def rules(n):\n    m = 1\n    return {\n        'n': 1,\n        'm': n\n    }", "max_n": "100000"}
{"task_id": "HumanEval/109", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n", "zh_prompt": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball", "rules": "def rules(n):\n    import random\n    import numpy\n    res= []\n    for i in range(n):\n        res.append(i)\n    random.shuffle(res)\n    res = numpy.array(res)\n    \n    return {\n        'arr': res\n    }", "max_n": "30000"}
{"task_id": "HumanEval/114", "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n", "zh_prompt": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n", "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum", "rules": "def rules(n):\n    import random\n    res= []\n    for i in range(n):\n        if random.randint(0,2)==0:\n            flag=-1\n        else:\n            flag=1\n        res.append(random.randint(0, min(0.6*n, 200))*flag)\n    return {\n        'nums': res\n    }", "max_n": "30000"}
{"task_id": "MBPP/12", "prompt": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    Write a function to sort a given matrix M in ascending order according to the sum of its rows.\n    '''", "zh_prompt": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''", "canonical_solution": "    result = sorted(M, key=sum) \n    return result", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    assert candidate([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n    assert candidate([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]", "entry_point": "sort_matrix", "rules": "def rules(n):\n    import random\n    M = [[random.randint(-n,n) for i in range(n)] for j in range(n)]\n    return {\n        'M':M\n    }", "max_n": "1000"}
{"task_id": "MBPP/24", "prompt": "def binary_to_decimal(binum): \n    '''\n    Write a function to convert the given binary number to its decimal equivalent.\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''", "zh_prompt": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''", "canonical_solution": "    binary1 = binum \n    decimal, i, n = 0, 0, 0\n    while(binum != 0): \n        dec = binum % 10 \n        decimal = decimal + dec * pow(2, i) \n        binum = binum//10 \n        i += 1 \n    return (decimal)", "test": "def check(candidate):\n    assert candidate(100) == 4\n    assert candidate(1011) == 11\n    assert candidate(1101101) == 109", "entry_point": "binary_to_decimal", "rules": "def rules(n):\n    import random\n    bi = random.randint(int(0.99*n), int(1.01*n))\n    return {\n        'binum': bi\n    }", "max_n": "100000000"}
{"task_id": "MBPP/27", "prompt": "import re \ndef remove(strlist):\n    '''\n    Write a python function to remove all digits from a list of strings.\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''", "zh_prompt": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''", "canonical_solution": "    pattern = '[0-9]' \n    strlist = [re.sub(pattern, '', i) for i in strlist] \n    return strlist", "test": "def check(candidate):\n    assert candidate(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']\n    assert candidate(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']\n    assert candidate(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']", "entry_point": "remove", "rules": "def rules(n):\n    import random\n    num = '0123456789'\n    char = 'abcdefghijklmnopqrstuvwxyz'\n    strlist = []\n    for i in range(n):\n        strs = ''\n        for j in range(10):\n            strs+=random.choice(char)+random.choice(num)\n        strlist.append(strs)\n\n    return {\n        'strlist': strlist\n    }", "max_n": "10000"}
{"task_id": "MBPP/42", "prompt": "def find_Sum(arr): \n    '''\n    Write a python function to find the sum of repeated elements in a given array.  \n    If one element is repeated more than once, the sum should be counted for multiple times.\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''", "zh_prompt": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''", "canonical_solution": "    return sum([x for x in arr if arr.count(x) > 1])", "test": "def check(candidate):\n    assert candidate([1, 1, 2]) == 2\n    assert candidate([1,2,3,1,1,4,5,6]) == 3\n    assert candidate([4, 5, 7, 5, 4, 8]) == 18\n    assert candidate([1, 1, 1, 1, 1, 1]) == 6", "entry_point": "find_Sum", "rules": "def rules(n):\n    import random\n    res = []\n    for i in range(n):\n        res.append(random.randint(1, int(n/2)))\n    return {\n        'arr': res\n    }", "max_n": "10000"}
{"task_id": "MBPP/149", "prompt": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''", "zh_prompt": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''", "canonical_solution": "    n = len(arr)\n    dp = [1 for i in range(n)] \n    for i in range(n): \n        for j in range(i): \n            if ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \n                dp[i] = max(dp[i], dp[j]+1) \n    result = 1\n    for i in range(n): \n        if (result < dp[i]): \n            result = dp[i] \n    return result", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 3, 2]) == 6\n    assert candidate([10, 9, 4, 5, 4, 8, 6]) == 3\n    assert candidate([1, 2, 3, 2, 3, 7, 2, 1]) == 7", "entry_point": "max_len_sub", "rules": "def rules(n):\n    import random\n    res = []\n    res.append(random.randint(1, int(n/2)))\n    for i in range(n):\n        if random.randint(0, 4) == 0:\n            res.append(res[-1]+1)\n        elif random.randint(0, 4) == 1:\n            res.append(res[-1]-1)\n        else:\n            res.append(random.randint(1, int(n/2)))\n    return {\n        'arr': res\n    }", "max_n": "3000"}
{"task_id": "MBPP/v522", "prompt": "def lbs(arr): \n    '''\n    Write a function to find the longest bitonic subsequence for the given array.\n    A bitonic subsequence is a subsequence of an array where the elements are first sorted in an increasing order, then in a decreasing order.\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''", "zh_prompt": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''", "canonical_solution": "    n = len(arr) \n    lis = [1 for i in range(n+1)] \n    for i in range(1 , n): \n        for j in range(0 , i): \n            if ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n                lis[i] = lis[j] + 1 \n    lds = [1 for i in range(n+1)] \n    for i in reversed(range(n-1)): \n        for j in reversed(range(i-1 ,n)): \n            if(arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1 \n    maximum = lis[0] + lds[0] - 1 \n    for i in range(1 , n): \n        maximum = max((lis[i] + lds[i]-1), maximum) \n    return maximum", "test": "def check(candidate):\n    assert candidate([0 , 8 , 4, 12, 2, 10 , 6 , 14 , 1 , 9 , 5 , 13, 3, 11 , 7 , 15]) == 7\n    assert candidate([1, 11, 2, 10, 4, 5, 2, 1]) == 6\n    assert candidate([80, 60, 30, 40, 20, 10]) == 5", "entry_point": "lbs", "rules": "def rules(n):\n    import random\n    res = []\n    for i in range(n):\n        res.append(random.randint(1, n))\n    return {\n        'arr': res\n    }", "max_n": "3000"}
{"task_id": "MBPP/v564", "prompt": "def count_Pairs(arr): \n    '''\n    Write a python function to count unequal element pairs from the given array.\n    A unequal element pair means a pair (arr[i], arr[j]) where i < j and arr[i] != arr[j].\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''", "zh_prompt": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''", "canonical_solution": "    n = len(arr)\n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt", "test": "def check(candidate):\n    assert candidate([1,2,1]) == 2\n    assert candidate([1,1,1,1]) == 0\n    assert candidate([1,2,3,4,5]) == 10", "entry_point": "count_Pairs", "rules": "def rules(n):\n    import random\n    res = []\n    for i in range(n):\n        res.append(random.randint(1, int(n**0.5)))\n    return {\n        'arr': res\n    }", "max_n": "3000"}
{"task_id": "MBPP/train620", "prompt": "def largest_subset(arr): \n    '''\n    Write a function to find the largest size of a subset where each pair is divisible.\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''", "zh_prompt": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''", "canonical_solution": "    n = len(arr)\n    dp = [0 for i in range(n)] \n    dp[n - 1] = 1; \n    for i in range(n - 2, -1, -1): \n        mxm = 0; \n        for j in range(i + 1, n): \n            if arr[j] % arr[i] == 0 or arr[i] % arr[j] == 0: \n                mxm = max(mxm, dp[j]) \n        dp[i] = 1 + mxm \n    return max(dp)", "test": "def check(candidate):\n    assert candidate([1, 3, 6, 13, 17, 18]) == 4\n    assert candidate([10, 5, 3, 15, 20]) == 3\n    assert candidate([18, 1, 3, 6, 13, 17]) == 4", "entry_point": "largest_subset", "rules": "def rules(n):\n    import random\n    res = []\n    for i in range(n):\n        res.append(random.randint(1, int(n**0.5)))\n    return {\n        'arr': res\n    }", "max_n": "3000"}
{"task_id": "MBPP/train689", "prompt": "def min_jumps(arr): \n    '''\n    write a function to find the minimum number of jumps to reach the end of the array from the fisrt element. For the given array 'arr' of integers, each element represents the max number of steps that can be made forward from that element.\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''", "zh_prompt": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''", "canonical_solution": "    n = len(arr)\n    jumps = [0 for i in range(n)] \n    jumps[0] = 0 \n    for i in range(1, n): \n        jumps[i] = float('inf') \n        for j in range(i): \n            if (i <= j + arr[j]) and (jumps[j] != float('inf')): \n                jumps[i] = min(jumps[i], jumps[j] + 1) \n                break \n    return jumps[n-1]", "test": "def check(candidate):\n    assert candidate([1, 3, 6, 1, 0, 9]) == 3\n    assert candidate([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10", "entry_point": "min_jumps", "rules": "def rules(n):\n    import random\n    res = []\n    for i in range(n):\n        res.append(random.randint(1, int(n**0.5)))\n    return {\n        'arr': res\n    }", "max_n": "3000"}
{"task_id": "leetcode/21", "prompt": "def mergeTwoLists(list1, list2):\n    '''\n    Given two sorted list 'list1' and 'list2', merge them into one sorted list.\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res", "zh_prompt": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res", "canonical_solution": "    list_res = list1 + list2\n    list_res.sort()\n    return list_res", "test": "def check(candidate):\n    assert candidate([1,2,4], [1,3,4]) == [1, 1, 2, 3, 4, 4]\n    assert candidate([], []) == []\n    assert candidate([1,1,2],[3]) == [1,1,2,3]", "entry_point": "mergeTwoLists", "rules": "def rules(n):\n    import random\n    list1 = []\n    list2 = []\n    for i in range(n):\n        list1.append(random.randint(1, int(n/2)))\n        list2.append(random.randint(1, int(n/2)))\n    return {\n        'list1': list1,\n        'list2': list2\n    }", "max_n": "100000"}
{"task_id": "leetcode/35", "prompt": "def searchInsert(nums, target):\n    '''\n    Given a sorted array 'nums' of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''", "zh_prompt": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''", "canonical_solution": "    if target in nums:\n        return nums.index(target)\n    else:\n        nums.append(target)\n        nums.sort()\n        return nums.index(target)", "test": "def check(candidate):\n    assert candidate([1,3,5,6], 5) == 2\n    assert candidate([1,3,5,6], 2) == 1\n    assert candidate([1,3,5,6], 7) == 4\n    assert candidate([1,3,5,6], 0) == 0", "entry_point": "searchInsert", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(1, int(n/2)))\n    nums.sort()\n    return {\n        'nums': nums,\n        'target': random.randint(1, int(n/2))\n    }", "max_n": "20000"}
{"task_id": "leetcode/217", "prompt": "def containsDuplicate(nums):\n    '''\n    Given an integer array 'nums', return true if any value appears at least twice in the array, and return false if every element is distinct.\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''", "zh_prompt": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''", "canonical_solution": "    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "test": "def check(candidate):\n    assert candidate([1,2,3,1]) == True\n    assert candidate([1,2,3,4]) == False\n    assert candidate([1,1,1,3,3,4,3,2,4,2]) == True", "entry_point": "containsDuplicate", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(0, int(n**2)))\n    return {\n        'nums': nums\n    }", "max_n": "10000"}
{"task_id": "leetcode/697", "prompt": "import collections\ndef findShortestSubArray(nums):\n    '''\n    Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\n    Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''", "zh_prompt": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''", "canonical_solution": "    nums_dict = collections.Counter(nums)\n    max_count = max(nums_dict.values())\n    max_count_list = []\n    for i in nums_dict:\n        if nums_dict[i] == max_count:\n            max_count_list.append(i)\n    min_length = len(nums)\n    for i in max_count_list:\n        min_length = min(min_length, len(nums) - nums[::-1].index(i) - nums.index(i))\n    return min_length", "test": "def check(candidate):\n    assert candidate([1,2,2,3,1]) == 2\n    assert candidate([1,2,2,3,1,4,2]) == 6\n    assert candidate([1,2,2,3,1,4,2,1,1,1,1,1,1,1,1,1,1,1]) == 18", "entry_point": "findShortestSubArray", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(0, min(int(n/2),1000)))\n    return {\n        'nums': nums\n    }", "max_n": "3000"}
{"task_id": "leetcode/832", "prompt": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''", "zh_prompt": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''", "canonical_solution": "    for i in range(len(image)):\n        image[i] = image[i][::-1]\n        for j in range(len(image[i])):\n            image[i][j] = 1 - image[i][j]\n    return image", "test": "def check(candidate):\n    assert candidate([[1,1,0],[1,0,1],[0,0,0]]) == [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    assert candidate([[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]) == [[1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 0]]", "entry_point": "flipAndInvertImage", "rules": "def rules(n):\n    import random\n    image = []\n    for i in range(n):\n        image.append([])\n        for j in range(n):\n            image[i].append(random.randint(0,1))\n    return {\n        'image': image\n    }", "max_n": "3000"}
{"task_id": "leetcode/300", "prompt": "def lengthOfLIS(nums):\n    '''\n    Given an integer array nums, return the length of the longest strictly increasing subsequence.\n    A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n    For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''", "zh_prompt": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''", "canonical_solution": "    if len(nums) == 0:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)", "test": "def check(candidate):\n    assert candidate([10,9,2,5,3,7,101,18]) == 4\n    assert candidate([7,7,7,7,7,7,7]) == 1\n    assert candidate([0,1,0,3,2,3]) == 4\n    assert candidate([7,7,7,7,7,7,8]) == 2", "entry_point": "lengthOfLIS", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(0, n))\n    return {\n        'nums': nums\n    }", "max_n": "3000"}
{"task_id": "leetcode/414", "prompt": "def thirdMax(nums):\n    '''\n    Given an integer array nums, return the third maximum number in this array. If the third maximum does not exist, return the maximum number.\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''", "zh_prompt": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''", "canonical_solution": "    nums = list(set(nums))\n    nums.sort()\n    if len(nums) < 3:\n        return nums[-1]\n    else:\n        return nums[-3]", "test": "def check(candidate):\n    assert candidate([3,2,1]) == 1\n    assert candidate([1,2,2,1]) == 2\n    assert candidate([1,2]) == 2\n    assert candidate([2,2,3,1]) == 1", "entry_point": "thirdMax", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(0, n))\n    return {\n        'nums': nums\n    }", "max_n": "10000"}
{"task_id": "leetcode/961", "prompt": "import collections\ndef repeatedNTimes(nums):\n    '''\n    In a array nums of size 2 * n, there are n + 1 unique elements, and exactly one of these elements is repeated n times.\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''", "zh_prompt": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''", "canonical_solution": "    nums_dict = collections.Counter(nums)\n    for i in nums_dict:\n        if nums_dict[i] == len(nums)/2:\n            return i", "test": "def check(candidate):\n    assert candidate([1,2,3,3]) == 3\n    assert candidate([2,1,2,5,3,2]) == 2\n    assert candidate([5,1,5,2,5,3,5,4]) == 5", "entry_point": "repeatedNTimes", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(i)\n        nums.append(n)\n    random.shuffle(nums)\n    return {\n        'nums': nums\n    }", "max_n": "10000"}
{"task_id": "leetcode/747", "prompt": "def dominantIndex(nums):\n    '''\n    You are given an integer array nums where the largest integer is unique.\n    Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.\n    For example, if nums = [1, 2, 3, 4], the largest element is 4, and it is at least twice as much as every other number in the array, so return 3.\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''", "zh_prompt": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''", "canonical_solution": "    if len(nums) == 1:\n        return 0\n    max_num = max(nums)\n    max_index = nums.index(max_num)\n    nums.remove(max_num)\n    if max_num >= 2 * max(nums):\n        return max_index\n    else:\n        return -1", "test": "def check(candidate):\n    assert candidate([3,6,1,0]) == 1\n    assert candidate([1,2,3,4]) == -1\n    assert candidate([1,0]) == 0", "entry_point": "dominantIndex", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n-1):\n        nums.append(random.randint(0, n))\n    nums.append(random.randint(n, 3*n))\n    return {\n        'nums': nums\n    }", "max_n": "10000"}
{"task_id": "leetcode/1200", "prompt": "def minimumAbsDifference(arr):\n    '''\n    Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\n    Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows,\n    a, b are from arr; a < b; b - a equals to the minimum absolute difference of any two elements in arr.\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''", "zh_prompt": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''", "canonical_solution": "    arr.sort()\n    min_diff = arr[1] - arr[0]\n    for i in range(len(arr)-1):\n        min_diff = min(min_diff, arr[i+1] - arr[i])\n    res = []\n    for i in range(len(arr)-1):\n        if arr[i+1] - arr[i] == min_diff:\n            res.append([arr[i], arr[i+1]])\n    return res", "test": "def check(candidate):\n    assert candidate([4,2,1,3]) == [[1, 2], [2, 3], [3, 4]]\n    assert candidate([1,3,6,10,15]) == [[1, 3]]\n    assert candidate([3,8,-10,23,19,-4,-14,27]) == [[-14, -10], [19, 23], [23, 27]]", "entry_point": "minimumAbsDifference", "rules": "def rules(n):\n    import random\n    arr = []\n    tmp = []\n    for i in range(n**1.5):\n        tmp.append(i)\n    arr = random.sample(tmp, n)\n    return {\n        'arr': arr\n    }", "max_n": "10000"}
{"task_id": "leetcode/1385", "prompt": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    Given two integer arrays 'arr1' and 'arr2', and the integer 'd', return the distance value between the two arrays.\n    The distance value is defined as the number of elements 'arr1[i]' such that there is not any element 'arr2[j]' where |arr1[i]-arr2[j]| <= d.\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''", "zh_prompt": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''", "canonical_solution": "    res = 0\n    for i in arr1:\n        flag = True\n        for j in arr2:\n            if abs(i-j) <= d:\n                flag = False\n                break\n        if flag:\n            res += 1\n    return res", "test": "def check(candidate):\n    assert candidate([4,5,8], [10,9,1,8], 2) == 2\n    assert candidate([1,4,2,3], [-4,-3,6,10,20,30], 3) == 2\n    assert candidate([2,1,100,3], [-5,-2,10,-3,7], 6) == 1", "entry_point": "findTheDistanceValue", "rules": "def rules(n):\n    import random\n    import math\n    arr1 = []\n    arr2 = []\n    for i in range(n):\n        arr1.append(random.randint(0, n))\n        arr2.append(random.randint(0, n))\n    d = random.randint(0, int(math.log(n+2)))\n    return {\n        'arr1': arr1,\n        'arr2': arr2,\n        'd': d\n    }", "max_n": "5000"}
{"task_id": "leetcode/349", "prompt": "def intersection(nums1, nums2):\n    '''\n    Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you must return the result in ascebding order.\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''", "zh_prompt": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''", "canonical_solution": "    res = []\n    for i in nums1:\n        if i in nums2 and i not in res:\n            res.append(i)\n    return res", "test": "def check(candidate):\n    assert candidate([1,2,2,1], [2,2]) == [2]\n    assert candidate([4,9,5], [9,4,9,8,4]) == [4,9]\n    assert candidate([1,2,3,4,5,6,7,8,9], [2,4,6,8,10]) == [2,4,6,8]", "entry_point": "intersection", "rules": "def rules(n):\n    import random\n    nums1 = []\n    nums2 = []\n    for i in range(n):\n        nums1.append(random.randint(0, 2*n))\n        nums2.append(random.randint(0, 2*n))\n    return {\n        'nums1': nums1,\n        'nums2': nums2\n    }", "max_n": "5000"}
{"task_id": "leetcode/1491", "prompt": "def average(salary):\n    '''\n    Given an array of unique integers salary where salary[i] is the salary of the employee i.\n    Return the average salary in a rounded integer of employees excluding the minimum and maximum salary.\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''", "zh_prompt": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''", "canonical_solution": "    salary.sort()\n    salary.pop()\n    salary.pop(0)\n    return int(sum(salary)/len(salary))", "test": "def check(candidate):\n    assert candidate([4000,3000,1000,2000]) == 2500\n    assert candidate([1000,2000,3000]) == 2000\n    assert candidate([6000,5000,4000,3000,2000,1000]) == 3500", "entry_point": "average", "rules": "def rules(n):\n    import random\n    salary = []\n    for i in range(n):\n        salary.append(random.randint(0, 2*n))\n    return {\n        'salary': salary\n    }", "max_n": "10000"}
{"task_id": "leetcode/561", "prompt": "def arrayPairSum(nums):\n    '''\n    Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) \n    such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''", "zh_prompt": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''", "canonical_solution": "    nums.sort()\n    res = 0\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            res += nums[i]\n    return res", "test": "def check(candidate):\n    assert candidate([1,4,3,2]) == 4\n    assert candidate([6,2,6,5,1,2]) == 9\n    assert candidate([1,1,1,1,1,1]) == 3", "entry_point": "arrayPairSum", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(2*n):\n        nums.append(random.randint(0, n))\n    return {\n        'nums': nums\n    }", "max_n": "10000"}
{"task_id": "leetcode/209", "prompt": "def minSubArrayLen(target, nums):\n    '''\n    Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] \n    of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''", "zh_prompt": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''", "canonical_solution": "    if sum(nums) < target:\n        return 0\n    min_length = len(nums)\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if sum(nums[i:j+1]) >= target:\n                min_length = min(min_length, j-i+1)\n                break\n    return min_length", "test": "def check(candidate):\n    assert candidate(7, [2,3,1,2,4,3]) == 2\n    assert candidate(4, [1,4,4]) == 1\n    assert candidate(11, [1,1,1,1,1,1,1,1]) == 0", "entry_point": "minSubArrayLen", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(2*n):\n        nums.append(random.randint(1, n))\n    return {\n        'target': random.randint(n, 2*n),\n        'nums': nums\n    }", "max_n": "3000"}
{"task_id": "leetcode/1", "prompt": "def twoSum(nums, target):\n    '''\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    Return the two index in ascending order.\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''", "zh_prompt": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''", "canonical_solution": "    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i]+nums[j] == target:\n                return [i,j]", "test": "def check(candidate):\n    assert candidate([3,2,4], 6) == [1, 2]\n    assert candidate([3,3], 6) == [0, 1]\n    assert candidate([1,2,3,4,5,6,7,8,9], 17) == [7, 8]", "entry_point": "twoSum", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n-2):\n        nums.append(random.randint(0, n))\n    nums.append(n+2)\n    nums.append(n+3)\n    random.shuffle(nums)\n    tar = 2*n+5\n    return {\n        'nums': nums,\n        'target': tar\n    }", "max_n": "3000"}
{"task_id": "leetcode/409", "prompt": "def longestPalindrome(s):\n    '''\n    Given a string s which consists of lowercase letters, return the length of the longest palindrome that can be built with those letters.\n    Letters are case sensitive, for example, \"Aa\" is not considered a palindrome here.\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''", "zh_prompt": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''", "canonical_solution": "    s_dict = collections.Counter(s)\n    res = 0\n    flag = False\n    for i in s_dict:\n        if s_dict[i] % 2 == 0:\n            res += s_dict[i]\n        else:\n            res += s_dict[i] - 1\n            flag = True\n    if flag:\n        res += 1\n    return res", "test": "def check(candidate):\n    assert candidate(\"abccccdd\") == 7\n    assert candidate(\"a\") == 1\n    assert candidate(\"bb\") == 2", "entry_point": "longestPalindrome", "rules": "def rules(n):\n    import random\n    s=''\n    for i in range(n):\n        s += chr(random.randint(97, 122))\n    return {\n        's': s\n    }", "max_n": "3000"}
{"task_id": "leetcode/121", "prompt": "def maxProfit(prices):\n    '''\n    You are given an array prices where prices[i] is the price of a given stock on the ith day.\n    You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n    Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''", "zh_prompt": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''", "canonical_solution": "    max_profit = 0\n    for i in range(len(prices)):\n        for j in range(i+1, len(prices)):\n            max_profit = max(max_profit, prices[j]-prices[i])\n    return max_profit", "test": "def check(candidate):\n    assert candidate([7,1,5,3,6,4]) == 5\n    assert candidate([7,6,4,3,1]) == 0\n    assert candidate([1,2,3,4,5,6,7,8,9]) == 8", "entry_point": "maxProfit", "rules": "def rules(n):\n    import random\n    nums = []\n    for i in range(n):\n        nums.append(random.randint(0, n))\n    return {\n        'prices': nums\n    }", "max_n": "3000"}

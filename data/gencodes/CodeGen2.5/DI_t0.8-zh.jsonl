{"task_id": "HumanEval/0", "completion": "    for x in numbers:\n        for y in numbers[numbers.index(x) + 1:]:\n            if abs(x - y) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for x in numbers:\n        for y in numbers[numbers.index(x) + 1:]:\n            if abs(x - y) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    :param numbers:\n    :param threshold:\n    :return:\n    \"\"\"\n    return list_comprehensions.has_close_elements2(numbers, threshold)\n\n\ndef has_close_elements3(numbers: List[float], threshold: float) -> bool", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    :param numbers:\n    :param threshold:\n    :return:\n    \"\"\"\n    return list_comprehensions.has_close_elements2(numbers, threshold)\n\n\ndef has_close_elements3(numbers: List[float], threshold: float) -> bool"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return any(abs(x - y) < threshold for x in numbers for y in numbers[:i])\n\n\nif __name__ == '__main__':\n    print(has_close_elements2([1.0, 2.", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return any(abs(x - y) < threshold for x in numbers for y in numbers[:i])\n\n\nif __name__ == '__main__':\n    print(has_close_elements2([1.0, 2."}
{"task_id": "HumanEval/0", "completion": "    if len(numbers) < 2:\n        return False\n\n    pairs = itertools.combinations(numbers, 2)\n    return any(a - b < threshold for a, b in pairs)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### [欧几里得距离](https://leetcode-cn.com/problems/euclidian-", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    pairs = itertools.combinations(numbers, 2)\n    return any(a - b < threshold for a, b in pairs)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### [欧几里得距离](https://leetcode-cn.com/problems/euclidian-"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef print_close_elements(numbers: List[float], threshold: float) -> None:\n    \"\"\" 在给定的数字列表中，输出距离小于给定阈值的所有数字 \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                print(f'{numbers[i]} and {numbers[j]}')\n\n\nif __name__ == '__main__':\n    print_close_elements([1.1, 2.0, 2.2, 3.0, 4.0, 5.0, 5.1, 5.5, 5.6], 0.3)\n    print_close_elements([1.1, 1", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef print_close_elements(numbers: List[float], threshold: float) -> None:\n    \"\"\" 在给定的数字列表中，输出距离小于给定阈值的所有数字 \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                print(f'{numbers[i]} and {numbers[j]}')\n\n\nif __name__ == '__main__':\n    print_close_elements([1.1, 2.0, 2.2, 3.0, 4.0, 5.0, 5.1, 5.5, 5.6], 0.3)\n    print_close_elements([1.1, 1"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(\"Hello", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(\"Hello"}
{"task_id": "HumanEval/0", "completion": "    return max([ abs(b - a) for a, b in zip(numbers, numbers[1:]) ]) < threshold\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值  \n    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    for i, first in enumerate(numbers):\n        for next_ in numbers[i+1:]:\n            if abs(first - next_) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements3(numbers: List[float], threshold: float) -> bool:\n", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return max([ abs(b - a) for a, b in zip(numbers, numbers[1:]) ]) < threshold\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值  \n    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    for i, first in enumerate(numbers):\n        for next_ in numbers[i+1:]:\n            if abs(first - next_) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements3(numbers: List[float], threshold: float) -> bool:\n"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))  # True\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.5))  # False\n    print(has_close_", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))  # True\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.5))  # False\n    print(has_close_"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            x = numbers[i]\n            y = numbers[j]\n            if x - y < threshold and y - x < threshold:\n                return True\n    return False\n\n\ndef get_close_elements(numbers: List[float], threshold: float) -> List[List[float]]:\n    \"\"\" 返回在给定的数字列表中，符合两个数字的距离小于给定的阈值的元素的索引    >>> get_close_elements([1.0, 2.0, 3.0], 0.5)\n    []\n    \"\"\"\n    res = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            x = numbers[i]\n            y = numbers[j]\n            if x - y < threshold and y - x < threshold:\n                res.append([x, y])\n    return res\n\n\ndef remove_close_elements", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            x = numbers[i]\n            y = numbers[j]\n            if x - y < threshold and y - x < threshold:\n                return True\n    return False\n\n\ndef get_close_elements(numbers: List[float], threshold: float) -> List[List[float]]:\n    \"\"\" 返回在给定的数字列表中，符合两个数字的距离小于给定的阈值的元素的索引    >>> get_close_elements([1.0, 2.0, 3.0], 0.5)\n    []\n    \"\"\"\n    res = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            x = numbers[i]\n            y = numbers[j]\n            if x - y < threshold and y - x < threshold:\n                res.append([x, y])\n    return res\n\n\ndef remove_close_elements"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\ndef filter_by_substrings(strings: List[str], substrings: List[str]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串列表中的任一字符串的字符串\n    >>> filter_by_substrings([], [])\n    []\n    >>> filter_by_substrings(['abc', 'bacd', 'cde', 'array'], ['a', 'array'])\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if any(substring in s for substring in substrings)]\n\n\ndef filter_by_words_positions(words_list: List[str], words_positions: List[int]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定单词位置列表中的单词的字符串\n    >>> filter_by_words_positions([], [])\n    []\n", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substrings(strings: List[str], substrings: List[str]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串列表中的任一字符串的字符串\n    >>> filter_by_substrings([], [])\n    []\n    >>> filter_by_substrings(['abc', 'bacd', 'cde', 'array'], ['a', 'array'])\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if any(substring in s for substring in substrings)]\n\n\ndef filter_by_words_positions(words_list: List[str], words_positions: List[int]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定单词位置列表中的单词的字符串\n    >>> filter_by_words_positions([], [])\n    []\n"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_pattern(strings: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    筛选输入字符串列表中包含给定模式的字符串。\n    >>> filter_by_pattern([], 'a')\n    []\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if re.search(pattern, string)]\n\n\ndef get_all_strings_in_file(filename: str) -> List[str]:\n    \"\"\"获取给定文件中的所有字符串。\"\"\"\n    with open(filename, 'r', encoding='utf-8') as file:\n        content = file.read()\n        return [string for string in content.split(' ') if string]\n\n\ndef write_all_strings_in_file(strings: List[str], filename: str) -> None:\n    \"\"\"", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_pattern(strings: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    筛选输入字符串列表中包含给定模式的字符串。\n    >>> filter_by_pattern([], 'a')\n    []\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if re.search(pattern, string)]\n\n\ndef get_all_strings_in_file(filename: str) -> List[str]:\n    \"\"\"获取给定文件中的所有字符串。\"\"\"\n    with open(filename, 'r', encoding='utf-8') as file:\n        content = file.read()\n        return [string for string in content.split(' ') if string]\n\n\ndef write_all_strings_in_file(strings: List[str], filename: str) -> None:\n    \"\"\""}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_substring_from_dict(strings_dict: Dict[str, str], substring: str) -> Dict[str, str]:\n    \"\"\" 筛选输入字典中包含给定子串的字符串，返回字典    >>> filter_by_substring_from_dict({'a': 'a', 'b': 'b'}, 'a')\n    {'a': 'a'}\n    \"\"\"\n    return dict(filter(lambda x: substring in x[1], strings_dict.items()))\n\n\ndef filter_by_substring_from_list(string_list: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入列表中包含给定子串的字符串，返回列表    >>> filter_by_substring_from_list(['a', 'b', 'c'], 'a')\n    ['a', 'b']\n    \"\"\"\n    return list(filter(lambda x: substring in x, string_list))\n", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_substring_from_dict(strings_dict: Dict[str, str], substring: str) -> Dict[str, str]:\n    \"\"\" 筛选输入字典中包含给定子串的字符串，返回字典    >>> filter_by_substring_from_dict({'a': 'a', 'b': 'b'}, 'a')\n    {'a': 'a'}\n    \"\"\"\n    return dict(filter(lambda x: substring in x[1], strings_dict.items()))\n\n\ndef filter_by_substring_from_list(string_list: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入列表中包含给定子串的字符串，返回列表    >>> filter_by_substring_from_list(['a', 'b', 'c'], 'a')\n    ['a', 'b']\n    \"\"\"\n    return list(filter(lambda x: substring in x, string_list))\n"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring2([], 'a')\n    []\n    >>> filter_by_substring2(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring not in string]\n\n\ndef filter_by_substring3(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring3([], 'a')\n    []\n    >>> filter_by_substring3(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n   ", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring2([], 'a')\n    []\n    >>> filter_by_substring2(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring not in string]\n\n\ndef filter_by_substring3(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring3([], 'a')\n    []\n    >>> filter_by_substring3(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n   "}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef is_subset(first_set: List[int], second_set: List[int]) -> bool:\n    \"\"\" 判断第一个集合是否是第二个集合的子集    >>> is_subset([1, 2], [1, 2, 3])\n    True\n    >>> is_subset([1, 2], [3, 4])\n    False\n    \"\"\"\n    return all(map(lambda x: x in second_set, first_set))\n\n\ndef count_items(strings: List[str], substring: str) -> int:\n    \"\"\" 统计输入字符串列表中包含给定字符串的字符串数量   >>> count_items([], 'a')\n    0\n    >>> count_items(['abc', 'bacd', 'cde', 'array'], 'a')\n    4\n    \"\"\"\n    return len(filter_by_substring(strings, substring))\n\n\ndef all_are_subsets(first_set: List[int],", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef is_subset(first_set: List[int], second_set: List[int]) -> bool:\n    \"\"\" 判断第一个集合是否是第二个集合的子集    >>> is_subset([1, 2], [1, 2, 3])\n    True\n    >>> is_subset([1, 2], [3, 4])\n    False\n    \"\"\"\n    return all(map(lambda x: x in second_set, first_set))\n\n\ndef count_items(strings: List[str], substring: str) -> int:\n    \"\"\" 统计输入字符串列表中包含给定字符串的字符串数量   >>> count_items([], 'a')\n    0\n    >>> count_items(['abc', 'bacd', 'cde', 'array'], 'a')\n    4\n    \"\"\"\n    return len(filter_by_substring(strings, substring))\n\n\ndef all_are_subsets(first_set: List[int],"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中长度为给定长度的字符串    \n    >>> filter_by_length([], 1)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 3)\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if len(s) == length]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    # strings = ['abc','", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中长度为给定长度的字符串    \n    >>> filter_by_length([], 1)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 3)\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if len(s) == length]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    # strings = ['abc','"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中具有给定长度的字符串    >>> filter_by_length([], 3)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if len(string) == length]\n\n\ndef filter_by_index(strings: List[str], index: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定字符的字符串    >>> filter_by_index([], 'a')\n    []\n    >>> filter_by_index(['abc', 'bacd', 'cde', 'array'], 0)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中具有给定长度的字符串    >>> filter_by_length([], 3)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if len(string) == length]\n\n\ndef filter_by_index(strings: List[str], index: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定字符的字符串    >>> filter_by_index([], 'a')\n    []\n    >>> filter_by_index(['abc', 'bacd', 'cde', 'array'], 0)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中长度等于给定长度的字符串    >>> filter_by_length([], 0)\n    []\n    >>> filter_by_", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_length(strings: List[str], length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表中长度等于给定长度的字符串    >>> filter_by_length([], 0)\n    []\n    >>> filter_by_"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_length(strings: List[str], min_length: int) -> List[str]:\n    \"\"\" 筛选低于给定长度的字符串   >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if len(string) >= min_length]\n\n\nif __name__ == '__main__':\n    strings = ['abc', 'bacd', 'cde', 'array']\n    for filter_func in [filter_by_substring, filter_by_length]:\n        print(filter_func(strings, 'a'))\n        print(filter_func(strings, 4))\n        print()\n```\n\n## 6. 模式\n\n在上面的例子中，我们使用的逻辑都是相同的，但是我们将筛选逻辑应用", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_length(strings: List[str], min_length: int) -> List[str]:\n    \"\"\" 筛选低于给定长度的字符串   >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4)\n    ['abc', 'bacd']\n    \"\"\"\n    return [string for string in strings if len(string) >= min_length]\n\n\nif __name__ == '__main__':\n    strings = ['abc', 'bacd', 'cde', 'array']\n    for filter_func in [filter_by_substring, filter_by_length]:\n        print(filter_func(strings, 'a'))\n        print(filter_func(strings, 4))\n        print()\n```\n\n## 6. 模式\n\n在上面的例子中，我们使用的逻辑都是相同的，但是我们将筛选逻辑应用"}
{"task_id": "HumanEval/7", "completion": "    res = []\n    for i in strings:\n        if substring in i:\n            res.append(i)\n    return res\n\n\ndef filter_by_substring_using_map(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 使用map函数筛选输入字符串列表中包含给定子串的字符串 \"\"\"\n    return list(filter(lambda i: substring in i, strings))\n\n\nif __name__ == '__main__':\n    print(filter_by_substring([], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n\n    print(filter_by_substring_using_map([], 'a'))\n   ", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    res = []\n    for i in strings:\n        if substring in i:\n            res.append(i)\n    return res\n\n\ndef filter_by_substring_using_map(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 使用map函数筛选输入字符串列表中包含给定子串的字符串 \"\"\"\n    return list(filter(lambda i: substring in i, strings))\n\n\nif __name__ == '__main__':\n    print(filter_by_substring([], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n\n    print(filter_by_substring_using_map([], 'a'))\n   "}
{"task_id": "HumanEval/16", "completion": "    count = 0\n    for character in string:\n        key = character.lower()\n        if key not in string:\n            count += 1\n    return count\n\n\ndef count_distinct_characters2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters2('xyzXYZ')\n    3\n    >>> count_distinct_characters2('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for character in string:\n        key = character.lower()\n        # 去重\n        if key not in string[:count]:\n            count += 1\n    return count\n\n\ndef first_non_repeating_character(string: str) -> chr:\n    \"\"\" 给定一个字符串，找出它的第一个不重复的字符\n    >>> first_non_repeating_character('xyzXYZ')\n    'V", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for character in string:\n        key = character.lower()\n        if key not in string:\n            count += 1\n    return count\n\n\ndef count_distinct_characters2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters2('xyzXYZ')\n    3\n    >>> count_distinct_characters2('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for character in string:\n        key = character.lower()\n        # 去重\n        if key not in string[:count]:\n            count += 1\n    return count\n\n\ndef first_non_repeating_character(string: str) -> chr:\n    \"\"\" 给定一个字符串，找出它的第一个不重复的字符\n    >>> first_non_repeating_character('xyzXYZ')\n    'V"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))  # 注意区分大小写\n\n\ndef count_distinct_chars_by_list(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_chars_by_list('xyzXYZ')\n    3\n    >>> count_distinct_chars_by_list('Jerry')\n    4\n    \"\"\"\n    return len(list(set(string.lower())))\n\n\ndef count_distinct_chars_by_regex(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_chars_by_regex('xyzXYZ')\n    3\n    >>> count_distinct_chars_by_regex('Jerry')\n    4\n    \"\"\"\n    return len", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))  # 注意区分大小写\n\n\ndef count_distinct_chars_by_list(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_chars_by_list('xyzXYZ')\n    3\n    >>> count_distinct_chars_by_list('Jerry')\n    4\n    \"\"\"\n    return len(list(set(string.lower())))\n\n\ndef count_distinct_chars_by_regex(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_chars_by_regex('xyzXYZ')\n    3\n    >>> count_distinct_chars_by_regex('Jerry')\n    4\n    \"\"\"\n    return len"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\ndef count_vowels(string: str) -> int:\n    \"\"\" 计算输入字符串中的元音字母(a->A->i->I->o->O->u->U) 的个数\n    \n    >>> count_vowels('aAOuU')\n    4\n    \n    >>> count_vowels('Jerry')\n    3\n    \"\"\"\n    vowel_set = set('aeiouAEIOU')\n    return len([s for s in string if s in vowel_set])\n\ndef count_consecutive_chars(string: str, char: str) -> int:\n    \"\"\" 给定一个字符串和一个字符，计算字符串中该字符连续出现的次数\n    \n    >>> count_consecutive_chars(\"abbbcd\", \"b\")\n    3\n    \n    >>> count_consecutive_chars(\"abcabc\", \"a\")\n    2\n    \n    >>> count_consecutive_ch", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\ndef count_vowels(string: str) -> int:\n    \"\"\" 计算输入字符串中的元音字母(a->A->i->I->o->O->u->U) 的个数\n    \n    >>> count_vowels('aAOuU')\n    4\n    \n    >>> count_vowels('Jerry')\n    3\n    \"\"\"\n    vowel_set = set('aeiouAEIOU')\n    return len([s for s in string if s in vowel_set])\n\ndef count_consecutive_chars(string: str, char: str) -> int:\n    \"\"\" 给定一个字符串和一个字符，计算字符串中该字符连续出现的次数\n    \n    >>> count_consecutive_chars(\"abbbcd\", \"b\")\n    3\n    \n    >>> count_consecutive_chars(\"abcabc\", \"a\")\n    2\n    \n    >>> count_consecutive_ch"}
{"task_id": "HumanEval/16", "completion": "    # 哈希集合\n    char_set = set()\n    for char in string:\n        if char.lower() not in char_set:\n            char_set.add(char.lower())\n\n    return len(char_set)\n\n\ndef count_distinct_vowels(string: str) -> int:\n    \"\"\" 统计字符串中的元音字母的数量\n    >>> count_distinct_vowels('hello world')\n    3\n    >>> count_distinct_vowels('Jerry')\n    1\n    \"\"\"\n    # 哈希集合\n    vowel_set = set('aeiouAEIOU')\n    count = 0\n    for char in string:\n        if char.lower() in vowel_set:\n            count += 1\n\n    return count\n\n\ndef count_distinct_consonants(string: str) -> int:\n    \"\"\" 统计字符串中的辅音字母的数量\n    >>> count_distinct_consonants('hello world')\n", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # 哈希集合\n    char_set = set()\n    for char in string:\n        if char.lower() not in char_set:\n            char_set.add(char.lower())\n\n    return len(char_set)\n\n\ndef count_distinct_vowels(string: str) -> int:\n    \"\"\" 统计字符串中的元音字母的数量\n    >>> count_distinct_vowels('hello world')\n    3\n    >>> count_distinct_vowels('Jerry')\n    1\n    \"\"\"\n    # 哈希集合\n    vowel_set = set('aeiouAEIOU')\n    count = 0\n    for char in string:\n        if char.lower() in vowel_set:\n            count += 1\n\n    return count\n\n\ndef count_distinct_consonants(string: str) -> int:\n    \"\"\" 统计字符串中的辅音字母的数量\n    >>> count_distinct_consonants('hello world')\n"}
{"task_id": "HumanEval/16", "completion": "    counter: Dict[chr, int] = dict()\n    for char in string:\n        if char.lower() not in counter:\n            counter[char.lower()] = 1\n        else:\n            counter[char.lower()] += 1\n    return len(counter)\n            \n\ndef reverse(string: str) -> str:\n    \"\"\" 反转字符串\n    >>> reverse('Jerry')\n    'yrreJ'\n    \"\"\"\n    result: list = list()\n    for i in range(len(string)-1, -1, -1):\n        result.append(string[i])\n    return ''.join(result)\n\n\ndef sort(string: str) -> str:\n    \"\"\" 对字符串进行排序\n    >>> sort('Jerry')\n    'Jerry'\n    >>> sort('Jerry is a good boy')\n   'Jaeeeebd ggoi  hryr'\n    \"\"\"\n    result: list = list()\n    tmp: list = string.split()\n    result.extend(tmp)\n", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    counter: Dict[chr, int] = dict()\n    for char in string:\n        if char.lower() not in counter:\n            counter[char.lower()] = 1\n        else:\n            counter[char.lower()] += 1\n    return len(counter)\n            \n\ndef reverse(string: str) -> str:\n    \"\"\" 反转字符串\n    >>> reverse('Jerry')\n    'yrreJ'\n    \"\"\"\n    result: list = list()\n    for i in range(len(string)-1, -1, -1):\n        result.append(string[i])\n    return ''.join(result)\n\n\ndef sort(string: str) -> str:\n    \"\"\" 对字符串进行排序\n    >>> sort('Jerry')\n    'Jerry'\n    >>> sort('Jerry is a good boy')\n   'Jaeeeebd ggoi  hryr'\n    \"\"\"\n    result: list = list()\n    tmp: list = string.split()\n    result.extend(tmp)\n"}
{"task_id": "HumanEval/16", "completion": "    # 借助集合来解决\n    set_of_characters = set()\n\n    for character in string:\n        # 将字母小写化，以便统计\n        set_of_characters.add(character.lower())\n\n    return len(set_of_characters)\n\n\ndef count_distinct_words(text: str) -> int:\n    \"\"\" 给定一段文本，找出其中有多少个不同的单词（空格是分隔符，不计入）\n    >>> count_distinct_words('Hello World!')\n    3\n    >>> count_distinct_words('hi')\n    1\n    \"\"\"\n    # 借助集合来解决，但我们要把单词分开来\n    set_of_words = set()\n    # 使用 split 把文本分成单词\n    for word in text.split():\n        # 统计一下\n        set_of", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # 借助集合来解决\n    set_of_characters = set()\n\n    for character in string:\n        # 将字母小写化，以便统计\n        set_of_characters.add(character.lower())\n\n    return len(set_of_characters)\n\n\ndef count_distinct_words(text: str) -> int:\n    \"\"\" 给定一段文本，找出其中有多少个不同的单词（空格是分隔符，不计入）\n    >>> count_distinct_words('Hello World!')\n    3\n    >>> count_distinct_words('hi')\n    1\n    \"\"\"\n    # 借助集合来解决，但我们要把单词分开来\n    set_of_words = set()\n    # 使用 split 把文本分成单词\n    for word in text.split():\n        # 统计一下\n        set_of"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_vowels(string: str) -> int:\n    \"\"\" 统计一个字符串中各种元音字母的个数\n    >>> count_vowels('ABCDE')\n    0\n    >>> count_vowels('Jerry')\n    3\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    return sum(vowel in vowels for vowel in string)\n\n\ndef split_by_space(line: str) -> list:\n    \"\"\" 分隔字符串，并且返回一个list\n    >>> split_by_space('Jerry Siu')\n    ['Jerry', 'Siu']\n    >>> split_by_space('Jerry')\n    ['Jerry']\n    \"\"\"\n    return line.split()\n\ndef split_by_comma(line: str) -> list:\n    \"\"\" 分隔字符串，并且返回一个list\n    >>> split_by_comma", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_vowels(string: str) -> int:\n    \"\"\" 统计一个字符串中各种元音字母的个数\n    >>> count_vowels('ABCDE')\n    0\n    >>> count_vowels('Jerry')\n    3\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    return sum(vowel in vowels for vowel in string)\n\n\ndef split_by_space(line: str) -> list:\n    \"\"\" 分隔字符串，并且返回一个list\n    >>> split_by_space('Jerry Siu')\n    ['Jerry', 'Siu']\n    >>> split_by_space('Jerry')\n    ['Jerry']\n    \"\"\"\n    return line.split()\n\ndef split_by_comma(line: str) -> list:\n    \"\"\" 分隔字符串，并且返回一个list\n    >>> split_by_comma"}
{"task_id": "HumanEval/16", "completion": "    char_counts = []\n    for char in string.lower():\n        if char_counts and char_counts[-1][0] == char:\n            char_counts[-1][1] += 1\n        else:\n            char_counts.append((char, 1))\n    return len(char_counts)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)\n\n    print(count_distinct_characters('xyzXYZ'))\n    print(count_distinct_char", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    char_counts = []\n    for char in string.lower():\n        if char_counts and char_counts[-1][0] == char:\n            char_counts[-1][1] += 1\n        else:\n            char_counts.append((char, 1))\n    return len(char_counts)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)\n\n    print(count_distinct_characters('xyzXYZ'))\n    print(count_distinct_char"}
{"task_id": "HumanEval/16", "completion": "    # 先将字符串中的所有字符转成小写，再统计，不区分大小写\n    return len(set(string.lower()))\n```\n\n<br>\n\n## 5.1 总结\n\n总而言之，熟练使用循环、条件语句和判断语句是学习编程的关键！\n\n你遇到的任何问题都应该思考你能不能用循环或条件语句来解决。\n\n## 5.2 练习\n\n- [5.2.1](./exercise_5_02_01.md)\n- [5.2.2](./exercise_5_02_02.md)\n- [5.2.3](./exercise_5_02_03.md)\n- [5.2.4](./exercise_5_0", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # 先将字符串中的所有字符转成小写，再统计，不区分大小写\n    return len(set(string.lower()))\n```\n\n<br>\n\n## 5.1 总结\n\n总而言之，熟练使用循环、条件语句和判断语句是学习编程的关键！\n\n你遇到的任何问题都应该思考你能不能用循环或条件语句来解决。\n\n## 5.2 练习\n\n- [5.2.1](./exercise_5_02_01.md)\n- [5.2.2](./exercise_5_02_02.md)\n- [5.2.3](./exercise_5_02_03.md)\n- [5.2.4](./exercise_5_0"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_distinct_characters2(string: str) -> int:\n    \"\"\"\n    给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    同时统计每个不同的字符个数，eg:\n    >>> count_distinct_characters2('xyzXYZ')\n    {'x': 1, 'y': 1, 'z': 2, 'a': 1}\n    >>> count_distinct_characters2('Jerry')\n    {'j': 1, 'e': 1, 'r': 2, 'y': 1}\n    \"\"\"\n    ans = {}\n    for char in string.lower():\n        ans[char] = ans.get(char, 0) + 1\n    return ans\n\ndef count_distinct_characters3(string: str) -> Dict[str, int]:\n    \"\"\"\n    给定一个字符串，找出它", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_distinct_characters2(string: str) -> int:\n    \"\"\"\n    给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    同时统计每个不同的字符个数，eg:\n    >>> count_distinct_characters2('xyzXYZ')\n    {'x': 1, 'y': 1, 'z': 2, 'a': 1}\n    >>> count_distinct_characters2('Jerry')\n    {'j': 1, 'e': 1, 'r': 2, 'y': 1}\n    \"\"\"\n    ans = {}\n    for char in string.lower():\n        ans[char] = ans.get(char, 0) + 1\n    return ans\n\ndef count_distinct_characters3(string: str) -> Dict[str, int]:\n    \"\"\"\n    给定一个字符串，找出它"}
{"task_id": "HumanEval/18", "completion": "    i = 0\n    n = len(substring)\n    if n == 0:\n        return 0\n    while True:\n        i = string.find(substring, i)\n        if i == -1:\n            break\n        i += n\n    return i\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 返回一个字符串是否是回文(palindrome)， 回文是指读和写都一致,\n    如 \"madam\" 和 \"radar\" 是回文，而 \"mad\" 是不回文的。\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('a')\n    True\n    >>> is_palindrome('aa')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('adad')\n    True\n    >>> is_palindrome('madam')\n    True\n    >>> is_palindrome('mad')\n    False\n    \"\"\"\n    return string == string[", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    i = 0\n    n = len(substring)\n    if n == 0:\n        return 0\n    while True:\n        i = string.find(substring, i)\n        if i == -1:\n            break\n        i += n\n    return i\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 返回一个字符串是否是回文(palindrome)， 回文是指读和写都一致,\n    如 \"madam\" 和 \"radar\" 是回文，而 \"mad\" 是不回文的。\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('a')\n    True\n    >>> is_palindrome('aa')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('adad')\n    True\n    >>> is_palindrome('madam')\n    True\n    >>> is_palindrome('mad')\n    False\n    \"\"\"\n    return string == string["}
{"task_id": "HumanEval/18", "completion": "    n = len(string)\n    m = len(substring)\n    count = 0\n    for i in range(n - m + 1):\n        if string[i:i+m] == substring:\n            count += 1\n    return count\n\n\ndef check_substr(string: str, substring: str) -> bool:\n    \"\"\" 检查给定子串在原始字符串中是否存在。\n        检查重叠?\n    >>> check_substr('', 'a')\n    False\n    >>> check_substr('aaa', 'a')\n    True\n    >>> check_substr('aaaa', 'aa')\n    True\n    >>> check_substr('aaaa', 'aaa')\n    False\n    \"\"\"\n    n = len(string)\n    m = len(substring)\n    return how_many_times(string, substring) >= 1\n\n\ndef find_first(string: str, substring: str) -> Optional[int]:\n    \"\"\" 查找给定子串在原始字符串中第一次出现的位", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    n = len(string)\n    m = len(substring)\n    count = 0\n    for i in range(n - m + 1):\n        if string[i:i+m] == substring:\n            count += 1\n    return count\n\n\ndef check_substr(string: str, substring: str) -> bool:\n    \"\"\" 检查给定子串在原始字符串中是否存在。\n        检查重叠?\n    >>> check_substr('', 'a')\n    False\n    >>> check_substr('aaa', 'a')\n    True\n    >>> check_substr('aaaa', 'aa')\n    True\n    >>> check_substr('aaaa', 'aaa')\n    False\n    \"\"\"\n    n = len(string)\n    m = len(substring)\n    return how_many_times(string, substring) >= 1\n\n\ndef find_first(string: str, substring: str) -> Optional[int]:\n    \"\"\" 查找给定子串在原始字符串中第一次出现的位"}
{"task_id": "HumanEval/18", "completion": "    counter = 0\n    idx = 0  # 搜索起始点\n    while True:\n        idx = string.find(substring, idx)\n        if idx == -1:  # 找不到子串，直接返回\n            return counter\n        counter += 1\n        idx += 1  # 下个字符开始搜索\n\n\ndef how_many_times_with_overlap(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。不计算重叠次数。    >>> how_many_times_with_overlap('', 'a')\n    0\n    >>> how_many_times_with_overlap('aaa', 'a')\n    1\n    >>> how_many_times_with_overlap('aaaa', 'aa')\n    1\n    \"\"\"\n    counter = 0\n    idx = 0  # 搜索起始点\n    while True:\n        idx = string.find(substring,", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    counter = 0\n    idx = 0  # 搜索起始点\n    while True:\n        idx = string.find(substring, idx)\n        if idx == -1:  # 找不到子串，直接返回\n            return counter\n        counter += 1\n        idx += 1  # 下个字符开始搜索\n\n\ndef how_many_times_with_overlap(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。不计算重叠次数。    >>> how_many_times_with_overlap('', 'a')\n    0\n    >>> how_many_times_with_overlap('aaa', 'a')\n    1\n    >>> how_many_times_with_overlap('aaaa', 'aa')\n    1\n    \"\"\"\n    counter = 0\n    idx = 0  # 搜索起始点\n    while True:\n        idx = string.find(substring,"}
{"task_id": "HumanEval/18", "completion": "    return string.count(substring)\n\n\ndef find_all_indexes(string: str, substring: str) -> list:\n    \"\"\" 查找给定子串在原始字符串中出现的所有位置（索引）。\n    重叠查找算法。\n    >>> find_all_indexes('', 'a')\n    []\n    >>> find_all_indexes('aaa', 'a')\n    [0, 1, 2]\n    >>> find_all_indexes('aaaa', 'aa')\n    [0, 1]\n    \"\"\"\n    # ----------------------------------------------------------------------------\n    # 1. 对照解答文档和刷题细节（第1题），填写相应代码\n    # ----------------------------------------------------------------------------\n    return [i for i in range(len(string)-len(substring)) if string[i:i+len(substring)] == substring]\n    # return [i for i in string if string[:i].count(substring", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return string.count(substring)\n\n\ndef find_all_indexes(string: str, substring: str) -> list:\n    \"\"\" 查找给定子串在原始字符串中出现的所有位置（索引）。\n    重叠查找算法。\n    >>> find_all_indexes('', 'a')\n    []\n    >>> find_all_indexes('aaa', 'a')\n    [0, 1, 2]\n    >>> find_all_indexes('aaaa', 'aa')\n    [0, 1]\n    \"\"\"\n    # ----------------------------------------------------------------------------\n    # 1. 对照解答文档和刷题细节（第1题），填写相应代码\n    # ----------------------------------------------------------------------------\n    return [i for i in range(len(string)-len(substring)) if string[i:i+len(substring)] == substring]\n    # return [i for i in string if string[:i].count(substring"}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    i = 0\n    while i < len(string):\n        j = 0\n        while j <= len(substring) and i + j < len(string):\n            if string[i + j] == substring[j]:\n                j += 1\n            else:\n                break\n        if j == len(substring):\n            count += 1\n        i += 1\n    return count\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 判断是否是回文字符串。\n\n    一个字符串是回文字符串，如果它能被写成 a + b + c + b + a （a ≠ b ≠ c）形式，并且 a == b == c 。\n    例如，'racecar', 'noon' 和 'rotor' 都是回文字符串，但是 'palindrome' 不是。\n\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('noon')\n   ", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    i = 0\n    while i < len(string):\n        j = 0\n        while j <= len(substring) and i + j < len(string):\n            if string[i + j] == substring[j]:\n                j += 1\n            else:\n                break\n        if j == len(substring):\n            count += 1\n        i += 1\n    return count\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 判断是否是回文字符串。\n\n    一个字符串是回文字符串，如果它能被写成 a + b + c + b + a （a ≠ b ≠ c）形式，并且 a == b == c 。\n    例如，'racecar', 'noon' 和 'rotor' 都是回文字符串，但是 'palindrome' 不是。\n\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('noon')\n   "}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    start_index = 0\n    while True:\n        index = string.find(substring, start_index)\n        if index == -1:\n            return count\n        count += 1\n        start_index = index + 1\n\n\ndef find_index(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中的第一次出现的索引。返回 -1 表示不存在。\n    >>> find_index('', 'a')\n    -1\n    >>> find_index('aaa', 'a')\n    0\n    >>> find_index('aaaa', 'aa')\n    0\n    >>> find_index('aba', 'ab')\n    0\n    >>> find_index('aba', 'ba')\n    2\n    \"\"\"\n    if substring in string:\n        return string.find(substring)\n    else:\n        return -1\n\n\ndef find_all_indexes(string: str, substring: str) -> List[int]:\n    \"\"\" 返回给定子", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    start_index = 0\n    while True:\n        index = string.find(substring, start_index)\n        if index == -1:\n            return count\n        count += 1\n        start_index = index + 1\n\n\ndef find_index(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中的第一次出现的索引。返回 -1 表示不存在。\n    >>> find_index('', 'a')\n    -1\n    >>> find_index('aaa', 'a')\n    0\n    >>> find_index('aaaa', 'aa')\n    0\n    >>> find_index('aba', 'ab')\n    0\n    >>> find_index('aba', 'ba')\n    2\n    \"\"\"\n    if substring in string:\n        return string.find(substring)\n    else:\n        return -1\n\n\ndef find_all_indexes(string: str, substring: str) -> List[int]:\n    \"\"\" 返回给定子"}
{"task_id": "HumanEval/18", "completion": "    return 0  # TODO\n\n\n\ndef get_all_substrings(string: str) -> List[str]:\n    \"\"\" 返回字符串中所有子串。\n\n    >>> get_all_substrings('cat')\n    ['', 'c', 'ca', 'cat', 'a', 'at', 't', '']\n    \"\"\"\n    result = []  # type: List[str]\n    # 把 string 的每一个字符作为子串\n    for i in range(len(string)+1):\n        result.append(string[0:i])\n    return result\n\n\n\ndef get_all_substrings_with_overlap(string: str) -> List[str]:\n    \"\"\" 返回字符串中所有子串\n\n    >>> get_all_substrings_with_overlap('cat')\n    ['', 'c', 'ca', 't', 'a', 'ta', 'a', 'at', 't', '']\n    \"\"\"\n    result = [] # type: List[str]\n    length = len(string)\n", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return 0  # TODO\n\n\n\ndef get_all_substrings(string: str) -> List[str]:\n    \"\"\" 返回字符串中所有子串。\n\n    >>> get_all_substrings('cat')\n    ['', 'c', 'ca', 'cat', 'a', 'at', 't', '']\n    \"\"\"\n    result = []  # type: List[str]\n    # 把 string 的每一个字符作为子串\n    for i in range(len(string)+1):\n        result.append(string[0:i])\n    return result\n\n\n\ndef get_all_substrings_with_overlap(string: str) -> List[str]:\n    \"\"\" 返回字符串中所有子串\n\n    >>> get_all_substrings_with_overlap('cat')\n    ['', 'c', 'ca', 't', 'a', 'ta', 'a', 'at', 't', '']\n    \"\"\"\n    result = [] # type: List[str]\n    length = len(string)\n"}
{"task_id": "HumanEval/18", "completion": "    n = len(substring)\n    m = len(string)\n    times = 0\n    for i in range(m):\n        if string[i: i + n] == substring:\n            times += 1\n    return times\n\n\ndef longest_common_substring(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    L = []\n    # 动态规划，最长公共子序列\n    for i in range(m):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                if i == 0 or j == 0:\n                    L[i][j] = 1\n                else:\n                    L[i][j] = 1 + L[i - 1][j - 1]  # 即当前位置和上一位置的长度都加一\n            else:\n                L[i][j] = 0\n\n    longest = 0\n    max_index = (0, 0)  #", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    n = len(substring)\n    m = len(string)\n    times = 0\n    for i in range(m):\n        if string[i: i + n] == substring:\n            times += 1\n    return times\n\n\ndef longest_common_substring(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    L = []\n    # 动态规划，最长公共子序列\n    for i in range(m):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                if i == 0 or j == 0:\n                    L[i][j] = 1\n                else:\n                    L[i][j] = 1 + L[i - 1][j - 1]  # 即当前位置和上一位置的长度都加一\n            else:\n                L[i][j] = 0\n\n    longest = 0\n    max_index = (0, 0)  #"}
{"task_id": "HumanEval/18", "completion": "    times = 0\n    start = 0\n    while start!= -1:\n        start = string.find(substring, start)\n        times += 1\n        start += 1\n    return times\n\n'''\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>\n    how_many_times('', 'a')\n    0\n    how_many_times('aaa', 'a')\n    3\n    how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    start = 0\n    times = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            return times\n        start += 1\n        times += 1\n\n\ndef how_many_times_v2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    times = 0\n    start = 0\n    while start!= -1:\n        start = string.find(substring, start)\n        times += 1\n        start += 1\n    return times\n\n'''\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>\n    how_many_times('', 'a')\n    0\n    how_many_times('aaa', 'a')\n    3\n    how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    start = 0\n    times = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            return times\n        start += 1\n        times += 1\n\n\ndef how_many_times_v2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次"}
{"task_id": "HumanEval/18", "completion": "    return len(string) - len(string.replace(substring, ''))\n\n\n\"\"\" \n19. 检查回文子串 \n给定字符串s，检查s是否是回文串。\n\n一个回文串是正反颠倒之后一模一样的字符串(包括空串)。\n\n\n注意\n\n如果你想一次性检查整个字符串是不是回文串，请使用方法19-1。\n\n\n来源\n\n本题是做题人的学习题。\n\n如果你还不快乐的话，你可以：\n\n尝试使用额外的存储空间。\n\n请注意，额外的空间不包括O(1)的存储空间，比如常数级的数组或者O(1)的空间。\n\n\"\"\"\n\n\ndef is_palind", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string) - len(string.replace(substring, ''))\n\n\n\"\"\" \n19. 检查回文子串 \n给定字符串s，检查s是否是回文串。\n\n一个回文串是正反颠倒之后一模一样的字符串(包括空串)。\n\n\n注意\n\n如果你想一次性检查整个字符串是不是回文串，请使用方法19-1。\n\n\n来源\n\n本题是做题人的学习题。\n\n如果你还不快乐的话，你可以：\n\n尝试使用额外的存储空间。\n\n请注意，额外的空间不包括O(1)的存储空间，比如常数级的数组或者O(1)的空间。\n\n\"\"\"\n\n\ndef is_palind"}
{"task_id": "HumanEval/24", "completion": "    for n in range(n, 0, -1):\n        if n % 12 == 0:\n            return n\n\ndef fizz_buzz_test(upper_bound: int) -> None:\n    \"\"\" 执行 fizzbuzz 游戏，范围为 1~ upper_bound 的整数    \n    \"\"\"\n    for i in range(1, upper_bound):\n        # 判断规则： 如果是3的倍数则输出fizz，是5的倍数则输出buzz，是3和5的倍数则输出fizzbuzz\n        if i % 3 == 0 and i % 5 == 0:\n            print('fizzbuzz')\n        # 判断规则： 如果是3的倍数则输出fizz，是5的倍数则输出buzz\n        elif i % 3 == 0:\n            print('fizz')\n        elif i % 5 == ", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for n in range(n, 0, -1):\n        if n % 12 == 0:\n            return n\n\ndef fizz_buzz_test(upper_bound: int) -> None:\n    \"\"\" 执行 fizzbuzz 游戏，范围为 1~ upper_bound 的整数    \n    \"\"\"\n    for i in range(1, upper_bound):\n        # 判断规则： 如果是3的倍数则输出fizz，是5的倍数则输出buzz，是3和5的倍数则输出fizzbuzz\n        if i % 3 == 0 and i % 5 == 0:\n            print('fizzbuzz')\n        # 判断规则： 如果是3的倍数则输出fizz，是5的倍数则输出buzz\n        elif i % 3 == 0:\n            print('fizz')\n        elif i % 5 == "}
{"task_id": "HumanEval/24", "completion": "    i_max = 0\n    for i in range(1,n+1):\n        if n % i == 0:\n            i_max = i\n    return i_max\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 检查 n 是否是素数    >>> is_prime(13195)\n    True\n    \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, largest_divisor(n)+1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 计算 n 的所有质因子    >>> prime_factors(13195)\n    [3, 5, 7, 13, 29]\n    \"\"\"\n    factors_list = []\n    # 找到所有的质数因子\n    for i in range(2", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i_max = 0\n    for i in range(1,n+1):\n        if n % i == 0:\n            i_max = i\n    return i_max\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 检查 n 是否是素数    >>> is_prime(13195)\n    True\n    \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, largest_divisor(n)+1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 计算 n 的所有质因子    >>> prime_factors(13195)\n    [3, 5, 7, 13, 29]\n    \"\"\"\n    factors_list = []\n    # 找到所有的质数因子\n    for i in range(2"}
{"task_id": "HumanEval/24", "completion": "    for i in range(n, 0, -1):\n        if n % i == 0:\n            return i\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的所有的质数，要求不能返回重复的质因子。\n    1. 找出最大的因子 (不大于n)\n    2. 将最大的因子减去所有能被最大的因子整除的数，即得到最大质因子\n    3. 循环找出最大质因子所有整除的因子，得到所有质因子，并删除重复的质因子\n        最后得到的质因子都是最小的质因子，不会超过最大因子\n    >>> prime_factors(100", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n, 0, -1):\n        if n % i == 0:\n            return i\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的所有的质数，要求不能返回重复的质因子。\n    1. 找出最大的因子 (不大于n)\n    2. 将最大的因子减去所有能被最大的因子整除的数，即得到最大质因子\n    3. 循环找出最大质因子所有整除的因子，得到所有质因子，并删除重复的质因子\n        最后得到的质因子都是最小的质因子，不会超过最大因子\n    >>> prime_factors(100"}
{"task_id": "HumanEval/24", "completion": "    return bisect.bisect_right(divisors(n), n)\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    30\n    \"\"\"\n    return bisect.bisect_left(divisors(n), n)\n\n\ndef divisors(n: int) -> List[int]:\n    \"\"\" 质因数分解的最小除数列表    >>> divisors(15)\n    [3, 5]\n    \"\"\"\n    if n < 1:\n        return []\n    if n == 1:\n        return [1]\n    if n in cache:\n        return cache[n]\n\n    ans = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            ans.append(i)\n            ans.append(n // i)\n\n   ", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return bisect.bisect_right(divisors(n), n)\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    30\n    \"\"\"\n    return bisect.bisect_left(divisors(n), n)\n\n\ndef divisors(n: int) -> List[int]:\n    \"\"\" 质因数分解的最小除数列表    >>> divisors(15)\n    [3, 5]\n    \"\"\"\n    if n < 1:\n        return []\n    if n == 1:\n        return [1]\n    if n in cache:\n        return cache[n]\n\n    ans = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            ans.append(i)\n            ans.append(n // i)\n\n   "}
{"task_id": "HumanEval/24", "completion": "    div = 0\n    while div < n:\n        if n % div == 0:\n            return div\n        else:\n            div += 1\n\n# 1.2 质因子整除\ndef is_q_even(n: int, p: int) -> bool:\n    \"\"\" 判断一个整数是否能被 p 整除，如果能则返回 True ，否则返回 False\n    >>> is_q_even(15, 2)\n    True\n    \"\"\"\n    return n % p == 0\n\ndef has_even_q_div(n: int) -> bool:\n    \"\"\" 检查一个数是否是偶数的因数，如果是，返回 True ，否则返回 False \"\"\"\n    check = is_q_even(n, largest_divisor(n))\n    if check:\n        return True\n    else:\n        return False\n\n# 1.3 忽略质数\ndef is_q_prime", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    div = 0\n    while div < n:\n        if n % div == 0:\n            return div\n        else:\n            div += 1\n\n# 1.2 质因子整除\ndef is_q_even(n: int, p: int) -> bool:\n    \"\"\" 判断一个整数是否能被 p 整除，如果能则返回 True ，否则返回 False\n    >>> is_q_even(15, 2)\n    True\n    \"\"\"\n    return n % p == 0\n\ndef has_even_q_div(n: int) -> bool:\n    \"\"\" 检查一个数是否是偶数的因数，如果是，返回 True ，否则返回 False \"\"\"\n    check = is_q_even(n, largest_divisor(n))\n    if check:\n        return True\n    else:\n        return False\n\n# 1.3 忽略质数\ndef is_q_prime"}
{"task_id": "HumanEval/24", "completion": "    for x in range(int(n**0.5), 1, -1):\n        if n % x == 0:\n            if x > int(n**0.5):\n                return int(n**0.5)\n            return x\n    return 1\n\n\nif __name__ == \"__main__\":\n    print(count_down_by_ones(100))\n    print(sum_divisors(100))\n    print(sum_divisors_2(100))\n    print(largest_divisor(15))\n    print(largest_divisor(200))\n    print(largest_divisor(1000))\n    print(largest_divisor(2000))\n    print(sum_divisors(10000))\n    print(sum_divisors_2(10000))\n    print(sum_divisors_3(10000))\n    print(sum_divisors(100000))\n    print(", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for x in range(int(n**0.5), 1, -1):\n        if n % x == 0:\n            if x > int(n**0.5):\n                return int(n**0.5)\n            return x\n    return 1\n\n\nif __name__ == \"__main__\":\n    print(count_down_by_ones(100))\n    print(sum_divisors(100))\n    print(sum_divisors_2(100))\n    print(largest_divisor(15))\n    print(largest_divisor(200))\n    print(largest_divisor(1000))\n    print(largest_divisor(2000))\n    print(sum_divisors(10000))\n    print(sum_divisors_2(10000))\n    print(sum_divisors_3(10000))\n    print(sum_divisors(100000))\n    print("}
{"task_id": "HumanEval/24", "completion": "    for divisor in range(n, 0, -1):\n        if n % divisor == 0:\n            return divisor\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            return divisor\n\n\ndef all_divisors(n: int) -> list:\n    \"\"\" 对于给定的数 n，返回能整除 n 且大于1 的所有数    >>> all_divisors(15)\n    [3, 5]\n    \"\"\"\n    divisors = []\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            divisors.append(divisor)\n    return divisors\n\n\ndef is_", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n, 0, -1):\n        if n % divisor == 0:\n            return divisor\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            return divisor\n\n\ndef all_divisors(n: int) -> list:\n    \"\"\" 对于给定的数 n，返回能整除 n 且大于1 的所有数    >>> all_divisors(15)\n    [3, 5]\n    \"\"\"\n    divisors = []\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            divisors.append(divisor)\n    return divisors\n\n\ndef is_"}
{"task_id": "HumanEval/24", "completion": "    start = 1\n    end = n\n    while start < end:\n        mid = start + (end - start) // 2\n        if n % mid == 0:\n            end = mid\n        else:\n            start = mid + 1\n    return end\n\nprint(largest_divisor(15))\n\n    # 迭代\n    # while mid and n%mid:\n    #     if n%mid<mid:\n    #         end = mid\n    #     else:\n    #         start = mid+1\n    #     mid = start + (end-start)//2\n    # return end\n\n    # 递归\n    # while n % mid:\n    #     if n % mid < mid:\n    #         end = mid\n    #     else:\n    #         start = mid\n    #     mid = start + (end - start) // 2\n    # return mid\n\n\ndef get_largest_divisor(n: int) -> int:\n    \"\"\" \n    找出整除n的最", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    start = 1\n    end = n\n    while start < end:\n        mid = start + (end - start) // 2\n        if n % mid == 0:\n            end = mid\n        else:\n            start = mid + 1\n    return end\n\nprint(largest_divisor(15))\n\n    # 迭代\n    # while mid and n%mid:\n    #     if n%mid<mid:\n    #         end = mid\n    #     else:\n    #         start = mid+1\n    #     mid = start + (end-start)//2\n    # return end\n\n    # 递归\n    # while n % mid:\n    #     if n % mid < mid:\n    #         end = mid\n    #     else:\n    #         start = mid\n    #     mid = start + (end - start) // 2\n    # return mid\n\n\ndef get_largest_divisor(n: int) -> int:\n    \"\"\" \n    找出整除n的最"}
{"task_id": "HumanEval/24", "completion": "    return _largest_divisor(n, math.sqrt(n))\n\ndef _largest_divisor(n: int, max_value: int) -> int:\n    \"\"\" 对于给定的数 n 和最大值 max_value，找出能整除 n 且小于  n 的最大的数\n    \"\"\"\n    for i in range(max_value, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\ndef smallest_divisor(n:int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于 n 的最小的数\n            >>> smallest_divisor(16)\n            33\n    \"\"\"\n    return _smallest_divisor(n, int(n**0.5) +1)\n\ndef _smallest_divisor(n: int, min_value: int) -> int:\n    \"\"\" 对于给定的数 n 和", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return _largest_divisor(n, math.sqrt(n))\n\ndef _largest_divisor(n: int, max_value: int) -> int:\n    \"\"\" 对于给定的数 n 和最大值 max_value，找出能整除 n 且小于  n 的最大的数\n    \"\"\"\n    for i in range(max_value, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\ndef smallest_divisor(n:int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于 n 的最小的数\n            >>> smallest_divisor(16)\n            33\n    \"\"\"\n    return _smallest_divisor(n, int(n**0.5) +1)\n\ndef _smallest_divisor(n: int, min_value: int) -> int:\n    \"\"\" 对于给定的数 n 和"}
{"task_id": "HumanEval/24", "completion": "    return [i for i in range(n // 2, 0, -1) if n % i == 0][0]\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\" 最大公约数 \"\"\"\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\" 最小公倍数 \"\"\"\n    return (a * b) // gcd(a, b)\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 计算整数n的质因子 \"\"\"\n    result = []\n    while n % 2 == 0:\n        result.append(2)\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            result.append(i)\n            n //= i\n    if n > 2:\n        result.append(n)\n    return result", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return [i for i in range(n // 2, 0, -1) if n % i == 0][0]\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\" 最大公约数 \"\"\"\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\" 最小公倍数 \"\"\"\n    return (a * b) // gcd(a, b)\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 计算整数n的质因子 \"\"\"\n    result = []\n    while n % 2 == 0:\n        result.append(2)\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            result.append(i)\n            n //= i\n    if n > 2:\n        result.append(n)\n    return result"}
{"task_id": "HumanEval/25", "completion": "    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    # 如果输入数字小于2，返回空列表\n    if n < 2:\n        # 如果输入数字是2，返回单个元素的列表\n        return [n]\n    # 从2开始，尝试除出一个数，直到无法再除尽\n    for divisor in range(2, n + 1):\n        # n在除去divisor之后，仍然存在\n        if n % divisor == 0:\n            # 将质数加入到因数列表中\n            factors.append(divisor)\n            # 更新num，不再有需要除去的质数了\n            n = n // divisor\n            # 重新开始尝试除法\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### 练习\n\n1. 下面的", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    # 如果输入数字小于2，返回空列表\n    if n < 2:\n        # 如果输入数字是2，返回单个元素的列表\n        return [n]\n    # 从2开始，尝试除出一个数，直到无法再除尽\n    for divisor in range(2, n + 1):\n        # n在除去divisor之后，仍然存在\n        if n % divisor == 0:\n            # 将质数加入到因数列表中\n            factors.append(divisor)\n            # 更新num，不再有需要除去的质数了\n            n = n // divisor\n            # 重新开始尝试除法\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### 练习\n\n1. 下面的"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:  # 找到一个质因子, 就不断地找它的倍数\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:  # 判", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:  # 找到一个质因子, 就不断地找它的倍数\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:  # 判"}
{"task_id": "HumanEval/25", "completion": "    result = []\n    temp = n\n    for i in range(2, int(pow(n, 0.5) + 1)):\n        if temp % i == 0:\n            while temp % i == 0:\n                temp //= i\n                result.append(i)\n    if temp > 1:\n        result.append(temp)\n    return result\n\n\ndef get_sum_of_divisors(n: int) -> int:\n    \"\"\" 返回一整数的所有（不超过它本身的）因子的和\n    >>> get_sum_of_divisors(8)\n    30\n    >>> get_sum_of_divisors(25)\n    25\n    >>> get_sum_of_divisors(70)\n    128\n    \"\"\"\n    summation = 1\n    for i in factorize(n):\n        summation *= i + 1\n    return summation\n\n\ndef has_property(n: int, p: int) -> bool:\n    \"\"\" 从", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    result = []\n    temp = n\n    for i in range(2, int(pow(n, 0.5) + 1)):\n        if temp % i == 0:\n            while temp % i == 0:\n                temp //= i\n                result.append(i)\n    if temp > 1:\n        result.append(temp)\n    return result\n\n\ndef get_sum_of_divisors(n: int) -> int:\n    \"\"\" 返回一整数的所有（不超过它本身的）因子的和\n    >>> get_sum_of_divisors(8)\n    30\n    >>> get_sum_of_divisors(25)\n    25\n    >>> get_sum_of_divisors(70)\n    128\n    \"\"\"\n    summation = 1\n    for i in factorize(n):\n        summation *= i + 1\n    return summation\n\n\ndef has_property(n: int, p: int) -> bool:\n    \"\"\" 从"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(1, math.ceil(math.sqrt(n))):\n        if not n % i:\n            factors.append(i)\n            factors.append(n // i)\n    return sorted(factors)\n\n\ndef check_prime(n: int) -> bool:\n    \"\"\" 判断n是否为质数\n    >>> check_prime(5)\n    True\n    >>> check_prime(12)\n    False\n    >>> check_prime(11)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    factors = factorize(n)\n    return len(factors) == 1 and factors[0] == n\n\n\ndef check_perfect_number(n: int) -> bool:\n    \"\"\" 判断n是否为完全数\n    >>> check_perfect_number(30)\n    True\n    >>> check_perfect_number(144)\n    False\n    >>> check_perfect_number(120)\n    True\n    >>> check_perfect_", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(1, math.ceil(math.sqrt(n))):\n        if not n % i:\n            factors.append(i)\n            factors.append(n // i)\n    return sorted(factors)\n\n\ndef check_prime(n: int) -> bool:\n    \"\"\" 判断n是否为质数\n    >>> check_prime(5)\n    True\n    >>> check_prime(12)\n    False\n    >>> check_prime(11)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    factors = factorize(n)\n    return len(factors) == 1 and factors[0] == n\n\n\ndef check_perfect_number(n: int) -> bool:\n    \"\"\" 判断n是否为完全数\n    >>> check_perfect_number(30)\n    True\n    >>> check_perfect_number(144)\n    False\n    >>> check_perfect_number(120)\n    True\n    >>> check_perfect_"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    number = n\n    while number % 2 == 0:\n        factors.append(2)\n        number //= 2\n    for i in range(3, int(pow(n, 0.5)) + 1, 2):\n        while number % i == 0:\n            factors.append(i)\n            number //= i\n    if number > 1:\n        factors.append(number)\n    return factors\n\n\ndef main() -> None:\n    print(factorize(8))  # [2, 2, 2]\n    print(factorize(25))  # [5, 5]\n    print(factorize(70))  # [2, 5, 7]\n    print(factorize(80))  # [2, 2, 2, 5]\n    print(factorize(100))  # [2, 2", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    number = n\n    while number % 2 == 0:\n        factors.append(2)\n        number //= 2\n    for i in range(3, int(pow(n, 0.5)) + 1, 2):\n        while number % i == 0:\n            factors.append(i)\n            number //= i\n    if number > 1:\n        factors.append(number)\n    return factors\n\n\ndef main() -> None:\n    print(factorize(8))  # [2, 2, 2]\n    print(factorize(25))  # [5, 5]\n    print(factorize(70))  # [2, 5, 7]\n    print(factorize(80))  # [2, 2, 2, 5]\n    print(factorize(100))  # [2, 2"}
{"task_id": "HumanEval/25", "completion": "    if n <= 1:\n        raise ValueError\n    num = n\n    factors = []\n\n    for i in range(2, int(n**0.5)+1):\n        while num % i == 0:\n            factors.append(i)\n", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n <= 1:\n        raise ValueError\n    num = n\n    factors = []\n\n    for i in range(2, int(n**0.5)+1):\n        while num % i == 0:\n            factors.append(i)\n"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            factors.append(n // i)\n    if factors[-1] == factors[-2]:\n        del factors[-1]\n    return sorted(factors)\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断给定的整数是否是质数\n    >>> is_prime(1)\n    False\n    >>> is_prime(4)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(37)\n    True\n    \"\"\"\n    return n == 2 or n == 3 or n % 2!= 0 and not any([n % i == 0 for i in range(3, int(n**0.5) + 1, 2)])\n\n\ndef prime_factors(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            factors.append(n // i)\n    if factors[-1] == factors[-2]:\n        del factors[-1]\n    return sorted(factors)\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断给定的整数是否是质数\n    >>> is_prime(1)\n    False\n    >>> is_prime(4)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(37)\n    True\n    \"\"\"\n    return n == 2 or n == 3 or n % 2!= 0 and not any([n % i == 0 for i in range(3, int(n**0.5) + 1, 2)])\n\n\ndef prime_factors(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定"}
{"task_id": "HumanEval/25", "completion": "\n    lst = []\n    while n % 2 == 0:\n        lst.append(2)\n        n //= 2\n    for i in range(3, int(sqrt(n) + 1), 2):\n        while n % i == 0:\n            lst.append(i)\n            n //= i\n    if n > 1:\n        lst.append(n)\n    return lst\n\n\ndef prime_factors(n: int) -> List[int]:\n    \"\"\" 返回大于1的最小的正整数的集合所有质因数的最大列表，如果n是偶数，则返回[]\n    >>> prime_factors(60)\n    [2, 3, 5]\n    >>> prime_factors(48)\n    [2, 2, 2, 3]\n    >>> prime_factors(70)\n    [2, 3, 5, 7]\n    >>> prime_factors(25)\n    [5]\n    >>> prime_fact", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n    lst = []\n    while n % 2 == 0:\n        lst.append(2)\n        n //= 2\n    for i in range(3, int(sqrt(n) + 1), 2):\n        while n % i == 0:\n            lst.append(i)\n            n //= i\n    if n > 1:\n        lst.append(n)\n    return lst\n\n\ndef prime_factors(n: int) -> List[int]:\n    \"\"\" 返回大于1的最小的正整数的集合所有质因数的最大列表，如果n是偶数，则返回[]\n    >>> prime_factors(60)\n    [2, 3, 5]\n    >>> prime_factors(48)\n    [2, 2, 2, 3]\n    >>> prime_factors(70)\n    [2, 3, 5, 7]\n    >>> prime_factors(25)\n    [5]\n    >>> prime_fact"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    while n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n    factors.append(n)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n**15.16 找出数字中的素数**\n\n```python\n\"\"\" 找出数字中的素数 \"\"\"\n\n\ndef get_prime_num(num: int) -> List[int]:\n    \"\"\" 找出数字中的素数 \"\"\"\n    prime_num = []\n    for num_prime in range(2, num + 1):\n        if all(num_prime % i!= 0 for i in range(2, num_prime)):\n            prime_num.append(num_prime)\n    return prime_num\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    while n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n    factors.append(n)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n**15.16 找出数字中的素数**\n\n```python\n\"\"\" 找出数字中的素数 \"\"\"\n\n\ndef get_prime_num(num: int) -> List[int]:\n    \"\"\" 找出数字中的素数 \"\"\"\n    prime_num = []\n    for num_prime in range(2, num + 1):\n        if all(num_prime % i!= 0 for i in range(2, num_prime)):\n            prime_num.append(num_prime)\n    return prime_num\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest"}
{"task_id": "HumanEval/26", "completion": "    return list(filter(lambda x: numbers.count(x) == 1, numbers))\n\n\nif __name__ == '__main__':\n\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 1, 2, 2]))\n    print(remove_duplicates([1, 1, 1, 1]))\n    print(remove_duplicates([1]))\n    print(remove_duplicates", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(filter(lambda x: numbers.count(x) == 1, numbers))\n\n\nif __name__ == '__main__':\n\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 1, 2, 2]))\n    print(remove_duplicates([1, 1, 1, 1]))\n    print(remove_duplicates([1]))\n    print(remove_duplicates"}
{"task_id": "HumanEval/26", "completion": "```\n\n### 2.2 简单条件语句\n\n使用if语句来控制程序流，从而处理不同的输入情况。\n\n```python\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if not numbers:  # 如果numbers为空列表或者None，则不做任何处理\n        return []\n    if len(numbers) == 1: # 如果len(numbers) == 1，则可以直接返回这个列表\n        return numbers\n    if len(numbers) == 2: # 如果len(numbers) == 2，则只需要比��", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n```\n\n### 2.2 简单条件语句\n\n使用if语句来控制程序流，从而处理不同的输入情况。\n\n```python\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if not numbers:  # 如果numbers为空列表或者None，则不做任何处理\n        return []\n    if len(numbers) == 1: # 如果len(numbers) == 1，则可以直接返回这个列表\n        return numbers\n    if len(numbers) == 2: # 如果len(numbers) == 2，则只需要比��"}
{"task_id": "HumanEval/26", "completion": "    numbers = list(set(numbers))\n    numbers.sort()\n    return numbers\n\n\nif __name__ == \"__main__\":\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    numbers = [1, 2, 3, 3", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers = list(set(numbers))\n    numbers.sort()\n    return numbers\n\n\nif __name__ == \"__main__\":\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    numbers = [1, 2, 3, 3"}
{"task_id": "HumanEval/26", "completion": "    seen: List[int] = []\n    results: List[int] = []\n    for number in numbers:\n        if number not in seen:\n            results.append(number)\n            seen.append(number)\n    return results\n\n\ndef find_the_odd_int(arr: List[int]) -> int:\n    \"\"\" 找出给定的整数列表中，唯一出现一次的整数    >>> find_the_odd_int([2, 2, 1, 3, 4, 5, 6, 7, 8, 8])\n    3\n    \"\"\"\n    odds: List[int] = []\n    for number in arr:\n        if arr.count(number) == 1:\n            odds.append(number)\n    if len(odds) == 1:\n        return odds[0]\n    else:\n        raise ValueError\n\n\ndef find_the_duplicate_values(numbers: List[int]) -> List[int]:\n    \"\"\" 找出给定列", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen: List[int] = []\n    results: List[int] = []\n    for number in numbers:\n        if number not in seen:\n            results.append(number)\n            seen.append(number)\n    return results\n\n\ndef find_the_odd_int(arr: List[int]) -> int:\n    \"\"\" 找出给定的整数列表中，唯一出现一次的整数    >>> find_the_odd_int([2, 2, 1, 3, 4, 5, 6, 7, 8, 8])\n    3\n    \"\"\"\n    odds: List[int] = []\n    for number in arr:\n        if arr.count(number) == 1:\n            odds.append(number)\n    if len(odds) == 1:\n        return odds[0]\n    else:\n        raise ValueError\n\n\ndef find_the_duplicate_values(numbers: List[int]) -> List[int]:\n    \"\"\" 找出给定列"}
{"task_id": "HumanEval/26", "completion": "    numbers_set = set()\n    numbers_list = []\n    for num in numbers:\n        if num not in numbers_set:\n            numbers_set.add(num)\n            numbers_list.append(num)\n    return numbers_list\n\nif __name__ == '__main__':\n    import doctest\n    (failure_count, test_count) = doctest.testmod()\n    print('{} failures, {} tests'.format(failure_count, test_count))\n    if failure_count > 0:\n        print('*** TEST FAILURES ***')\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers_set = set()\n    numbers_list", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers_set = set()\n    numbers_list = []\n    for num in numbers:\n        if num not in numbers_set:\n            numbers_set.add(num)\n            numbers_list.append(num)\n    return numbers_list\n\nif __name__ == '__main__':\n    import doctest\n    (failure_count, test_count) = doctest.testmod()\n    print('{} failures, {} tests'.format(failure_count, test_count))\n    if failure_count > 0:\n        print('*** TEST FAILURES ***')\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers_set = set()\n    numbers_list"}
{"task_id": "HumanEval/26", "completion": "    if len(numbers) <= 1:\n        return numbers\n    else:\n        numbers.sort()\n        return [numbers[0]] + remove_duplicates(numbers[1:])\n\n\nif __name__ == '__main__':\n    s = [1, 2, 3, 2, 4]\n    print(remove_duplicates(s))\n\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9]\n    # print(remove_duplicates(s))\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9]\n    # print(remove_duplicates(s))\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9, 3, 4, 4, 8, 2, 1, 4, 9, 3, 6, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if len(numbers) <= 1:\n        return numbers\n    else:\n        numbers.sort()\n        return [numbers[0]] + remove_duplicates(numbers[1:])\n\n\nif __name__ == '__main__':\n    s = [1, 2, 3, 2, 4]\n    print(remove_duplicates(s))\n\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9]\n    # print(remove_duplicates(s))\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9]\n    # print(remove_duplicates(s))\n    # s = [1, 2, 3, 2, 4, 2, 7, 8, 8, 3, 9, 3, 4, 4, 8, 2, 1, 4, 9, 3, 6, "}
{"task_id": "HumanEval/26", "completion": "    # TODO: 要支持集合 排序 去重\n    # TODO: 去重\n    pass\n\n\n# 递归实现\ndef get_length(nums: List[int]) -> int:\n    \"\"\"获得列表长度\n\n    >>> get_length([1, 2, 3, 4])\n    4\n    >>> get_length([1])\n    1\n    >>> get_length([])\n    0\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    else:\n        return get_length(nums[1:]) + 1\n\n\ndef insertion_sort(nums: List[int]) -> List[int]:\n    \"\"\" 插入排序\n\n    [1, 3, 2, 5, 4]\n    >>> insertion_sort([1, 3, 2, 5, 4])\n    [1, 2, 3, 4, 5]\n    >>> insertion_sort([1, 3, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # TODO: 要支持集合 排序 去重\n    # TODO: 去重\n    pass\n\n\n# 递归实现\ndef get_length(nums: List[int]) -> int:\n    \"\"\"获得列表长度\n\n    >>> get_length([1, 2, 3, 4])\n    4\n    >>> get_length([1])\n    1\n    >>> get_length([])\n    0\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    else:\n        return get_length(nums[1:]) + 1\n\n\ndef insertion_sort(nums: List[int]) -> List[int]:\n    \"\"\" 插入排序\n\n    [1, 3, 2, 5, 4]\n    >>> insertion_sort([1, 3, 2, 5, 4])\n    [1, 2, 3, 4, 5]\n    >>> insertion_sort([1, 3, "}
{"task_id": "HumanEval/26", "completion": "    if not numbers:\n        return []\n\n    numbers.sort()\n    last = numbers[0]\n    result = []\n    for num in numbers:\n        if num!= last:\n            last = num\n            result.append(num)\n    return result\n\n\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\" 找出数组中所有子数组的和的最大值  >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> max_sub_array([1, -2, 3, 10, -4, 7, 2, -5])\n    18\n    \"\"\"\n    if not nums:\n        return 0\n    # 假定最大子数组为第一个元素\n    result = nums[0]\n    # 假定当前为第一个元素\n    current = nums[0]\n    for i in range(1, len(", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    numbers.sort()\n    last = numbers[0]\n    result = []\n    for num in numbers:\n        if num!= last:\n            last = num\n            result.append(num)\n    return result\n\n\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\" 找出数组中所有子数组的和的最大值  >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> max_sub_array([1, -2, 3, 10, -4, 7, 2, -5])\n    18\n    \"\"\"\n    if not nums:\n        return 0\n    # 假定最大子数组为第一个元素\n    result = nums[0]\n    # 假定当前为第一个元素\n    current = nums[0]\n    for i in range(1, len("}
{"task_id": "HumanEval/26", "completion": "    print('hello')\n    res = []\n    # 空列表的情况\n    if not numbers:\n        print('hello')\n        return []\n    for item in numbers:\n        # 欲删去的元素在列表中出现过时\n        if item in res:\n            # 什么都不做\n            pass\n        else:\n            # 执行到这里就意味着这个数没有被删去，即是没有重复的\n            res.append(item)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([4, 4, 2, 2, 3, 3, 1, 1, 2]))\n    print(remove_duplicates([1, 2, 3, 4, 5]))\n    print(remove_duplicates([1, 2, 4, 3, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    print('hello')\n    res = []\n    # 空列表的情况\n    if not numbers:\n        print('hello')\n        return []\n    for item in numbers:\n        # 欲删去的元素在列表中出现过时\n        if item in res:\n            # 什么都不做\n            pass\n        else:\n            # 执行到这里就意味着这个数没有被删去，即是没有重复的\n            res.append(item)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([4, 4, 2, 2, 3, 3, 1, 1, 2]))\n    print(remove_duplicates([1, 2, 3, 4, 5]))\n    print(remove_duplicates([1, 2, 4, 3, "}
{"task_id": "HumanEval/26", "completion": "    if not numbers:\n        return numbers\n    number_count = {}\n    for number in numbers:\n        number_count[number] = number_count.get(number, 0) + 1\n    new_numbers = []\n    for number in numbers:\n        if number_count[number] == 1:\n            new_numbers.append(number)\n    return new_numbers\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n\n    numbers = [1, 1, 2, 3, 3, 3, 4]", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if not numbers:\n        return numbers\n    number_count = {}\n    for number in numbers:\n        number_count[number] = number_count.get(number, 0) + 1\n    new_numbers = []\n    for number in numbers:\n        if number_count[number] == 1:\n            new_numbers.append(number)\n    return new_numbers\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n\n    numbers = [1, 1, 2, 3, 3, 3, 4]"}
{"task_id": "HumanEval/31", "completion": "    return n > 1 and all(n % i for i in range(2, int(n**0.5) + 1))\n    \ndef is_prime_iterative(n):\n    \"\"\"如果给定数字是质数，则返回True，否则返回False。   >>> is_prime_iterative(6)\n    False\n    >>> is_prime_iterative(101)\n    True\n    >>> is_prime_iterative(11)\n    True\n    >>> is_prime_iterative(13441)\n    True\n    >>> is_prime_iterative(61)\n    True\n    >>> is_prime_iterative(4)\n    False\n    >>> is_prime_iterative(1)\n    False\n    \"\"\"\n    if n > 1:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\ndef is_prime_iterative1(n):\n    \"\"\"如果给定", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    return n > 1 and all(n % i for i in range(2, int(n**0.5) + 1))\n    \ndef is_prime_iterative(n):\n    \"\"\"如果给定数字是质数，则返回True，否则返回False。   >>> is_prime_iterative(6)\n    False\n    >>> is_prime_iterative(101)\n    True\n    >>> is_prime_iterative(11)\n    True\n    >>> is_prime_iterative(13441)\n    True\n    >>> is_prime_iterative(61)\n    True\n    >>> is_prime_iterative(4)\n    False\n    >>> is_prime_iterative(1)\n    False\n    \"\"\"\n    if n > 1:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\ndef is_prime_iterative1(n):\n    \"\"\"如果给定"}
{"task_id": "HumanEval/31", "completion": "    if n == 2:\n        return True\n    # 如果n小于2或者不是质数，则返回值 False\n    if n <= 1 or not is_odd(n):\n        return False\n    # 如果n大于2且是奇数，则从 3 开始验证\n    for i in range(3, n, 2):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef is_odd(n):\n    \"\"\"如果给定的数字是奇数，则返回true，否则返回false  >>> is_odd(6)\n    False\n    >>> is_odd(101)\n    True\n    >>> is_odd(11)\n    True\n    >>> is_odd(13441)\n    False\n    >>> is_odd(61)\n    False\n    >>> is_odd(4)\n    True\n    >>> is_odd(1)\n    False\n    \"\"\"\n    if n == 1:\n", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    # 如果n小于2或者不是质数，则返回值 False\n    if n <= 1 or not is_odd(n):\n        return False\n    # 如果n大于2且是奇数，则从 3 开始验证\n    for i in range(3, n, 2):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef is_odd(n):\n    \"\"\"如果给定的数字是奇数，则返回true，否则返回false  >>> is_odd(6)\n    False\n    >>> is_odd(101)\n    True\n    >>> is_odd(11)\n    True\n    >>> is_odd(13441)\n    False\n    >>> is_odd(61)\n    False\n    >>> is_odd(4)\n    True\n    >>> is_odd(1)\n    False\n    \"\"\"\n    if n == 1:\n"}
{"task_id": "HumanEval/31", "completion": "    for i in range (2, int(n**0.5)+1):\n        if n%i == 0:\n            return False            \n    return True\n            \n\ndef randprime(low,high):\n    \"\"\"返回一个（随机的）质数，范围在[low,high]之间   >>> randprime(100000000,10000000000)\n    14140825731273940621\n    \"\"\"\n    if not isinstance(low,int):raise ValueError\n    if not isinstance(high,int):raise ValueError\n    if low >= high:raise ValueError\n    n = randint(low,high)\n    while not is_prime(n):\n        n = randint(low,high)\n    return n\n\ndef lcm(*args):\n    \"\"\" 计算不同数值的最小公倍数 15:10:9   lcm(15,10,9)   6", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    for i in range (2, int(n**0.5)+1):\n        if n%i == 0:\n            return False            \n    return True\n            \n\ndef randprime(low,high):\n    \"\"\"返回一个（随机的）质数，范围在[low,high]之间   >>> randprime(100000000,10000000000)\n    14140825731273940621\n    \"\"\"\n    if not isinstance(low,int):raise ValueError\n    if not isinstance(high,int):raise ValueError\n    if low >= high:raise ValueError\n    n = randint(low,high)\n    while not is_prime(n):\n        n = randint(low,high)\n    return n\n\ndef lcm(*args):\n    \"\"\" 计算不同数值的最小公倍数 15:10:9   lcm(15,10,9)   6"}
{"task_id": "HumanEval/31", "completion": "    \n    if n==2:\n        return True\n    if n%2==0:\n        return False\n    for i in range(3,int(math.sqrt(n))+1,2):\n        if n%i==0:\n            return False\n    return True\n\n# def next_prime(n):\n#     \"\"\"返回大于指定数字的下一个质数\"\"\"\n#     n=n+1\n#     while True:\n#         if is_prime(n):\n#             return n\n#         n=n+1\n\ndef prime(start=1, end=1000):\n    \"\"\"返回质数列表\"\"\"\n    p_list=[]\n    for i in range(start,end+1):\n        if is_prime(i):\n            p_list.append(i)\n    return p_list\n\ndef next_prime(n):\n    \"\"\"返回大于指定数字的下一个质数\"\"\"\n    n=n+1\n    while True:\n        if is_prime(", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    if n==2:\n        return True\n    if n%2==0:\n        return False\n    for i in range(3,int(math.sqrt(n))+1,2):\n        if n%i==0:\n            return False\n    return True\n\n# def next_prime(n):\n#     \"\"\"返回大于指定数字的下一个质数\"\"\"\n#     n=n+1\n#     while True:\n#         if is_prime(n):\n#             return n\n#         n=n+1\n\ndef prime(start=1, end=1000):\n    \"\"\"返回质数列表\"\"\"\n    p_list=[]\n    for i in range(start,end+1):\n        if is_prime(i):\n            p_list.append(i)\n    return p_list\n\ndef next_prime(n):\n    \"\"\"返回大于指定数字的下一个质数\"\"\"\n    n=n+1\n    while True:\n        if is_prime("}
{"task_id": "HumanEval/31", "completion": "    # 如果n小于或等于1，那么一定不是质数。\n    if n <= 1:\n        return False\n    # 如果n小于或等于3，那么一定是质数。\n    if n <= 3:\n        return True\n    # 如果 n能被2整除，那么一定不是质数。\n    if not n % 2:\n        return False\n    # 如果 n能被3整除，那么一定不是质数。\n    if not n % 3:\n        return False\n    # 把n的去最小素数2的幂的倍数。\n    i = n - 1\n    while i % 2 == 0 or i % 3 == 0:\n        i //= 2\n        i //= 3\n    # 现在 i是大于1的最小素数，并且和n不同余。\n    # 用i对n进行�", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # 如果n小于或等于1，那么一定不是质数。\n    if n <= 1:\n        return False\n    # 如果n小于或等于3，那么一定是质数。\n    if n <= 3:\n        return True\n    # 如果 n能被2整除，那么一定不是质数。\n    if not n % 2:\n        return False\n    # 如果 n能被3整除，那么一定不是质数。\n    if not n % 3:\n        return False\n    # 把n的去最小素数2的幂的倍数。\n    i = n - 1\n    while i % 2 == 0 or i % 3 == 0:\n        i //= 2\n        i //= 3\n    # 现在 i是大于1的最小素数，并且和n不同余。\n    # 用i对n进行�"}
{"task_id": "HumanEval/31", "completion": "    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    # 检查从 3 到最大偶数的质数\n    for k in range(3, n//2 + 1, 2):\n        if n % k == 0:\n            return False\n    return True\n\n\ndef sum_of_divisors(n):\n    \"\"\"求数字 n 的所有因子的和 \n    >>> sum_of_divisors(6)\n    5\n    >>> sum_of_divisors(10)\n    30\n    >>> sum_of_divisors(15)\n    225\n    >>> sum_of_divisors(101)  \n    259\n    >>> sum_of_divisors(100)\n    250\n    >>> sum_of_divisors(113)  \n    358\n    >>> sum_of_divisors(114)\n    383\n    \"\"\"\n", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    # 检查从 3 到最大偶数的质数\n    for k in range(3, n//2 + 1, 2):\n        if n % k == 0:\n            return False\n    return True\n\n\ndef sum_of_divisors(n):\n    \"\"\"求数字 n 的所有因子的和 \n    >>> sum_of_divisors(6)\n    5\n    >>> sum_of_divisors(10)\n    30\n    >>> sum_of_divisors(15)\n    225\n    >>> sum_of_divisors(101)  \n    259\n    >>> sum_of_divisors(100)\n    250\n    >>> sum_of_divisors(113)  \n    358\n    >>> sum_of_divisors(114)\n    383\n    \"\"\"\n"}
{"task_id": "HumanEval/31", "completion": "    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef prime(n):\n    \"\"\"列出n以内的所有质数   >>> prime(10)\n    [2, 3, 5, 7]\n    \"\"\"\n    def is_not_divided(j):\n        return n % j > 0\n    return filter(is_not_divided, [n for n in range(2, n + 1) if is_prime(n)])\n\ndef sum(n):\n    \"\"\"求1到n之间的所有数字之和   >>> sum(10)\n    55\n    >>> sum(20)\n    210\n    \"\"\"\n    return reduce(lambda x,y : x + y, [", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef prime(n):\n    \"\"\"列出n以内的所有质数   >>> prime(10)\n    [2, 3, 5, 7]\n    \"\"\"\n    def is_not_divided(j):\n        return n % j > 0\n    return filter(is_not_divided, [n for n in range(2, n + 1) if is_prime(n)])\n\ndef sum(n):\n    \"\"\"求1到n之间的所有数字之和   >>> sum(10)\n    55\n    >>> sum(20)\n    210\n    \"\"\"\n    return reduce(lambda x,y : x + y, ["}
{"task_id": "HumanEval/31", "completion": "    i = 2\n    while i < n:\n        if n % i == 0:\n            return False\n        i = i + 1\n    return True\n\ndef isprime(n):\n    \"\"\"如果给定的数字是质数，则返回true，否则返回false   >>> isprime(6)\n    False\n    >>> isprime(101)\n    True\n    >>> isprime(11)\n    True\n    >>> isprime(13441)\n    True\n    >>> isprime(61)\n    True\n    >>> isprime(4)\n    False\n    >>> isprime(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef is_composite(n):\n    \"\"\"如果给定的数字是合数，则返回true，否则返回false   >>> is_composite(", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    i = 2\n    while i < n:\n        if n % i == 0:\n            return False\n        i = i + 1\n    return True\n\ndef isprime(n):\n    \"\"\"如果给定的数字是质数，则返回true，否则返回false   >>> isprime(6)\n    False\n    >>> isprime(101)\n    True\n    >>> isprime(11)\n    True\n    >>> isprime(13441)\n    True\n    >>> isprime(61)\n    True\n    >>> isprime(4)\n    False\n    >>> isprime(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef is_composite(n):\n    \"\"\"如果给定的数字是合数，则返回true，否则返回false   >>> is_composite("}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n#-------------------------------------------------------------------------------\ndef is_prime2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime2(6)\n    False\n    >>> is_prime2(101)\n    True\n    >>> is_prime2(11)\n    True\n    >>> is_prime2(13441)\n    True\n    >>> is_prime2(61)\n    True\n    >>> is_prime2(4)\n    False\n    >>> is_prime2(1)\n    False\n    \"\"\"\n    if n == 2:\n        return False\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True  \n\n#-------------------------------------------------------------------------------\ndef prime_fac(n", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n#-------------------------------------------------------------------------------\ndef is_prime2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime2(6)\n    False\n    >>> is_prime2(101)\n    True\n    >>> is_prime2(11)\n    True\n    >>> is_prime2(13441)\n    True\n    >>> is_prime2(61)\n    True\n    >>> is_prime2(4)\n    False\n    >>> is_prime2(1)\n    False\n    \"\"\"\n    if n == 2:\n        return False\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True  \n\n#-------------------------------------------------------------------------------\ndef prime_fac(n"}
{"task_id": "HumanEval/31", "completion": "    # 如果 n 小于 2，一定不是质数\n    if n < 2:\n        return False\n    # 如果 n 小于 4，只需要判断 n 是否是 2 的倍数就可以了\n    if n < 4:\n        return True\n\n    # 先把 n 限制为只能被 2 整除\n    if n % 2 == 0:\n        return False\n\n    # 如果此时已经达到最大的质数 13441，则直接返回 True\n    if n == 13441:\n        return True\n\n    i = 3\n    while i ** 2 <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\nis_prime(101) # True\nis_prime(61) # True\nis_prime(1) # False\nis_prime(101) # True\n```\n\n###", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # 如果 n 小于 2，一定不是质数\n    if n < 2:\n        return False\n    # 如果 n 小于 4，只需要判断 n 是否是 2 的倍数就可以了\n    if n < 4:\n        return True\n\n    # 先把 n 限制为只能被 2 整除\n    if n % 2 == 0:\n        return False\n\n    # 如果此时已经达到最大的质数 13441，则直接返回 True\n    if n == 13441:\n        return True\n\n    i = 3\n    while i ** 2 <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\nis_prime(101) # True\nis_prime(61) # True\nis_prime(1) # False\nis_prime(101) # True\n```\n\n###"}
{"task_id": "HumanEval/34", "completion": "    l = sorted(l)\n    r = []\n    for i in range(len(l)):\n        if l[i]!= l[i - 1]:\n            r.append(l[i])\n    return r\n\n\ndef is_int_list(l: list):\n    \"\"\"判断是否为整型列表/元组\n    >>> is_int_list([1,2,3])\n    True\n    >>> is_int_list([1,2,3.2])\n    False\n    >>> is_int_list((1,2,3))\n    True\n    >>> is_int_list((1,2,3.2))\n    False\n    \"\"\"\n    for i in l:\n        if not (isinstance(i, int)):\n            return False\n    return True\n\n\ndef is_float_list(l: list):\n    \"\"\"判断是否为实数列表/元组\n    >>> is_float_list([1,2,3])\n    False\n    >>> is_float_list([1,2,3.2])\n    True", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l = sorted(l)\n    r = []\n    for i in range(len(l)):\n        if l[i]!= l[i - 1]:\n            r.append(l[i])\n    return r\n\n\ndef is_int_list(l: list):\n    \"\"\"判断是否为整型列表/元组\n    >>> is_int_list([1,2,3])\n    True\n    >>> is_int_list([1,2,3.2])\n    False\n    >>> is_int_list((1,2,3))\n    True\n    >>> is_int_list((1,2,3.2))\n    False\n    \"\"\"\n    for i in l:\n        if not (isinstance(i, int)):\n            return False\n    return True\n\n\ndef is_float_list(l: list):\n    \"\"\"判断是否为实数列表/元组\n    >>> is_float_list([1,2,3])\n    False\n    >>> is_float_list([1,2,3.2])\n    True"}
{"task_id": "HumanEval/34", "completion": "    if len(l) == 0:\n        return []\n    elif len(l) == 1:\n        return l\n    l.sort()\n    res = list(set(l))\n    res.sort()\n    return res\n\ndef unique1(l: list):\n    \"\"\"\n    :param l:\n    :return:\n    >>> unique1([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    res = []\n    for i in range(len(l)):\n        if i == 0 or l[i]!= l[i-1]:\n            res.append(l[i])\n    return res\n\nif __name__ == \"__main__\":\n    # print(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n    print(unique1([5, 3, 5, 2, 3, ", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l) == 0:\n        return []\n    elif len(l) == 1:\n        return l\n    l.sort()\n    res = list(set(l))\n    res.sort()\n    return res\n\ndef unique1(l: list):\n    \"\"\"\n    :param l:\n    :return:\n    >>> unique1([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    res = []\n    for i in range(len(l)):\n        if i == 0 or l[i]!= l[i-1]:\n            res.append(l[i])\n    return res\n\nif __name__ == \"__main__\":\n    # print(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n    print(unique1([5, 3, 5, 2, 3, "}
{"task_id": "HumanEval/34", "completion": "    return list(set(l))\n\ndef unique_order(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(OrderedDict.fromkeys(l).keys())\n\ndef uniq(l: list):\n    \"\"\"根据细颗粒度度量值，返回唯一值? >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set([i.microsecond for i in l]))\n\ndef uniq_order(l: list):\n    \"\"\"根据细颗粒度度量", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n\ndef unique_order(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(OrderedDict.fromkeys(l).keys())\n\ndef uniq(l: list):\n    \"\"\"根据细颗粒度度量值，返回唯一值? >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set([i.microsecond for i in l]))\n\ndef uniq_order(l: list):\n    \"\"\"根据细颗粒度度量"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    i, j = 0, 1\n    while j < len(l):\n        if l[j]!= l[i]:\n            i += 1\n            l[i] = l[j]\n        j += 1\n    return l[:i+1]\n\n\ndef unique2(l):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return [l[i] for i in range(len(l)) if l[i-1]!= l[i]]\n\n\ndef unique3(l):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    i, j = 0, 1\n    while j < len(l):\n        if l[j]!= l[i]:\n            i += 1\n            l[i] = l[j]\n        j += 1\n    return l[:i+1]\n\n\ndef unique2(l):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return [l[i] for i in range(len(l)) if l[i-1]!= l[i]]\n\n\ndef unique3(l):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    res = list()\n    for i in range(len(l)):\n        if l[i]!= l[i-1]:\n            res.append(l[i])\n    return res\n\ndef unique_2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    res = []\n    for i in l:\n        if i not in res:\n            res.append(i)\n    return res\n\ndef unique_3(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3,", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    res = list()\n    for i in range(len(l)):\n        if l[i]!= l[i-1]:\n            res.append(l[i])\n    return res\n\ndef unique_2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    res = []\n    for i in l:\n        if i not in res:\n            res.append(i)\n    return res\n\ndef unique_3(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3,"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    ret = []\n    for e in l:\n        if ret and ret[-1] == e:\n            continue\n        else:\n            ret.append(e)\n    return ret\n \ndef unique2(l: list):\n    \"\"\"返回列表中独特元素?\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n \ndef unique3(l: list):\n    \"\"\"返回列表中独特元素?\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    s = set()\n    for e in l:\n        if e not in s:\n            s.add(e)\n   ", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    ret = []\n    for e in l:\n        if ret and ret[-1] == e:\n            continue\n        else:\n            ret.append(e)\n    return ret\n \ndef unique2(l: list):\n    \"\"\"返回列表中独特元素?\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n \ndef unique3(l: list):\n    \"\"\"返回列表中独特元素?\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    s = set()\n    for e in l:\n        if e not in s:\n            s.add(e)\n   "}
{"task_id": "HumanEval/34", "completion": "    result = []\n    for i in l:\n        if i not in result:\n            result.append(i)\n    result.sort()\n    return result\n\ndef unique2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?\n    这个函数使用了 set 的特点，\n    不过无法应用到字符串的列表中。\n    >>> unique(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    ['0', '2', '3', '5', '9', '123']\n    \"\"\"\n    return list(set(l))\n\ndef unique3(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?\n    适用于字符串的列表。\n    >>> unique(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    ['0', '2", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    for i in l:\n        if i not in result:\n            result.append(i)\n    result.sort()\n    return result\n\ndef unique2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?\n    这个函数使用了 set 的特点，\n    不过无法应用到字符串的列表中。\n    >>> unique(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    ['0', '2', '3', '5', '9', '123']\n    \"\"\"\n    return list(set(l))\n\ndef unique3(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?\n    适用于字符串的列表。\n    >>> unique(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    ['0', '2"}
{"task_id": "HumanEval/34", "completion": "    ls, ret = list(l), []\n    ls.sort()\n    for i in range(0, len(ls)):\n        if i == 0 or ls[i]!= ls[i - 1]:\n            ret.append(ls[i])\n    return ret\n\n\ndef union(ls1: list, ls2: list):\n    \"\"\"返回两个列表的并集?\n    >>> union([4, 5, 7, 12, 34], [7, 53, 45, 7, 23])\n    [4, 5, 7, 12, 34, 53, 45, 7, 23]\n    \"\"\"\n    ls = [x for x in ls1 if x not in ls2] + [x for x in ls2 if x not in ls1]\n    return sorted(ls)\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表的交集?\n    >>> intersection([1, 2, 4, 5], [4,", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    ls, ret = list(l), []\n    ls.sort()\n    for i in range(0, len(ls)):\n        if i == 0 or ls[i]!= ls[i - 1]:\n            ret.append(ls[i])\n    return ret\n\n\ndef union(ls1: list, ls2: list):\n    \"\"\"返回两个列表的并集?\n    >>> union([4, 5, 7, 12, 34], [7, 53, 45, 7, 23])\n    [4, 5, 7, 12, 34, 53, 45, 7, 23]\n    \"\"\"\n    ls = [x for x in ls1 if x not in ls2] + [x for x in ls2 if x not in ls1]\n    return sorted(ls)\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表的交集?\n    >>> intersection([1, 2, 4, 5], [4,"}
{"task_id": "HumanEval/34", "completion": "    # 返回列表中经过排序后的独特元素\n    return list(set(l))\n\n\ndef unique_sort(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 返回列表中经过排序后的独特元素\n    return sorted(set(l), key=l.index)\n\n\ndef unique_sort_l(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 返回列表中经过排序后的独特元素\n    return list(set(l))\n\n\ndef unique_sort(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 返回列表中经过排序后的独特元素\n    return sorted(set(l), key=l.index)\n\n\ndef unique_sort_l(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n"}
{"task_id": "HumanEval/34", "completion": "    tmp = []\n    for i in l:\n        if not tmp or i!= tmp[-1]: tmp.append(i)\n    return tmp\n\ndef to_dict(l: list, index: int = None) -> dict:\n    \"\"\"将列表转换为字典\"\"\"\n    d = {}\n    for item in l:\n        if index is None:\n            d[item] = None\n        else:\n            d[item[index]] = item\n    return d\n\ndef to_set(l: list, index: int = None) -> set:\n    \"\"\"将列表去重并转换为集合\"\"\"\n    return set(unique(l, index))\n\ndef transpose(*l: list) -> list:\n    \"\"\"转置\"\"\"\n    _l = []\n    for i in zip(*l):\n        _l.append(i)\n    return _l\n\ndef filter_list(l: list, pattern) -> list:\n    \"\"\"根据元素模式过滤列表\"\"\"\n    return [item for item in l if pattern in item]\n\n", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    tmp = []\n    for i in l:\n        if not tmp or i!= tmp[-1]: tmp.append(i)\n    return tmp\n\ndef to_dict(l: list, index: int = None) -> dict:\n    \"\"\"将列表转换为字典\"\"\"\n    d = {}\n    for item in l:\n        if index is None:\n            d[item] = None\n        else:\n            d[item[index]] = item\n    return d\n\ndef to_set(l: list, index: int = None) -> set:\n    \"\"\"将列表去重并转换为集合\"\"\"\n    return set(unique(l, index))\n\ndef transpose(*l: list) -> list:\n    \"\"\"转置\"\"\"\n    _l = []\n    for i in zip(*l):\n        _l.append(i)\n    return _l\n\ndef filter_list(l: list, pattern) -> list:\n    \"\"\"根据元素模式过滤列表\"\"\"\n    return [item for item in l if pattern in item]\n\n"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef sum_elements(l: list):\n    \"\"\"返回列表中的元素之和    >>> sum_elements([1, 2, 3])\n    6\n    >>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    100\n    \"\"\"\n    return sum(l)\n\n\ndef average_elements(l: list):\n    \"\"\"返回列表中元素之", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef sum_elements(l: list):\n    \"\"\"返回列表中的元素之和    >>> sum_elements([1, 2, 3])\n    6\n    >>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    100\n    \"\"\"\n    return sum(l)\n\n\ndef average_elements(l: list):\n    \"\"\"返回列表中元素之"}
{"task_id": "HumanEval/35", "completion": "    if len(l) == 0:\n        raise ValueError(\"列表为空\")\n    max_value = l[0]\n    for i in range(1, len(l)):\n        if l[i] > max_value:\n            max_value = l[i]\n    return max_value\n\n\ndef remove_element(l: list, e: object):\n    \"\"\"在列表中移除指定元素，返回布尔值，表示移除是否成功\n    >>> remove_element([1, 2, 3], 2)\n    True\n    >>> remove_element([1, 2, 3], 2)\n    False\n    >>> remove_element([], 1)\n    False\n    \n    \"\"\"\n    if len(l) == 0 or e not in l:\n        return False\n    l.remove(e)\n    return True\n\n\ndef remove_first_element(l: list, e: object):\n    \"\"\"在列表中移除第一个指定元素，返回布尔值，表示移除是否", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError(\"列表为空\")\n    max_value = l[0]\n    for i in range(1, len(l)):\n        if l[i] > max_value:\n            max_value = l[i]\n    return max_value\n\n\ndef remove_element(l: list, e: object):\n    \"\"\"在列表中移除指定元素，返回布尔值，表示移除是否成功\n    >>> remove_element([1, 2, 3], 2)\n    True\n    >>> remove_element([1, 2, 3], 2)\n    False\n    >>> remove_element([], 1)\n    False\n    \n    \"\"\"\n    if len(l) == 0 or e not in l:\n        return False\n    l.remove(e)\n    return True\n\n\ndef remove_first_element(l: list, e: object):\n    \"\"\"在列表中移除第一个指定元素，返回布尔值，表示移除是否"}
{"task_id": "HumanEval/35", "completion": "    if not l:\n        return None\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l:\n        return None\n    return min(l)\n\n\ndef sum_of_list(l: list):\n    \"\"\"返回列表中所有元素的总和  >>> sum_of_list([1, 2, 3])\n    6\n    >>> sum_of_list([5, 3, -5])\n    -6\n    \"\"\"\n    if not l:\n        return None\n    return sum(l)\n\n\ndef average_of_list(l: list):\n    \"\"\"返回列表中元素的平均值    >>> average_of_list([1,", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l:\n        return None\n    return min(l)\n\n\ndef sum_of_list(l: list):\n    \"\"\"返回列表中所有元素的总和  >>> sum_of_list([1, 2, 3])\n    6\n    >>> sum_of_list([5, 3, -5])\n    -6\n    \"\"\"\n    if not l:\n        return None\n    return sum(l)\n\n\ndef average_of_list(l: list):\n    \"\"\"返回列表中元素的平均值    >>> average_of_list([1,"}
{"task_id": "HumanEval/35", "completion": "    if not l:\n        return None\n    else:\n        return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l:\n        return None\n    else:\n        return min(l)\n\n\ndef max_element2(l: list):\n    \"\"\"返回列表中的最大元素, 不使用max, 只使用for循环, while\n    >>> max_element2([1, 2, 3])\n    3\n    >>> max_element2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n    else:\n        return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l:\n        return None\n    else:\n        return min(l)\n\n\ndef max_element2(l: list):\n    \"\"\"返回列表中的最大元素, 不使用max, 只使用for循环, while\n    >>> max_element2([1, 2, 3])\n    3\n    >>> max_element2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:"}
{"task_id": "HumanEval/35", "completion": "    if len(l) == 1:\n        return l[0]\n    else:\n        return max(l[0], max_element(l[1:]))\n\n\ndef find_kth_sort(l: list, k: int):\n    \"\"\"K小的数,快排的思想\n    >>> find_kth_sort([3, 1, 2, 5, 4], 2)\n    1\n    >>> find_kth_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    5\n    >>> find_kth_sort([8, -9, 0, 2, -1, 4, 3, 7, 6, 5], 6)\n    6\n    >>> find_kth_sort([8, -9, 0, 2, -1, 4, 3, 7, 6, 5], 3)\n    3\n    \"\"\"\n    if len(l)", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return max(l[0], max_element(l[1:]))\n\n\ndef find_kth_sort(l: list, k: int):\n    \"\"\"K小的数,快排的思想\n    >>> find_kth_sort([3, 1, 2, 5, 4], 2)\n    1\n    >>> find_kth_sort([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    5\n    >>> find_kth_sort([8, -9, 0, 2, -1, 4, 3, 7, 6, 5], 6)\n    6\n    >>> find_kth_sort([8, -9, 0, 2, -1, 4, 3, 7, 6, 5], 3)\n    3\n    \"\"\"\n    if len(l)"}
{"task_id": "HumanEval/35", "completion": "    max_ = l[0]\n    for i in range(1, len(l)):\n        if l[i] > max_:\n            max_ = l[i]\n    return max_\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_ = l[0]\n    for i in range(1, len(l)):\n        if l[i] < min_:\n            min_ = l[i]\n    return min_\n```\n\n## 2. 列表去重\n\n去重的操作有很多，比如可以先进行排序，然后如果相邻两个数据相等，则舍弃相邻的那个元素。\n", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_ = l[0]\n    for i in range(1, len(l)):\n        if l[i] > max_:\n            max_ = l[i]\n    return max_\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_ = l[0]\n    for i in range(1, len(l)):\n        if l[i] < min_:\n            min_ = l[i]\n    return min_\n```\n\n## 2. 列表去重\n\n去重的操作有很多，比如可以先进行排序，然后如果相邻两个数据相等，则舍弃相邻的那个元素。\n"}
{"task_id": "HumanEval/35", "completion": "    max_value = l[0]\n    for i in l:\n        if i > max_value:\n            max_value = i\n    return max_value\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_value = l[0]\n    for i in l:\n        if i < min_value:\n            min_value = i\n    return min_value\n\n\ndef my_sum(l: list):\n    \"\"\"求列表的和\n    >>> l = [1, 2, 3, 4, 5]\n    >>> my_sum(l)\n    15\n    \"\"\"\n    sum = 0\n    for i in l:\n        sum += i\n    return sum\n\n\ndef filter_max_", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_value = l[0]\n    for i in l:\n        if i > max_value:\n            max_value = i\n    return max_value\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_value = l[0]\n    for i in l:\n        if i < min_value:\n            min_value = i\n    return min_value\n\n\ndef my_sum(l: list):\n    \"\"\"求列表的和\n    >>> l = [1, 2, 3, 4, 5]\n    >>> my_sum(l)\n    15\n    \"\"\"\n    sum = 0\n    for i in l:\n        sum += i\n    return sum\n\n\ndef filter_max_"}
{"task_id": "HumanEval/35", "completion": "    # 以当前元素为基准\n    curr_max = l[0]\n    for i in range(len(l)):\n        # 如果下一个元素大于当前元素，则更新当前元素\n        if l[i] > curr_max:\n            curr_max = l[i]\n    \n    return curr_max\n\n\ndef max_element_2(l: list):\n    \"\"\"\n    返回列表中的最大元素(更优)\n    >>> max_element_2([1, 2, 3])\n    3\n    >>> max_element_2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    # 因为初始最大元素取不到，所以最开始肯定要比最后一个较大，\n    # 所以循环遍历，每次比最后", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    # 以当前元素为基准\n    curr_max = l[0]\n    for i in range(len(l)):\n        # 如果下一个元素大于当前元素，则更新当前元素\n        if l[i] > curr_max:\n            curr_max = l[i]\n    \n    return curr_max\n\n\ndef max_element_2(l: list):\n    \"\"\"\n    返回列表中的最大元素(更优)\n    >>> max_element_2([1, 2, 3])\n    3\n    >>> max_element_2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    # 因为初始最大元素取不到，所以最开始肯定要比最后一个较大，\n    # 所以循环遍历，每次比最后"}
{"task_id": "HumanEval/35", "completion": "    if l:\n        return max(l)\n    else:\n        return None\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if l:\n        return min(l)\n    else:\n        return None\n\n\ndef get_max_min(l: list):\n    \"\"\"返回列表的最大最小元素（元组数据）    >>> get_max_min([1, 2, 3])\n    (3, 1)\n    >>> get_max_min([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    (123, -10)\n    \"\"\"\n    if l:\n        return max", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if l:\n        return max(l)\n    else:\n        return None\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if l:\n        return min(l)\n    else:\n        return None\n\n\ndef get_max_min(l: list):\n    \"\"\"返回列表的最大最小元素（元组数据）    >>> get_max_min([1, 2, 3])\n    (3, 1)\n    >>> get_max_min([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    (123, -10)\n    \"\"\"\n    if l:\n        return max"}
{"task_id": "HumanEval/35", "completion": "    # 这里假设列表中至少有一个元素\n    if len(l) == 1:\n        return l[0]\n    elif len(l) == 0:\n        return \"l是空列表\"\n        # 实际上应该报ValueError异常\n    else:\n        max = l[0]\n        for i in range(1, len(l)):\n            if l[i] > max:\n                max = l[i]\n        return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    # 这里假设列表中至少有一个元素\n    if len(l) == 1:\n        return l", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    # 这里假设列表中至少有一个元素\n    if len(l) == 1:\n        return l[0]\n    elif len(l) == 0:\n        return \"l是空列表\"\n        # 实际上应该报ValueError异常\n    else:\n        max = l[0]\n        for i in range(1, len(l)):\n            if l[i] > max:\n                max = l[i]\n        return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    # 这里假设列表中至少有一个元素\n    if len(l) == 1:\n        return l"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            if i % 7 == 0:\n                count += 1\n    return count\n\n\n# def fizz_buzz(n: int):\n#     \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n#     0\n#     >>> fizz_buzz(78)\n#     2\n#     >>> fizz_buzz(79)\n#     3\n#     \"\"\"\n#     return sum([i % 7 == 0 for i in range(n + 1) if i % 11 == 0 and i % 13 == 0])\n# 152/152 cases passed (32 ms)\n#    Your runtime beats 77.25 % of python3 submissions\n#    Your memory usage beats 10", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            if i % 7 == 0:\n                count += 1\n    return count\n\n\n# def fizz_buzz(n: int):\n#     \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n#     0\n#     >>> fizz_buzz(78)\n#     2\n#     >>> fizz_buzz(79)\n#     3\n#     \"\"\"\n#     return sum([i % 7 == 0 for i in range(n + 1) if i % 11 == 0 and i % 13 == 0])\n# 152/152 cases passed (32 ms)\n#    Your runtime beats 77.25 % of python3 submissions\n#    Your memory usage beats 10"}
{"task_id": "HumanEval/36", "completion": "    num = 0\n    for i in range(1, n+1):\n        if i%11 == 0 and i%13 == 0:\n            if i%7 == 0:\n                num += 1\n    return num\n\n\nif __name__ == \"__main__\":\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))\n```\n\n### 【题目4】\n\n```python\n\"\"\"\n数字2 ，4 ，6 ，8 ，10 ， 12 ，14 ，16 ，18 ，20 ，22 ，24 ， 26 ，28 ，30，32，\n34，36，38，40，42，44，46，48，50，52，54，56，58，60，62，64，66，68，70，72，74，\n", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    num = 0\n    for i in range(1, n+1):\n        if i%11 == 0 and i%13 == 0:\n            if i%7 == 0:\n                num += 1\n    return num\n\n\nif __name__ == \"__main__\":\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))\n```\n\n### 【题目4】\n\n```python\n\"\"\"\n数字2 ，4 ，6 ，8 ，10 ， 12 ，14 ，16 ，18 ，20 ，22 ，24 ， 26 ，28 ，30，32，\n34，36，38，40，42，44，46，48，50，52，54，56，58，60，62，64，66，68，70，72，74，\n"}
{"task_id": "HumanEval/36", "completion": "    fizz_buzz_count = 0\n    for i in range(1, n+1):\n        if i%11 == 0 and i%13 == 0:\n            if i%7 == 0:\n                fizz_buzz_count += 1\n    return fizz_buzz_count\n```\n\n## 每天一个小功能：随机冒泡排序\n\n```python\nimport random\n\ndef bubble_sort(lst):\n    \"\"\"\n        实现冒泡排序\n        :param lst: 一个随机数字列表\n        :return: None\n    \"\"\"\n    for i in range(len(lst)):\n        for j in range(len(lst)-i-1):\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n    return lst\n```\n\n## 每天一个小功能：汉诺塔\n\n> 汉��", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    fizz_buzz_count = 0\n    for i in range(1, n+1):\n        if i%11 == 0 and i%13 == 0:\n            if i%7 == 0:\n                fizz_buzz_count += 1\n    return fizz_buzz_count\n```\n\n## 每天一个小功能：随机冒泡排序\n\n```python\nimport random\n\ndef bubble_sort(lst):\n    \"\"\"\n        实现冒泡排序\n        :param lst: 一个随机数字列表\n        :return: None\n    \"\"\"\n    for i in range(len(lst)):\n        for j in range(len(lst)-i-1):\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n    return lst\n```\n\n## 每天一个小功能：汉诺塔\n\n> 汉��"}
{"task_id": "HumanEval/36", "completion": "    result = 0\n    for i in range(1, n):\n        if str(i)[1:2] in ('7', '1') and str(i)[:1] in ('7', '1'):\n            result += 1\n    return result\n\nprint(fizz_buzz(50))  # 0\nprint(fizz_buzz(78))  # 2\nprint(fizz_buzz(79))  # 3\n\n\ndef is_prime_number(n: int) -> bool:\n    \"\"\"\n    判断一个数是不是素数\n    判断n 是不是素数， 一定要先判断n 是不是大于1， 因为n 小于1 就肯定不是素数了，是0 或者负数\n    :param n:\n    :return:\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    result = 0\n    for i in range(1, n):\n        if str(i)[1:2] in ('7', '1') and str(i)[:1] in ('7', '1'):\n            result += 1\n    return result\n\nprint(fizz_buzz(50))  # 0\nprint(fizz_buzz(78))  # 2\nprint(fizz_buzz(79))  # 3\n\n\ndef is_prime_number(n: int) -> bool:\n    \"\"\"\n    判断一个数是不是素数\n    判断n 是不是素数， 一定要先判断n 是不是大于1， 因为n 小于1 就肯定不是素数了，是0 或者负数\n    :param n:\n    :return:\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n"}
{"task_id": "HumanEval/36", "completion": "    if n<1:\n        return 0\n    return fizz_buzz(n-1)+fizz_buzz_(n-1)\n\ndef fizz_buzz_(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数\"\"\"\n    if n<1:\n        return 0\n    if (n%7)==0 and (n%11)==0 and (n%13)==0:\n        return 1+fizz_buzz(n-1);\n    else:\n        return fizz_buzz(n-1);\n\n\nif __name__ == '__main__':\n    # print(fizz_buzz(50))\n    # print(fizz_buzz_(50))\n    # print(fizz_buzz(78))\n    # print(fizz_buzz(79))\n    # print(fizz_buzz(32))\n    # print(f", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n<1:\n        return 0\n    return fizz_buzz(n-1)+fizz_buzz_(n-1)\n\ndef fizz_buzz_(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数\"\"\"\n    if n<1:\n        return 0\n    if (n%7)==0 and (n%11)==0 and (n%13)==0:\n        return 1+fizz_buzz(n-1);\n    else:\n        return fizz_buzz(n-1);\n\n\nif __name__ == '__main__':\n    # print(fizz_buzz(50))\n    # print(fizz_buzz_(50))\n    # print(fizz_buzz(78))\n    # print(fizz_buzz(79))\n    # print(fizz_buzz(32))\n    # print(f"}
{"task_id": "HumanEval/36", "completion": "    if n>78 and n<227:\n        return 78/11 + 78/13 + 79/11 + 79/13 - 3*(78/11)/2 - (78/13)/2\n    elif n>226 and n<250:\n        return 78/11 + 78/13 + 79/11 + 79/13 \n    elif n>250 and n<300:\n        return 78/11 + 78/13 + 79/11 + 79/13 - (78/11)/2 + (78/13)/2\n    elif n>300:\n        return 78/11 + 78/13 + 79/11 + 79/13 - (78/11)/2 + (78/13)/2 - (11+13-1)/2 * (227-78)/11 * (250", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n>78 and n<227:\n        return 78/11 + 78/13 + 79/11 + 79/13 - 3*(78/11)/2 - (78/13)/2\n    elif n>226 and n<250:\n        return 78/11 + 78/13 + 79/11 + 79/13 \n    elif n>250 and n<300:\n        return 78/11 + 78/13 + 79/11 + 79/13 - (78/11)/2 + (78/13)/2\n    elif n>300:\n        return 78/11 + 78/13 + 79/11 + 79/13 - (78/11)/2 + (78/13)/2 - (11+13-1)/2 * (227-78)/11 * (250"}
{"task_id": "HumanEval/36", "completion": "    # 检查数值是否是11 的倍数\n    if n % 11 == 0:\n        return n\n    # 检查数值是否是13 的倍数\n    if n % 13 == 0:\n        return n\n    \n    # 如果上面两个条件均不满足，继续循环\n    while n < 1000000:\n        # 检查是否是11 的倍数\n        if n % 11 == 0:\n            return n\n        # 检查是否是13 的倍数\n        if n % 13 == 0:\n            return n\n        n += 1\n    return 0\n\n\nif __name__ == '__main__':\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))\n", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 检查数值是否是11 的倍数\n    if n % 11 == 0:\n        return n\n    # 检查数值是否是13 的倍数\n    if n % 13 == 0:\n        return n\n    \n    # 如果上面两个条件均不满足，继续循环\n    while n < 1000000:\n        # 检查是否是11 的倍数\n        if n % 11 == 0:\n            return n\n        # 检查是否是13 的倍数\n        if n % 13 == 0:\n            return n\n        n += 1\n    return 0\n\n\nif __name__ == '__main__':\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))\n"}
{"task_id": "HumanEval/36", "completion": "    # 当执行到下面第一行的时候，就开始计算了，所以需要给n 赋一个值\n    if n < 11:\n        return 0\n    count = 0\n    for i in range(1, n):\n        if not i % 11 and not i % 13:\n            count += 1\n\n    return count\n\n\ndef fizz_buzz_2(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 当执行到下面第一行的时候，就开始计算了，所以需要给n 赋一个值\n    if n < 11:\n        return 0\n", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 当执行到下面第一行的时候，就开始计算了，所以需要给n 赋一个值\n    if n < 11:\n        return 0\n    count = 0\n    for i in range(1, n):\n        if not i % 11 and not i % 13:\n            count += 1\n\n    return count\n\n\ndef fizz_buzz_2(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 当执行到下面第一行的时候，就开始计算了，所以需要给n 赋一个值\n    if n < 11:\n        return 0\n"}
{"task_id": "HumanEval/36", "completion": "    return 0 if n % 11 else 1 + fizz_buzz(n - 7)\n```\n\n**示例5：** \n\n```\n输入：n = 11\n输出：1\n\n示例 5：\n\n输入：n = 12\n输出：2\n\n示例 6：\n\n输入：n = 13\n输出：2\n\n示例 7：\n\n输入：n = 17\n输出：4\n\n示例 8：\n\n输入：n = 20\n输出：5\n```\n\n**提示：** \n\n-  *1 <= n <= 1000*  \n\n\n\n\n# 算法思路\n\n# 测试用例\n```\n1345. Jump Game IV 1345. 跳跃游戏 IV Medium\n```\n\n[enTitle]: https://leetcode.com/problems/jump-game-iv/\n[cnTitle", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return 0 if n % 11 else 1 + fizz_buzz(n - 7)\n```\n\n**示例5：** \n\n```\n输入：n = 11\n输出：1\n\n示例 5：\n\n输入：n = 12\n输出：2\n\n示例 6：\n\n输入：n = 13\n输出：2\n\n示例 7：\n\n输入：n = 17\n输出：4\n\n示例 8：\n\n输入：n = 20\n输出：5\n```\n\n**提示：** \n\n-  *1 <= n <= 1000*  \n\n\n\n\n# 算法思路\n\n# 测试用例\n```\n1345. Jump Game IV 1345. 跳跃游戏 IV Medium\n```\n\n[enTitle]: https://leetcode.com/problems/jump-game-iv/\n[cnTitle"}
{"task_id": "HumanEval/36", "completion": "    return sum(1 for i in range(n) if i%11==0 and i%13==0 and (set(str(i))=={\"7\"}))\n\nif __name__ == \"__main__\":\n    import doctest", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum(1 for i in range(n) if i%11==0 and i%13==0 and (set(str(i))=={\"7\"}))\n\nif __name__ == \"__main__\":\n    import doctest"}
{"task_id": "HumanEval/43", "completion": "    lt = l[:]\n    lt.sort()\n    start = 0\n    end = len(lt) - 1\n    while start < end:\n        if lt[start] + lt[end] == 0:\n            return True\n        if lt[start] + lt[end] < 0:\n            start += 1\n        if lt[start] + lt[end] > 0:\n            end -= 1\n    return False\n\n\ndef max_prod(l):\n    \"\"\"\n    max_prod 将整数列表作为输入，返回列表中最大可能乘积\n    >>> max_prod([2, 5, 3, 10])\n    300\n    >>> max_prod([2, 1, 4, 3, 8])\n    128\n    >>> max_prod([1, 2, 3, 4, 5])\n    120\n    >>> max_prod([4, 5, 6, 7, 8])\n", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    lt = l[:]\n    lt.sort()\n    start = 0\n    end = len(lt) - 1\n    while start < end:\n        if lt[start] + lt[end] == 0:\n            return True\n        if lt[start] + lt[end] < 0:\n            start += 1\n        if lt[start] + lt[end] > 0:\n            end -= 1\n    return False\n\n\ndef max_prod(l):\n    \"\"\"\n    max_prod 将整数列表作为输入，返回列表中最大可能乘积\n    >>> max_prod([2, 5, 3, 10])\n    300\n    >>> max_prod([2, 1, 4, 3, 8])\n    128\n    >>> max_prod([1, 2, 3, 4, 5])\n    120\n    >>> max_prod([4, 5, 6, 7, 8])\n"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(len(l)-1):\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\ndef test_pairs_sum_to_zero():\n    assert pairs_sum_to_zero([1, 3, 5, 0]) is False\n    assert pairs_sum_to_zero([1, 3, -2, 1]) is False\n    assert pairs_sum_to_zero([1, 2, 3, 7]) is False\n    assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) is True\n    assert pairs_sum_to_zero([1]) is False\n\ndef pairs_sum_to_zero2(l):\n    \"\"\"\n    pairs_sum_to_zero2 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\ndef test_pairs_sum_to_zero():\n    assert pairs_sum_to_zero([1, 3, 5, 0]) is False\n    assert pairs_sum_to_zero([1, 3, -2, 1]) is False\n    assert pairs_sum_to_zero([1, 2, 3, 7]) is False\n    assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) is True\n    assert pairs_sum_to_zero([1]) is False\n\ndef pairs_sum_to_zero2(l):\n    \"\"\"\n    pairs_sum_to_zero2 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_"}
{"task_id": "HumanEval/43", "completion": "    for index1, value1 in enumerate(l):\n        for index2, value2 in enumerate(l):\n            if index1!= index2 and value1 + value2 == 0:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    print(pairs_sum_to_zero([1, 3, 5, 0]))\n    print(pairs_sum_to_zero([1, 3, -2, 1]))\n    print(pairs_sum_to_zero([1, 2, 3, 7]))\n    print(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))\n    print(pairs_sum_to_zero([1]))\n\n```\n\n## 8.跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台����", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for index1, value1 in enumerate(l):\n        for index2, value2 in enumerate(l):\n            if index1!= index2 and value1 + value2 == 0:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    print(pairs_sum_to_zero([1, 3, 5, 0]))\n    print(pairs_sum_to_zero([1, 3, -2, 1]))\n    print(pairs_sum_to_zero([1, 2, 3, 7]))\n    print(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))\n    print(pairs_sum_to_zero([1]))\n\n```\n\n## 8.跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台����"}
{"task_id": "HumanEval/43", "completion": "    d = {}\n    for v in l:\n        if v not in d:\n            d[v] = 1\n        else:\n            d[v] += 1\n\n    for k, v in d.items():\n        if -k in d and v > 1 and d[", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    d = {}\n    for v in l:\n        if v not in d:\n            d[v] = 1\n        else:\n            d[v] += 1\n\n    for k, v in d.items():\n        if -k in d and v > 1 and d["}
{"task_id": "HumanEval/43", "completion": "    pass\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    pass\n```\n\n## 1.3 字符串实例 \n下面的代码中，实现把一个字符串倒过来输出，但是不能使用�����", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    pass\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    pass\n```\n\n## 1.3 字符串实例 \n下面的代码中，实现把一个字符串倒过来输出，但是不能使用�����"}
{"task_id": "HumanEval/43", "completion": "    # 使用 set() 去重\n    nums = set(l)\n    # 判断是否有两个数加起来等于0\n    return sum(nums) + sum(nums, -sum(nums)) == 0 \n\n\n# 5\n\ndef count_floats(s):\n    \"\"\"\n    count_floats 将字符串作为输入，如果字符串中有小数，则返回小数的个数。\n    否则返回0    >>> count_floats(\"Hello World\")\n    0\n    >>> count_floats(\"Hello 3.14 World\")\n    1\n    >>> count_floats(\"Hello 3 World\")\n    0\n    \"\"\"\n    return len([float(c) for c in s if c.isdigit()]) # 返回列表长度\n\n# 6\n\ndef is_pos_neg_equal(s):\n    \"\"\"\n    is_pos_neg_equal 将字符串作为输入，判断字符串中有正数和", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    # 使用 set() 去重\n    nums = set(l)\n    # 判断是否有两个数加起来等于0\n    return sum(nums) + sum(nums, -sum(nums)) == 0 \n\n\n# 5\n\ndef count_floats(s):\n    \"\"\"\n    count_floats 将字符串作为输入，如果字符串中有小数，则返回小数的个数。\n    否则返回0    >>> count_floats(\"Hello World\")\n    0\n    >>> count_floats(\"Hello 3.14 World\")\n    1\n    >>> count_floats(\"Hello 3 World\")\n    0\n    \"\"\"\n    return len([float(c) for c in s if c.isdigit()]) # 返回列表长度\n\n# 6\n\ndef is_pos_neg_equal(s):\n    \"\"\"\n    is_pos_neg_equal 将字符串作为输入，判断字符串中有正数和"}
{"task_id": "HumanEval/43", "completion": "    num = []\n    for i in range(0, len(l)):\n        num.append(l[i])\n        if i > 0:\n            num.pop(0)\n    for j in range(0, len(num)):\n        if sum(num) == 0:\n            return True\n        else:\n            return False\n\n\ndef first_repeated_word(str1):\n    \"\"\"\n    将字符串作为输入，如果有重复字符返回第一个重复的单词，否则返回None。\n    注意：大写和小写字母被视为不同\n        >>> first_repeated_word(\"a\")\n        None\n        >>> first_repeated_word(\"\")\n        None\n        >>> first_repeated_word(\"a a\")\n        'a'\n        >>> first_repeated_word(\"a a b\")\n        'a'\n        >>> first_repeated_word(\"a a b b\")\n        'a'\n        >>> first_repeated_word(\"a a b", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    num = []\n    for i in range(0, len(l)):\n        num.append(l[i])\n        if i > 0:\n            num.pop(0)\n    for j in range(0, len(num)):\n        if sum(num) == 0:\n            return True\n        else:\n            return False\n\n\ndef first_repeated_word(str1):\n    \"\"\"\n    将字符串作为输入，如果有重复字符返回第一个重复的单词，否则返回None。\n    注意：大写和小写字母被视为不同\n        >>> first_repeated_word(\"a\")\n        None\n        >>> first_repeated_word(\"\")\n        None\n        >>> first_repeated_word(\"a a\")\n        'a'\n        >>> first_repeated_word(\"a a b\")\n        'a'\n        >>> first_repeated_word(\"a a b b\")\n        'a'\n        >>> first_repeated_word(\"a a b"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    print(l)\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\ndef make_histogram(integers, bins):\n    \"\"\"\n    make_histogram 函数将整数列表 integers 中的整数分成 bins 组，\n    每组有多少个整数取决于 integers 中的整数数量，\n    返回一个包含数组中每组元素数量的列表。\n    如果 bins 的值大于 integers 中整数的数量，\n    则数组中有 bins 个元素，每个元素的值都是 1。\n    如果 bins 的值小于 integers 中整数的数量，\n    则数组中只有 bins 个元素，每个元素的值是 integers ", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    print(l)\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\ndef make_histogram(integers, bins):\n    \"\"\"\n    make_histogram 函数将整数列表 integers 中的整数分成 bins 组，\n    每组有多少个整数取决于 integers 中的整数数量，\n    返回一个包含数组中每组元素数量的列表。\n    如果 bins 的值大于 integers 中整数的数量，\n    则数组中有 bins 个元素，每个元素的值都是 1。\n    如果 bins 的值小于 integers 中整数的数量，\n    则数组中只有 bins 个元素，每个元素的值是 integers "}
{"task_id": "HumanEval/43", "completion": "    if not l:\n        return False\n    for i in range(len(l) - 1):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\n# 练习4.3：完成pairs_sum_to_zero的速度优化，充分利用遍历顺序，快速跳过无用的测试。\n# 比如，当第一元素为正数时，不必再遍历后面的所有元素，因为结果一定是False。\n\n# 练习4.4：阅读一下列表解析表达式中的for循环和 while循环，特别是它们与range的结合用法。\n\n# 练习4.5：将pairs_sum_to", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if not l:\n        return False\n    for i in range(len(l) - 1):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\n# 练习4.3：完成pairs_sum_to_zero的速度优化，充分利用遍历顺序，快速跳过无用的测试。\n# 比如，当第一元素为正数时，不必再遍历后面的所有元素，因为结果一定是False。\n\n# 练习4.4：阅读一下列表解析表达式中的for循环和 while循环，特别是它们与range的结合用法。\n\n# 练习4.5：将pairs_sum_to"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(0, len(l) - 1):\n        if l[i] > 0:\n            return False\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\n\ndef remove_dups_from_list(l):\n    \"\"\"\n    remove_dups_from_list 移除列表l中重复项，不改变原列表，并将返回\n    一个新列表\n    >>> remove_dups_from_list([])\n    []\n    >>> remove_dups_from_list([1])\n    [1]\n    >>> remove_dups_from_list([1, 1, 2, 2, 3, 3])\n    [1, 2, 3]\n    \"\"\"\n    new_list = []\n    for i in l:\n        if not i in new_list:\n            new_list.append(i)\n    return new_list\n\n\ndef remove_dups_from_list_in_place(", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(0, len(l) - 1):\n        if l[i] > 0:\n            return False\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\n\ndef remove_dups_from_list(l):\n    \"\"\"\n    remove_dups_from_list 移除列表l中重复项，不改变原列表，并将返回\n    一个新列表\n    >>> remove_dups_from_list([])\n    []\n    >>> remove_dups_from_list([1])\n    [1]\n    >>> remove_dups_from_list([1, 1, 2, 2, 3, 3])\n    [1, 2, 3]\n    \"\"\"\n    new_list = []\n    for i in l:\n        if not i in new_list:\n            new_list.append(i)\n    return new_list\n\n\ndef remove_dups_from_list_in_place("}
{"task_id": "HumanEval/52", "completion": "    for item in l:\n        if item >= t:\n            return False\n    return True\n\n\n#### 对于不定参数的函数的默认参数\n\ndef print_two(*args):\n    arg1, arg2 = args\n    print(f\"arg1: {arg1}, arg2: {arg2}\")\n\n\nprint_two(1, 2)\nprint_two('one', 'two')\nprint_two('one', 'two', 'three')\n\n# 用 * 来简写参数列表\n# 用 ** 来简写关键字参数\n\ndef print_two_again(arg1, arg2):\n    print(f\"arg1: {arg1}, arg2: {arg2}\")\n\n\nprint_two_again('one', 'two')\n\nargs = [1, 2]\nprint_two_again(*args)\n\nkwargs = {'arg1': 1, 'arg2': 2}\nprint_two_again(**kwargs)\n\n\ndef print_one(arg", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for item in l:\n        if item >= t:\n            return False\n    return True\n\n\n#### 对于不定参数的函数的默认参数\n\ndef print_two(*args):\n    arg1, arg2 = args\n    print(f\"arg1: {arg1}, arg2: {arg2}\")\n\n\nprint_two(1, 2)\nprint_two('one', 'two')\nprint_two('one', 'two', 'three')\n\n# 用 * 来简写参数列表\n# 用 ** 来简写关键字参数\n\ndef print_two_again(arg1, arg2):\n    print(f\"arg1: {arg1}, arg2: {arg2}\")\n\n\nprint_two_again('one', 'two')\n\nargs = [1, 2]\nprint_two_again(*args)\n\nkwargs = {'arg1': 1, 'arg2': 2}\nprint_two_again(**kwargs)\n\n\ndef print_one(arg"}
{"task_id": "HumanEval/52", "completion": "    return all([i <= t for i in l])\n\ndef average():\n    \"\"\"计算数字列表的平均数\n     >>> average([1.0, 2.0, 3.0, 4.0])\n     2.5\n     >>> average([1, 2, 4, 10])\n     3.25\n    \"\"\"\n    pass\n\ndef median():\n    \"\"\"计算数字列表的中位数\n    \"\"\"\n    pass\n```\n\n### 问题3\n\n编写一个函数，它计算给定数字列表中的最大值，并返回最大值的索引。\n\n```python\ndef max_index(l: list):\n    \"\"\"计算数字列表中的最大值\n    并返回最大值的索引\n    >>> max_index([1, 2, 4, 10])\n    1\n    \"\"\"\n    return l.index(max(l))\n```\n\n### 问题4\n\n编写一个函数，��", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([i <= t for i in l])\n\ndef average():\n    \"\"\"计算数字列表的平均数\n     >>> average([1.0, 2.0, 3.0, 4.0])\n     2.5\n     >>> average([1, 2, 4, 10])\n     3.25\n    \"\"\"\n    pass\n\ndef median():\n    \"\"\"计算数字列表的中位数\n    \"\"\"\n    pass\n```\n\n### 问题3\n\n编写一个函数，它计算给定数字列表中的最大值，并返回最大值的索引。\n\n```python\ndef max_index(l: list):\n    \"\"\"计算数字列表中的最大值\n    并返回最大值的索引\n    >>> max_index([1, 2, 4, 10])\n    1\n    \"\"\"\n    return l.index(max(l))\n```\n\n### 问题4\n\n编写一个函数，��"}
{"task_id": "HumanEval/52", "completion": "    return all([m < t for m in l])\n\ndef below_threshold_iter(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for m in l:\n        if m >= t:\n            return False\n    return True\n\n\ndef all_equal(l: list):\n    \"\"\"如果列表 l 中的所有元素相等则返回 True >>> all_equal([1, 1, 1, 1])\n    True\n    >>> all_equal([1, 2, 1, 1])\n    False\n    \"\"\"\n    return all([l[0] == m for m in l])\n\ndef all_equal_iter(l: list):\n    \"\"\"如果列表 l ", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([m < t for m in l])\n\ndef below_threshold_iter(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for m in l:\n        if m >= t:\n            return False\n    return True\n\n\ndef all_equal(l: list):\n    \"\"\"如果列表 l 中的所有元素相等则返回 True >>> all_equal([1, 1, 1, 1])\n    True\n    >>> all_equal([1, 2, 1, 1])\n    False\n    \"\"\"\n    return all([l[0] == m for m in l])\n\ndef all_equal_iter(l: list):\n    \"\"\"如果列表 l "}
{"task_id": "HumanEval/52", "completion": "    if len(l) == 0:\n        return True\n    elif l[0] < t:\n        l = l[1:]\n        return below_threshold(l, t)\n    else:\n        return False\n\n\n# 剩下的我们跳过\n\n\ndef test():\n    print(below_threshold([], 0))\n\n\nif __name__ == '__main__':\n    test()\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\ndef f(l):\n    return l[0] > 5\n\n\ndef below_threshold(l, t):\n    if len(l) == 0:\n        return True\n    elif f(l):\n        l = l[1:]\n        return below_threshold(l, t)\n    else:\n        return False\n\n\ndef test():\n    print(below_threshold([1, 2, 4, 10], 100))\n\n\nif __name__ == '__main__':\n    test()\n\"\"\"\n\n\"\"\"\ndef", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    if len(l) == 0:\n        return True\n    elif l[0] < t:\n        l = l[1:]\n        return below_threshold(l, t)\n    else:\n        return False\n\n\n# 剩下的我们跳过\n\n\ndef test():\n    print(below_threshold([], 0))\n\n\nif __name__ == '__main__':\n    test()\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\ndef f(l):\n    return l[0] > 5\n\n\ndef below_threshold(l, t):\n    if len(l) == 0:\n        return True\n    elif f(l):\n        l = l[1:]\n        return below_threshold(l, t)\n    else:\n        return False\n\n\ndef test():\n    print(below_threshold([1, 2, 4, 10], 100))\n\n\nif __name__ == '__main__':\n    test()\n\"\"\"\n\n\"\"\"\ndef"}
{"task_id": "HumanEval/52", "completion": "    if None in l:\n        return True\n    if len(l) == 0:\n        return True\n    return all([n < t for n in l])\n\n\ndef below_threshold2(l, t):\n    if l == []:\n        return True\n    return all([x < t for x in l])\n\n\ndef below_threshold3(l, t):\n    if None in l:\n        return True\n    if l == []:\n        return True\n    return all([x < t for x in l])\n\n\ndef below_threshold4(l, t):\n    return all(x < t for x in l)\n\n\n# 描述：定义函数 all_equal，函数接受一个列表 l，并且返回 True 如果列表的所有元素均相等，如果不相等则返回 False。\n# \n\ndef all_equal(l: list):\n    \"\"\"如果列表l中的所有元素相等，则返回True   >>> all_", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    if None in l:\n        return True\n    if len(l) == 0:\n        return True\n    return all([n < t for n in l])\n\n\ndef below_threshold2(l, t):\n    if l == []:\n        return True\n    return all([x < t for x in l])\n\n\ndef below_threshold3(l, t):\n    if None in l:\n        return True\n    if l == []:\n        return True\n    return all([x < t for x in l])\n\n\ndef below_threshold4(l, t):\n    return all(x < t for x in l)\n\n\n# 描述：定义函数 all_equal，函数接受一个列表 l，并且返回 True 如果列表的所有元素均相等，如果不相等则返回 False。\n# \n\ndef all_equal(l: list):\n    \"\"\"如果列表l中的所有元素相等，则返回True   >>> all_"}
{"task_id": "HumanEval/52", "completion": "    for x in l:\n        if x >= t:\n            return False\n    return True\n\n\ndef first_non_matching(l: list, p: list) -> int:\n    \"\"\"返回列表 l 中，与列表 p 中的任何元素不匹配的第一个元素在 l 中的索引  >>> first_non_matching([1, 4, 2, 5, 7], [1, 4, 2, 5])\n    3\n    >>> first_non_matching([1, 4, 2, 5, 7], [2, 4, 5, 7, 1, 6, 8])\n    4\n    \"\"\"\n    for i in range(len(l)):\n        if l[i]!= p[i]:\n            return i\n    return None\n\n\ndef first_non_matching_2(l: list, p: list) -> int:\n    \"\"\"返回列表 l 中，与列表 p 中的任何元素不匹配的第", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for x in l:\n        if x >= t:\n            return False\n    return True\n\n\ndef first_non_matching(l: list, p: list) -> int:\n    \"\"\"返回列表 l 中，与列表 p 中的任何元素不匹配的第一个元素在 l 中的索引  >>> first_non_matching([1, 4, 2, 5, 7], [1, 4, 2, 5])\n    3\n    >>> first_non_matching([1, 4, 2, 5, 7], [2, 4, 5, 7, 1, 6, 8])\n    4\n    \"\"\"\n    for i in range(len(l)):\n        if l[i]!= p[i]:\n            return i\n    return None\n\n\ndef first_non_matching_2(l: list, p: list) -> int:\n    \"\"\"返回列表 l 中，与列表 p 中的任何元素不匹配的第"}
{"task_id": "HumanEval/52", "completion": "    return all([n < t for n in l])\n\n\ndef no_dups(l: list):\n    \"\"\"如果整数列表 l 中没有重复数字，则返回 True   >>> no_dups([1, 2, 3, 10, 100])\n    True\n    >>> no_dups([1, 2, 3, 4, 10, 100])\n    False\n    \"\"\"\n    return len(l) == len(set(l))\n\n\ndef one_away(s1: str, s2: str):\n    \"\"\"如果字符串 s1 和 s2 之间只差一个字符，则返回 True   >>> one_away(\"abc\", \"abcde\")\n    True\n    >>> one_away(\"abc\", \"abd\")\n    False\n    \"\"\"\n    if s1 == s2:\n        return True\n    diff = 0\n    for i in range(min(len(s1), len(s2))):\n        if s1[i]!= s", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([n < t for n in l])\n\n\ndef no_dups(l: list):\n    \"\"\"如果整数列表 l 中没有重复数字，则返回 True   >>> no_dups([1, 2, 3, 10, 100])\n    True\n    >>> no_dups([1, 2, 3, 4, 10, 100])\n    False\n    \"\"\"\n    return len(l) == len(set(l))\n\n\ndef one_away(s1: str, s2: str):\n    \"\"\"如果字符串 s1 和 s2 之间只差一个字符，则返回 True   >>> one_away(\"abc\", \"abcde\")\n    True\n    >>> one_away(\"abc\", \"abd\")\n    False\n    \"\"\"\n    if s1 == s2:\n        return True\n    diff = 0\n    for i in range(min(len(s1), len(s2))):\n        if s1[i]!= s"}
{"task_id": "HumanEval/52", "completion": "    return all(x < t for x in l)\n\n\ndef all_vowels(s: str):\n    \"\"\"如果字符串中的所有字母都是元音，则返回 True >>> all_vowels(\"hi\")\n    True\n    >>> all_vowels(\"Oh yay!\")\n    False\n    \"\"\"\n    return all(x in \"aeiouAEIOU\" for x in s)\n\n\ndef all_even(l: list):\n    \"\"\"如果列表中的所有元素都是偶数，则返回 True >>> all_even([2, 4, 6, 8])\n    True\n    >>> all_even([1, 3, 4])\n    False\n    \"\"\"\n    return all(i % 2 == 0 for i in l)\n\n\ndef all_same(l: list):\n    \"\"\"如果列表中的所有元素都是相同的，则返回 True   >>> all_same([1, 1, 1])\n    True\n    >>> all_same([1, -", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)\n\n\ndef all_vowels(s: str):\n    \"\"\"如果字符串中的所有字母都是元音，则返回 True >>> all_vowels(\"hi\")\n    True\n    >>> all_vowels(\"Oh yay!\")\n    False\n    \"\"\"\n    return all(x in \"aeiouAEIOU\" for x in s)\n\n\ndef all_even(l: list):\n    \"\"\"如果列表中的所有元素都是偶数，则返回 True >>> all_even([2, 4, 6, 8])\n    True\n    >>> all_even([1, 3, 4])\n    False\n    \"\"\"\n    return all(i % 2 == 0 for i in l)\n\n\ndef all_same(l: list):\n    \"\"\"如果列表中的所有元素都是相同的，则返回 True   >>> all_same([1, 1, 1])\n    True\n    >>> all_same([1, -"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n    return True\n\n\n# 推导式 ： https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries\ndef below_threshold2(l: list, t: int):\n    return all(i <= t for i in l)\n\n\ndef below_threshold3(l: list, t: int):\n    return all((i <= t for i in l))\n\n\n# 更加精简的写法\ndef below_threshold4(l, t):\n    return all(i <= t for i in l)\n\n\ndef print_if_all_below(l, t):\n    if all(i <= t for i in l):\n        print('ALL BELOW')\n    else:\n        print('SOME ABOVE')\n\n\ndef count_above(l: list, t: int):\n    \"\"\"统计列表中大于阈值t的数字个数，返回值类", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n    return True\n\n\n# 推导式 ： https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries\ndef below_threshold2(l: list, t: int):\n    return all(i <= t for i in l)\n\n\ndef below_threshold3(l: list, t: int):\n    return all((i <= t for i in l))\n\n\n# 更加精简的写法\ndef below_threshold4(l, t):\n    return all(i <= t for i in l)\n\n\ndef print_if_all_below(l, t):\n    if all(i <= t for i in l):\n        print('ALL BELOW')\n    else:\n        print('SOME ABOVE')\n\n\ndef count_above(l: list, t: int):\n    \"\"\"统计列表中大于阈值t的数字个数，返回值类"}
{"task_id": "HumanEval/52", "completion": "    return all(n < t for n in l)\n\n\nif __name__ == \"__main__\":\n    print(below_threshold([1, 2, 4, 10], 100))\n    print(below_threshold([1, 20, 4, 10], 5))\n\n```\n\n**输出结果：**\n\n```py\nTrue\nFalse\n```\n\n以上就是所有逻辑函数的介绍，下面我们来看看循环的使用\n\n---\n\n## 循环\n\n我们已经对所有 python 里的内置函数都有所了解，接下来就来学习关于循环的内容了。\n\n### for 循环\n\nfor循环（from **f**irst **o**r **f**orever）是最简单的循环结构，for循环的主", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(n < t for n in l)\n\n\nif __name__ == \"__main__\":\n    print(below_threshold([1, 2, 4, 10], 100))\n    print(below_threshold([1, 20, 4, 10], 5))\n\n```\n\n**输出结果：**\n\n```py\nTrue\nFalse\n```\n\n以上就是所有逻辑函数的介绍，下面我们来看看循环的使用\n\n---\n\n## 循环\n\n我们已经对所有 python 里的内置函数都有所了解，接下来就来学习关于循环的内容了。\n\n### for 循环\n\nfor循环（from **f**irst **o**r **f**orever）是最简单的循环结构，for循环的主"}
{"task_id": "HumanEval/54", "completion": "    if len(s0)!= len(s1):\n        return False\n    \n    if not len(s0) or not len(s1):\n        return False\n    \n    s_dict = get_dicts(s0, s1)\n    \n    for k in s_dict:\n        if s_dict[k]!= 0:\n            return False\n    \n    return True\n\n\ndef get_dicts(s0: str, s1: str):\n    \"\"\"\n    s0, s1 两个字符串，返回 s0, s1 中各字符对应字频字典（把 s0, s1 中所有字符放到字典）\n    {'a': 2, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'z': 4}\n    >>> get_dicts('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    {'e': 1, 'a': 2, 'b': 1, 'c':", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    \n    if not len(s0) or not len(s1):\n        return False\n    \n    s_dict = get_dicts(s0, s1)\n    \n    for k in s_dict:\n        if s_dict[k]!= 0:\n            return False\n    \n    return True\n\n\ndef get_dicts(s0: str, s1: str):\n    \"\"\"\n    s0, s1 两个字符串，返回 s0, s1 中各字符对应字频字典（把 s0, s1 中所有字符放到字典）\n    {'a': 2, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'z': 4}\n    >>> get_dicts('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    {'e': 1, 'a': 2, 'b': 1, 'c':"}
{"task_id": "HumanEval/54", "completion": "    for s0_char in s0:\n        if s1.count(s0_char) == 0:\n            return False\n    return True\n\n\ndef same_chars_v2(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return len([c for c in s0 if s1.count(c) > 0]) == len(s0)\n", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    for s0_char in s0:\n        if s1.count(s0_char) == 0:\n            return False\n    return True\n\n\ndef same_chars_v2(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return len([c for c in s0 if s1.count(c) > 0]) == len(s0)\n"}
{"task_id": "HumanEval/54", "completion": "    return Counter(s0) == Counter(s1)\n\n\ndef same_chars1(s0: str, s1: str):\n    \"\"\"\n    循环遍历比较每对字符串中的字符是否相同\n    时间复杂度：O(n)  n是字符串长度，循环一个字符串即需要n次\n    空间复杂度：O(1)\n    >>> same_chars1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars1('abcd', 'dddddddabc')\n    True\n    >>> same_chars1('dddddddabc', 'abcd')\n    True\n    >>> same_chars1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars1('abcd', 'dddddddabce')\n    False\n    >>> same_chars1('eabcdzz", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return Counter(s0) == Counter(s1)\n\n\ndef same_chars1(s0: str, s1: str):\n    \"\"\"\n    循环遍历比较每对字符串中的字符是否相同\n    时间复杂度：O(n)  n是字符串长度，循环一个字符串即需要n次\n    空间复杂度：O(1)\n    >>> same_chars1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars1('abcd', 'dddddddabc')\n    True\n    >>> same_chars1('dddddddabc', 'abcd')\n    True\n    >>> same_chars1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars1('abcd', 'dddddddabce')\n    False\n    >>> same_chars1('eabcdzz"}
{"task_id": "HumanEval/54", "completion": "    return bool(set(s0) & set(s1))\n\n\ndef same_char_count(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同数量的字符。 \n \n    >>> same_char_count('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_char_count('abcd', 'dddddddabc')\n    False\n    >>> same_char_count('dddddddabc', 'abcd')\n    False\n    >>> same_char_count('eabcd', 'dddzzzzzzzddeddabc')\n    False\n    >>> same_char_count('abcd', 'dddddddabce')\n    False\n    >>> same_char_count('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    d0 = char_counts(s0)\n    d1", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return bool(set(s0) & set(s1))\n\n\ndef same_char_count(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同数量的字符。 \n \n    >>> same_char_count('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_char_count('abcd', 'dddddddabc')\n    False\n    >>> same_char_count('dddddddabc', 'abcd')\n    False\n    >>> same_char_count('eabcd', 'dddzzzzzzzddeddabc')\n    False\n    >>> same_char_count('abcd', 'dddddddabce')\n    False\n    >>> same_char_count('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    d0 = char_counts(s0)\n    d1"}
{"task_id": "HumanEval/54", "completion": "    s0_set = set(s0)\n    s1_set = set(s1)\n    s0_set_len = len(s0_set)\n    s1_set_len = len(s1_set)\n    if s0_set_len!= s1_set_len:\n        return False\n    return s0_set == s1_set\n\n\nclass TestExercise6(unittest.TestCase):\n\n    def test_same_chars(self):\n        self.assertTrue(same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc'))\n        self.assertTrue(same_chars('abcd', 'dddddddabc'))\n        self.assertTrue(same_chars('dddddddabc', 'abcd'))\n        self.assertFalse(same_chars('eabcd', 'dddzzzzzzzddddabc'))\n        self.assertFalse(same_chars('abcd', 'dddddddabce'))\n        self.assertFalse(same_chars('eabcdzzzz", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    s0_set = set(s0)\n    s1_set = set(s1)\n    s0_set_len = len(s0_set)\n    s1_set_len = len(s1_set)\n    if s0_set_len!= s1_set_len:\n        return False\n    return s0_set == s1_set\n\n\nclass TestExercise6(unittest.TestCase):\n\n    def test_same_chars(self):\n        self.assertTrue(same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc'))\n        self.assertTrue(same_chars('abcd', 'dddddddabc'))\n        self.assertTrue(same_chars('dddddddabc', 'abcd'))\n        self.assertFalse(same_chars('eabcd', 'dddzzzzzzzddddabc'))\n        self.assertFalse(same_chars('abcd', 'dddddddabce'))\n        self.assertFalse(same_chars('eabcdzzzz"}
{"task_id": "HumanEval/54", "completion": "    c0 = Counter(s0)\n    c1 = Counter(s1)\n    for c, n0 in c0.items():\n        if not c1.get(c, 0):\n            return False\n        n1 = c1.get(c, 0)\n        if abs(n0 - n1) > 1:\n            return False\n    for c, n1 in c1.items():\n        if not c0.get(c, 0):\n            return False\n    return True\n\n\ndef rotate(s: str, n: int) -> str:\n    \"\"\"\n    对于任意字符串 s 和整数 n，我们可以将 s 的第 n 个字符移动到最前面，\n    并将其余字符顺次向右（循环移位），这样就得到了字符串 s 的旋转。\n    例如，若 s = 'abcde' 且n = 2，那么旋转后的字符串", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    c0 = Counter(s0)\n    c1 = Counter(s1)\n    for c, n0 in c0.items():\n        if not c1.get(c, 0):\n            return False\n        n1 = c1.get(c, 0)\n        if abs(n0 - n1) > 1:\n            return False\n    for c, n1 in c1.items():\n        if not c0.get(c, 0):\n            return False\n    return True\n\n\ndef rotate(s: str, n: int) -> str:\n    \"\"\"\n    对于任意字符串 s 和整数 n，我们可以将 s 的第 n 个字符移动到最前面，\n    并将其余字符顺次向右（循环移位），这样就得到了字符串 s 的旋转。\n    例如，若 s = 'abcde' 且n = 2，那么旋转后的字符串"}
{"task_id": "HumanEval/54", "completion": "    if len(s0)!= len(s1):\n        return False\n    # if len(set(s0) & set(s1))!= len(s0):\n    #     return False\n    if len(set(s0) & set(s1))!= len(s0):\n        return False\n    return True\n\n\ndef get_sub_str(s: str, sub_len: int, c: str = '*'):\n    \"\"\"\n    获取一个字符串的每个子串，长度为 sub_len    >>> get_sub_str('hello, world', 3)\n    ['hel', 'ell', 'llo', 'lo,', ', w', 'wo', 'or', 'rl', 'ld']\n    >>> get_sub_str('hello, world', 4, '*')\n    ['hell', 'ello', 'llo,', 'lo, ','o, ','o ', ', ','d', ', ', ', ', 'd ','d',' ','d', 'ld', 'llo']\n    >>> get_sub_str('", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    # if len(set(s0) & set(s1))!= len(s0):\n    #     return False\n    if len(set(s0) & set(s1))!= len(s0):\n        return False\n    return True\n\n\ndef get_sub_str(s: str, sub_len: int, c: str = '*'):\n    \"\"\"\n    获取一个字符串的每个子串，长度为 sub_len    >>> get_sub_str('hello, world', 3)\n    ['hel', 'ell', 'llo', 'lo,', ', w', 'wo', 'or', 'rl', 'ld']\n    >>> get_sub_str('hello, world', 4, '*')\n    ['hell', 'ello', 'llo,', 'lo, ','o, ','o ', ', ','d', ', ', ', ', 'd ','d',' ','d', 'ld', 'llo']\n    >>> get_sub_str('"}
{"task_id": "HumanEval/54", "completion": "    # TODO: 你的代码\n    return False    \n\n\ndef one_of_two_diff(s0: str, s1: str):\n    \"\"\"\n    判断两个单词中字符的数目是否相同，只要有一个字符的数目相同，就返回 True\n    >>> one_of_two_diff('abcd', 'ababcd')\n    True\n    >>> one_of_two_diff('abcd', 'abcd')\n    False\n    >>> one_of_two_diff('abcd', 'abcdd')\n    False\n    >>> one_of_two_diff('eabcd', 'ababdd')\n    False\n    \"\"\"\n    # TODO: 你的代码\n    return False\n\n\ndef get_length_diff(s0: str, s1: str):\n    \"\"\"\n    返回两个字符串中字符的数目差值\n    如果差值大于 0，返回正数\n    如果差值小于 0，返回�", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # TODO: 你的代码\n    return False    \n\n\ndef one_of_two_diff(s0: str, s1: str):\n    \"\"\"\n    判断两个单词中字符的数目是否相同，只要有一个字符的数目相同，就返回 True\n    >>> one_of_two_diff('abcd', 'ababcd')\n    True\n    >>> one_of_two_diff('abcd', 'abcd')\n    False\n    >>> one_of_two_diff('abcd', 'abcdd')\n    False\n    >>> one_of_two_diff('eabcd', 'ababdd')\n    False\n    \"\"\"\n    # TODO: 你的代码\n    return False\n\n\ndef get_length_diff(s0: str, s1: str):\n    \"\"\"\n    返回两个字符串中字符的数目差值\n    如果差值大于 0，返回正数\n    如果差值小于 0，返回�"}
{"task_id": "HumanEval/54", "completion": "    if len(s0) == len(s1) and len(s0) > 1:\n        s0s = set(s0)\n        s1s = set(s1)\n        if s0s == s1s:\n            return True\n    return False\n\n\ndef count_substring(s: str, t: str):\n    \"\"\"\n    统计一个句子中子字符串出现的次数    >>> count_substring('abab', 'ab')\n    2\n    >>> count_substring('abab', 'a')\n    2\n    >>> count_substring('abab', 'b')\n    1\n    \"\"\"\n    if t and s and len(s) > len(t):\n        count = 0\n        t_len = len(t)\n        n = len(s)\n        for i in range(n - t_len + 1):\n            if s[i:i + t_len] == t:\n                count += 1\n        return count\n    return 0\n\n\ndef reverse_string(s: str):\n    if s", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0) == len(s1) and len(s0) > 1:\n        s0s = set(s0)\n        s1s = set(s1)\n        if s0s == s1s:\n            return True\n    return False\n\n\ndef count_substring(s: str, t: str):\n    \"\"\"\n    统计一个句子中子字符串出现的次数    >>> count_substring('abab', 'ab')\n    2\n    >>> count_substring('abab', 'a')\n    2\n    >>> count_substring('abab', 'b')\n    1\n    \"\"\"\n    if t and s and len(s) > len(t):\n        count = 0\n        t_len = len(t)\n        n = len(s)\n        for i in range(n - t_len + 1):\n            if s[i:i + t_len] == t:\n                count += 1\n        return count\n    return 0\n\n\ndef reverse_string(s: str):\n    if s"}
{"task_id": "HumanEval/54", "completion": "  \n    def compare(s0, s1, s0_len, s1_len):\n        for i in range(s0_len):\n            idx = s0.find(s0[i], i, s0_len)\n            if idx!= s1.find(s0[i], i, s1_len):\n                return False\n        return True\n    \n    s0_len = len(s0)\n    s1_len = len(s1)\n    if s0_len!= s1_len:\n        return False\n    else:\n        return compare(s0, s1, s0_len, s1_len)\ndef same_chars2(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddd", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n  \n    def compare(s0, s1, s0_len, s1_len):\n        for i in range(s0_len):\n            idx = s0.find(s0[i], i, s0_len)\n            if idx!= s1.find(s0[i], i, s1_len):\n                return False\n        return True\n    \n    s0_len = len(s0)\n    s1_len = len(s1)\n    if s0_len!= s1_len:\n        return False\n    else:\n        return compare(s0, s1, s0_len, s1_len)\ndef same_chars2(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddd"}
{"task_id": "HumanEval/58", "completion": "    # 先把两个列表合并成一个列表\n    l3 = l1+l2\n    # 遍历拆分后的列表\n    for i in l3:\n        # 找出列表元素在两个列表中都出现过的内容\n        if i in l1 and i in l2:\n            # 加入满足条件的内容\n            print(i)\n\n\ncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])  # [1, 653, 5]\ncommon([5, 3, 2, 8], [3, 2])  # [2, 3]\n\n\ndef common_list(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # 先把两个列表合并成一个列表\n    l3 = l1+l2\n    # 遍历拆分后的列表\n    for i in l3:\n        # 找出列表元素在两个列表中都出现过的内容\n        if i in l1 and i in l2:\n            # 加入满足条件的内容\n            print(i)\n\n\ncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])  # [1, 653, 5]\ncommon([5, 3, 2, 8], [3, 2])  # [2, 3]\n\n\ndef common_list(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序"}
{"task_id": "HumanEval/58", "completion": "    l_1_set = set(l1)\n    l_2_set = set(l2)\n    l_3_set = l_1_set & l_2_set\n    return list(l_3_set)\n\n\nif __name__ == '__main__':\n    # print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    # print(common([5, 3, 2, 8], [3, 2]))\n    # print(common([1, 4, 3, 34, 653, 2, 5], []))\n    # print(common([1, 4, 3, 34, 653, 2, 5], [8, 6, 23, 2, 5, 3, 4]))\n    # print(common([],", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l_1_set = set(l1)\n    l_2_set = set(l2)\n    l_3_set = l_1_set & l_2_set\n    return list(l_3_set)\n\n\nif __name__ == '__main__':\n    # print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    # print(common([5, 3, 2, 8], [3, 2]))\n    # print(common([1, 4, 3, 34, 653, 2, 5], []))\n    # print(common([1, 4, 3, 34, 653, 2, 5], [8, 6, 23, 2, 5, 3, 4]))\n    # print(common([],"}
{"task_id": "HumanEval/58", "completion": "    l1, l2 = sorted(l1), sorted(l2)\n    i = j = 0\n    res = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        elif l1[i] > l2[j]:\n            j += 1\n    return res\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n   ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1, l2 = sorted(l1), sorted(l2)\n    i = j = 0\n    res = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        elif l1[i] > l2[j]:\n            j += 1\n    return res\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n   "}
{"task_id": "HumanEval/58", "completion": "    if l1 and l2:\n        l3 = set(l1) & set(l2)\n        l3.sort()\n        return l3\n    else:\n        return False\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if l1 and l2:\n        l3 = list(set(l1) & set(l2))\n        l3.sort()\n        return l3\n    else:\n        return False\n\n\ndef common2", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if l1 and l2:\n        l3 = set(l1) & set(l2)\n        l3.sort()\n        return l3\n    else:\n        return False\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if l1 and l2:\n        l3 = list(set(l1) & set(l2))\n        l3.sort()\n        return l3\n    else:\n        return False\n\n\ndef common2"}
{"task_id": "HumanEval/58", "completion": "    if(not l1 or not l2):\n        return []\n    tmp = []\n    i = 0\n    j = 0\n    while(i < len(l1) and j < len(l2)):\n        if(l1[i] == l2[j]):\n            tmp.append(l1[i])\n            i += 1\n            j += 1\n        elif(l1[i] < l2[j]):\n            i += 1\n        else:\n            j += 1\n    return tmp\n\n\ndef common_set(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if(not l1 or not l2):\n        return []\n    tmp = []\n    i = 0\n    j = 0\n    while(i < len(l1) and j < len(l2)):\n        if(l1[i] == l2[j]):\n            tmp.append(l1[i])\n            i += 1\n            j += 1\n        elif(l1[i] < l2[j]):\n            i += 1\n        else:\n            j += 1\n    return tmp\n\n\ndef common_set(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common"}
{"task_id": "HumanEval/58", "completion": "    s1 = set(l1)\n    s2 = set(l2)\n    return list(s1 & s2)\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    s1 = set(l1)\n    s2 = set(l2)\n    return list(s1 | s2)\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    s1 = set(l1)\n    s2 = set(l2)\n    return list(s1 & s2)\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    s1 = set(l1)\n    s2 = set(l2)\n    return list(s1 | s2)\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，"}
{"task_id": "HumanEval/58", "completion": "    if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    res = []\n    for x in l1:\n        if x in l2 and (x not in res):\n            res.append(x)\n    return res\n\n\ndef common2(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = []\n    l1.sort()  # 排序后的链表较短，", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    res = []\n    for x in l1:\n        if x in l2 and (x not in res):\n            res.append(x)\n    return res\n\n\ndef common2(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = []\n    l1.sort()  # 排序后的链表较短，"}
{"task_id": "HumanEval/58", "completion": "    ls = list(set(l1) & set(l2))\n    ls.sort()\n    return ls\n\n\ndef commonIndex(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次，并且返回的列表下标元素是两个列表中的该元素下标，下标排序也是从小到大    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [(0, 0), (1, 1), (4, 4)]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [(0, 0), (1, 1)]\n\n    \"\"\"\n    ls = []\n    for i in range(len(l1)):\n       ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    ls = list(set(l1) & set(l2))\n    ls.sort()\n    return ls\n\n\ndef commonIndex(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次，并且返回的列表下标元素是两个列表中的该元素下标，下标排序也是从小到大    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [(0, 0), (1, 1), (4, 4)]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [(0, 0), (1, 1)]\n\n    \"\"\"\n    ls = []\n    for i in range(len(l1)):\n       "}
{"task_id": "HumanEval/58", "completion": "    return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    print(__doc__)\n    # common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    # common([5, 3, 2, 8], [3, ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    print(__doc__)\n    # common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    # common([5, 3, 2, 8], [3, "}
{"task_id": "HumanEval/58", "completion": "\n    common_list = list(set(l1) & set(l2))\n    return sorted(common_list)\n\n\ndef uncommon(l1: list, l2: list):\n    \"\"\"返回两个列表中不同的元素，返回列表要求排过序且每个元素只出现一次    >>> uncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 653, 7, 9, 121]\n    >>> uncommon([1, 4, 3, 34, 653, 2, 5], [1, 7, 5, 9, 121])\n    [7, 9, 121, 4, 653, 3, 34, 2, 5]\n    \"\"\"\n    uncommon_list = list(set(l1).union", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n\n    common_list = list(set(l1) & set(l2))\n    return sorted(common_list)\n\n\ndef uncommon(l1: list, l2: list):\n    \"\"\"返回两个列表中不同的元素，返回列表要求排过序且每个元素只出现一次    >>> uncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 653, 7, 9, 121]\n    >>> uncommon([1, 4, 3, 34, 653, 2, 5], [1, 7, 5, 9, 121])\n    [7, 9, 121, 4, 653, 3, 34, 2, 5]\n    \"\"\"\n    uncommon_list = list(set(l1).union"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while n > i:\n        if n % i == 0:\n            n = n // i\n        else:\n            i += 1\n    return n\n\ndef prime_factorization(n: int):\n    \"\"\"返回 n 的质因数分解。假设n > 2 且不是质数\n    >>> prime_factorization(13195)\n    {2: 2, 3: 1, 5: 1, 7: 1, 13: 1}\n    >>> prime_factorization(2048)\n    {2: 12}\n    \"\"\"\n    d = {}\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            n //= i\n            d[i] = d.get(i, 0) + 1\n        i += 1\n    return d\n \ndef square_of_largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大��", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while n > i:\n        if n % i == 0:\n            n = n // i\n        else:\n            i += 1\n    return n\n\ndef prime_factorization(n: int):\n    \"\"\"返回 n 的质因数分解。假设n > 2 且不是质数\n    >>> prime_factorization(13195)\n    {2: 2, 3: 1, 5: 1, 7: 1, 13: 1}\n    >>> prime_factorization(2048)\n    {2: 12}\n    \"\"\"\n    d = {}\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            n //= i\n            d[i] = d.get(i, 0) + 1\n        i += 1\n    return d\n \ndef square_of_largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大��"}
{"task_id": "HumanEval/59", "completion": "    # 逐个递增，如果 n 和 n-1 的约数里有质因数，则将 n 的约数里的质因数减 1，直到 n 等于 1 或减到 1 后为 1。\n    # 注意，仅当 n 为 1 时，约数里的质因数可能会减到 1，此时最大质因数就是 n 本身\n    while n > 1:\n        for i in range(n-1, 1, -1):\n            if i % n == 0:\n                n = i\n                break\n        else:\n            return n\n\n\ndef prime_factors(n: int):\n    \"\"\"返回 n 的所有因子列表。\"\"\"\n    answer = []\n    while n > 1:\n        for i in range(2, n + 1):\n            if n % i == 0:\n                answer", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # 逐个递增，如果 n 和 n-1 的约数里有质因数，则将 n 的约数里的质因数减 1，直到 n 等于 1 或减到 1 后为 1。\n    # 注意，仅当 n 为 1 时，约数里的质因数可能会减到 1，此时最大质因数就是 n 本身\n    while n > 1:\n        for i in range(n-1, 1, -1):\n            if i % n == 0:\n                n = i\n                break\n        else:\n            return n\n\n\ndef prime_factors(n: int):\n    \"\"\"返回 n 的所有因子列表。\"\"\"\n    answer = []\n    while n > 1:\n        for i in range(2, n + 1):\n            if n % i == 0:\n                answer"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    n = n\n    while i * i <= n:\n        # 如果n整除 i，就尝试除以i\n        if n % i == 0:\n            # 记录i，并更新n为除以i的商\n            n = n // i\n        else:\n            # 否则i侧不存在整除n的任意数，将i+1\n            i += 1\n    return n\n    \ndef main():\n    # 找到最大质因数\n    print(largest_prime_factor(600851475143))\n    \nif __name__ == '__main__':\n    main()\n```\n\n运行结果：\n\n```\n6857\n```\n\n### 找到最大质因数 - 高精度版\n\n```python\ndef largest_prime_factor(n: int) -> int:\n    # 找到最大质因数\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    n = n\n    while i * i <= n:\n        # 如果n整除 i，就尝试除以i\n        if n % i == 0:\n            # 记录i，并更新n为除以i的商\n            n = n // i\n        else:\n            # 否则i侧不存在整除n的任意数，将i+1\n            i += 1\n    return n\n    \ndef main():\n    # 找到最大质因数\n    print(largest_prime_factor(600851475143))\n    \nif __name__ == '__main__':\n    main()\n```\n\n运行结果：\n\n```\n6857\n```\n\n### 找到最大质因数 - 高精度版\n\n```python\ndef largest_prime_factor(n: int) -> int:\n    # 找到最大质因数\n"}
{"task_id": "HumanEval/59", "completion": "    if n % 2 == 0:\n        return 2  \n    # 如果是奇数，那么我们可以试着除以3\n    if n % 3 == 0:\n        return 3\n    \n    # 从第4个数字开始，我们逐渐尝试除以各种质数，\n    # 直到我们找到一个质数，最后n能被它整除\n    for i in range(1, n // 2, 2):\n        if is_prime(i):\n            if n % i == 0:\n                return largest_prime_factor(n / i)\n\n# 使用时请先调用 is_prime 函数来检查数字是否为质数，\n# 否则将导致报错。\n# 这里为了避免计算质因数的除法，我们可以暂时����", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0:\n        return 2  \n    # 如果是奇数，那么我们可以试着除以3\n    if n % 3 == 0:\n        return 3\n    \n    # 从第4个数字开始，我们逐渐尝试除以各种质数，\n    # 直到我们找到一个质数，最后n能被它整除\n    for i in range(1, n // 2, 2):\n        if is_prime(i):\n            if n % i == 0:\n                return largest_prime_factor(n / i)\n\n# 使用时请先调用 is_prime 函数来检查数字是否为质数，\n# 否则将导致报错。\n# 这里为了避免计算质因数的除法，我们可以暂时����"}
{"task_id": "HumanEval/59", "completion": "    n = abs(int(n))\n    limit = int((n ** 0.5) + 0.5)\n    for i in range(3, limit, 2):\n        while n % i == 0:\n            n //= i\n    return n\n\ndef test_largest_prime_factor():\n    assert largest_prime_factor(600851475143) == 6857\n    assert largest_prime_factor(13195) == 29\n    assert largest_prime_factor(2048) == 2\n\n\n\n\ndef least_common_multiple(factors: List[int]) -> int:\n    \"\"\"返回两个数字的最小公倍数。 假设所有数字都不是1。 \n    >>> least_common_multiple([4, 3])\n    12\n    >>> least_common_multiple([3, 5, 7])\n    105\n    >>> least_common_multiple([2, 4, 6])\n    6\n    \"\"\"", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    n = abs(int(n))\n    limit = int((n ** 0.5) + 0.5)\n    for i in range(3, limit, 2):\n        while n % i == 0:\n            n //= i\n    return n\n\ndef test_largest_prime_factor():\n    assert largest_prime_factor(600851475143) == 6857\n    assert largest_prime_factor(13195) == 29\n    assert largest_prime_factor(2048) == 2\n\n\n\n\ndef least_common_multiple(factors: List[int]) -> int:\n    \"\"\"返回两个数字的最小公倍数。 假设所有数字都不是1。 \n    >>> least_common_multiple([4, 3])\n    12\n    >>> least_common_multiple([3, 5, 7])\n    105\n    >>> least_common_multiple([2, 4, 6])\n    6\n    \"\"\""}
{"task_id": "HumanEval/59", "completion": "    # 1 是质数 且 它总是被所有数的因子。\n    if n in (2, 3, 5, 7): return n\n    # 把 n 一分为二，直到它只是由两个质数之一组成。\n    \"\"\"\n    13195 = 3 * 5 * 7 * 11 * 13, 因此至少有一个质数\n    3 * 5 * 7 = 27 * 2, 因此至少有一个质数\n    27 * 2 = 54 * 1, 因此至少有一个质数\n    54 * 1 = 6 * 9, 因此至少有一个质数\n    \"\"\"\n    # 找到 n 的质因数\n    while True:\n        \"\"\"\n        n 除以 2 的结果为 548", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # 1 是质数 且 它总是被所有数的因子。\n    if n in (2, 3, 5, 7): return n\n    # 把 n 一分为二，直到它只是由两个质数之一组成。\n    \"\"\"\n    13195 = 3 * 5 * 7 * 11 * 13, 因此至少有一个质数\n    3 * 5 * 7 = 27 * 2, 因此至少有一个质数\n    27 * 2 = 54 * 1, 因此至少有一个质数\n    54 * 1 = 6 * 9, 因此至少有一个质数\n    \"\"\"\n    # 找到 n 的质因数\n    while True:\n        \"\"\"\n        n 除以 2 的结果为 548"}
{"task_id": "HumanEval/59", "completion": "    if is_prime(n):\n        return n\n    \n    p = 2\n    while n > 1:\n        if n % p == 0:\n            n = n // p\n        else:\n            p += 1\n    return p\n\nif __name__ == '__main__':\n    print(largest_prime_factor(13195))\n\n\"\"\"\npython -m pytest -q pylist04-3.py\n\"\"\"\n\nfrom typing import List\n\ndef find_run_median(nums: List[int]) -> float: \n    \"\"\"计算给定的数字的跑团中位数。 \n    跑团中是指一系列数字，当在某个位置上添加一个数字后，数字均小于该位置上的元素和大于或等于其位置以下的所有元素。\n    跑团中位数是数字最大的那个。\n    \n    例如，给定序列", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if is_prime(n):\n        return n\n    \n    p = 2\n    while n > 1:\n        if n % p == 0:\n            n = n // p\n        else:\n            p += 1\n    return p\n\nif __name__ == '__main__':\n    print(largest_prime_factor(13195))\n\n\"\"\"\npython -m pytest -q pylist04-3.py\n\"\"\"\n\nfrom typing import List\n\ndef find_run_median(nums: List[int]) -> float: \n    \"\"\"计算给定的数字的跑团中位数。 \n    跑团中是指一系列数字，当在某个位置上添加一个数字后，数字均小于该位置上的元素和大于或等于其位置以下的所有元素。\n    跑团中位数是数字最大的那个。\n    \n    例如，给定序列"}
{"task_id": "HumanEval/59", "completion": "    assert n > 1 and not is_prime(n)\n    res = 1\n    while 1:\n        # 取出 n 的最大质因数，直到这个质因数大于 n\n        div = n // n  # 这里意思是除以它自己，这样就会得到 n 的最大质因数，肯定是一个大于 n 的数字。\n        res = div\n        if is_prime(div):\n            return div\n        n = div\n\n\nif __name__ == \"__main__\":\n    print(largest_prime_factor(13195))\n    print(largest_prime_factor(2))\n    print(largest_prime_factor(2048))\n    print(largest_prime_factor(312000))\n```\n\n\n\n\n\n\n\n## 代码4\n\n\n\n### 【剑指 II 017】矩形覆盖\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    assert n > 1 and not is_prime(n)\n    res = 1\n    while 1:\n        # 取出 n 的最大质因数，直到这个质因数大于 n\n        div = n // n  # 这里意思是除以它自己，这样就会得到 n 的最大质因数，肯定是一个大于 n 的数字。\n        res = div\n        if is_prime(div):\n            return div\n        n = div\n\n\nif __name__ == \"__main__\":\n    print(largest_prime_factor(13195))\n    print(largest_prime_factor(2))\n    print(largest_prime_factor(2048))\n    print(largest_prime_factor(312000))\n```\n\n\n\n\n\n\n\n## 代码4\n\n\n\n### 【剑指 II 017】矩形覆盖\n"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while n % i!= 0:\n        i += 1\n    return i\n    \n\ndef find_max_primes_product(limit: int):\n    \"\"\"在 0 到 limit 之间寻找具有最大质因数乘积的数。\n    \n        返回这个数的值和乘积。\n    >>> find_max_primes_product(10)\n    (9, 25)\n    >>> find_max_primes_product(100)\n    (97, 9009)\n    \"\"\"\n    primes = []\n    # 从 2 开始，将所有质数添加到 primes 列表中\n    for n in range(2, limit):\n        if is_prime(n):\n            primes.append(n)\n    max_product = 1\n    max_product_n = 1\n    for i in primes:\n        product = 1\n        for j in primes", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while n % i!= 0:\n        i += 1\n    return i\n    \n\ndef find_max_primes_product(limit: int):\n    \"\"\"在 0 到 limit 之间寻找具有最大质因数乘积的数。\n    \n        返回这个数的值和乘积。\n    >>> find_max_primes_product(10)\n    (9, 25)\n    >>> find_max_primes_product(100)\n    (97, 9009)\n    \"\"\"\n    primes = []\n    # 从 2 开始，将所有质数添加到 primes 列表中\n    for n in range(2, limit):\n        if is_prime(n):\n            primes.append(n)\n    max_product = 1\n    max_product_n = 1\n    for i in primes:\n        product = 1\n        for j in primes"}
{"task_id": "HumanEval/59", "completion": "    return reduce(lambda x, y: x * y, prime_factors(n))\n\ndef smallest_prime_factor(n: int):\n    \"\"\"返回 n 的最小质因数。假设n > 1 且不是质数  >>> smallest_prime_factor(13195)\n    5.\n    >>> smallest_prime_factor(2048)\n    2\n    \"\"\"\n    return reduce(lambda x, y: x * y, prime_factors(n)[1:])\n\ndef test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    test()\n\n# 运行结果如下：\n# >python prime_factorization.py\n# 127435873", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return reduce(lambda x, y: x * y, prime_factors(n))\n\ndef smallest_prime_factor(n: int):\n    \"\"\"返回 n 的最小质因数。假设n > 1 且不是质数  >>> smallest_prime_factor(13195)\n    5.\n    >>> smallest_prime_factor(2048)\n    2\n    \"\"\"\n    return reduce(lambda x, y: x * y, prime_factors(n)[1:])\n\ndef test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    test()\n\n# 运行结果如下：\n# >python prime_factorization.py\n# 127435873"}
{"task_id": "HumanEval/60", "completion": "    sum_numbers = 0\n    for i in range(1, n+1):\n        sum_numbers += i\n    return sum_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.test", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    sum_numbers = 0\n    for i in range(1, n+1):\n        sum_numbers += i\n    return sum_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.test"}
{"task_id": "HumanEval/60", "completion": "    current, sum = 0, 0\n    while current <= n:\n        sum += current\n        current += 1\n    return sum\n\n\ndef get_primes_less_than(n: int):\n    \"\"\"get_primes_less_than 返回小于n的所有素数\n    >>> get_primes_less_than(10)\n    [2, 3, 5, 7]\n    >>> get_primes_less_than(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    >>> get_primes_less_than(100)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    assert n > 0, \"n must be an positive integer\"\n    result = []\n    for i in", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    current, sum = 0, 0\n    while current <= n:\n        sum += current\n        current += 1\n    return sum\n\n\ndef get_primes_less_than(n: int):\n    \"\"\"get_primes_less_than 返回小于n的所有素数\n    >>> get_primes_less_than(10)\n    [2, 3, 5, 7]\n    >>> get_primes_less_than(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    >>> get_primes_less_than(100)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    assert n > 0, \"n must be an positive integer\"\n    result = []\n    for i in"}
{"task_id": "HumanEval/60", "completion": "    s = 0\n    for x in range(1, n + 1):\n        s += x\n    return s\n\n\ndef factorial(n: int):\n    \"\"\"factorial 计算n的阶乘.   >>> factorial(5)\n    120\n    >>> factorial(2)\n    2\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\n\ndef n_sum(n: int):\n    \"\"\" n_sum 计算整数n的阶乘被2整除的和.\n    注意：n的阶乘被2整除的和，等于n的阶乘除以2后的值.\n\n    如果n为负数，则返回0.\n    \n    >>> n_sum(3)\n    4\n    >>> n_sum(1)\n    1\n   ", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    s = 0\n    for x in range(1, n + 1):\n        s += x\n    return s\n\n\ndef factorial(n: int):\n    \"\"\"factorial 计算n的阶乘.   >>> factorial(5)\n    120\n    >>> factorial(2)\n    2\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\n\ndef n_sum(n: int):\n    \"\"\" n_sum 计算整数n的阶乘被2整除的和.\n    注意：n的阶乘被2整除的和，等于n的阶乘除以2后的值.\n\n    如果n为负数，则返回0.\n    \n    >>> n_sum(3)\n    4\n    >>> n_sum(1)\n    1\n   "}
{"task_id": "HumanEval/60", "completion": "    return sum(range(1, n + 1))\n\ndef is_power_of_two(n: int) -> bool:\n    \"\"\"  判断数字n是不是2的整数次方  >>> is_power_of_two(1048576)\n    True\n    >>> is_power_of_two(1024)\n    True\n    >>> is_power_of_two(3)\n    False\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(1)\n    True\n    \"\"\"\n    return (n > 0) and (n & (n - 1) == 0)\n\n\ndef is_number_prime(n: int) -> bool:\n    \"\"\"  判断数字n是不是素数  >>> is_number_prime(1048576)\n    False\n    >>> is_number_prime(15)\n    True\n    >>> is_number_prime(1024)\n    False\n    >>> is_number_prime(", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))\n\ndef is_power_of_two(n: int) -> bool:\n    \"\"\"  判断数字n是不是2的整数次方  >>> is_power_of_two(1048576)\n    True\n    >>> is_power_of_two(1024)\n    True\n    >>> is_power_of_two(3)\n    False\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(1)\n    True\n    \"\"\"\n    return (n > 0) and (n & (n - 1) == 0)\n\n\ndef is_number_prime(n: int) -> bool:\n    \"\"\"  判断数字n是不是素数  >>> is_number_prime(1048576)\n    False\n    >>> is_number_prime(15)\n    True\n    >>> is_number_prime(1024)\n    False\n    >>> is_number_prime("}
{"task_id": "HumanEval/60", "completion": "    return sum(range(n + 1))\n\n\"\"\"\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))\n\"\"\"\n\ndef sum_to_n_iter(n: int):\n    \"\"\"sum_to_n_iter 计算从1到n的数字的和.   >>> sum_to_n_iter(30)\n    465\n    >>> sum_to_n_iter(100)\n    5050\n    >>> sum_to_n_iter(5)\n    15\n    >>> sum_to_n_iter(10)", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(n + 1))\n\n\"\"\"\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))\n\"\"\"\n\ndef sum_to_n_iter(n: int):\n    \"\"\"sum_to_n_iter 计算从1到n的数字的和.   >>> sum_to_n_iter(30)\n    465\n    >>> sum_to_n_iter(100)\n    5050\n    >>> sum_to_n_iter(5)\n    15\n    >>> sum_to_n_iter(10)"}
{"task_id": "HumanEval/60", "completion": "    s = 0\n    if n < 0:\n        print('非法参数')\n    elif n == 0:\n        return 0\n    else: \n        for i in range(n):\n            s += i + 1\n    return s\n\ndef main():\n    num =", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    s = 0\n    if n < 0:\n        print('非法参数')\n    elif n == 0:\n        return 0\n    else: \n        for i in range(n):\n            s += i + 1\n    return s\n\ndef main():\n    num ="}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\ndef fibonacci(n: int):\n    \"\"\"fibonacci 计算斐波拉契数列.  >>> fibonacci(10)\n    55\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\ndef fibonacci_v2(n: int):\n    \"\"\"fibonacci 计算斐波拉契数列.  >>> fibonacci(10)\n    55\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci_v2(n - 2", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef fibonacci(n: int):\n    \"\"\"fibonacci 计算斐波拉契数列.  >>> fibonacci(10)\n    55\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\ndef fibonacci_v2(n: int):\n    \"\"\"fibonacci 计算斐波拉契数列.  >>> fibonacci(10)\n    55\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci_v2(n - 2"}
{"task_id": "HumanEval/60", "completion": "    sum = 0\n    for i in range(1, n + 1):\n        sum += i\n    return sum\n\n\ndef sum_of_squares(n: int) -> int:\n    \"\"\"计算从1到n的方幂和\"\"\"\n    return sum_to_n(n) * (n + 1) // 2\n\n\ndef square_of_sum(n: int) -> int:\n    \"\"\"计算从1到n的平方和\"\"\"\n    sum_ = sum_to_n(n)\n    return sum_ * sum_\n\n\ndef diff_of_squares(n: int) -> int:\n    \"\"\"计算从1到n的方幂和减去方幂和的平方\"\"\"\n    return square_of_sum(n) - sum_of_squares(n)\n\n\ndef diff_of_squares_v2(n: int) -> int:\n    \"\"\"计算从1到n的方幂和减去方幂和的平方\"\"\"\n", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i\n    return sum\n\n\ndef sum_of_squares(n: int) -> int:\n    \"\"\"计算从1到n的方幂和\"\"\"\n    return sum_to_n(n) * (n + 1) // 2\n\n\ndef square_of_sum(n: int) -> int:\n    \"\"\"计算从1到n的平方和\"\"\"\n    sum_ = sum_to_n(n)\n    return sum_ * sum_\n\n\ndef diff_of_squares(n: int) -> int:\n    \"\"\"计算从1到n的方幂和减去方幂和的平方\"\"\"\n    return square_of_sum(n) - sum_of_squares(n)\n\n\ndef diff_of_squares_v2(n: int) -> int:\n    \"\"\"计算从1到n的方幂和减去方幂和的平方\"\"\"\n"}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\ndef sum_to_n(n: int): return n * (n + 1) // 2\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>>", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef sum_to_n(n: int): return n * (n + 1) // 2\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>>"}
{"task_id": "HumanEval/60", "completion": "    s = 0\n    for i in range(1, n + 1):\n        s += i\n    return s\n\ndef fibonacci(n):\n    \"\"\"fibonacci 斐波那契数列.\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(8)\n    21\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\ndef prime(n):\n    \"\"\"prime 判断是否为质数.\n    >>> prime(3)\n    True\n    >>> prime(5)\n    True\n    >>> prime(10)\n    False\n    \"\"\"\n    for i in range(2, int(n**0.5)+1):\n        if n%i == 0:\n            return False\n    return True\n\ndef fibo(n):\n    \"\"\"fibo 斐波那契数列", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    s = 0\n    for i in range(1, n + 1):\n        s += i\n    return s\n\ndef fibonacci(n):\n    \"\"\"fibonacci 斐波那契数列.\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(8)\n    21\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\ndef prime(n):\n    \"\"\"prime 判断是否为质数.\n    >>> prime(3)\n    True\n    >>> prime(5)\n    True\n    >>> prime(10)\n    False\n    \"\"\"\n    for i in range(2, int(n**0.5)+1):\n        if n%i == 0:\n            return False\n    return True\n\ndef fibo(n):\n    \"\"\"fibo 斐波那契数列"}
{"task_id": "HumanEval/70", "completion": "    dic = {}\n    for i in lst:\n        dic[i] = 1\n    lst_sorted =  sorted(dic.keys())\n    return lst_sorted\n#执行用时 : 64 ms, 在所有 Python3 提交中击败了93.59%的用户\n#内存消耗 : 15.1 MB, 在所有 Python3 提交中击败了5.00%的用户\nif __name__ == '__main__':\n    ans = strange_sort_list([1, 2, 3, 4])\n    print(ans)\n    ans = strange_sort_list([5, 5, 5, 5])\n    print(ans)\n    ans = strange_sort_list([])\n    print(ans)\n    ans = strange_sort_list([10,1,2,3,4,5,6,7,8,9])\n    print(ans)\n    ans = strange_sort_list([1,2,3,4,5])\n    print(ans", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    dic = {}\n    for i in lst:\n        dic[i] = 1\n    lst_sorted =  sorted(dic.keys())\n    return lst_sorted\n#执行用时 : 64 ms, 在所有 Python3 提交中击败了93.59%的用户\n#内存消耗 : 15.1 MB, 在所有 Python3 提交中击败了5.00%的用户\nif __name__ == '__main__':\n    ans = strange_sort_list([1, 2, 3, 4])\n    print(ans)\n    ans = strange_sort_list([5, 5, 5, 5])\n    print(ans)\n    ans = strange_sort_list([])\n    print(ans)\n    ans = strange_sort_list([10,1,2,3,4,5,6,7,8,9])\n    print(ans)\n    ans = strange_sort_list([1,2,3,4,5])\n    print(ans"}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return lst\n\n    n = len(lst)\n    res = []\n    i = 0\n    w = n // 2\n    # print(w,n)\n    while i<n:\n        for j in range(0,n):\n            if j % w == 0:\n                res.append(lst[j])\n                lst.pop(j)\n            else:\n                lst.append(lst.pop(j))\n        i += 1\n\n    return res\n\n\ndef longest_substring(lst):\n    '''\n    给定一个字符串，返回其中最长的不包含重复字符的子串。如果字符串本身就是最长的不重复子串，则返回它本身。\n    示例\n    longest_substring(\"abcabcbb\") == \"abc\"\n    longest_substring(\"bbbbb\") == \"b\"\n    longest_substring(\"pwwkew\") == \"wke", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return lst\n\n    n = len(lst)\n    res = []\n    i = 0\n    w = n // 2\n    # print(w,n)\n    while i<n:\n        for j in range(0,n):\n            if j % w == 0:\n                res.append(lst[j])\n                lst.pop(j)\n            else:\n                lst.append(lst.pop(j))\n        i += 1\n\n    return res\n\n\ndef longest_substring(lst):\n    '''\n    给定一个字符串，返回其中最长的不包含重复字符的子串。如果字符串本身就是最长的不重复子串，则返回它本身。\n    示例\n    longest_substring(\"abcabcbb\") == \"abc\"\n    longest_substring(\"bbbbb\") == \"b\"\n    longest_substring(\"pwwkew\") == \"wke"}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    else:\n        return min(lst) + strange_sort_list([i for i in lst if i!=min(lst)])\n\n\n\ndef merge_sort_list(lst):\n    '''\n    给定整数列表，按递增排序返回列表，使用分治法。\n    '''\n    if len(lst) == 1 or len(lst) == 0:\n        return lst\n    else:\n        mid = len(lst)//2\n        lst_left = lst[:mid]\n        lst_right = lst[mid:]\n        lst_left = merge_sort_list(lst_left)\n        lst_right = merge_sort_list(lst_right)\n        return merge_list(lst_left,lst_right)\n\n\ndef merge_list(lst1,lst2):\n    '''\n    lst1、lst2已按递增排序。\n    合并两个已经排序的整数列", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    else:\n        return min(lst) + strange_sort_list([i for i in lst if i!=min(lst)])\n\n\n\ndef merge_sort_list(lst):\n    '''\n    给定整数列表，按递增排序返回列表，使用分治法。\n    '''\n    if len(lst) == 1 or len(lst) == 0:\n        return lst\n    else:\n        mid = len(lst)//2\n        lst_left = lst[:mid]\n        lst_right = lst[mid:]\n        lst_left = merge_sort_list(lst_left)\n        lst_right = merge_sort_list(lst_right)\n        return merge_list(lst_left,lst_right)\n\n\ndef merge_list(lst1,lst2):\n    '''\n    lst1、lst2已按递增排序。\n    合并两个已经排序的整数列"}
{"task_id": "HumanEval/70", "completion": "    li = []\n    for i in range(min(lst)):\n        li.append(i)\n    if len(li) == len(lst):\n        return li\n    else:\n        li.append(lst[max(lst)])\n    for i in range(len(lst)-1,0,-1):\n        li.append(lst[i])\n    return li\n\n\ndef unique_morse_code_words(words):\n    '''\n    输入：一组整数列表，例如 words = [\"gin\", \"zen\", \"gig\", \"msg\"]。每个单词都是由小写字母组成的，没有任何空格或其他特殊字符。\n    输出：唯一的摩尔斯密码单词列表，例如 [\"gin\", \"zen\"]。\n    注意：对于每个单词，你不需要返回其唯一密码，只需要返回每个单词的密码的唯一列表。\n    注", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    li = []\n    for i in range(min(lst)):\n        li.append(i)\n    if len(li) == len(lst):\n        return li\n    else:\n        li.append(lst[max(lst)])\n    for i in range(len(lst)-1,0,-1):\n        li.append(lst[i])\n    return li\n\n\ndef unique_morse_code_words(words):\n    '''\n    输入：一组整数列表，例如 words = [\"gin\", \"zen\", \"gig\", \"msg\"]。每个单词都是由小写字母组成的，没有任何空格或其他特殊字符。\n    输出：唯一的摩尔斯密码单词列表，例如 [\"gin\", \"zen\"]。\n    注意：对于每个单词，你不需要返回其唯一密码，只需要返回每个单词的密码的唯一列表。\n    注"}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return lst\n    else:\n        temp_list = []\n        temp_value = lst[0]\n        while temp_value in lst:\n            temp_list.append(temp_value)\n            lst.remove(temp_value)\n        return temp_list + strange_sort_list(lst)\n\n# ----------------------------------------------------------------------\ndef get_max_value(value_list, target):\n    '''\n    给定整数列表值列表和目标值target，如果存在返回最大的值，否则返回None\n    示例   get_max_value([1, 2, 3], 3) == 3\n    示例   get_max_value([1, 2, 3], 4) == None\n    '''\n    if target == 0:\n        return None\n    for i in range(len(value_list)):\n        if value_list[i] == target:\n            return value_list[i]\n", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return lst\n    else:\n        temp_list = []\n        temp_value = lst[0]\n        while temp_value in lst:\n            temp_list.append(temp_value)\n            lst.remove(temp_value)\n        return temp_list + strange_sort_list(lst)\n\n# ----------------------------------------------------------------------\ndef get_max_value(value_list, target):\n    '''\n    给定整数列表值列表和目标值target，如果存在返回最大的值，否则返回None\n    示例   get_max_value([1, 2, 3], 3) == 3\n    示例   get_max_value([1, 2, 3], 4) == None\n    '''\n    if target == 0:\n        return None\n    for i in range(len(value_list)):\n        if value_list[i] == target:\n            return value_list[i]\n"}
{"task_id": "HumanEval/70", "completion": "    return lst[::2] + lst[1::2][::-1]\n\ndef find_first_duplicate_value(lst): # 找到重复元素\n    '''\n    给定一个整数的列表，返回列表中第一个重复的值\n    示例  \n    find_first_duplicate_value([1, 2, 3, 1]) == 1\n    find_first_duplicate_value([1, 2, 3, 4]) == None\n    find_first_duplicate_value([]) == None\n    '''\n    if len(lst) == 0:\n        return None\n    d = {}\n    for i in range(len(lst)):\n        if d.get(lst[i]) is not None:\n            return lst[i]\n        d[lst[i]] = i\n    return None\n\ndef find_first_missing_positive_int(lst): #找到最小缺失的正整数\n    '''\n    给定一个正整数", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    return lst[::2] + lst[1::2][::-1]\n\ndef find_first_duplicate_value(lst): # 找到重复元素\n    '''\n    给定一个整数的列表，返回列表中第一个重复的值\n    示例  \n    find_first_duplicate_value([1, 2, 3, 1]) == 1\n    find_first_duplicate_value([1, 2, 3, 4]) == None\n    find_first_duplicate_value([]) == None\n    '''\n    if len(lst) == 0:\n        return None\n    d = {}\n    for i in range(len(lst)):\n        if d.get(lst[i]) is not None:\n            return lst[i]\n        d[lst[i]] = i\n    return None\n\ndef find_first_missing_positive_int(lst): #找到最小缺失的正整数\n    '''\n    给定一个正整数"}
{"task_id": "HumanEval/70", "completion": "    new_list = []\n    # 将列表中的数字放在一个list中\n    for i in range(len(lst)):\n        new_list.append(lst[i])\n    # 如果列表为空\n    if new_list == []:\n        return []\n    else:\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        # 将列表中最大的数字放在最后面\n        highest = max(new_list)\n        new_list.remove(highest)\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        return new_list\n\ndef reverse_string(st):\n    '''\n    将字符串反转并返回反转后的字符串", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    new_list = []\n    # 将列表中的数字放在一个list中\n    for i in range(len(lst)):\n        new_list.append(lst[i])\n    # 如果列表为空\n    if new_list == []:\n        return []\n    else:\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        # 将列表中最大的数字放在最后面\n        highest = max(new_list)\n        new_list.remove(highest)\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        # 将最小的数字放在最前面\n        lowest = min(new_list)\n        new_list.remove(lowest)\n        return new_list\n\ndef reverse_string(st):\n    '''\n    将字符串反转并返回反转后的字符串"}
{"task_id": "HumanEval/70", "completion": "    lst_min = min(lst)\n    for num in lst:\n        if num > lst_min:\n            lst.remove(num)\n            lst.append(lst_min)\n            lst_min = min(lst)\n    return lst\n\n\n# 如果给定的数字在列表中，返回 True; 否则 False\ndef number_in_list(num, lst):\n    return num in lst\n\n\n# 返回列表中最大的值\ndef max_value_in_list(lst):\n    return max(lst)\n\n\ndef sum_digits(num):\n    '''\n    计算数字的所有数字的和\n    示例   sum_digits(123) == 6\n    sum_digits(9876) == 28\n    sum_digits(1234567890) == 45\n    '''\n    s = 0\n    while num > 0:\n        s += num % 10\n        num //= 10\n    return s\n\n\n", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    lst_min = min(lst)\n    for num in lst:\n        if num > lst_min:\n            lst.remove(num)\n            lst.append(lst_min)\n            lst_min = min(lst)\n    return lst\n\n\n# 如果给定的数字在列表中，返回 True; 否则 False\ndef number_in_list(num, lst):\n    return num in lst\n\n\n# 返回列表中最大的值\ndef max_value_in_list(lst):\n    return max(lst)\n\n\ndef sum_digits(num):\n    '''\n    计算数字的所有数字的和\n    示例   sum_digits(123) == 6\n    sum_digits(9876) == 28\n    sum_digits(1234567890) == 45\n    '''\n    s = 0\n    while num > 0:\n        s += num % 10\n        num //= 10\n    return s\n\n\n"}
{"task_id": "HumanEval/70", "completion": "    result_lst = []\n    max_num = max(lst)\n    min_num = min(lst)\n    lst.remove(min_num)\n    lst.remove(max_num)\n    lst.append(min_num)\n    lst.insert(0, max_num)\n    result_lst = lst\n    return result_lst\ndef remove_value(lst, value):\n    '''\n    给定列表和一个数值，返回列表，去掉列表中所有与给定数值相等的值，并返回新列表。\n    示例   remove_value([1, 2, 3, 4], 3) == [1, 2, 4]\n    remove_value([1, 2, 3, 4], 10) == [1, 2, 3, 4]\n    remove_value([1, 2, 3, 1], 1) == [2, 3, 1]\n    remove_value([], 10) == []\n    '''\n    result_lst =", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    result_lst = []\n    max_num = max(lst)\n    min_num = min(lst)\n    lst.remove(min_num)\n    lst.remove(max_num)\n    lst.append(min_num)\n    lst.insert(0, max_num)\n    result_lst = lst\n    return result_lst\ndef remove_value(lst, value):\n    '''\n    给定列表和一个数值，返回列表，去掉列表中所有与给定数值相等的值，并返回新列表。\n    示例   remove_value([1, 2, 3, 4], 3) == [1, 2, 4]\n    remove_value([1, 2, 3, 4], 10) == [1, 2, 3, 4]\n    remove_value([1, 2, 3, 1], 1) == [2, 3, 1]\n    remove_value([], 10) == []\n    '''\n    result_lst ="}
{"task_id": "HumanEval/70", "completion": "    # pass 执行判断，否则程序进入循环时， lst 为 0 元素，不进入循环。\n    n = 0\n    l = len(lst)\n    if l == 0:\n        return []\n    elif l == 1:\n        return lst\n    else:\n        min_value = lst[0]\n        for x in range(l):\n            if lst[x] < min_value:\n                min_value = lst[x]\n        # 对所有值进行比较\n        for i in range(l):\n            if min_value == lst[i]:\n                lst.pop(i)\n                n += 1\n        # 由于有 pop 操作，len(lst) 长度减一\n        lst.append(min_value)\n        # 判断是否全部都被置换\n        if n == l:\n            return lst\n        else:\n            return strange_sort_list(lst)\n\n\n# 面试题", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    # pass 执行判断，否则程序进入循环时， lst 为 0 元素，不进入循环。\n    n = 0\n    l = len(lst)\n    if l == 0:\n        return []\n    elif l == 1:\n        return lst\n    else:\n        min_value = lst[0]\n        for x in range(l):\n            if lst[x] < min_value:\n                min_value = lst[x]\n        # 对所有值进行比较\n        for i in range(l):\n            if min_value == lst[i]:\n                lst.pop(i)\n                n += 1\n        # 由于有 pop 操作，len(lst) 长度减一\n        lst.append(min_value)\n        # 判断是否全部都被置换\n        if n == l:\n            return lst\n        else:\n            return strange_sort_list(lst)\n\n\n# 面试题"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n    s = set(arr)\n    if len(s) < len(arr):\n        return len(arr) - len(s)\n    if len(arr) % 2 == 1:\n        return len(arr) - len(s)\n    else:\n        l = arr[::2]\n        r = arr[1::2]\n        if len(l) > len(r):\n            r += r[::-1]\n        else:\n            l += l[::-1]\n        return len(arr) - len(s) - len(l)\n\n\ndef is_bst(root):\n    \"\"\"\n    给定一棵二叉树的根节点root，请判断这棵二叉树是不是二叉搜索树。\n    如果一个二叉树满足下列性质，那么它是一棵二叉搜索树：\n    1", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    s = set(arr)\n    if len(s) < len(arr):\n        return len(arr) - len(s)\n    if len(arr) % 2 == 1:\n        return len(arr) - len(s)\n    else:\n        l = arr[::2]\n        r = arr[1::2]\n        if len(l) > len(r):\n            r += r[::-1]\n        else:\n            l += l[::-1]\n        return len(arr) - len(s) - len(l)\n\n\ndef is_bst(root):\n    \"\"\"\n    给定一棵二叉树的根节点root，请判断这棵二叉树是不是二叉搜索树。\n    如果一个二叉树满足下列性质，那么它是一棵二叉搜索树：\n    1"}
{"task_id": "HumanEval/73", "completion": "    \n    if len(arr) <= 1:\n        return 0\n\n    max_idx = max_idx_in_arr(arr)\n    min_idx = min_idx_in_arr(arr)\n    if min_idx >= max_idx: return 1\n\n    if arr[max_idx] >= arr[min_idx]:\n        return 1\n    else:\n        return min(smallest_change(arr[:min_idx]+arr[min_idx+1:])+1,\n                   smallest_change(arr[:max_idx]+arr[max_idx-1:])+1)\n\n\nif __name__ == \"__main__\":\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1,2,3,5,4,7,9,6]))\n    print(smallest_change([1, 2, 3, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 4,", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    \n    if len(arr) <= 1:\n        return 0\n\n    max_idx = max_idx_in_arr(arr)\n    min_idx = min_idx_in_arr(arr)\n    if min_idx >= max_idx: return 1\n\n    if arr[max_idx] >= arr[min_idx]:\n        return 1\n    else:\n        return min(smallest_change(arr[:min_idx]+arr[min_idx+1:])+1,\n                   smallest_change(arr[:max_idx]+arr[max_idx-1:])+1)\n\n\nif __name__ == \"__main__\":\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1,2,3,5,4,7,9,6]))\n    print(smallest_change([1, 2, 3, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 4,"}
{"task_id": "HumanEval/73", "completion": "    length = len(arr)\n    if not arr:\n        return 0\n    dp = [0 for i in range(length)]\n    for i in range(length):\n        if arr[i] <= 2:\n            dp[i] = arr[i] - 1\n            arr[i] = 2\n\n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[j] == arr[i] + 1:\n                dp[j] = 1 + dp[i]\n    return dp[length - 1] - dp[0]\n\n\nif __name__ == '__main__':\n    print small_change_", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    length = len(arr)\n    if not arr:\n        return 0\n    dp = [0 for i in range(length)]\n    for i in range(length):\n        if arr[i] <= 2:\n            dp[i] = arr[i] - 1\n            arr[i] = 2\n\n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[j] == arr[i] + 1:\n                dp[j] = 1 + dp[i]\n    return dp[length - 1] - dp[0]\n\n\nif __name__ == '__main__':\n    print small_change_"}
{"task_id": "HumanEval/73", "completion": "\n    def count(arr):\n        \"\"\"\n        统计每个元素出现的次数，用于筛选可能小于该次数的数字\n        \"\"\"\n        dic = {}\n        for num in arr:\n            if num in dic:\n                dic[num] += 1\n            else:\n                dic[num] = 1\n\n        return dic\n\n    dic = count(arr)\n    min_num = min(dic.values())\n\n    ans = 0\n    for k, v in dic.items():\n        while v > min_num:\n            ans += 1\n            v -= 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    print(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 2, 1]))\n\n\n\"\"\"", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n\n    def count(arr):\n        \"\"\"\n        统计每个元素出现的次数，用于筛选可能小于该次数的数字\n        \"\"\"\n        dic = {}\n        for num in arr:\n            if num in dic:\n                dic[num] += 1\n            else:\n                dic[num] = 1\n\n        return dic\n\n    dic = count(arr)\n    min_num = min(dic.values())\n\n    ans = 0\n    for k, v in dic.items():\n        while v > min_num:\n            ans += 1\n            v -= 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    print(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 2, 1]))\n\n\n\"\"\""}
{"task_id": "HumanEval/73", "completion": "    l = len(arr)\n    if l==1:return 0\n    dp = [[0,0] for i in range(l +1)]\n    dp[0][0] = 0\n    for k in range(1,l+1):\n        for i in range(l,k-1,-1):\n            if dp[i+1][1] > abs(arr[i]-arr[i+1]):\n                dp[i][0] = dp[i+1][0]\n                dp[i][1] = abs(arr[i]-arr[i+1])\n            else:\n                dp[i][0] = dp[i+1][0] + 1\n                dp[i][1] = dp[i+1][1]\n    return dp[0][0]\n\n# 求最大回文子串的长度\ndef max_palindrome_length(s):\n    \"\"\"\n    给定一个字符串s，求s中最长的回文子串的长度。回文", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    l = len(arr)\n    if l==1:return 0\n    dp = [[0,0] for i in range(l +1)]\n    dp[0][0] = 0\n    for k in range(1,l+1):\n        for i in range(l,k-1,-1):\n            if dp[i+1][1] > abs(arr[i]-arr[i+1]):\n                dp[i][0] = dp[i+1][0]\n                dp[i][1] = abs(arr[i]-arr[i+1])\n            else:\n                dp[i][0] = dp[i+1][0] + 1\n                dp[i][1] = dp[i+1][1]\n    return dp[0][0]\n\n# 求最大回文子串的长度\ndef max_palindrome_length(s):\n    \"\"\"\n    给定一个字符串s，求s中最长的回文子串的长度。回文"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n    \n    for i in range(len(arr)):\n        if arr[i]!= arr[-i-1]:\n            return i + len(arr) - i - 2 \n    return 0\n\n\nprint(smallest_change([1,2,3,5,4,7,9,6])) #4\nprint(smallest_change([1, 2, 3, 4, 3, 2, 2])) #1\nprint(smallest_change([1, 2, 3, 2, 1])) #0\n\n\n# 走迷宫(maze_path)\n# 给出一个二维矩阵M，我们从左上角(0,0)开始，每次只能往右或者下走. 如果走到了右下角(M-1, N-1),则成功通过了这个迷宫。在这个迷宫中，我们不", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    \n    for i in range(len(arr)):\n        if arr[i]!= arr[-i-1]:\n            return i + len(arr) - i - 2 \n    return 0\n\n\nprint(smallest_change([1,2,3,5,4,7,9,6])) #4\nprint(smallest_change([1, 2, 3, 4, 3, 2, 2])) #1\nprint(smallest_change([1, 2, 3, 2, 1])) #0\n\n\n# 走迷宫(maze_path)\n# 给出一个二维矩阵M，我们从左上角(0,0)开始，每次只能往右或者下走. 如果走到了右下角(M-1, N-1),则成功通过了这个迷宫。在这个迷宫中，我们不"}
{"task_id": "HumanEval/73", "completion": "    # write code here\n    n = len(arr)\n    if n < 2:\n        return 0\n    dp1 = [0] * n\n    dp2 = [0] * n\n    for i in range(n):\n        dp1[i] = 1\n        dp2[i] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] == arr[j]:\n                dp1[i] = dp2[j]\n            else:\n                dp1[i] = min(dp1[i], dp1[j] + 1)\n\n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] == arr[j]:\n                dp2[i] = dp1[j]\n            else:\n                dp2[i] = min(dp1[j] + 1, dp2[i])\n\n    return dp1[n", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # write code here\n    n = len(arr)\n    if n < 2:\n        return 0\n    dp1 = [0] * n\n    dp2 = [0] * n\n    for i in range(n):\n        dp1[i] = 1\n        dp2[i] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] == arr[j]:\n                dp1[i] = dp2[j]\n            else:\n                dp1[i] = min(dp1[i], dp1[j] + 1)\n\n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] == arr[j]:\n                dp2[i] = dp1[j]\n            else:\n                dp2[i] = min(dp1[j] + 1, dp2[i])\n\n    return dp1[n"}
{"task_id": "HumanEval/73", "completion": "    n_length = len(arr)\n    min_length = 0\n    left = 0\n    right = n_length - 1\n    while left < right:\n        if arr[left] == arr[right]:\n            left += 1\n            right -= 1\n        else:\n            if arr[left] < arr[right]:\n                min_length += right - left\n                arr[left] = arr[right] - arr[left]\n            else:\n                min_length += (n_length - right) + 1\n                arr[right] = arr[left] + arr[right] - arr[left]\n                left += 1\n                right -= 1\n    return min_length\n\ndef is_sorted_(array):\n    \"\"\"\n    判断一个数组是否已经按从小到大的顺序排序。\n    For example:\n    is_sorted_([1, 2, 2, 3, 5]) == True\n    arr.sort() # 这里是排序\n    \"\"\"\n    for i in range(", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    n_length = len(arr)\n    min_length = 0\n    left = 0\n    right = n_length - 1\n    while left < right:\n        if arr[left] == arr[right]:\n            left += 1\n            right -= 1\n        else:\n            if arr[left] < arr[right]:\n                min_length += right - left\n                arr[left] = arr[right] - arr[left]\n            else:\n                min_length += (n_length - right) + 1\n                arr[right] = arr[left] + arr[right] - arr[left]\n                left += 1\n                right -= 1\n    return min_length\n\ndef is_sorted_(array):\n    \"\"\"\n    判断一个数组是否已经按从小到大的顺序排序。\n    For example:\n    is_sorted_([1, 2, 2, 3, 5]) == True\n    arr.sort() # 这里是排序\n    \"\"\"\n    for i in range("}
{"task_id": "HumanEval/73", "completion": "    def _compare(x, y):\n        a, b = x, y\n        while a and b:\n            if a[0]!= b[0]:\n                break\n            a, b = a[1:], b[1:]\n        if len(a) < len(b):\n            return 1\n        elif len(a) > len(b):\n            return -1\n        else:\n            return 0\n\n    def is_palindrome(arr, start, end):\n        while start >= end:\n            if _compare(arr[start], arr[end]) < 0:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def is_not_palindrome(arr):\n        for i in range(len(arr) // 2 + 1):\n            if _compare(arr[i], arr[-i - 1]) < 0:\n                return True\n        return False\n\n    def min_change(arr, index, cur):\n        if cur == 0 or is_palindrome(arr, index, index + 1", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    def _compare(x, y):\n        a, b = x, y\n        while a and b:\n            if a[0]!= b[0]:\n                break\n            a, b = a[1:], b[1:]\n        if len(a) < len(b):\n            return 1\n        elif len(a) > len(b):\n            return -1\n        else:\n            return 0\n\n    def is_palindrome(arr, start, end):\n        while start >= end:\n            if _compare(arr[start], arr[end]) < 0:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def is_not_palindrome(arr):\n        for i in range(len(arr) // 2 + 1):\n            if _compare(arr[i], arr[-i - 1]) < 0:\n                return True\n        return False\n\n    def min_change(arr, index, cur):\n        if cur == 0 or is_palindrome(arr, index, index + 1"}
{"task_id": "HumanEval/73", "completion": "    def flip(arr, i, j):\n        for k in range(i, j):\n            arr[k], arr[~k] = arr[~k], arr[k]\n    arr, arr_len = arr.copy(), len(arr)\n    i, j = 0, arr_len - 1\n    count = 0\n    while i < j:\n        if arr[i] == arr[j]:\n            i += 1\n            j -= 1\n        elif arr[i] > arr[j]:\n            flip(arr, i", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    def flip(arr, i, j):\n        for k in range(i, j):\n            arr[k], arr[~k] = arr[~k], arr[k]\n    arr, arr_len = arr.copy(), len(arr)\n    i, j = 0, arr_len - 1\n    count = 0\n    while i < j:\n        if arr[i] == arr[j]:\n            i += 1\n            j -= 1\n        elif arr[i] > arr[j]:\n            flip(arr, i"}
{"task_id": "HumanEval/82", "completion": "    return True if length_of_string(string) == len(set(string)) else False\n\n\ndef length_of_string(string):\n    \"\"\"编写一个函数，接受一个字符串，返回字符串的长度\"\"\"\n    return len(string)\n\n\ndef number_of_vowels(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串中元音字母的数量。\"\"\"\n    return sum(1 for x in string if x in 'aeiouAEIOU')\n\n\ndef reverse_string(string):\n    \"\"\"编写一个函数，接收一个字符串，返回逆转后的字符串\"\"\"\n    return string[::-1]\n\n\ndef find_middle(string):\n    \"\"\"用递归函数编写一个函数，接收一个字符串，并返回其中间一个字符的索引位置（假设字符串是非空的）。例", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return True if length_of_string(string) == len(set(string)) else False\n\n\ndef length_of_string(string):\n    \"\"\"编写一个函数，接受一个字符串，返回字符串的长度\"\"\"\n    return len(string)\n\n\ndef number_of_vowels(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串中元音字母的数量。\"\"\"\n    return sum(1 for x in string if x in 'aeiouAEIOU')\n\n\ndef reverse_string(string):\n    \"\"\"编写一个函数，接收一个字符串，返回逆转后的字符串\"\"\"\n    return string[::-1]\n\n\ndef find_middle(string):\n    \"\"\"用递归函数编写一个函数，接收一个字符串，并返回其中间一个字符的索引位置（假设字符串是非空的）。例"}
{"task_id": "HumanEval/82", "completion": "    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    if is_prime(len(string)):\n        return True\n    else:\n        return False\n \n```\n\n参考答案\n\n```\ndef prime_length(string):\n    if len(string) == 0:\n        return False\n    for i in range(2, len(string)+1):\n        if len(string) % i!= 0:\n            return False\n    return True\n\n```\n\n\n\n---\n\n\n\n\n\n### 28. 闰年\n\n写一个函数，接收一个年份，如果是闰年返回True，否则返回False。\n\n```\ndef leap_year(year):\n    \"\"\"编写一个函数，接收一个年份，如果是闰年返", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    if is_prime(len(string)):\n        return True\n    else:\n        return False\n \n```\n\n参考答案\n\n```\ndef prime_length(string):\n    if len(string) == 0:\n        return False\n    for i in range(2, len(string)+1):\n        if len(string) % i!= 0:\n            return False\n    return True\n\n```\n\n\n\n---\n\n\n\n\n\n### 28. 闰年\n\n写一个函数，接收一个年份，如果是闰年返回True，否则返回False。\n\n```\ndef leap_year(year):\n    \"\"\"编写一个函数，接收一个年份，如果是闰年返"}
{"task_id": "HumanEval/82", "completion": "    length = len(string)\n    for i in range(2, length):\n        if length % i == 0:\n            return False\n    return True\n\n\n# 4. 编写一个函数，接收一个字符串，这个函数有两个必须参数，一个默认参数。这个函数的作用是把这个字符串中的大写字母变成小写字母，小写字母变成大写字母。\ndef swap_case(string1, string2=''):\n    \"\"\"编写一个函数，接收一个字符串，这个函数有两个必须参数，一个默认参数。这个函数的作用是把这个字符串中的大写字母变成小写字母，小写字母变成大写字母。\n    示例：\n    swap_case('Hello') == 'hELLo'\n    swap_case('aBcDeF') == 'AbCdEf'\n    swap_", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = len(string)\n    for i in range(2, length):\n        if length % i == 0:\n            return False\n    return True\n\n\n# 4. 编写一个函数，接收一个字符串，这个函数有两个必须参数，一个默认参数。这个函数的作用是把这个字符串中的大写字母变成小写字母，小写字母变成大写字母。\ndef swap_case(string1, string2=''):\n    \"\"\"编写一个函数，接收一个字符串，这个函数有两个必须参数，一个默认参数。这个函数的作用是把这个字符串中的大写字母变成小写字母，小写字母变成大写字母。\n    示例：\n    swap_case('Hello') == 'hELLo'\n    swap_case('aBcDeF') == 'AbCdEf'\n    swap_"}
{"task_id": "HumanEval/82", "completion": "    if not len(string):\n        return False\n\n    i = 2\n    length = len(string)\n    while i < length:\n        if length % i == 0:\n            return False\n        i += 1\n    return True\n\ndef unique_char(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串里有重复字符，则返回 False，否则返回True    示例：\n    unique_char('Hello') == True\n    unique_char('abcdcba') == False\n    unique_char('kittens') == False\n    unique_char('orange') == True\n    \"\"\"\n    if not len(string):\n        return False\n\n    if len(string) == len(set(string)):\n        return True\n    return False\n\ndef is_abbreviation(abbreviation, word):\n    \"\"\"编写一个函数，判断两个字符串是否是简读字符串。如果一个字符串是另一个字符串的", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if not len(string):\n        return False\n\n    i = 2\n    length = len(string)\n    while i < length:\n        if length % i == 0:\n            return False\n        i += 1\n    return True\n\ndef unique_char(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串里有重复字符，则返回 False，否则返回True    示例：\n    unique_char('Hello') == True\n    unique_char('abcdcba') == False\n    unique_char('kittens') == False\n    unique_char('orange') == True\n    \"\"\"\n    if not len(string):\n        return False\n\n    if len(string) == len(set(string)):\n        return True\n    return False\n\ndef is_abbreviation(abbreviation, word):\n    \"\"\"编写一个函数，判断两个字符串是否是简读字符串。如果一个字符串是另一个字符串的"}
{"task_id": "HumanEval/82", "completion": "    return all([i not in string for i in string[1:]])\n\nprint(prime_length('Hello'))\nprint(prime_length('abcdcba'))\nprint(prime_length('kittens'))\nprint(prime_length('orange'))\n\n\n# 10.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True and False)\nprint(True or False)\nprint(not False)\nprint(not (True and False))\n\n# 11.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True and not False)\n\n\n# 12.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True or not False)\n\n# 13.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(not True or not False)\n", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return all([i not in string for i in string[1:]])\n\nprint(prime_length('Hello'))\nprint(prime_length('abcdcba'))\nprint(prime_length('kittens'))\nprint(prime_length('orange'))\n\n\n# 10.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True and False)\nprint(True or False)\nprint(not False)\nprint(not (True and False))\n\n# 11.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True and not False)\n\n\n# 12.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(True or not False)\n\n# 13.下面这段代码的运行效果是什么呢？请返回结果。 \n\nprint(not True or not False)\n"}
{"task_id": "HumanEval/82", "completion": "\n    if(len(string) in [1,2,3,5,7,11,13]):\n        # if 判断的是质数的长度，而不是字符串是不是质数\n        return True\n    else:\n        return False\n\n\n# 编写一个is_palindrome函数，接收一个字符串，判断这个字符串是不是回文。\n# 一个回文是指从左边读和从右边读是一样的，举个例子：'level', 'racecar'都是回文，\n# 'level', 'racecar'都不是回文。\ndef is_palindrome(string):\n    \"\"\"编写一个函数，接收一个字符串，判断这个字符串是不是回文。\n    一个回文是指从左边读和从右边读是一样的，举个例子：'level', 'racecar'都是回文，\n   ", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n\n    if(len(string) in [1,2,3,5,7,11,13]):\n        # if 判断的是质数的长度，而不是字符串是不是质数\n        return True\n    else:\n        return False\n\n\n# 编写一个is_palindrome函数，接收一个字符串，判断这个字符串是不是回文。\n# 一个回文是指从左边读和从右边读是一样的，举个例子：'level', 'racecar'都是回文，\n# 'level', 'racecar'都不是回文。\ndef is_palindrome(string):\n    \"\"\"编写一个函数，接收一个字符串，判断这个字符串是不是回文。\n    一个回文是指从左边读和从右边读是一样的，举个例子：'level', 'racecar'都是回文，\n   "}
{"task_id": "HumanEval/82", "completion": "    if len(string) == 0:\n        return False\n    i = 2\n    while i <= len(string", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) == 0:\n        return False\n    i = 2\n    while i <= len(string"}
{"task_id": "HumanEval/82", "completion": "    return len(string)==2 or (len(string)%2==1 and isPrime(len(string)))\n\n\ndef palindrome_permutation(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串的所有字符的所有可能排列中有一个是回文串，\n    则返回True，否则返回False    示例：\n    palindrome_permutation('Tact Coa') == True\n    palindrome_permutation('Tact Oa') == False\n    \"\"\"\n    string_1 = \"\"\n    for s in string:\n        string_1+=s\n    string_1 = string_1.lower()\n    string_2 = \"\"\n    for i in range(len(string_1)):\n        if string_1.endswith(string_1[i]):\n            string_2 += string_1[i]\n            string_1 = string_1[:i]+string_1[(i+1):]\n    if string_1 == string_2:\n       ", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return len(string)==2 or (len(string)%2==1 and isPrime(len(string)))\n\n\ndef palindrome_permutation(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串的所有字符的所有可能排列中有一个是回文串，\n    则返回True，否则返回False    示例：\n    palindrome_permutation('Tact Coa') == True\n    palindrome_permutation('Tact Oa') == False\n    \"\"\"\n    string_1 = \"\"\n    for s in string:\n        string_1+=s\n    string_1 = string_1.lower()\n    string_2 = \"\"\n    for i in range(len(string_1)):\n        if string_1.endswith(string_1[i]):\n            string_2 += string_1[i]\n            string_1 = string_1[:i]+string_1[(i+1):]\n    if string_1 == string_2:\n       "}
{"task_id": "HumanEval/82", "completion": "    i = 0\n    prime_count = 1\n    num = 0\n    string_len = len(string)\n    while i < string_len:\n        num = string_len - i\n        if string_len % num == 0:\n            prime_count += 1\n        i += 1\n    return prime_count == 2\n\n\n# 题目：将一个英文句子翻译成蛇形字符串，蛇形字符串的格式是：首字母大写，之后的字母小写，例如：HeLLo WORLD -> HeLLo wORld，蛇形字符串长度应当与输入字符串长度相同。\n\ndef snake_string(string):\n    \"\"\"编写一个函数，接收一个英文句子，翻译成蛇形字符串，蛇形字符串的格式是：首字母大写，之后的字母小写，例如：HeLL", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    i = 0\n    prime_count = 1\n    num = 0\n    string_len = len(string)\n    while i < string_len:\n        num = string_len - i\n        if string_len % num == 0:\n            prime_count += 1\n        i += 1\n    return prime_count == 2\n\n\n# 题目：将一个英文句子翻译成蛇形字符串，蛇形字符串的格式是：首字母大写，之后的字母小写，例如：HeLLo WORLD -> HeLLo wORld，蛇形字符串长度应当与输入字符串长度相同。\n\ndef snake_string(string):\n    \"\"\"编写一个函数，接收一个英文句子，翻译成蛇形字符串，蛇形字符串的格式是：首字母大写，之后的字母小写，例如：HeLL"}
{"task_id": "HumanEval/82", "completion": "    string = string.lower()\n    length = 1\n    for s in string:\n        length *= ord(s)\n    if is_prime(length):\n        return True\n    else:\n        return False\n\n\ndef prime_length1(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    string = string.lower()\n    length = 1\n    for s in string:\n        length *= ord(s)\n    length = math.sqrt(length)\n    for i in range(2, int(length) + 1):\n        if length % i == 0:\n            return False\n    return True\n\n\ns = \"Hello\"\nprint(prime_length1(s))\n\n# ����", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    string = string.lower()\n    length = 1\n    for s in string:\n        length *= ord(s)\n    if is_prime(length):\n        return True\n    else:\n        return False\n\n\ndef prime_length1(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    string = string.lower()\n    length = 1\n    for s in string:\n        length *= ord(s)\n    length = math.sqrt(length)\n    for i in range(2, int(length) + 1):\n        if length % i == 0:\n            return False\n    return True\n\n\ns = \"Hello\"\nprint(prime_length1(s))\n\n# ����"}
{"task_id": "HumanEval/90", "completion": "\n    lst = list(lst)\n    lst.sort()\n    if len(lst) <= 1:\n        return None\n    else:\n        return lst[1]\n\n\n# 输入为一个整数列表，将列表中小于该整数的元素删除，返回一个列表，例如[1, 2, 3, 4]，4删掉之后返回[1, 2, 3]\ndef remove_less(num, lst):\n    \"\"\"\n    给你一个整数列表，请编写函数remove_less()，将列表中小于该整数的元素删除，返回一个列表，\n    例如[1, 2, 3, 4]，4删掉之后返回[1, 2, 3]。\n    \"\"\"\n    lst_new = []\n    for i in range(len(lst)):\n        if num < lst[i]:\n            lst_new.append(lst[i])\n    return lst", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    lst = list(lst)\n    lst.sort()\n    if len(lst) <= 1:\n        return None\n    else:\n        return lst[1]\n\n\n# 输入为一个整数列表，将列表中小于该整数的元素删除，返回一个列表，例如[1, 2, 3, 4]，4删掉之后返回[1, 2, 3]\ndef remove_less(num, lst):\n    \"\"\"\n    给你一个整数列表，请编写函数remove_less()，将列表中小于该整数的元素删除，返回一个列表，\n    例如[1, 2, 3, 4]，4删掉之后返回[1, 2, 3]。\n    \"\"\"\n    lst_new = []\n    for i in range(len(lst)):\n        if num < lst[i]:\n            lst_new.append(lst[i])\n    return lst"}
{"task_id": "HumanEval/90", "completion": "    lst.sort()\n    return lst[1] if len(lst) > 1 else None\n\n\n\ndef main():\n    a = [1, 2, 3, 4, 5]\n    b = [5, 1, 4, 3, 2]\n    c = [1, 1]\n    d = []\n    print(next_smallest(a))\n    print(next_smallest(b))\n    print(next_smallest(c))\n    print(next_smallest(d))\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n\n### 4. 打印最大的n个数\n\n```python\n# -*- coding: UTF-8 -*-\n\"\"\"\n题目：输入一个整数数组，把数组里所有数字拆成两部分，\n第一部分的元素大于第二部分的元素，请把第二部分的元素放在数组的最前面，", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst.sort()\n    return lst[1] if len(lst) > 1 else None\n\n\n\ndef main():\n    a = [1, 2, 3, 4, 5]\n    b = [5, 1, 4, 3, 2]\n    c = [1, 1]\n    d = []\n    print(next_smallest(a))\n    print(next_smallest(b))\n    print(next_smallest(c))\n    print(next_smallest(d))\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n\n### 4. 打印最大的n个数\n\n```python\n# -*- coding: UTF-8 -*-\n\"\"\"\n题目：输入一个整数数组，把数组里所有数字拆成两部分，\n第一部分的元素大于第二部分的元素，请把第二部分的元素放在数组的最前面，"}
{"task_id": "HumanEval/90", "completion": "    if lst==[]:\n        return None\n    if len(lst)==1:\n        return None\n    return min(lst[i] for i in range(len(lst)-1) if lst[i]<lst[i+1])\n\n\ndef merge_and_sum(l1, l2):\n    \"\"\"\n    给你两个整数列表，请你返回一个列表，这个列表是由两个列表的每个元素按顺序逐一加和组成的。    \n    merge_and_sum([1, 4], [2, 5]) == [3, 9, 7]\n    merge_and_sum([1, 4, 6], [2, 5, 7]) == [3, 9, 11, 13, 7]\n    merge_and_sum([1, 4, 6], [2, 5]) == [3, 9, 7, 5]\n    merge_and_sum([1, 4, 6], [2, 5", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if lst==[]:\n        return None\n    if len(lst)==1:\n        return None\n    return min(lst[i] for i in range(len(lst)-1) if lst[i]<lst[i+1])\n\n\ndef merge_and_sum(l1, l2):\n    \"\"\"\n    给你两个整数列表，请你返回一个列表，这个列表是由两个列表的每个元素按顺序逐一加和组成的。    \n    merge_and_sum([1, 4], [2, 5]) == [3, 9, 7]\n    merge_and_sum([1, 4, 6], [2, 5, 7]) == [3, 9, 11, 13, 7]\n    merge_and_sum([1, 4, 6], [2, 5]) == [3, 9, 7, 5]\n    merge_and_sum([1, 4, 6], [2, 5"}
{"task_id": "HumanEval/90", "completion": "    lst.remove(min(lst))\n    return min(lst)\n\n# 给定一个整数数组和一个整数 k，返回数组中第k大的元素。例如，如果数组是 [3, 2, 1, 5, 6, 4] 和 k = 2，那么返回 5。\ndef kth_largest(nums, k):\n    \"\"\"\n    给定一个整数数组和一个整数 k，返回数组中第k大的元素。例如，如果数组是 [3, 2, 1, 5, 6, 4] 和 k = 2，那么返回 5。\n    kth_largest([3, 2, 1, 5, 6, 4],2) == 5\n    kth_largest([3, 2, 1, 5, 6, 4],3) == 6\n    kth_largest([3, 2, 1,", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst.remove(min(lst))\n    return min(lst)\n\n# 给定一个整数数组和一个整数 k，返回数组中第k大的元素。例如，如果数组是 [3, 2, 1, 5, 6, 4] 和 k = 2，那么返回 5。\ndef kth_largest(nums, k):\n    \"\"\"\n    给定一个整数数组和一个整数 k，返回数组中第k大的元素。例如，如果数组是 [3, 2, 1, 5, 6, 4] 和 k = 2，那么返回 5。\n    kth_largest([3, 2, 1, 5, 6, 4],2) == 5\n    kth_largest([3, 2, 1, 5, 6, 4],3) == 6\n    kth_largest([3, 2, 1,"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 0:\n        return None\n    if len(lst) == 1:\n        return None\n    lst.sort()\n    # next = lst[1]\n    # for i in lst:\n    #     if i > next:\n    #         next = i\n    # return next\n    # next = lst[2]\n    # for i in lst[:2]:\n    #     if i > next:\n    #         next = i\n    # return next\n    next = lst[0]\n    for i in lst:\n        if i > next and i < lst[-1]:\n            next = i\n    return next\n\n\n# 最长回文子串问题\ndef longest_palindrome(s):\n    \"\"\"\n    请编写一个函数，将字符串中的空格替换为\"%20\"。\n    Input: \"Mr John Smith    \"\n    Output: \"Mr%20John%20Smith\"\n    \"\"\"\n    s = s.replace(\" \", \"%20\")\n    return s\n\n\ndef longest_", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 0:\n        return None\n    if len(lst) == 1:\n        return None\n    lst.sort()\n    # next = lst[1]\n    # for i in lst:\n    #     if i > next:\n    #         next = i\n    # return next\n    # next = lst[2]\n    # for i in lst[:2]:\n    #     if i > next:\n    #         next = i\n    # return next\n    next = lst[0]\n    for i in lst:\n        if i > next and i < lst[-1]:\n            next = i\n    return next\n\n\n# 最长回文子串问题\ndef longest_palindrome(s):\n    \"\"\"\n    请编写一个函数，将字符串中的空格替换为\"%20\"。\n    Input: \"Mr John Smith    \"\n    Output: \"Mr%20John%20Smith\"\n    \"\"\"\n    s = s.replace(\" \", \"%20\")\n    return s\n\n\ndef longest_"}
{"task_id": "HumanEval/90", "completion": "    return lst[lst.index(min(lst)) + 1] if len(lst) >= 2 else None\n\n\n\ndef test():\n    assert next", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    return lst[lst.index(min(lst)) + 1] if len(lst) >= 2 else None\n\n\n\ndef test():\n    assert next"}
{"task_id": "HumanEval/90", "completion": "    lst = sorted(lst)\n    if len(lst) < 2:\n        return None\n    return lst[1]\n\nlst = [1, 5, 3, 4, 2]\nprint(next_smallest(lst))\n\n\n# def next_smallest(lst):\n#     \"\"\"\n#     给你一个整数列表，请编写函数next_smallest()，返回列表中第一小的元素。 如果没有这样的元素，则返回None。    \n#     next_smallest([1, 2, 3, 4, 5]) == 1\n#     next_smallest([5, 1, 4, 3, 2]) == 1\n#     next_smallest([]) == None\n#     next_smallest([1, 1]) == None\n#     \"\"\"\n\n#     if len(lst) == 0:\n#         return None\n#     if len(lst) == 1:\n#         return None\n#     else:\n#         first = lst[0", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst = sorted(lst)\n    if len(lst) < 2:\n        return None\n    return lst[1]\n\nlst = [1, 5, 3, 4, 2]\nprint(next_smallest(lst))\n\n\n# def next_smallest(lst):\n#     \"\"\"\n#     给你一个整数列表，请编写函数next_smallest()，返回列表中第一小的元素。 如果没有这样的元素，则返回None。    \n#     next_smallest([1, 2, 3, 4, 5]) == 1\n#     next_smallest([5, 1, 4, 3, 2]) == 1\n#     next_smallest([]) == None\n#     next_smallest([1, 1]) == None\n#     \"\"\"\n\n#     if len(lst) == 0:\n#         return None\n#     if len(lst) == 1:\n#         return None\n#     else:\n#         first = lst[0"}
{"task_id": "HumanEval/90", "completion": "    if not lst or len(lst)==1:\n        return None\n    lst.sort()\n    return lst[1]\n\n\n\ndef find_max_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_max_min()，返回一个列表，包含列表中最大值和最小值。\n    find_max_min([1, 2, 3, 4, 5]) == [5, 1]\n    find_max_min([5, 1, 4, 3, 2]) == [5, 1]\n    find_max_min([]) == None\n    find_max_min([1, 1]) == None\n    \"\"\"\n    if len(lst)==0:\n        return None\n    lst.sort()\n    return lst[-2], lst[0]\n\n\n\ndef find_max_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_max_min()，返回一个列", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst)==1:\n        return None\n    lst.sort()\n    return lst[1]\n\n\n\ndef find_max_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_max_min()，返回一个列表，包含列表中最大值和最小值。\n    find_max_min([1, 2, 3, 4, 5]) == [5, 1]\n    find_max_min([5, 1, 4, 3, 2]) == [5, 1]\n    find_max_min([]) == None\n    find_max_min([1, 1]) == None\n    \"\"\"\n    if len(lst)==0:\n        return None\n    lst.sort()\n    return lst[-2], lst[0]\n\n\n\ndef find_max_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_max_min()，返回一个列"}
{"task_id": "HumanEval/90", "completion": "    lst.sort()\n    lst.pop()\n    return lst[-1]\n\n\ndef longest_decreasing(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数longest_decreasing()，返回最长的单调递减子序列的长度。如果没有单调递减子序列，返回0。    \n    longest_decreasing([1,2,3,4]) == 0\n    longest_decreasing([1,4,2,3]) == 3\n    longest_decreasing([1,1]) == 0\n    longest_decreasing([]) == 0\n    \"\"\"\n    length = len(lst)\n    if length < 2:\n        return 0\n    \n    dp = [1 for i in range(length)]\n    for i in range(length):\n        for j in range(i):\n            if lst[i] < lst[j]:\n                dp[i] = max(dp[i], dp[j]+1)", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst.sort()\n    lst.pop()\n    return lst[-1]\n\n\ndef longest_decreasing(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数longest_decreasing()，返回最长的单调递减子序列的长度。如果没有单调递减子序列，返回0。    \n    longest_decreasing([1,2,3,4]) == 0\n    longest_decreasing([1,4,2,3]) == 3\n    longest_decreasing([1,1]) == 0\n    longest_decreasing([]) == 0\n    \"\"\"\n    length = len(lst)\n    if length < 2:\n        return 0\n    \n    dp = [1 for i in range(length)]\n    for i in range(length):\n        for j in range(i):\n            if lst[i] < lst[j]:\n                dp[i] = max(dp[i], dp[j]+1)"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) < 1:\n        return None\n    lst.sort()\n    return lst[1]\n\nif __name__ == \"__main__\":\n    assert next_smallest([1, 2, 3, 4, 5]) == 2\n    assert next_smallest([5, 1, 4, 3, 2]) == 2\n    assert next_smallest([]) is None\n    assert next_smallest([1, 1]) is None\n\n```\n\n### 用链表实现栈(list实现)\n\n```py\nclass Stack:\n    \"\"\"\n    要求：\n    1. push()方法：将一个元素压入栈中\n    2. pop()方法：栈中拿出第一个元素\n    3. top()方法：返回栈顶元素\n    4. empty()方法：判断栈是否为空\n    5. get_min()方法：返回当前栈中的最", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 1:\n        return None\n    lst.sort()\n    return lst[1]\n\nif __name__ == \"__main__\":\n    assert next_smallest([1, 2, 3, 4, 5]) == 2\n    assert next_smallest([5, 1, 4, 3, 2]) == 2\n    assert next_smallest([]) is None\n    assert next_smallest([1, 1]) is None\n\n```\n\n### 用链表实现栈(list实现)\n\n```py\nclass Stack:\n    \"\"\"\n    要求：\n    1. push()方法：将一个元素压入栈中\n    2. pop()方法：栈中拿出第一个元素\n    3. top()方法：返回栈顶元素\n    4. empty()方法：判断栈是否为空\n    5. get_min()方法：返回当前栈中的最"}
{"task_id": "HumanEval/94", "completion": "    nums = []\n    for i in lst:\n        for j in range(2,i):\n            if(i % j == 0):\n                nums.append(i)\n                break\n    return sum(len(str(i)) for i in nums)\n\ndef sh(lst):\n    lst.sort(reverse=True)\n    res = 0\n    for i in lst:\n        res = res ^ i\n    return res\n\ndef dfs(nums,n):\n    if n == 0:\n        return 1\n    res = 0\n    for i in nums:\n        if n - i >= 0:\n            res = res + dfs(nums,n-i)\n    return res\n\ndef dsf(nums,n):\n    if n == 0:\n        return 1\n    res = 0\n    for i in nums:\n        if n - i >= 0:\n            res = res + dsf(nums,n-i)\n    return res\n\ndef dfs1(nums,n):\n    if n", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    nums = []\n    for i in lst:\n        for j in range(2,i):\n            if(i % j == 0):\n                nums.append(i)\n                break\n    return sum(len(str(i)) for i in nums)\n\ndef sh(lst):\n    lst.sort(reverse=True)\n    res = 0\n    for i in lst:\n        res = res ^ i\n    return res\n\ndef dfs(nums,n):\n    if n == 0:\n        return 1\n    res = 0\n    for i in nums:\n        if n - i >= 0:\n            res = res + dfs(nums,n-i)\n    return res\n\ndef dsf(nums,n):\n    if n == 0:\n        return 1\n    res = 0\n    for i in nums:\n        if n - i >= 0:\n            res = res + dsf(nums,n-i)\n    return res\n\ndef dfs1(nums,n):\n    if n"}
{"task_id": "HumanEval/94", "completion": "    def is_prime(num):\n        \"\"\" 判断是否为质数\n        \"\"\"\n        for i in range(2, int(num **.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def sum_of_digits_in_num(num):\n        \"\"\" 求一个整数的位数之和\n        \"\"\"\n        s = 0\n        while num:\n            s += num % 10\n            num = num // 10\n        return s\n\n    def get_largest_prime_in_lst(lst):\n        \"\"\" 获取最大质数\n        \"\"\"\n        for num in reversed(lst):\n            if is_prime(num):\n                return num\n        print(\"没有可用的质数\")\n        return 0\n\n    def sum_of_digits_of_largest_prime(lst):\n        \"\"\" 求最大质数的位数之和\n        \"\"\"\n        largest_prime = get_largest_prime", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    def is_prime(num):\n        \"\"\" 判断是否为质数\n        \"\"\"\n        for i in range(2, int(num **.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def sum_of_digits_in_num(num):\n        \"\"\" 求一个整数的位数之和\n        \"\"\"\n        s = 0\n        while num:\n            s += num % 10\n            num = num // 10\n        return s\n\n    def get_largest_prime_in_lst(lst):\n        \"\"\" 获取最大质数\n        \"\"\"\n        for num in reversed(lst):\n            if is_prime(num):\n                return num\n        print(\"没有可用的质数\")\n        return 0\n\n    def sum_of_digits_of_largest_prime(lst):\n        \"\"\" 求最大质数的位数之和\n        \"\"\"\n        largest_prime = get_largest_prime"}
{"task_id": "HumanEval/94", "completion": "    # 因为质数的定义恒大于2，所以可以跳过第一个值\n    ans=0\n    prime_lst=[]\n    for i in range(len(lst)):\n        if i == 0 : continue\n        # 判断当前数字是否是素数\n        if is_prime(lst[i]):\n            prime_lst.append(lst[i])\n            ans+=1\n        # 如果不是素数，并且刚好除以lst[i], 不能被整除，那么当前数字就是素数\n        elif lst[i]>2 and lst[i]%lst[i-1]==0:\n            prime_lst.append(lst[i])\n            ans+=1\n        # 否则，当前数字不是素数，并且刚好能被lst[i]整除。对于lst[i]的上一个数字，如果能被lst[i]整除，那么lst", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    # 因为质数的定义恒大于2，所以可以跳过第一个值\n    ans=0\n    prime_lst=[]\n    for i in range(len(lst)):\n        if i == 0 : continue\n        # 判断当前数字是否是素数\n        if is_prime(lst[i]):\n            prime_lst.append(lst[i])\n            ans+=1\n        # 如果不是素数，并且刚好除以lst[i], 不能被整除，那么当前数字就是素数\n        elif lst[i]>2 and lst[i]%lst[i-1]==0:\n            prime_lst.append(lst[i])\n            ans+=1\n        # 否则，当前数字不是素数，并且刚好能被lst[i]整除。对于lst[i]的上一个数字，如果能被lst[i]整除，那么lst"}
{"task_id": "HumanEval/94", "completion": "    def is_prime(number):\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n        return True\n\n    numbers, prime_length = [], []\n    for i in range(len(lst)):\n        num = lst[i]\n        if is_prime(num):\n            prime_length.append(prime_of(num))\n            continue\n        else:\n            numbers.append(num)\n\n    numbers = list(dict.fromkeys(numbers))\n    for i in range(len(numbers)):\n        if prime_length:\n            prime_length.append(prime_of(numbers[i]))\n        else:\n            prime_length.append(prime_of(numbers[i]))\n\n    return sum(prime_length)\n\n\nif __name__ == \"__main__\":\n    print(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    def is_prime(number):\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n        return True\n\n    numbers, prime_length = [], []\n    for i in range(len(lst)):\n        num = lst[i]\n        if is_prime(num):\n            prime_length.append(prime_of(num))\n            continue\n        else:\n            numbers.append(num)\n\n    numbers = list(dict.fromkeys(numbers))\n    for i in range(len(numbers)):\n        if prime_length:\n            prime_length.append(prime_of(numbers[i]))\n        else:\n            prime_length.append(prime_of(numbers[i]))\n\n    return sum(prime_length)\n\n\nif __name__ == \"__main__\":\n    print(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32"}
{"task_id": "HumanEval/94", "completion": "    return sum(len('{0:b}'.format(prime(x))) for x in lst)\n\n\n# 解决方案2\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,2", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    return sum(len('{0:b}'.format(prime(x))) for x in lst)\n\n\n# 解决方案2\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,2"}
{"task_id": "HumanEval/94", "completion": "    l = len(lst)\n    for i in range(l-1):\n        if i == 0:\n            if prime(lst[i]) == True:\n                count += 1\n        else:\n            if prime(lst[i]) == True:\n                count += 1\n                if prime(lst[i-1]) == False:\n                    continue\n                else:\n                    if lst[i] > lst[i-1]:\n                        count += 1\n                        if prime(lst[i-2]) == False:\n                            continue\n                        else:\n                            if lst[i] > lst[i-2]:\n                                count += 1\n        if i == l-1:\n            if count == 0:\n                return 0\n            if count == 1:\n                if prime(lst[i]) == True:\n                    return 1\n                else:\n                    return 0\n            if prime(lst[i]) == True:\n                return count + 1\n            else:\n                return count\n\nif __name__ == '__main__':\n    lst", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    l = len(lst)\n    for i in range(l-1):\n        if i == 0:\n            if prime(lst[i]) == True:\n                count += 1\n        else:\n            if prime(lst[i]) == True:\n                count += 1\n                if prime(lst[i-1]) == False:\n                    continue\n                else:\n                    if lst[i] > lst[i-1]:\n                        count += 1\n                        if prime(lst[i-2]) == False:\n                            continue\n                        else:\n                            if lst[i] > lst[i-2]:\n                                count += 1\n        if i == l-1:\n            if count == 0:\n                return 0\n            if count == 1:\n                if prime(lst[i]) == True:\n                    return 1\n                else:\n                    return 0\n            if prime(lst[i]) == True:\n                return count + 1\n            else:\n                return count\n\nif __name__ == '__main__':\n    lst"}
{"task_id": "HumanEval/94", "completion": "    lst2=[]\n    lst3=[]\n    lst4=[]\n    lst5=[]\n    for i in range(len(lst)):\n        if check(lst[i],lst):\n            lst2.append(lst[i])\n    lst3=sortNum(lst2)\n    for i in range(len(lst)):\n        if lst3[i] not in lst3[i+1:]:\n            lst4.append(lst3[i])\n    lst5=sortNum(lst4)\n    return len(str(lst5[-1]))\n\n    \n    \n\n#测试用例\nlst1 = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\nlst2 = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\nlst3 = [1,3,1,3", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst2=[]\n    lst3=[]\n    lst4=[]\n    lst5=[]\n    for i in range(len(lst)):\n        if check(lst[i],lst):\n            lst2.append(lst[i])\n    lst3=sortNum(lst2)\n    for i in range(len(lst)):\n        if lst3[i] not in lst3[i+1:]:\n            lst4.append(lst3[i])\n    lst5=sortNum(lst4)\n    return len(str(lst5[-1]))\n\n    \n    \n\n#测试用例\nlst1 = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\nlst2 = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\nlst3 = [1,3,1,3"}
{"task_id": "HumanEval/94", "completion": "    count = 0\n    res = 0\n    for i in lst:\n        count += 1\n        if i % 2!= 0:\n            res += count\n            count = 0\n    return res\n\n\ndef skjkasdkd2(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    count = 0\n    res = 0\n    for i in lst:\n        count += 1\n        if i % 2!= 0:\n            res += count\n            count = 0\n    return res\n\n\ndef skjkasdkd2(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34"}
{"task_id": "HumanEval/94", "completion": "    if not lst:\n        return 0\n    else:\n        if len(str(max(lst))) == 1:\n            return len(lst)\n        else:\n            return len(lst)+sum(skjkasdkd(lst))\n\n\ndef m_sum(lst):\n    \"\"\"返回列表中所有数字和。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return lst[0]+m_sum(lst[1:])\n\n\ndef m_max(lst):\n    \"\"\"返回列表中最大的数字。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return max(lst[0], m_max(lst[1:]))\n\n\ndef m_min(lst):\n    \"\"\"返回列表中最小的数字。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return min(lst[0], m_min(lst[1:]))\n\n\ndef m_len(lst):\n    \"\"\"返回列表中元素个数。\"\"", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    if not lst:\n        return 0\n    else:\n        if len(str(max(lst))) == 1:\n            return len(lst)\n        else:\n            return len(lst)+sum(skjkasdkd(lst))\n\n\ndef m_sum(lst):\n    \"\"\"返回列表中所有数字和。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return lst[0]+m_sum(lst[1:])\n\n\ndef m_max(lst):\n    \"\"\"返回列表中最大的数字。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return max(lst[0], m_max(lst[1:]))\n\n\ndef m_min(lst):\n    \"\"\"返回列表中最小的数字。\"\"\"\n    if not lst:\n        return 0\n    else:\n        return min(lst[0], m_min(lst[1:]))\n\n\ndef m_len(lst):\n    \"\"\"返回列表中元素个数。\"\""}
{"task_id": "HumanEval/94", "completion": "    num_dict = {}\n    for num in lst:\n        num_dict[num] = str(num)\n    result = 0\n    k = 0\n    for i in num_dict.values():\n        result += len(i)\n    return result\n\n\n\ndef test():\n    print(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    print(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    print(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    num_dict = {}\n    for num in lst:\n        num_dict[num] = str(num)\n    result = 0\n    k = 0\n    for i in num_dict.values():\n        result += len(i)\n    return result\n\n\n\ndef test():\n    print(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    print(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    print(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278,"}
{"task_id": "HumanEval/103", "completion": "    \n    if n > m:\n        return -1\n    else:\n        l = []\n        for i in range(n, m+1):\n            l.append(i)\n        return str(int(round(sum(l)/len(l))))\n\n\nif __name__ == '__main__':\n    main()\n\n\n# 作者：john_huang\n# 链接：https://leetcode-cn.com/problems/rounded-average/solution/yuan-suan-by-john_huang/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    \n    if n > m:\n        return -1\n    else:\n        l = []\n        for i in range(n, m+1):\n            l.append(i)\n        return str(int(round(sum(l)/len(l))))\n\n\nif __name__ == '__main__':\n    main()\n\n\n# 作者：john_huang\n# 链接：https://leetcode-cn.com/problems/rounded-average/solution/yuan-suan-by-john_huang/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    x = (m-n+1)\n    y = (m-n)\n    z = ((n+y)*x)\n    return bin(z)\n\n\n# Question 31\ndef array_sum(arr, n):\n    \"\"\"给出一个数组arr和一个正整数n，返回arr中前n项的和。 \n    Example:\n    array_sum([1,2,3,4,5], 3) => 6  \n    array_sum([1,2,3,4,5], 4) => 10\n    array_sum([1,2,3,4,5], 5) => 15\n    array_sum([1,2,3,4,5], 6) => -1\n    \"\"\"\n    sum_n = 0\n    if n > len(arr):\n        return -1\n    for i in range(n):\n        sum_n += arr[i]\n    return sum_n\n\n\n# Question 32\ndef array_product", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    x = (m-n+1)\n    y = (m-n)\n    z = ((n+y)*x)\n    return bin(z)\n\n\n# Question 31\ndef array_sum(arr, n):\n    \"\"\"给出一个数组arr和一个正整数n，返回arr中前n项的和。 \n    Example:\n    array_sum([1,2,3,4,5], 3) => 6  \n    array_sum([1,2,3,4,5], 4) => 10\n    array_sum([1,2,3,4,5], 5) => 15\n    array_sum([1,2,3,4,5], 6) => -1\n    \"\"\"\n    sum_n = 0\n    if n > len(arr):\n        return -1\n    for i in range(n):\n        sum_n += arr[i]\n    return sum_n\n\n\n# Question 32\ndef array_product"}
{"task_id": "HumanEval/103", "completion": "    # TODO\ndef list_length(arr):\n    \"\"\"给您一个数组arr，它包含n个数字，其中n是整数。 你的任务是计算arr中的数字的平均值，并返回它们的数量。 您可以假定数组中只包含数字。   Example:\n    list_length([1, 2, 3, 4, 5]) => 3\n    list_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) => 10\n    \"\"\"\n    # TODO\ndef list_average(arr):\n    \"\"\"给您一个数组arr，它包含n个数字，其中n是整数。 你的任务是计算arr中的数字的平均值，并返回它的值。 您可以假定数组中只", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    # TODO\ndef list_length(arr):\n    \"\"\"给您一个数组arr，它包含n个数字，其中n是整数。 你的任务是计算arr中的数字的平均值，并返回它们的数量。 您可以假定数组中只包含数字。   Example:\n    list_length([1, 2, 3, 4, 5]) => 3\n    list_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) => 10\n    \"\"\"\n    # TODO\ndef list_average(arr):\n    \"\"\"给您一个数组arr，它包含n个数字，其中n是整数。 你的任务是计算arr中的数字的平均值，并返回它的值。 您可以假定数组中只"}
{"task_id": "HumanEval/103", "completion": "    if m<n:\n        return -1\n    elif m==n:\n        return bin(n)\n    else:\n        l_bin = bin(m+1)[2:]\n        bin_ = ''\n        for i in l_bin:\n            bin_ += str(i)\n        return bin_[:(len(bin_)-n)]\n    return -1\n\ndef get_number_of_occurrences(a, b):\n    \"\"\"给您两个二进制整数a和b，您的任务是计算a中b的数字出现的次数。 返回它的数字。 如果a或b中的任何一个不是0或1，则返回-1。   Example:\n    get_number_of_occurrences(0b101010, 0b101) => 3\n    get_number_of_occurrences(0b11011010, 0b101) => 2\n    get_number_of_occurrences", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if m<n:\n        return -1\n    elif m==n:\n        return bin(n)\n    else:\n        l_bin = bin(m+1)[2:]\n        bin_ = ''\n        for i in l_bin:\n            bin_ += str(i)\n        return bin_[:(len(bin_)-n)]\n    return -1\n\ndef get_number_of_occurrences(a, b):\n    \"\"\"给您两个二进制整数a和b，您的任务是计算a中b的数字出现的次数。 返回它的数字。 如果a或b中的任何一个不是0或1，则返回-1。   Example:\n    get_number_of_occurrences(0b101010, 0b101) => 3\n    get_number_of_occurrences(0b11011010, 0b101) => 2\n    get_number_of_occurrences"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    elif (m - n) % 2 == 0:\n        return bin(int((n + m)/2))\n    else:\n        return bin(int((n + m)/2 + 1))\n\n\n# Solution \ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    return bin(int(((n + m) / 2) + (((n + m) % 2) == 1)))\n\n\n# Solution \ndef rounded_avg(n, m):\n    return bin(int(round((n + m) / 2, m > n)))\n\n\n# Solution \ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    return bin(round((n + m) / 2))\n```\n\n### 129. 有交集的两个整数集合\n\n[原题链接](https://leetcode-cn.com/problems/intersection-of-two-array", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    elif (m - n) % 2 == 0:\n        return bin(int((n + m)/2))\n    else:\n        return bin(int((n + m)/2 + 1))\n\n\n# Solution \ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    return bin(int(((n + m) / 2) + (((n + m) % 2) == 1)))\n\n\n# Solution \ndef rounded_avg(n, m):\n    return bin(int(round((n + m) / 2, m > n)))\n\n\n# Solution \ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    return bin(round((n + m) / 2))\n```\n\n### 129. 有交集的两个整数集合\n\n[原题链接](https://leetcode-cn.com/problems/intersection-of-two-array"}
{"task_id": "HumanEval/103", "completion": "\n    if n>m:\n        return -1\n    n_s = bin(n)[2:]\n    m_s = bin(m)[2:]\n    s = ''\n    if len(n_s)!= len(m_s):\n        if len(n_s) > len(m_s):\n            s = n_s[0:len(m_s)]\n        else:\n            s = m_s[0:len(n_s)]\n    else:\n        s = n_s\n    k = 1\n    while True:\n        if k==1:\n            s = s + '0'\n        else:\n            s = s + '1'\n        count = 0\n        for j in range(len(s)):\n            if s[j]=='1':\n                count +=1\n        if count == len(s):\n            break\n        k +=1\n    return str(int(s, 2))\n\n\n# 第21题\ndef factorial_digits(n):\n    \"\"\"给您一个正整数n", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n\n    if n>m:\n        return -1\n    n_s = bin(n)[2:]\n    m_s = bin(m)[2:]\n    s = ''\n    if len(n_s)!= len(m_s):\n        if len(n_s) > len(m_s):\n            s = n_s[0:len(m_s)]\n        else:\n            s = m_s[0:len(n_s)]\n    else:\n        s = n_s\n    k = 1\n    while True:\n        if k==1:\n            s = s + '0'\n        else:\n            s = s + '1'\n        count = 0\n        for j in range(len(s)):\n            if s[j]=='1':\n                count +=1\n        if count == len(s):\n            break\n        k +=1\n    return str(int(s, 2))\n\n\n# 第21题\ndef factorial_digits(n):\n    \"\"\"给您一个正整数n"}
{"task_id": "HumanEval/103", "completion": "    \n    if m < n:\n        return -1\n    \n    count = 0\n    res = 0\n    for i in range(n, m+1):\n        res += i\n        count += 1\n        #res += (i + 0.5)\n    res = round(res / count)\n    res_bin = bin(res)[2:]\n    res_bin = \"0\" * (len(str(n)) - len(res_bin)) + res_bin\n    return res_bin\n```\n\n## 1.1.8 基数转换\n\n```python\ndef radix_conversion(number, from_radix, to_radix):\n    \"\"\"给您一个非负整数number以及两个正整数from_radix和to_radix。 如果number不是from_radix的幂，则返回-1。 如果from_radix和to_radix相等，则返回number本身。 否则，你的任务是将number从from_radix", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    \n    if m < n:\n        return -1\n    \n    count = 0\n    res = 0\n    for i in range(n, m+1):\n        res += i\n        count += 1\n        #res += (i + 0.5)\n    res = round(res / count)\n    res_bin = bin(res)[2:]\n    res_bin = \"0\" * (len(str(n)) - len(res_bin)) + res_bin\n    return res_bin\n```\n\n## 1.1.8 基数转换\n\n```python\ndef radix_conversion(number, from_radix, to_radix):\n    \"\"\"给您一个非负整数number以及两个正整数from_radix和to_radix。 如果number不是from_radix的幂，则返回-1。 如果from_radix和to_radix相等，则返回number本身。 否则，你的任务是将number从from_radix"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    l = 0\n\n    for i in range(n, m+1):\n        l += int(i)\n\n    return str(bin(round(l/((m-n+1)*1.0))))[2:]\n\n\n# 案例 1\n# print(rounded_avg(1, 5))\n# 案例 2\n# print(rounded_avg(7, 5))\n# 案例 3\n# print(rounded_avg(10, 20))\n# 案例 4\n# print(rounded_avg(20, 33))\n\n# 案例 1\n# print(rounded_avg(1, 5))\n# 案例 2\n# print(rounded_avg(7, 5))\n# 案例 3\n# print(rounded_avg(10, 20))\n# 案例 4\n# print(r", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    l = 0\n\n    for i in range(n, m+1):\n        l += int(i)\n\n    return str(bin(round(l/((m-n+1)*1.0))))[2:]\n\n\n# 案例 1\n# print(rounded_avg(1, 5))\n# 案例 2\n# print(rounded_avg(7, 5))\n# 案例 3\n# print(rounded_avg(10, 20))\n# 案例 4\n# print(rounded_avg(20, 33))\n\n# 案例 1\n# print(rounded_avg(1, 5))\n# 案例 2\n# print(rounded_avg(7, 5))\n# 案例 3\n# print(rounded_avg(10, 20))\n# 案例 4\n# print(r"}
{"task_id": "HumanEval/103", "completion": "    #return hex(round(int((m + n) / 2)))[2:]\n    if n > m: return -1\n    count = 0\n    for i in range(n, m + 1): count += i\n    return format(round(count / (m - n + 1)), 'b')\n\ndef my_floor(d, n):\n    \"\"\"Returns the largest integer <= d/n. \n    my_floor(2, 3) => 0\n    my_floor(5.7, 2) => 2\n    my_floor(7, 5) => 1\n    \"\"\"\n    return math.floor(d / n)\n\ndef avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 Return the number rounded down, and converted to a string. \n    Example:\n    avg(1, 5) => '0b11'\n    avg", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    #return hex(round(int((m + n) / 2)))[2:]\n    if n > m: return -1\n    count = 0\n    for i in range(n, m + 1): count += i\n    return format(round(count / (m - n + 1)), 'b')\n\ndef my_floor(d, n):\n    \"\"\"Returns the largest integer <= d/n. \n    my_floor(2, 3) => 0\n    my_floor(5.7, 2) => 2\n    my_floor(7, 5) => 1\n    \"\"\"\n    return math.floor(d / n)\n\ndef avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 Return the number rounded down, and converted to a string. \n    Example:\n    avg(1, 5) => '0b11'\n    avg"}
{"task_id": "HumanEval/103", "completion": "    # Code here\n    if n > m:\n        return -1\n    avg = (n + m) / 2\n    return bin(int(avg))[2:]\n\n\ndef rotate_matrix(matrix):\n    \"\"\"给您一个阵列，它是一个阵列，其中阵列是阵列。 您的任务是将阵列转置并逆时针旋转90度，然后将其打印到屏幕。   Example:\n    rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) => 1 4 7  2 5 8  3 6 9\n    \"\"\"\n    # Code here\n    for i in range(0, len(matrix[0])):\n        for j in range(0, len(matrix)):\n            print (\"%d \" % (matrix[j][i]), end='')\n        print ()\n\n\ndef get_", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    # Code here\n    if n > m:\n        return -1\n    avg = (n + m) / 2\n    return bin(int(avg))[2:]\n\n\ndef rotate_matrix(matrix):\n    \"\"\"给您一个阵列，它是一个阵列，其中阵列是阵列。 您的任务是将阵列转置并逆时针旋转90度，然后将其打印到屏幕。   Example:\n    rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) => 1 4 7  2 5 8  3 6 9\n    \"\"\"\n    # Code here\n    for i in range(0, len(matrix[0])):\n        for j in range(0, len(matrix)):\n            print (\"%d \" % (matrix[j][i]), end='')\n        print ()\n\n\ndef get_"}
{"task_id": "HumanEval/109", "completion": "    # O(1)\n    if not arr:\n        return True\n\n    last_index = len(arr) - 1\n    while last_index >= 1 and arr[last_index] < arr[last_index - 1]:\n        arr[last_index - 1], arr[last_index] = arr[last_index], arr[last_index-1]\n        last_index -= 1\n\n    # O(n/2)\n    for i in range(last_index + 1):\n        for j in range(i+1, last_index+1):\n            if arr[i] > arr[j]:\n                return False\n    return True\n\ndef get_unique_list(arr):\n    \"\"\"我们有一个由n个整数组成的数组arr[]。从数组中选出一个子数组子arr[]，其中子数组子arr[]中的元素是arr[]的唯一元素。    我们可以连续选出arr[]中1到n-1个元素作为子数组", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # O(1)\n    if not arr:\n        return True\n\n    last_index = len(arr) - 1\n    while last_index >= 1 and arr[last_index] < arr[last_index - 1]:\n        arr[last_index - 1], arr[last_index] = arr[last_index], arr[last_index-1]\n        last_index -= 1\n\n    # O(n/2)\n    for i in range(last_index + 1):\n        for j in range(i+1, last_index+1):\n            if arr[i] > arr[j]:\n                return False\n    return True\n\ndef get_unique_list(arr):\n    \"\"\"我们有一个由n个整数组成的数组arr[]。从数组中选出一个子数组子arr[]，其中子数组子arr[]中的元素是arr[]的唯一元素。    我们可以连续选出arr[]中1到n-1个元素作为子数组"}
{"task_id": "HumanEval/109", "completion": "    # ----------------------------------------------------------------------\n    #\n    # 以下为 Leetcode 答案\n    #\n    # ----------------------------------------------------------------------\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i+1]:\n            return False\n    return True\n\n\ndef move_one_ball_1(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_2(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_3(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_4(arr):\n", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # ----------------------------------------------------------------------\n    #\n    # 以下为 Leetcode 答案\n    #\n    # ----------------------------------------------------------------------\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i+1]:\n            return False\n    return True\n\n\ndef move_one_ball_1(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_2(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_3(arr):\n    N = len(arr)\n    for i in range(N):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\ndef move_one_ball_4(arr):\n"}
{"task_id": "HumanEval/109", "completion": "    pass\n\n\ndef test():\n    assert move_one_ball([3, 5, 4, 1, 2]) == False\n    \n    \n    \n    \nif __name__ == \"__main__\":\n    test()\n\n```\n\n\n\n### 72. [640.霸王归来](https://leetcode-cn.com/problems/solve-the-equation/)\n\n```python\nclass Solution:\n    def solveEquation(self, equation: str):\n        \"\"\"\n        \n        \"\"\"\n        equation = equation.split('=')\n        nums = equation[0].split(' ')\n        x = 'x' + nums[0]\n        y = 'x' + nums[2]\n        equation = [x + '+' + y, x + '-' + y]\n        equation = [list(e) for e in equation]\n        print(equation)\n        x = self.solveEquation(['1x+1y', '1x-1y'])\n        print(x)\n        \n\ndef test():", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    pass\n\n\ndef test():\n    assert move_one_ball([3, 5, 4, 1, 2]) == False\n    \n    \n    \n    \nif __name__ == \"__main__\":\n    test()\n\n```\n\n\n\n### 72. [640.霸王归来](https://leetcode-cn.com/problems/solve-the-equation/)\n\n```python\nclass Solution:\n    def solveEquation(self, equation: str):\n        \"\"\"\n        \n        \"\"\"\n        equation = equation.split('=')\n        nums = equation[0].split(' ')\n        x = 'x' + nums[0]\n        y = 'x' + nums[2]\n        equation = [x + '+' + y, x + '-' + y]\n        equation = [list(e) for e in equation]\n        print(equation)\n        x = self.solveEquation(['1x+1y', '1x-1y'])\n        print(x)\n        \n\ndef test():"}
{"task_id": "HumanEval/109", "completion": "    \n    # return move_one_ball_recursive(arr)\n    return move_one_ball_dfs(arr)\n\n\ndef move_one_ball_dfs(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: bool\n    \"\"\"\n\n    if not arr:\n        return True\n\n    def dfs(A, target, index):\n        if index == len(A):\n            if target == 0:\n                return True\n            else:\n                return False\n\n        if target == 0:\n            return True\n\n        for i in range(index, len(A)):\n            if A[i] > target:\n                A[i], A[index] = A[index], A[i]\n                if dfs(A, target, index+1):\n                    return True\n                A[i], A[index] = A[index], A[i]\n            # 如果遇到目标就不继续找\n            if A[i] == target:\n                break\n\n        return False\n\n", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    \n    # return move_one_ball_recursive(arr)\n    return move_one_ball_dfs(arr)\n\n\ndef move_one_ball_dfs(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: bool\n    \"\"\"\n\n    if not arr:\n        return True\n\n    def dfs(A, target, index):\n        if index == len(A):\n            if target == 0:\n                return True\n            else:\n                return False\n\n        if target == 0:\n            return True\n\n        for i in range(index, len(A)):\n            if A[i] > target:\n                A[i], A[index] = A[index], A[i]\n                if dfs(A, target, index+1):\n                    return True\n                A[i], A[index] = A[index], A[i]\n            # 如果遇到目标就不继续找\n            if A[i] == target:\n                break\n\n        return False\n\n"}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    first_no = arr[0]\n    second_no = arr[1]\n    for i in range(1, len(arr)):\n        arr[i] = arr[i-1]\n    arr[0] = second_no\n    first_no = second_no\n    for i in range(1, len(arr)):\n        arr[i] = arr[i-1]\n    arr[0] = first_no\n    return arr\n\n\ndef find_first_number(arr, target):\n    \"\"\" 在一个数组中查找第一次出现的数字。    如果找不到则返回-1     For Example:\n    \n    find_first_number([1, 2, 2, 9, 9, 9], 2)==>1\n    Explanation: 1是数组中第一次出现的2\n    \"\"\"\n    if not arr:\n        return -1\n    for i in range(len(arr)):\n        if arr[i]==target:\n", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    first_no = arr[0]\n    second_no = arr[1]\n    for i in range(1, len(arr)):\n        arr[i] = arr[i-1]\n    arr[0] = second_no\n    first_no = second_no\n    for i in range(1, len(arr)):\n        arr[i] = arr[i-1]\n    arr[0] = first_no\n    return arr\n\n\ndef find_first_number(arr, target):\n    \"\"\" 在一个数组中查找第一次出现的数字。    如果找不到则返回-1     For Example:\n    \n    find_first_number([1, 2, 2, 9, 9, 9], 2)==>1\n    Explanation: 1是数组中第一次出现的2\n    \"\"\"\n    if not arr:\n        return -1\n    for i in range(len(arr)):\n        if arr[i]==target:\n"}
{"task_id": "HumanEval/109", "completion": "    d = collections.Counter(arr)\n    for k, v in d.items():\n        if v > 1:\n            return False\n    return True\n\n# 面试题-10-I\ndef last_remaining_number_with_repeat(n):\n    \"\"\"假设有从1,2,3,...,n这n个数字的序列，从第一个数字开始，每一步除了移除剩下的最后一个数字外，你可以随意选择一个数字，并将它和当前的数字进行交换。\n    问题：第n个数字到底是哪个?\n    For Example:\n    \n    last_remaining_number_with_repeat(3)==>3\n    Explanation: 1 2 3-->2 3 1-->1 3 2-->3 1 2-->1 2 3\n    \"\"\"\n    a = list(range(1, n + 1))\n    for i in range", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    d = collections.Counter(arr)\n    for k, v in d.items():\n        if v > 1:\n            return False\n    return True\n\n# 面试题-10-I\ndef last_remaining_number_with_repeat(n):\n    \"\"\"假设有从1,2,3,...,n这n个数字的序列，从第一个数字开始，每一步除了移除剩下的最后一个数字外，你可以随意选择一个数字，并将它和当前的数字进行交换。\n    问题：第n个数字到底是哪个?\n    For Example:\n    \n    last_remaining_number_with_repeat(3)==>3\n    Explanation: 1 2 3-->2 3 1-->1 3 2-->3 1 2-->1 2 3\n    \"\"\"\n    a = list(range(1, n + 1))\n    for i in range"}
{"task_id": "HumanEval/109", "completion": "    arr = set(arr)\n    if len(arr) == 1:\n        return True\n    return False\n\n\n\nif __name__ == \"__main__\":\n    # print(is_sorted([1, 2, 3, 4, 5]))\n    # print(is_sorted([5, 4, 3, 2, 1]))\n    # print(is_sorted([1, 2, 3, 3, 3]))\n    # print(is_sorted([2, 3, 4, 3, 2]))\n\n    print(move_one_ball([3, 4, 5, 1, 2]))\n    print(move_one_ball([3, 5, 4, 1, 2]))\n    print(move_one_ball([1, 2, 3, 3, 3]))\n    print(move_one_ball([", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    arr = set(arr)\n    if len(arr) == 1:\n        return True\n    return False\n\n\n\nif __name__ == \"__main__\":\n    # print(is_sorted([1, 2, 3, 4, 5]))\n    # print(is_sorted([5, 4, 3, 2, 1]))\n    # print(is_sorted([1, 2, 3, 3, 3]))\n    # print(is_sorted([2, 3, 4, 3, 2]))\n\n    print(move_one_ball([3, 4, 5, 1, 2]))\n    print(move_one_ball([3, 5, 4, 1, 2]))\n    print(move_one_ball([1, 2, 3, 3, 3]))\n    print(move_one_ball(["}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    return move_one_ball_helper(arr,[0])\n\ndef move_one_ball_helper(arr,indexes):\n    \"\"\"\n    \n    \"\"\"\n    if not arr:\n        return True\n    if len(arr)==1:\n        return True\n    if len(arr)==2:\n        return arr[0]>=arr[1]\n    if indexes[-1]==len(arr)-1:\n        return True\n    if indexes[-1]==0:\n        return False\n    if indexes[-1]>0:\n        indexes.append(indexes[-1]-1)\n        res_left = move_one_ball_helper(arr,indexes)\n        indexes", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    return move_one_ball_helper(arr,[0])\n\ndef move_one_ball_helper(arr,indexes):\n    \"\"\"\n    \n    \"\"\"\n    if not arr:\n        return True\n    if len(arr)==1:\n        return True\n    if len(arr)==2:\n        return arr[0]>=arr[1]\n    if indexes[-1]==len(arr)-1:\n        return True\n    if indexes[-1]==0:\n        return False\n    if indexes[-1]>0:\n        indexes.append(indexes[-1]-1)\n        res_left = move_one_ball_helper(arr,indexes)\n        indexes"}
{"task_id": "HumanEval/109", "completion": "    if len(arr)<=1:\n        return True\n    else:\n        if arr[-1]>arr[0]:\n            return False\n        else:\n            i=0\n            while arr[i]>=arr[i+1]:\n                i=i+1\n            if(arr[i]>=arr[-1]):\n                return True\n            else:\n                return False\n\ndef merge_two_sorted_arrays(arr1,arr2):\n    \"\"\"将两个有序数组合并为一个有序数组。\n    For Example:\n    merge_two_sorted_arrays([4, 5, 6], [1, 2, 3]) ==>[1, 2, 3, 4, 5, 6]\n    \"\"\"\n    arr1_length=len(arr1)\n    arr2_length=len(arr2)\n    if arr1_length<=0 or arr2_length<=0:\n        return []\n    else:\n        if arr1[0]<=arr2[0]:\n            result=[]\n            result.append(", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if len(arr)<=1:\n        return True\n    else:\n        if arr[-1]>arr[0]:\n            return False\n        else:\n            i=0\n            while arr[i]>=arr[i+1]:\n                i=i+1\n            if(arr[i]>=arr[-1]):\n                return True\n            else:\n                return False\n\ndef merge_two_sorted_arrays(arr1,arr2):\n    \"\"\"将两个有序数组合并为一个有序数组。\n    For Example:\n    merge_two_sorted_arrays([4, 5, 6], [1, 2, 3]) ==>[1, 2, 3, 4, 5, 6]\n    \"\"\"\n    arr1_length=len(arr1)\n    arr2_length=len(arr2)\n    if arr1_length<=0 or arr2_length<=0:\n        return []\n    else:\n        if arr1[0]<=arr2[0]:\n            result=[]\n            result.append("}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    temp = [0] * len(arr)\n    j = 0\n    for i in arr:\n        if i > arr[j]:\n            return False\n        else:\n            temp[i - 1] = arr[j]\n            j += 1\n    return temp == arr\n\n\nif __name__ == \"__main__\":\n    print(move_one_ball([1", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    temp = [0] * len(arr)\n    j = 0\n    for i in arr:\n        if i > arr[j]:\n            return False\n        else:\n            temp[i - 1] = arr[j]\n            j += 1\n    return temp == arr\n\n\nif __name__ == \"__main__\":\n    print(move_one_ball([1"}
{"task_id": "HumanEval/114", "completion": "    if len(nums) == 1:\n        return nums[0]\n    min_sum = 0\n    cur_sum = 0\n    j = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        # 当前子序列全部元素小于等于零时，更新 min_sum\n        while cur_sum <= 0:\n            cur_sum -= nums[j]\n            j += 1\n        min_sum = min(min_sum, cur_sum)\n    return min_sum\n    \n\n\ndef longestSubarray(nums):\n    \"\"\"\n    给定一个整数数组，找到最长和最大的子数组，输出其长度。示例如下：\n    longestSubarray([0, -1, 2, -3, 4]) == 2\n    longestSubarray([-1, -2, -3]) == 0\n    \"\"\"\n    if len(nums) == 1:\n        return 1\n", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if len(nums) == 1:\n        return nums[0]\n    min_sum = 0\n    cur_sum = 0\n    j = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        # 当前子序列全部元素小于等于零时，更新 min_sum\n        while cur_sum <= 0:\n            cur_sum -= nums[j]\n            j += 1\n        min_sum = min(min_sum, cur_sum)\n    return min_sum\n    \n\n\ndef longestSubarray(nums):\n    \"\"\"\n    给定一个整数数组，找到最长和最大的子数组，输出其长度。示例如下：\n    longestSubarray([0, -1, 2, -3, 4]) == 2\n    longestSubarray([-1, -2, -3]) == 0\n    \"\"\"\n    if len(nums) == 1:\n        return 1\n"}
{"task_id": "HumanEval/114", "completion": "    if len(nums) == 1:\n        return nums[0]\n    res = nums[0]\n    sum_ = 0\n\n    # 当前数组的前缀和\n    preSum = [0] * len(nums)\n    preSum[0] = nums[0]\n    for i in range(1, len(nums)):\n        preSum[i] = preSum[i - 1] + nums[i]\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)+1):\n            if preSum[j] - preSum[i] <= 0:\n                continue\n            if i == 0:\n                if preSum[j] - preSum[i] < res:\n                    res = preSum[j] - preSum[i]\n            else:\n                sum_ = preSum[j] - preSum[i]\n                if sum_ < res:\n                    res = sum_\n    return res\n\n\nif __name__ == '__main__", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if len(nums) == 1:\n        return nums[0]\n    res = nums[0]\n    sum_ = 0\n\n    # 当前数组的前缀和\n    preSum = [0] * len(nums)\n    preSum[0] = nums[0]\n    for i in range(1, len(nums)):\n        preSum[i] = preSum[i - 1] + nums[i]\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)+1):\n            if preSum[j] - preSum[i] <= 0:\n                continue\n            if i == 0:\n                if preSum[j] - preSum[i] < res:\n                    res = preSum[j] - preSum[i]\n            else:\n                sum_ = preSum[j] - preSum[i]\n                if sum_ < res:\n                    res = sum_\n    return res\n\n\nif __name__ == '__main__"}
{"task_id": "HumanEval/114", "completion": "    max_sum = sum(nums)  # 即为答案\n    min_sum = max_sum\n    for i in range(len(nums)):\n        min_sum = min(min_sum, max_sum - sum(nums[i:]))\n    return min_sum\n\ndef minSubArrays(S):\n    \"\"\"\n    :type S: int\n    :rtype: int\n    给定一个负数数组 S 和一个正数 T 。找到最长的连续子数组 {A[i], A[i+1],..., A[j]}，使得\n    S[i] + S[i+1] +... + S[j] <= T。要求：\n    1. 子数组的长度至少为 3 。\n    2. 子数组中的每一个数字都是 负 数。\n    \"\"\"\n    if S in [0, 1]: return 2\n    j, k, res = 0, ", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    max_sum = sum(nums)  # 即为答案\n    min_sum = max_sum\n    for i in range(len(nums)):\n        min_sum = min(min_sum, max_sum - sum(nums[i:]))\n    return min_sum\n\ndef minSubArrays(S):\n    \"\"\"\n    :type S: int\n    :rtype: int\n    给定一个负数数组 S 和一个正数 T 。找到最长的连续子数组 {A[i], A[i+1],..., A[j]}，使得\n    S[i] + S[i+1] +... + S[j] <= T。要求：\n    1. 子数组的长度至少为 3 。\n    2. 子数组中的每一个数字都是 负 数。\n    \"\"\"\n    if S in [0, 1]: return 2\n    j, k, res = 0, "}
{"task_id": "HumanEval/114", "completion": "    n = len(nums)\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return min(nums[0], nums[1])\n    ans = sum(nums[:2])\n    pre = 0\n    for i in range(2, n):\n        pre += nums[i-2]\n        ans = min(ans, pre + nums[i])\n    return ans\n\nprint(minSubArraySum([2, 3, 4, 1, 2, 4]))\nprint(minSubArraySum([-1, -2, -3, -1]))\nprint(minSubArraySum([-2, -4, 1, 0, 3, 0, 0, 0]))\nprint(minSubArraySum([1, 3, 7, 1, 2, 1, 1, 2]))\nprint(minSubArraySum([-1, -2, -3, -2, -1, -5]))\n```\n\n## 最大矩形\n\n[![", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return min(nums[0], nums[1])\n    ans = sum(nums[:2])\n    pre = 0\n    for i in range(2, n):\n        pre += nums[i-2]\n        ans = min(ans, pre + nums[i])\n    return ans\n\nprint(minSubArraySum([2, 3, 4, 1, 2, 4]))\nprint(minSubArraySum([-1, -2, -3, -1]))\nprint(minSubArraySum([-2, -4, 1, 0, 3, 0, 0, 0]))\nprint(minSubArraySum([1, 3, 7, 1, 2, 1, 1, 2]))\nprint(minSubArraySum([-1, -2, -3, -2, -1, -5]))\n```\n\n## 最大矩形\n\n[!["}
{"task_id": "HumanEval/114", "completion": "\n    sumValue = 0\n    minSum = 0\n    for i in range(len(nums)):\n        sumValue += nums[i]\n        if (i + 1) < len(nums):\n            minSum += nums[i + 1]\n    print(\"minSubArraySum:\", sumValue - minSum)\n\n    return sumValue - minSum\n\n\nif __name__ == '__main", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n    sumValue = 0\n    minSum = 0\n    for i in range(len(nums)):\n        sumValue += nums[i]\n        if (i + 1) < len(nums):\n            minSum += nums[i + 1]\n    print(\"minSubArraySum:\", sumValue - minSum)\n\n    return sumValue - minSum\n\n\nif __name__ == '__main"}
{"task_id": "HumanEval/114", "completion": "    # 遍历数组\n    # 找到当前元素和之前元素相加之和，然后和前面所有元素相对比\n    # 找到最小值赋值给preIndex\n    # 之后遍历preIndex前的元素之和减掉preIndex\n    # 最后返回\n    preIndex = 0\n    minSum = 99999999\n    sumSum = 0\n    curSum = 0\n    for i in range(len(nums)):\n        curSum += nums[i]\n        if curSum < minSum:\n            preIndex = i\n            minSum = curSum\n        elif curSum > minSum:\n            sumSum += minSum\n            minSum = curSum\n\n        curSum = 0\n    return sumSum + minSum\n\n\n# 215. 数组中的第K个最大元素 中等\n# 给定整数数组 nums 和", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # 遍历数组\n    # 找到当前元素和之前元素相加之和，然后和前面所有元素相对比\n    # 找到最小值赋值给preIndex\n    # 之后遍历preIndex前的元素之和减掉preIndex\n    # 最后返回\n    preIndex = 0\n    minSum = 99999999\n    sumSum = 0\n    curSum = 0\n    for i in range(len(nums)):\n        curSum += nums[i]\n        if curSum < minSum:\n            preIndex = i\n            minSum = curSum\n        elif curSum > minSum:\n            sumSum += minSum\n            minSum = curSum\n\n        curSum = 0\n    return sumSum + minSum\n\n\n# 215. 数组中的第K个最大元素 中等\n# 给定整数数组 nums 和"}
{"task_id": "HumanEval/114", "completion": "    total = 0\n    minTotal = float('inf')\n    for i in nums:\n        total += i\n        minTotal = min(minTotal, total)\n        if total < 0:\n            total = 0\n    return minTotal\n\nprint(minSubArraySum", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    total = 0\n    minTotal = float('inf')\n    for i in nums:\n        total += i\n        minTotal = min(minTotal, total)\n        if total < 0:\n            total = 0\n    return minTotal\n\nprint(minSubArraySum"}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return 0\n    sum = 0\n    min_sum = sum\n    last = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum < min_sum:\n            min_sum = sum\n            last = i\n        elif sum > min_sum:\n            while last < i:\n                sum -= nums[last]\n                last += 1\n                if sum < min_sum:\n                    min_sum = sum\n                    last = i\n                elif sum > min_sum:\n                    break\n    print(last, min_sum)\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([-1, -2, -3]))\n    print(minSubArraySum([3, 4, 5, -1, 2, 3]))\n    print(minSubArraySum([1, 2, 3, 4, 2, 1]))\n    print(minSubArraySum([1, 2, 3, ", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    sum = 0\n    min_sum = sum\n    last = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum < min_sum:\n            min_sum = sum\n            last = i\n        elif sum > min_sum:\n            while last < i:\n                sum -= nums[last]\n                last += 1\n                if sum < min_sum:\n                    min_sum = sum\n                    last = i\n                elif sum > min_sum:\n                    break\n    print(last, min_sum)\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([-1, -2, -3]))\n    print(minSubArraySum([3, 4, 5, -1, 2, 3]))\n    print(minSubArraySum([1, 2, 3, 4, 2, 1]))\n    print(minSubArraySum([1, 2, 3, "}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return\n\n    n = len(nums)\n    res = float('inf')\n    total = 0\n    for i in range(n):\n        total += nums[i]\n        if total > res:\n            res = total\n        else:\n            continue\n\n    if res == float('inf'):\n        res = 0\n    return res\n\n# 第 114 题： 求 1 + 2 + 3 +... + n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\ndef sumNums(n):\n    \"\"\"\n    我不知道怎么做，所以不写代码了。\n    \"\"\"\n    return n\n\n# 第 115 题： 把字符串 s 中的每个空格替换成\"%20\"。\ndef replaceSpace(s):\n    \"\"\"\n    思路", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return\n\n    n = len(nums)\n    res = float('inf')\n    total = 0\n    for i in range(n):\n        total += nums[i]\n        if total > res:\n            res = total\n        else:\n            continue\n\n    if res == float('inf'):\n        res = 0\n    return res\n\n# 第 114 题： 求 1 + 2 + 3 +... + n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\ndef sumNums(n):\n    \"\"\"\n    我不知道怎么做，所以不写代码了。\n    \"\"\"\n    return n\n\n# 第 115 题： 把字符串 s 中的每个空格替换成\"%20\"。\ndef replaceSpace(s):\n    \"\"\"\n    思路"}
{"task_id": "HumanEval/114", "completion": "    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    minSum = float('inf')\n    start = 0\n    end = 0\n    sum = 0\n    while end < n:\n        while sum < 0 and end < n:\n            sum += nums[end]\n            end += 1\n        minSum = min(minSum, sum)\n        sum += nums[start]\n        start += 1\n    return minSum\n```\n\n## 滑动窗口算法\n滑动窗口算法核心思路是维护一个窗口，窗口的大小由移动方向决定，\n窗口内的元素是我们关心的。\n\n### 窗口滑动左进右出模式\n固定窗口大小，并移动窗口右边界，如果右边", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    minSum = float('inf')\n    start = 0\n    end = 0\n    sum = 0\n    while end < n:\n        while sum < 0 and end < n:\n            sum += nums[end]\n            end += 1\n        minSum = min(minSum, sum)\n        sum += nums[start]\n        start += 1\n    return minSum\n```\n\n## 滑动窗口算法\n滑动窗口算法核心思路是维护一个窗口，窗口的大小由移动方向决定，\n窗口内的元素是我们关心的。\n\n### 窗口滑动左进右出模式\n固定窗口大小，并移动窗口右边界，如果右边"}
{"task_id": "MBPP/12", "completion": "\n    # write code here\n    result = []\n    for i in range(len(M)):\n        result.append(sum(M[i]))\n    result.sort()\n    return result[::-1]\n```\n# 405. 数字序列中的最大跳跃\n```python\nimport math\nfrom typing import List\ndef maxSkip(nums: List[int]):\n    '''\n    给定一个非负整数数组 nums，你最初位于数组的 第一个下标 。\n\n    数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n    你的目标是使用最少的跳跃次数到达数组的最后一个下标。\n\n    示例:\n\n    输入: [2,3,1,1,4]\n    输出: 2\n    解释: 跳到最后一个下标需要跳 1", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # write code here\n    result = []\n    for i in range(len(M)):\n        result.append(sum(M[i]))\n    result.sort()\n    return result[::-1]\n```\n# 405. 数字序列中的最大跳跃\n```python\nimport math\nfrom typing import List\ndef maxSkip(nums: List[int]):\n    '''\n    给定一个非负整数数组 nums，你最初位于数组的 第一个下标 。\n\n    数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n    你的目标是使用最少的跳跃次数到达数组的最后一个下标。\n\n    示例:\n\n    输入: [2,3,1,1,4]\n    输出: 2\n    解释: 跳到最后一个下标需要跳 1"}
{"task_id": "MBPP/12", "completion": "\n    res = []\n    n = len(M)//2\n    for i in range(2**n):\n        res.append(0)\n        for j in range(2**n):\n            res[i] += M[2**n*j + i]\n    return res\n```\n\n### 9.字符串的排序\n\n```python\n# 题目：对字符串进行排序。\ndef sort_string(M: List[str]):\n    res = []\n    for i in range(max(M)):\n        res.append(\"\")\n        for j in range(len(M)):\n            if M[j][i]!= \"0\":\n                res[i] += M[j][i]\n    return res\n```\n\n### 10. 数组在减去某个值\n\n```python\n# 题目：对数组中的元素减去某个值，使其减少最小。\ndef sort_string(M: List[float]):\n    res", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    res = []\n    n = len(M)//2\n    for i in range(2**n):\n        res.append(0)\n        for j in range(2**n):\n            res[i] += M[2**n*j + i]\n    return res\n```\n\n### 9.字符串的排序\n\n```python\n# 题目：对字符串进行排序。\ndef sort_string(M: List[str]):\n    res = []\n    for i in range(max(M)):\n        res.append(\"\")\n        for j in range(len(M)):\n            if M[j][i]!= \"0\":\n                res[i] += M[j][i]\n    return res\n```\n\n### 10. 数组在减去某个值\n\n```python\n# 题目：对数组中的元素减去某个值，使其减少最小。\ndef sort_string(M: List[float]):\n    res"}
{"task_id": "MBPP/12", "completion": "\n    ret = []\n    mx = len(M)\n    my = len(M[0])\n    for i in range(mx):\n        ret.append((M[i][0], i, 0))\n    ret.sort()\n    for i in range(len(ret)):\n        x = ret[i][1]\n        y = ret[i][2]\n        M[x][y] = i\n        if y < my - 1:\n            ret.append((M[x][y + 1], x, y + 1))\n    return M\n\nM = [[-3, -3, 5], [-1, -4, 2], [2, 6, 5]]\nprint(sort_matrix(M))\n\nM = [[9, 15, 12], [5, 23, 8], [1, 6, 8]]\nprint(sort_matrix(M))\n\nM = [[1, 2], [3, 4]]\nprint(sort_matrix(M))\n\nM = [[1, 2, 3], [", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    ret = []\n    mx = len(M)\n    my = len(M[0])\n    for i in range(mx):\n        ret.append((M[i][0], i, 0))\n    ret.sort()\n    for i in range(len(ret)):\n        x = ret[i][1]\n        y = ret[i][2]\n        M[x][y] = i\n        if y < my - 1:\n            ret.append((M[x][y + 1], x, y + 1))\n    return M\n\nM = [[-3, -3, 5], [-1, -4, 2], [2, 6, 5]]\nprint(sort_matrix(M))\n\nM = [[9, 15, 12], [5, 23, 8], [1, 6, 8]]\nprint(sort_matrix(M))\n\nM = [[1, 2], [3, 4]]\nprint(sort_matrix(M))\n\nM = [[1, 2, 3], ["}
{"task_id": "MBPP/12", "completion": "\n    m,n = len(M),len(M[0])\n    s = [[0]*n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            s[i][j] = M[i][j]+s[i][j-1]\n    return s\ndef sort_matrix2(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    m,n = len(M),len(M[0])\n    s = [[0]*n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            s[i][j] = M[i][j]+s[i][j-1]\n    s = [(i,j,s[i][j]) for i in range(m) for j in range(n)]\n    res = []\n    for j in range(n):\n        res.", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    m,n = len(M),len(M[0])\n    s = [[0]*n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            s[i][j] = M[i][j]+s[i][j-1]\n    return s\ndef sort_matrix2(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    m,n = len(M),len(M[0])\n    s = [[0]*n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            s[i][j] = M[i][j]+s[i][j-1]\n    s = [(i,j,s[i][j]) for i in range(m) for j in range(n)]\n    res = []\n    for j in range(n):\n        res."}
{"task_id": "MBPP/12", "completion": "\n    result = []\n    for i in range(len(M)):\n        nums = 0\n        for j in range(len(M[i])):\n            nums += M[i][j]\n        result.append(nums)\n    return [result[i] for i in sorted(range(len(result)), key=result.__getitem__)]\n\nM = [[3,1,4,5],[7,9,2,3]]\nprint(sort_matrix(M))\n# 但是这样做做不到每一行的求和一定是从小到大排序的，\n# 总结下问题：从每一行的求和结果都是升序的，但是不一定是从小到大呈现，且求和结果的排序方式也不一定是从小到大，所以怎么做呢？\n\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个�", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    result = []\n    for i in range(len(M)):\n        nums = 0\n        for j in range(len(M[i])):\n            nums += M[i][j]\n        result.append(nums)\n    return [result[i] for i in sorted(range(len(result)), key=result.__getitem__)]\n\nM = [[3,1,4,5],[7,9,2,3]]\nprint(sort_matrix(M))\n# 但是这样做做不到每一行的求和一定是从小到大排序的，\n# 总结下问题：从每一行的求和结果都是升序的，但是不一定是从小到大呈现，且求和结果的排序方式也不一定是从小到大，所以怎么做呢？\n\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个�"}
{"task_id": "MBPP/12", "completion": "\n    # 按行求和求升序\n    # 思路:分别计算每一行的和，然后按照和的大小排序\n    # 时间复杂度O(n^2)\n    res=[]\n    for row in M:\n        sum=0", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 按行求和求升序\n    # 思路:分别计算每一行的和，然后按照和的大小排序\n    # 时间复杂度O(n^2)\n    res=[]\n    for row in M:\n        sum=0"}
{"task_id": "MBPP/12", "completion": "\n\n    def f(item):\n        return sum(item)\n\n    return sorted(M, key=f)\n\n\ndef sort_matrix_2(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按列求和结果的升序进行排序。\n    '''\n\n    def f(item):\n        return sum(item)\n\n    return sorted(M, key=f)\n\n\ndef sort_matrix_3(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按列求和结果的降序进行排序。\n    '''\n\n    def f(item):\n        return -sum(item)\n\n    return sorted(M, key=f)\n\n\nif __name__ == '__main__':\n    M = [[2, 1, 3], [1, 3, 4], [2, 4, 5]]\n   ", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n\n    def f(item):\n        return sum(item)\n\n    return sorted(M, key=f)\n\n\ndef sort_matrix_2(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按列求和结果的升序进行排序。\n    '''\n\n    def f(item):\n        return sum(item)\n\n    return sorted(M, key=f)\n\n\ndef sort_matrix_3(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按列求和结果的降序进行排序。\n    '''\n\n    def f(item):\n        return -sum(item)\n\n    return sorted(M, key=f)\n\n\nif __name__ == '__main__':\n    M = [[2, 1, 3], [1, 3, 4], [2, 4, 5]]\n   "}
{"task_id": "MBPP/12", "completion": "\n    # 解法：临时使用额外空间\n    N = len(M)\n    arr = [0] * N\n    for i in range(N):\n        for j in range(N):\n            arr[i] += M[j][i]\n    # 用arr升序排序\n    arr.sort()\n    # 将M根据arr进行排序\n    for i in range(N):\n        for j in range(N):\n            M[i][j] = arr[i]\n    return M\n```\n\n## 背包问题\n\n1. 0-1背包问题：假设有一个背包容量为W, n个物品的不同重量为w1,..,wN, 价值为v1,..,vN,求背包中的最大价值。\n\n```python\ndef knapSack(W, wt: List[int], val: List[int]):\n    '''", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 解法：临时使用额外空间\n    N = len(M)\n    arr = [0] * N\n    for i in range(N):\n        for j in range(N):\n            arr[i] += M[j][i]\n    # 用arr升序排序\n    arr.sort()\n    # 将M根据arr进行排序\n    for i in range(N):\n        for j in range(N):\n            M[i][j] = arr[i]\n    return M\n```\n\n## 背包问题\n\n1. 0-1背包问题：假设有一个背包容量为W, n个物品的不同重量为w1,..,wN, 价值为v1,..,vN,求背包中的最大价值。\n\n```python\ndef knapSack(W, wt: List[int], val: List[int]):\n    '''"}
{"task_id": "MBPP/12", "completion": "\n    x = []\n    for i in range(len(M)):\n        row = 0\n        for j in range(len(M[i])):\n            row += M[i][j]\n        x.append((row, i))\n    x.sort()\n    res = []\n    for i in range(len(M)):\n        temp = []\n        for j in range(len(M[i])):\n            temp.append(x[i][0])\n        res.append(temp)\n    return res\n```\n\n## 2. 优化方法\n\n- 用字典的key值代替列表索引\n- 用列表求和的方式代替嵌套for循环\n- 将求和结果和行的索引用一个元组保存\n- 根据求和结果和行的索引建一个list，\n\n## 3. 代码\n\n```python\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    x = []\n    for i in range(len(M)):\n        row = 0\n        for j in range(len(M[i])):\n            row += M[i][j]\n        x.append((row, i))\n    x.sort()\n    res = []\n    for i in range(len(M)):\n        temp = []\n        for j in range(len(M[i])):\n            temp.append(x[i][0])\n        res.append(temp)\n    return res\n```\n\n## 2. 优化方法\n\n- 用字典的key值代替列表索引\n- 用列表求和的方式代替嵌套for循环\n- 将求和结果和行的索引用一个元组保存\n- 根据求和结果和行的索引建一个list，\n\n## 3. 代码\n\n```python\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个"}
{"task_id": "MBPP/12", "completion": "\n    if", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    if"}
{"task_id": "MBPP/24", "completion": "\n    decimal, base = 0, 1\n    for digit in binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal, base = 0, 1\n    for digit in binu"}
{"task_id": "MBPP/24", "completion": "\n    result = 0\n    for i in range(len(binum)):\n        result += float(binum[-(i + 1)]) * 2 ** i\n    return int(result)\n\ndef decimal_to_binary(dec): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(5)\n    101\n    >>> decimal_to_binary(8)\n    1000\n    '''\n    result = []\n    while dec:\n        result.append(str(dec % 2))\n        dec /= 2\n\n    for i in range(len(result)):\n        result[i] = int(result[i])\n\n    result.reverse()\n    return [str(i) for i in result]\n\ndef binary_to_hex(binum): \n    '''\n    将给定的二进制数转化为十六进制数。\n    >>> binary_to_hex(101010)\n    '1ea'\n    >>> binary_to_hex(", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    result = 0\n    for i in range(len(binum)):\n        result += float(binum[-(i + 1)]) * 2 ** i\n    return int(result)\n\ndef decimal_to_binary(dec): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(5)\n    101\n    >>> decimal_to_binary(8)\n    1000\n    '''\n    result = []\n    while dec:\n        result.append(str(dec % 2))\n        dec /= 2\n\n    for i in range(len(result)):\n        result[i] = int(result[i])\n\n    result.reverse()\n    return [str(i) for i in result]\n\ndef binary_to_hex(binum): \n    '''\n    将给定的二进制数转化为十六进制数。\n    >>> binary_to_hex(101010)\n    '1ea'\n    >>> binary_to_hex("}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    number = 1\n    for i in binum:\n        dec += int(i)*number\n        number *= 2\n    return dec\n\ndef decimal_to_binary(number):\n    \"\"\"\n    将十进制数转换为二进制数\n    >>> decimal_to_binary(9)\n    100\n    >>> decimal_to_binary(10)\n    1010\n    \"\"\"\n    if number <= 1:\n        return list(str(number))\n    div, mod = divmod(number, 2)\n    return decimal_to_binary(div) + [mod]\n\ndef decimal_to_octal(number):\n    \"\"\"\n    将十进制数转换为八进制数\n    >>> decimal_to_octal(9)\n    11\n    >>> decimal_to_octal(10)\n    12\n    \"\"\"\n    if number <= 7:\n        return [str(number)]\n    div, mod = divmod(number, 8)\n    return decimal_to_octal(", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    number = 1\n    for i in binum:\n        dec += int(i)*number\n        number *= 2\n    return dec\n\ndef decimal_to_binary(number):\n    \"\"\"\n    将十进制数转换为二进制数\n    >>> decimal_to_binary(9)\n    100\n    >>> decimal_to_binary(10)\n    1010\n    \"\"\"\n    if number <= 1:\n        return list(str(number))\n    div, mod = divmod(number, 2)\n    return decimal_to_binary(div) + [mod]\n\ndef decimal_to_octal(number):\n    \"\"\"\n    将十进制数转换为八进制数\n    >>> decimal_to_octal(9)\n    11\n    >>> decimal_to_octal(10)\n    12\n    \"\"\"\n    if number <= 7:\n        return [str(number)]\n    div, mod = divmod(number, 8)\n    return decimal_to_octal("}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    for i in range(len(binum)):\n        dec = dec +(2**(len(binum)-1-i))*int(binum[i])\n    print(dec)\n\n\ndef decimal_to_binary(deci): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = ''\n    for i in range(len(bin(deci))-2):\n        if int(bin(deci)[2:][i]) == 1:\n            binum += '1'\n        else:\n            binum += '0'\n    print(binum)\n\n\ndef binary_to_octal(binum): \n    '''\n    将给定的二进制数转化为八进制数。\n    >>> binary_to_octal(1001)\n    11\n    >>> binary_to_oct", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    for i in range(len(binum)):\n        dec = dec +(2**(len(binum)-1-i))*int(binum[i])\n    print(dec)\n\n\ndef decimal_to_binary(deci): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = ''\n    for i in range(len(bin(deci))-2):\n        if int(bin(deci)[2:][i]) == 1:\n            binum += '1'\n        else:\n            binum += '0'\n    print(binum)\n\n\ndef binary_to_octal(binum): \n    '''\n    将给定的二进制数转化为八进制数。\n    >>> binary_to_octal(1001)\n    11\n    >>> binary_to_oct"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    j = 0\n    while binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    j = 0\n    while binu"}
{"task_id": "MBPP/24", "completion": "\n   ...\n\ndef decimal_to_binary(decnum):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n   ...\n\ndef base_convert(num, from_base, to_base):\n    '''\n    将给定的数字从指定的基础进制转换到另一个指定的基础进制。\n    >>> base_convert(23, 10, 2)\n    10111\n    >>> base_convert(10111, 2, 10)\n    23\n    '''\n    binary_result = []\n    while num:\n        binary_result.append(num % to_base)\n        num //= to_base\n\n    return int(''.join(map(str, binary_result[::-1])))\n\ndef base_to_decimal(num, base):\n   ", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n   ...\n\ndef decimal_to_binary(decnum):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n   ...\n\ndef base_convert(num, from_base, to_base):\n    '''\n    将给定的数字从指定的基础进制转换到另一个指定的基础进制。\n    >>> base_convert(23, 10, 2)\n    10111\n    >>> base_convert(10111, 2, 10)\n    23\n    '''\n    binary_result = []\n    while num:\n        binary_result.append(num % to_base)\n        num //= to_base\n\n    return int(''.join(map(str, binary_result[::-1])))\n\ndef base_to_decimal(num, base):\n   "}
{"task_id": "MBPP/24", "completion": "\n    # 初始化结果变量，并将二进制数转化为list\n    result = 0\n    value = get_two_list(binum)\n    \n    # 求解\n    for i, val in enumerate(value):\n        if val == '1':\n            result += 2**(len(value)-i-1)\n    \n    return result\n\n\ndef get_two_list(binum):\n    '''\n    将二进制数转化为list，其中值为0或1。\n    \n    给定的二进制数必须是二进制数的字符串表示。\n    '''\n    num_list = []\n    # 对于一个二进制数，可以直到取余数，这样的好处是简单。\n    while binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    # 初始化结果变量，并将二进制数转化为list\n    result = 0\n    value = get_two_list(binum)\n    \n    # 求解\n    for i, val in enumerate(value):\n        if val == '1':\n            result += 2**(len(value)-i-1)\n    \n    return result\n\n\ndef get_two_list(binum):\n    '''\n    将二进制数转化为list，其中值为0或1。\n    \n    给定的二进制数必须是二进制数的字符串表示。\n    '''\n    num_list = []\n    # 对于一个二进制数，可以直到取余数，这样的好处是简单。\n    while binu"}
{"task_id": "MBPP/24", "completion": "\n    total = 0\n    for i in range(len(binum)):\n        total +=binum[i]*((len(binum)-i-1)*2) \n    return total\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = ''\n    while num:\n        binum=str(num%2)+binum\n        num = num//2\n    return binum\n\ndef change_sign(num): \n    '''\n    将给定的数的正负号反转。\n    >>> change_sign(9)\n    -9\n    >>> change_sign(-9)\n    9\n    '''\n    if num<0:\n        return -num\n    else:\n        return num\n\ndef change_to_num(num): \n    '''\n    从给定的数字字符串中提", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    total = 0\n    for i in range(len(binum)):\n        total +=binum[i]*((len(binum)-i-1)*2) \n    return total\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = ''\n    while num:\n        binum=str(num%2)+binum\n        num = num//2\n    return binum\n\ndef change_sign(num): \n    '''\n    将给定的数的正负号反转。\n    >>> change_sign(9)\n    -9\n    >>> change_sign(-9)\n    9\n    '''\n    if num<0:\n        return -num\n    else:\n        return num\n\ndef change_to_num(num): \n    '''\n    从给定的数字字符串中提"}
{"task_id": "MBPP/24", "completion": "\n    num = binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    num = binu"}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    for i,b in enumerate(binum):\n        dec = dec + int(b)*2**(len(binum)-i-1)\n    return dec\n\ndef count_ones(binum): \n    '''\n    统计一个二进制数的1的个数。\n    >>> count_ones(1101)\n    3\n    '''\n    ones = 0\n    for b in binu:\n        if b == '1':\n            ones += 1\n    return ones\n\n\ndef power(x,n):\n    '''\n    求x的n次方。\n    >>> power(2,3)\n    8\n    '''\n    p = 1\n    while n>0:\n        n -= 1\n        p *= x\n    return p\n\ndef is_prime(num):\n    '''\n    判断正整数是否为素数。\n    >>> is_prime(13)\n    True\n    '''\n    if num == 1:\n        return False\n    for i in range(2,int(", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    for i,b in enumerate(binum):\n        dec = dec + int(b)*2**(len(binum)-i-1)\n    return dec\n\ndef count_ones(binum): \n    '''\n    统计一个二进制数的1的个数。\n    >>> count_ones(1101)\n    3\n    '''\n    ones = 0\n    for b in binu:\n        if b == '1':\n            ones += 1\n    return ones\n\n\ndef power(x,n):\n    '''\n    求x的n次方。\n    >>> power(2,3)\n    8\n    '''\n    p = 1\n    while n>0:\n        n -= 1\n        p *= x\n    return p\n\ndef is_prime(num):\n    '''\n    判断正整数是否为素数。\n    >>> is_prime(13)\n    True\n    '''\n    if num == 1:\n        return False\n    for i in range(2,int("}
{"task_id": "MBPP/27", "completion": "\n    ls = []\n    for i in strlist: # 可以理解成for i in 'abc123', 那么i就是string\n        ls.append(re.sub('\\d', '', i))\n    return ls\n\n\n# 2 填充括号\ndef add(strlist):\n    '''\n    给定一个字符串列表strlist\n    >>> add(['abc','def','ghi'])\n    ['a(bc)d(ef)g(hi)']\n    >>> add(['abcdefgh','ijklmnop'])\n    ['a(bcdefgh)i(jklmnop)']\n    '''\n    if len(strlist) == 0:\n        return strlist\n    if len(strlist) == 1:\n        return [strlist[0]]\n    s = strlist[0] + strlist[1]\n    return [s] + add(strlist[2:])\n\n# 3 检测闰年\ndef leapyear(year):\n    '''\n    给定一个", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    ls = []\n    for i in strlist: # 可以理解成for i in 'abc123', 那么i就是string\n        ls.append(re.sub('\\d', '', i))\n    return ls\n\n\n# 2 填充括号\ndef add(strlist):\n    '''\n    给定一个字符串列表strlist\n    >>> add(['abc','def','ghi'])\n    ['a(bc)d(ef)g(hi)']\n    >>> add(['abcdefgh','ijklmnop'])\n    ['a(bcdefgh)i(jklmnop)']\n    '''\n    if len(strlist) == 0:\n        return strlist\n    if len(strlist) == 1:\n        return [strlist[0]]\n    s = strlist[0] + strlist[1]\n    return [s] + add(strlist[2:])\n\n# 3 检测闰年\ndef leapyear(year):\n    '''\n    给定一个"}
{"task_id": "MBPP/27", "completion": "\n    strlist1=[]\n    for i in range(len(strlist)):\n        strlist1.append(re.sub(r'\\d+', '', strlist[i]))\n    return strlist1\n\n\n##############################################################################\n# 剪绳子\ndef cut_rope(n):\n    '''\n    给定一个1 <= n <= 58的正整数，请按如下算法求出结果\n    1. 把n拆分成尽可能多的连续正整数，并求和\n    2. 如果拆分后的连续正整数个数超过3个，就把它们之间的和作为连续正整数的一个部分，求和\n\n    >>> cut_rope(2)\n    1\n    >>> cut_rope(3)\n    2\n    >>> cut_rope(4)\n    3\n    >>> cut_rope(5)\n    ", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    strlist1=[]\n    for i in range(len(strlist)):\n        strlist1.append(re.sub(r'\\d+', '', strlist[i]))\n    return strlist1\n\n\n##############################################################################\n# 剪绳子\ndef cut_rope(n):\n    '''\n    给定一个1 <= n <= 58的正整数，请按如下算法求出结果\n    1. 把n拆分成尽可能多的连续正整数，并求和\n    2. 如果拆分后的连续正整数个数超过3个，就把它们之间的和作为连续正整数的一个部分，求和\n\n    >>> cut_rope(2)\n    1\n    >>> cut_rope(3)\n    2\n    >>> cut_rope(4)\n    3\n    >>> cut_rope(5)\n    "}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d+', '', s) for s in strlist]\n\ndef string_split(strlist, limit):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串拆分成几个长度小于limit的列表，如果一个字符串长度小于limit，那么该字符串为一个元素的列表。\n    >>> string_split(['abc123', 'def456', 'ghi789'], 1)\n    [['a', 'b', 'c', '1', '2', '3'], ['d', 'e', 'f', '4', '5', '6'], ['g', 'h', 'i', '7', '8', '9']]\n    >>> string_split(['abc123xyz', 'define456', '789ghi'], 2)\n    [['abc', '123', 'xyz'], ['de', 'fine', '456'], ['78', '", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'\\d+', '', s) for s in strlist]\n\ndef string_split(strlist, limit):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串拆分成几个长度小于limit的列表，如果一个字符串长度小于limit，那么该字符串为一个元素的列表。\n    >>> string_split(['abc123', 'def456', 'ghi789'], 1)\n    [['a', 'b', 'c', '1', '2', '3'], ['d', 'e', 'f', '4', '5', '6'], ['g', 'h', 'i', '7', '8', '9']]\n    >>> string_split(['abc123xyz', 'define456', '789ghi'], 2)\n    [['abc', '123', 'xyz'], ['de', 'fine', '456'], ['78', '"}
{"task_id": "MBPP/27", "completion": "\n    newlist = []\n    for item in strlist:\n        s = re.sub('\\d', '', item)\n        newlist.append(s)\n    return newlist\n```\n\n### 2.5 找出重复的字母\n\n```python\n# 问题描述：\n# 给定一组字符串，找出重复的字母，并将其转换为数字。\n# 比如：\n# 输入：['abcbac', 'acacac', 'acacacd', 'bacbac']\n# 输出：[{'a': 3}, {'d': 1}, {'c': 3}, {'b': 3}]\n# 说明：\n# 如果没有重复的字母，返回空列表\n# 如果有重复的字母，按出现的频率，从高到低排序\n# 如果有多组重复出现的字母，按第一个字母排序\n", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    newlist = []\n    for item in strlist:\n        s = re.sub('\\d', '', item)\n        newlist.append(s)\n    return newlist\n```\n\n### 2.5 找出重复的字母\n\n```python\n# 问题描述：\n# 给定一组字符串，找出重复的字母，并将其转换为数字。\n# 比如：\n# 输入：['abcbac', 'acacac', 'acacacd', 'bacbac']\n# 输出：[{'a': 3}, {'d': 1}, {'c': 3}, {'b': 3}]\n# 说明：\n# 如果没有重复的字母，返回空列表\n# 如果有重复的字母，按出现的频率，从高到低排序\n# 如果有多组重复出现的字母，按第一个字母排序\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d+', '', s) for s in strlist]         \n\n# 2019.06.04 17:33 ~18:00\n# 2019.06.06 14:57 ~15:07\n# 2019.06.06 15:39 ~16:18\n# 2019.06.24 09:54 ~10:06\n# 2019.06.24 12:16 ~12:20\n# 2019.06.24 15:51 ~15:58\n# 2019.06.24 16:23 ~17:42\n\n# 编写一个函数，接受一个字符串列表，返回一个列表。\n# 如果列表中一个元素的长度大于3，就把对应的下", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'\\d+', '', s) for s in strlist]         \n\n# 2019.06.04 17:33 ~18:00\n# 2019.06.06 14:57 ~15:07\n# 2019.06.06 15:39 ~16:18\n# 2019.06.24 09:54 ~10:06\n# 2019.06.24 12:16 ~12:20\n# 2019.06.24 15:51 ~15:58\n# 2019.06.24 16:23 ~17:42\n\n# 编写一个函数，接受一个字符串列表，返回一个列表。\n# 如果列表中一个元素的长度大于3，就把对应的下"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('[0-9]', '', i) for i in strlist]\n\n\n'''\n给定一个字符串str，请编写一个程序，使其满足：从左到右，遇到第一个非空（不是空格、换行符、制表符）字符就输出，且输出该字符左边所有的空格（包含换行符、制表符），直到遇到下一个非空字符；有至少一个空格，遇到下一个非空字符，输出该字符右边所有的空格（包含换行符、制表符），直到遇到下一个非空字符。\n\n下面是一些例子：\n\n    >>> remove_ws('abc   def')\n    'abc    def'\n    \n    >>> remove_ws('abc   def     ')\n    'abc    def     '\n    \n    >>> remove_ws('  abc   def    ", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub('[0-9]', '', i) for i in strlist]\n\n\n'''\n给定一个字符串str，请编写一个程序，使其满足：从左到右，遇到第一个非空（不是空格、换行符、制表符）字符就输出，且输出该字符左边所有的空格（包含换行符、制表符），直到遇到下一个非空字符；有至少一个空格，遇到下一个非空字符，输出该字符右边所有的空格（包含换行符、制表符），直到遇到下一个非空字符。\n\n下面是一些例子：\n\n    >>> remove_ws('abc   def')\n    'abc    def'\n    \n    >>> remove_ws('abc   def     ')\n    'abc    def     '\n    \n    >>> remove_ws('  abc   def    "}
{"task_id": "MBPP/27", "completion": "\n    result=[]\n    for i in strlist:\n        result.append(re.sub(r\"\\d\", '', i))\n    return result\n#-------------------------------------------------------------------------------\ndef remove_dup(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将列表中重复的字符串删除。\n    >>> remove_dup(['abc', 'abc', 'abc', 'def', 'def', 'ghi'])\n    ['abc', 'def', 'ghi']\n    '''\n    newlist=[]\n    for i in strlist:\n        if i not in newlist:\n            newlist.append(i)\n    return newlist\n#-------------------------------------------------------------------------------\n\ndef swap_case(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，把所有字母的大写转换成小写，\n    所有字母的小写转换成大写。\n    >>> swap_case(['abc', 'DEF'])\n    ['ABC', '", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    result=[]\n    for i in strlist:\n        result.append(re.sub(r\"\\d\", '', i))\n    return result\n#-------------------------------------------------------------------------------\ndef remove_dup(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将列表中重复的字符串删除。\n    >>> remove_dup(['abc', 'abc', 'abc', 'def', 'def', 'ghi'])\n    ['abc', 'def', 'ghi']\n    '''\n    newlist=[]\n    for i in strlist:\n        if i not in newlist:\n            newlist.append(i)\n    return newlist\n#-------------------------------------------------------------------------------\n\ndef swap_case(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，把所有字母的大写转换成小写，\n    所有字母的小写转换成大写。\n    >>> swap_case(['abc', 'DEF'])\n    ['ABC', '"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', s) for s in strlist]\n```\n\n输出结果：\n\n```\n['abc', 'def', 'ghi']\n['abcxyz', 'define', 'ghi']\n\nProcess finished with exit code 0\n```\n\n\n\n---\n\n#### 10.查找字符串\n\n- 问题：\n\n  - 编写一个函数，找出各个字符串中都出现过的字符出现的频率最高的字符，并返回该字符和出现的频率。如果频率相同，则返回其中一个。\n\n  - 示例：\n\n    ```python\n    >>> find_char(['abcabc', 'abcdabcde', 'abcefg'])\n    'a'\n    >>> find_char(['a', 'abcdabcde', 'abcd'])\n    'abcd'\n    >>> find_char(['a', 'abcdabcde', 'a'])\n", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub('\\d', '', s) for s in strlist]\n```\n\n输出结果：\n\n```\n['abc', 'def', 'ghi']\n['abcxyz', 'define', 'ghi']\n\nProcess finished with exit code 0\n```\n\n\n\n---\n\n#### 10.查找字符串\n\n- 问题：\n\n  - 编写一个函数，找出各个字符串中都出现过的字符出现的频率最高的字符，并返回该字符和出现的频率。如果频率相同，则返回其中一个。\n\n  - 示例：\n\n    ```python\n    >>> find_char(['abcabc', 'abcdabcde', 'abcefg'])\n    'a'\n    >>> find_char(['a', 'abcdabcde', 'abcd'])\n    'abcd'\n    >>> find_char(['a', 'abcdabcde', 'a'])\n"}
{"task_id": "MBPP/27", "completion": "\n    #正则表达式\n    #strlist = [\"abc123\", \"def456\", \"ghi789\"]\n    list_num = re.compile('^[0-9]+$')\n    for str in strlist:\n        strlist[str].replace(list_num, '')\n    return strlist\n\n\ndef print_list(strlist):\n    '''\n    让print_list()函数可以递归打印输入的列表，每项之间用空格分开，并在末尾打印出一个换行符。\n    >>> print_list(['abc', 'def', 'ghi'])\n    abc def ghi\n    >>> print_list(['a', 'b', 'c', 'd', 'e'])\n    a b c d e\n    '''\n    #for i in range(len(strlist)):\n\n    print(' '.join(strlist))\n    print()\n\n\nif __name__ == '__main__':\n    test0()\n    test1()\n    test2", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    #正则表达式\n    #strlist = [\"abc123\", \"def456\", \"ghi789\"]\n    list_num = re.compile('^[0-9]+$')\n    for str in strlist:\n        strlist[str].replace(list_num, '')\n    return strlist\n\n\ndef print_list(strlist):\n    '''\n    让print_list()函数可以递归打印输入的列表，每项之间用空格分开，并在末尾打印出一个换行符。\n    >>> print_list(['abc', 'def', 'ghi'])\n    abc def ghi\n    >>> print_list(['a', 'b', 'c', 'd', 'e'])\n    a b c d e\n    '''\n    #for i in range(len(strlist)):\n\n    print(' '.join(strlist))\n    print()\n\n\nif __name__ == '__main__':\n    test0()\n    test1()\n    test2"}
{"task_id": "MBPP/27", "completion": "\n    str_list = []\n    for item in strlist:\n        for i in re.findall('\\d+',item):\n            item = item.replace(i, '')\n        str_list.append(item)\n    return str_list\n\n# def main():\n#     str_list = ['abc123', 'def456', 'ghi789']\n#     print(remove(str_list))\n#     str_list = ['abc123xyz', 'define456', '789ghi']\n#     print(remove(str_list))\n\n# if __name__ == \"__main__\":\n#     main()    \n\n\ndef get_userip(client):\n\t'''\n\t用于获取用户的IP\n\t'''\n\tfor i in client.headers_dict:\n\t\tif i == \"X-Real-IP\":\n\t\t\treturn client.headers_dict.get(i)\n\t\telif i == \"X-Forwarded-For\":\n\t\t\treturn client.headers_dict.get(i).split(\",\")", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    str_list = []\n    for item in strlist:\n        for i in re.findall('\\d+',item):\n            item = item.replace(i, '')\n        str_list.append(item)\n    return str_list\n\n# def main():\n#     str_list = ['abc123', 'def456', 'ghi789']\n#     print(remove(str_list))\n#     str_list = ['abc123xyz', 'define456', '789ghi']\n#     print(remove(str_list))\n\n# if __name__ == \"__main__\":\n#     main()    \n\n\ndef get_userip(client):\n\t'''\n\t用于获取用户的IP\n\t'''\n\tfor i in client.headers_dict:\n\t\tif i == \"X-Real-IP\":\n\t\t\treturn client.headers_dict.get(i)\n\t\telif i == \"X-Forwarded-For\":\n\t\t\treturn client.headers_dict.get(i).split(\",\")"}
{"task_id": "MBPP/42", "completion": "\n    # code...\n    dic = dict()\n    sum = 0\n    for a in arr:\n        if a not in dic:\n            dic[a] = 1\n        else:\n            sum += a\n            dic[a] += 1\n    return sum\n\ndef find_product(arr, n): \n    '''\n    给定一个数组和数字n，返回数组中所有和为n的元素的乘积。\n    如果有多个和为n的元素，可以任选返回其中的一个。\n\n    如果没有元素，返回0。\n    如果有多余的0，要在前面返回。\n\n    >>> find_product([1, 2, 3, 4, 5], 6)\n    120\n    >>> find_product([1, 2, 3, 4, 5], 13)\n    0\n    >>> find_product([1, 2, 3, 4, 5], 0)\n    2", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    # code...\n    dic = dict()\n    sum = 0\n    for a in arr:\n        if a not in dic:\n            dic[a] = 1\n        else:\n            sum += a\n            dic[a] += 1\n    return sum\n\ndef find_product(arr, n): \n    '''\n    给定一个数组和数字n，返回数组中所有和为n的元素的乘积。\n    如果有多个和为n的元素，可以任选返回其中的一个。\n\n    如果没有元素，返回0。\n    如果有多余的0，要在前面返回。\n\n    >>> find_product([1, 2, 3, 4, 5], 6)\n    120\n    >>> find_product([1, 2, 3, 4, 5], 13)\n    0\n    >>> find_product([1, 2, 3, 4, 5], 0)\n    2"}
{"task_id": "MBPP/42", "completion": "\n\n    # 记录重复元素出现的次数\n    counter = Counter(arr)\n    total = 0\n    for i in counter:\n        if counter[i] >= 2:\n            total += arr.count(i) * i\n    return total\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n## 参考\n\n- [python-counter-example](https://www.programiz.com/python-programming/collections.Counter)\n- [collections.Counter 类](https://docs.python.org/zh-cn/3/library/collections.html#collections.Counter)\n\n## 公众号\n\n如果大家想要实时关注我更新的文章以及分享的干货的话，可以通过公众号扫码关注我（Python中文网）, 回复「Python」，拉您进 Python 社区。\n\n![](https", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n\n    # 记录重复元素出现的次数\n    counter = Counter(arr)\n    total = 0\n    for i in counter:\n        if counter[i] >= 2:\n            total += arr.count(i) * i\n    return total\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n## 参考\n\n- [python-counter-example](https://www.programiz.com/python-programming/collections.Counter)\n- [collections.Counter 类](https://docs.python.org/zh-cn/3/library/collections.html#collections.Counter)\n\n## 公众号\n\n如果大家想要实时关注我更新的文章以及分享的干货的话，可以通过公众号扫码关注我（Python中文网）, 回复「Python」，拉您进 Python 社区。\n\n![](https"}
{"task_id": "MBPP/42", "completion": "\n    res = 0\n    for i in arr:\n        while i>0:\n            res += i%10\n            i //= 10\n    return res\n\n\n# 打印一个字符串\ndef print_str(str):\n    for i in range(0, len(str)):\n        if i % 8 == 0 and i!= 0:\n            print(str[i], end=\"\\n\")\n        else:\n            print(str[i], end=\" \")\n\n# 找出列表中第一个只出现一次的数字\ndef find_First_Not_Repeat(arr):\n    '''\n    在一个数组里有很多数字，有的数字出现了两次，有的数字出现了三次，有的数字只出现了一次，\n    要求找出数组中只出现一次的数字。\n    \n    输入一个数组，返回数组中只出现一次的数字。\n    >>> arr = [1", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res = 0\n    for i in arr:\n        while i>0:\n            res += i%10\n            i //= 10\n    return res\n\n\n# 打印一个字符串\ndef print_str(str):\n    for i in range(0, len(str)):\n        if i % 8 == 0 and i!= 0:\n            print(str[i], end=\"\\n\")\n        else:\n            print(str[i], end=\" \")\n\n# 找出列表中第一个只出现一次的数字\ndef find_First_Not_Repeat(arr):\n    '''\n    在一个数组里有很多数字，有的数字出现了两次，有的数字出现了三次，有的数字只出现了一次，\n    要求找出数组中只出现一次的数字。\n    \n    输入一个数组，返回数组中只出现一次的数字。\n    >>> arr = [1"}
{"task_id": "MBPP/42", "completion": "\n    res = 0\n    d = {}\n    for num in arr:\n        d[num] = d.get(num,0) + 1\n    for key in d:\n        res += (d[key] - 1) * key\n    return res\n\n```\n\n#### 14、求一个数组中重复出现的最大的数字\n\n【题目】求一个数组中重复出现的最大的数字\n\n```python\ndef test(self):\n        nums = [7,2,3,1,4,6,8,5]\n        print(find_max(nums))\n\ndef find_max(arr):\n    '''\n        求一个数组中重复出现的最大的数字\n    题目：数组中有一个数字重复出现了三次，那么找出第一个这样重复出现的数字。\n    >>> find_max([7,2,3,1,4,6,8,5])\n    1\n    >>> find_max([", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res = 0\n    d = {}\n    for num in arr:\n        d[num] = d.get(num,0) + 1\n    for key in d:\n        res += (d[key] - 1) * key\n    return res\n\n```\n\n#### 14、求一个数组中重复出现的最大的数字\n\n【题目】求一个数组中重复出现的最大的数字\n\n```python\ndef test(self):\n        nums = [7,2,3,1,4,6,8,5]\n        print(find_max(nums))\n\ndef find_max(arr):\n    '''\n        求一个数组中重复出现的最大的数字\n    题目：数组中有一个数字重复出现了三次，那么找出第一个这样重复出现的数字。\n    >>> find_max([7,2,3,1,4,6,8,5])\n    1\n    >>> find_max(["}
{"task_id": "MBPP/42", "completion": "\n    result = []\n    for i in range(len(arr)):\n        if arr[i] in result:\n            arr[i] += arr[i]\n        else:\n            result.append(arr[i])\n    return sum(result)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n# 2.7 字符串匹配\ndef kmp(pattern, text):\n    '''\n        返回 text 中 pattern的第一次匹配的位置\n        如果匹配失败返回 -1\n        时间复杂度：O(m+n)\n        空间复杂度：O(m)\n    '''\n    mp = get_prefix_function(pattern)\n    j = 0\n    for i in range(len(text)):\n        while j>0 and pattern[j]!= text[i]:\n            j = mp[j-1]\n        if j > 0 and text[i] == pattern[j]:\n            j +=", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    result = []\n    for i in range(len(arr)):\n        if arr[i] in result:\n            arr[i] += arr[i]\n        else:\n            result.append(arr[i])\n    return sum(result)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n# 2.7 字符串匹配\ndef kmp(pattern, text):\n    '''\n        返回 text 中 pattern的第一次匹配的位置\n        如果匹配失败返回 -1\n        时间复杂度：O(m+n)\n        空间复杂度：O(m)\n    '''\n    mp = get_prefix_function(pattern)\n    j = 0\n    for i in range(len(text)):\n        while j>0 and pattern[j]!= text[i]:\n            j = mp[j-1]\n        if j > 0 and text[i] == pattern[j]:\n            j +="}
{"task_id": "MBPP/42", "completion": "\n    # your code here\n    res = 0\n    hash_dict = {}\n    for i in arr:\n        if i in hash_dict:\n            res += hash_dict[i]\n            hash_dict[i] += 1\n        else:\n            hash_dict[i] = 1\n    return res\n\n\n\ndef find_DuplicateNum(arr): \n    '''\n        找出重复的数字\n        如果一个数字在数组中出现2次或者更多次，请返回这个数字。\n    >>> find_DuplicateNum([4, 5, 7, 5, 4, 8])\n    4\n    >>> find_DuplicateNum([4, 5, 7, 8, 9, 1])\n    1\n    >>> find_DuplicateNum([1, 2, 3, 4, 5, 6])\n    None\n    >>> find_DuplicateNum([4, 5, 7, 5, 4, 8])\n    4\n   ", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    # your code here\n    res = 0\n    hash_dict = {}\n    for i in arr:\n        if i in hash_dict:\n            res += hash_dict[i]\n            hash_dict[i] += 1\n        else:\n            hash_dict[i] = 1\n    return res\n\n\n\ndef find_DuplicateNum(arr): \n    '''\n        找出重复的数字\n        如果一个数字在数组中出现2次或者更多次，请返回这个数字。\n    >>> find_DuplicateNum([4, 5, 7, 5, 4, 8])\n    4\n    >>> find_DuplicateNum([4, 5, 7, 8, 9, 1])\n    1\n    >>> find_DuplicateNum([1, 2, 3, 4, 5, 6])\n    None\n    >>> find_DuplicateNum([4, 5, 7, 5, 4, 8])\n    4\n   "}
{"task_id": "MBPP/42", "completion": "\n    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += i\n        else: \n            d[i] = i\n    ans = 0\n    for v in d.values():\n        ans += v\n    return ans\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([1,1,2],2),\n        ([4, 5, 7, 5, 4, 8],18),\n        ([1,-2,3,1],0)\n    ]\n    for t in test_cases:\n        print find_Sum(t[0]) == t[1]\n```\n\n### 最佳平均值\n\n> 给定一个整型数组，数组里有正数也有负数。\n> 要求找出这个数组的最佳平均值，最佳平均值是指连续多个数字，\n> 要么全部是正数", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += i\n        else: \n            d[i] = i\n    ans = 0\n    for v in d.values():\n        ans += v\n    return ans\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([1,1,2],2),\n        ([4, 5, 7, 5, 4, 8],18),\n        ([1,-2,3,1],0)\n    ]\n    for t in test_cases:\n        print find_Sum(t[0]) == t[1]\n```\n\n### 最佳平均值\n\n> 给定一个整型数组，数组里有正数也有负数。\n> 要求找出这个数组的最佳平均值，最佳平均值是指连续多个数字，\n> 要么全部是正数"}
{"task_id": "MBPP/42", "completion": "\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        if (arr[0] == arr[len(arr) - 1] and \n            arr[0]!= arr[1]):\n            return arr[0] + find_Sum(arr[1:len(arr) - 1])\n        else:\n            return find_Sum(arr[1:])\n\n\n\n    #     if len(arr) == 0:\n    #         return 0\n    #     sum = 0\n    #     if len(arr) == 1:\n    #         return arr[0]\n    #     else:\n    #         if (arr[0] == arr[len(arr) - 1] and \n    #             arr[0]!= arr[1]):\n    #             sum = arr[0] + find_Sum(arr[1:len(arr) - 1])\n    #         else:\n    #             sum = find_Sum(arr[1:])\n", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        if (arr[0] == arr[len(arr) - 1] and \n            arr[0]!= arr[1]):\n            return arr[0] + find_Sum(arr[1:len(arr) - 1])\n        else:\n            return find_Sum(arr[1:])\n\n\n\n    #     if len(arr) == 0:\n    #         return 0\n    #     sum = 0\n    #     if len(arr) == 1:\n    #         return arr[0]\n    #     else:\n    #         if (arr[0] == arr[len(arr) - 1] and \n    #             arr[0]!= arr[1]):\n    #             sum = arr[0] + find_Sum(arr[1:len(arr) - 1])\n    #         else:\n    #             sum = find_Sum(arr[1:])\n"}
{"task_id": "MBPP/42", "completion": "\n    # write code here\n    dic = {}\n    for i in arr:\n        if i in dic.keys():\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    for key, value in dic.items():\n        if value > 1:\n            dic[key] = key * value\n    s = 0\n    for i in dic:\n        s += dic[i]\n    return s\n\ndef find_Sum_1(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    ", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    # write code here\n    dic = {}\n    for i in arr:\n        if i in dic.keys():\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    for key, value in dic.items():\n        if value > 1:\n            dic[key] = key * value\n    s = 0\n    for i in dic:\n        s += dic[i]\n    return s\n\ndef find_Sum_1(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    "}
{"task_id": "MBPP/42", "completion": "\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                res += arr[i]\n\n    return res\n\n    # 一次遍历，用一个dict来记录每一个元素出现的次数。\n    # 再次遍历，对dict的元素进行求和，即可得到结果。\n    res = 0\n    counter = {}\n    for x in arr:\n        counter[x] = counter.get(x, 0) + 1\n    for i in counter.items():\n        res += i[1] * i[0]\n    return res\n\ndef find_Sum2(arr):\n    '''\n    求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                res += arr[i]\n\n    return res\n\n    # 一次遍历，用一个dict来记录每一个元素出现的次数。\n    # 再次遍历，对dict的元素进行求和，即可得到结果。\n    res = 0\n    counter = {}\n    for x in arr:\n        counter[x] = counter.get(x, 0) + 1\n    for i in counter.items():\n        res += i[1] * i[0]\n    return res\n\ndef find_Sum2(arr):\n    '''\n    求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum"}
{"task_id": "MBPP/149", "completion": "\n    if len(arr) < 3:\n        return len(arr)\n    max_len, l, r = 0, 0, 1\n    length = len(arr)\n    for i in range(length):\n        if i < 2:\n            l = 0\n            r = arr[i]\n        while r < length:\n            r += 1\n            l = max(1, l)\n            if r - l + 1 > max_len:\n                max_len = r - l + 1\n            if arr[r - 1] == arr[r]:\n                r += 1\n            else:\n                break\n        l, r = i, r", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr) < 3:\n        return len(arr)\n    max_len, l, r = 0, 0, 1\n    length = len(arr)\n    for i in range(length):\n        if i < 2:\n            l = 0\n            r = arr[i]\n        while r < length:\n            r += 1\n            l = max(1, l)\n            if r - l + 1 > max_len:\n                max_len = r - l + 1\n            if arr[r - 1] == arr[r]:\n                r += 1\n            else:\n                break\n        l, r = i, r"}
{"task_id": "MBPP/149", "completion": "\n\n    max_len = 0\n    for i in range(len(arr)):\n        for j in range(i + 2, len(arr) + 1):\n            a = arr[i:j]\n            if len(a) > max_len and a[0] + 1 == a[-1]:\n                max_len = len(a)\n    return max_len\n\n\n\n\n\n'''\n在一个二叉树中，每一个节点包含一个整数值。\n\n在树上从根节点到某一节点路径上所经过的节点值的和为一条路径的和。\n\n我们的目标是找到路径的和等于给定值的路径总数。 每一条路径都以根节点开始，然后通过从父节点到子节点的连接。 同样的，连接也满足从父节点到子节点的连接。\n\n\n给定一个二��", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n\n    max_len = 0\n    for i in range(len(arr)):\n        for j in range(i + 2, len(arr) + 1):\n            a = arr[i:j]\n            if len(a) > max_len and a[0] + 1 == a[-1]:\n                max_len = len(a)\n    return max_len\n\n\n\n\n\n'''\n在一个二叉树中，每一个节点包含一个整数值。\n\n在树上从根节点到某一节点路径上所经过的节点值的和为一条路径的和。\n\n我们的目标是找到路径的和等于给定值的路径总数。 每一条路径都以根节点开始，然后通过从父节点到子节点的连接。 同样的，连接也满足从父节点到子节点的连接。\n\n\n给定一个二��"}
{"task_id": "MBPP/149", "completion": "\n    dic = dict()\n    longest = 0\n    for i in range(len(arr) - 1):\n        if arr[i] in dic:\n            dic[arr[i]] += 1\n        else:\n            dic[arr", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    dic = dict()\n    longest = 0\n    for i in range(len(arr) - 1):\n        if arr[i] in dic:\n            dic[arr[i]] += 1\n        else:\n            dic[arr"}
{"task_id": "MBPP/149", "completion": "\n    dp = [1 for _ in arr]\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i]-arr[j] == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\narr = [1, 5, 2, 10, 3, 10, 20, 10, 10]\ndp = []\nfor i in range(len(arr)):\n    for j in range(i+1):\n", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    dp = [1 for _ in arr]\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i]-arr[j] == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\narr = [1, 5, 2, 10, 3, 10, 20, 10, 10]\ndp = []\nfor i in range(len(arr)):\n    for j in range(i+1):\n"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return None\n    dp=[]\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i]-arr[j]==1:\n                if len(dp)<len(dp)+len(arr[j+1:i+1]):\n                    dp", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return None\n    dp=[]\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i]-arr[j]==1:\n                if len(dp)<len(dp)+len(arr[j+1:i+1]):\n                    dp"}
{"task_id": "MBPP/149", "completion": "\n    if arr == []:\n        return 0\n    max_len = 1\n    diff = [0] * len(arr)\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == 1:\n            diff[i] = diff[i - 1] + 1\n            max_len = max(max_len, diff[i])\n        else:\n            diff[i] = 1\n    return max_len\n\nprint(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n\n\n# -------\n\n'''\n给定一个整数n，编写一个函数，求1+...+n的和，但是在计算过程中，每遇到一个数，就把它减掉。\n'''\n\n\nfrom typing import List\n\n\ndef sub_sum(n: int) -> int:\n    '''\n    >>> sub_sum(5)\n    8\n    '''\n    num = 0\n    for i in range(1", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if arr == []:\n        return 0\n    max_len = 1\n    diff = [0] * len(arr)\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == 1:\n            diff[i] = diff[i - 1] + 1\n            max_len = max(max_len, diff[i])\n        else:\n            diff[i] = 1\n    return max_len\n\nprint(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n\n\n# -------\n\n'''\n给定一个整数n，编写一个函数，求1+...+n的和，但是在计算过程中，每遇到一个数，就把它减掉。\n'''\n\n\nfrom typing import List\n\n\ndef sub_sum(n: int) -> int:\n    '''\n    >>> sub_sum(5)\n    8\n    '''\n    num = 0\n    for i in range(1"}
{"task_id": "MBPP/149", "completion": "\n    if len(arr) < 2:\n        return len(arr)\n    res = [0] * len(arr)\n    res[0] = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            res[i] = res[i-1]+1\n        else:\n            res[i] = 1\n    return max(res)\n\ndef max_len_sub_v2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub_v2([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr) < 2:\n        return len(arr)\n    res = [0] * (len(arr) + 1)\n    res[0] = 1\n    res[1] = 1\n    for i in range(2, len", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr) < 2:\n        return len(arr)\n    res = [0] * len(arr)\n    res[0] = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            res[i] = res[i-1]+1\n        else:\n            res[i] = 1\n    return max(res)\n\ndef max_len_sub_v2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub_v2([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr) < 2:\n        return len(arr)\n    res = [0] * (len(arr) + 1)\n    res[0] = 1\n    res[1] = 1\n    for i in range(2, len"}
{"task_id": "MBPP/149", "completion": "\n    n = len(arr)\n    dp = [max_len(arr[i:]) for i in range(n)]\n    return max(dp)\n\ndef max_len(arr:List[int]):\n    '''\n    以arr中的第一个数字开始，依次往后查找，找到与之差值为1的数字，并将这一段连续的数字的长度加1，如果找不到则为0\n    >>> max_len([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(n):\n        for j in range(i):\n            if arr[i] - arr[j] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef max_len2(arr:List[int]):\n    '''\n    以", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    n = len(arr)\n    dp = [max_len(arr[i:]) for i in range(n)]\n    return max(dp)\n\ndef max_len(arr:List[int]):\n    '''\n    以arr中的第一个数字开始，依次往后查找，找到与之差值为1的数字，并将这一段连续的数字的长度加1，如果找不到则为0\n    >>> max_len([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(n):\n        for j in range(i):\n            if arr[i] - arr[j] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef max_len2(arr:List[int]):\n    '''\n    以"}
{"task_id": "MBPP/149", "completion": "\n    length = len(arr)\n    if length == 0:\n        return 0\n    dp = [arr[0]]\n    max_len = 1\n    for i in range(1, length):\n        if arr[i] - dp[-1]!= 1:\n            dp.append(arr[i])\n            max_len += 1\n        else:\n            dp[-1] = arr[i]\n    return max_len\ndef longest_common_subsequence(S1:str, S2:str):\n    '''\n    给定两个字符串s1,s2，编写一个函数，求两个字符串的最长公共子序列的长度。\n    如果一个字符在s1和s2中出现了多次，那么每一次的出现都为1。\n    >>> longest_common_subsequence('abcbd', 'bcbda')\n    4\n    >>> longest_common_subsequence('abcbd', 'bcbbe')\n    3\n    >>> longest_common_subsequence('abcbd', 'bcbe')\n    3\n    '''\n    pass\n", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    length = len(arr)\n    if length == 0:\n        return 0\n    dp = [arr[0]]\n    max_len = 1\n    for i in range(1, length):\n        if arr[i] - dp[-1]!= 1:\n            dp.append(arr[i])\n            max_len += 1\n        else:\n            dp[-1] = arr[i]\n    return max_len\ndef longest_common_subsequence(S1:str, S2:str):\n    '''\n    给定两个字符串s1,s2，编写一个函数，求两个字符串的最长公共子序列的长度。\n    如果一个字符在s1和s2中出现了多次，那么每一次的出现都为1。\n    >>> longest_common_subsequence('abcbd', 'bcbda')\n    4\n    >>> longest_common_subsequence('abcbd', 'bcbbe')\n    3\n    >>> longest_common_subsequence('abcbd', 'bcbe')\n    3\n    '''\n    pass\n"}
{"task_id": "MBPP/149", "completion": "\n    ans = 1\n    for i in range(1, len(arr)):\n        if arr[i]!= arr[i-1]:\n            ans += 1\n    return ans\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n```\n\n### 问题解答\n![](https://pic.leetcode-cn.com/1620049800-YzVvQB-image.png)\n\n## 最长递增子序列长度\n\n### 问题描述\n给定一个整数数组nums ，找到其中最长且 连续递增的子序列的长度。\n\n**示例：**\n```\n输入：nums = [1,3,5,4,7]\n输出：3\n解释：最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    ans = 1\n    for i in range(1, len(arr)):\n        if arr[i]!= arr[i-1]:\n            ans += 1\n    return ans\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n```\n\n### 问题解答\n![](https://pic.leetcode-cn.com/1620049800-YzVvQB-image.png)\n\n## 最长递增子序列长度\n\n### 问题描述\n给定一个整数数组nums ，找到其中最长且 连续递增的子序列的长度。\n\n**示例：**\n```\n输入：nums = [1,3,5,4,7]\n输出：3\n解释：最长连续递增序列是 [1,3,5], 长度为3。\n尽管 ["}
{"task_id": "MBPP/v522", "completion": "\n    if not arr:\n        return 0\n    lens = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j] and lens[i] < lens[j] + 1:\n                lens[i] = lens[j] + 1\n    return max(lens)\n    \n\nprint(lbs([1, 2, 3, 4, 5, 3, 2]))\nprint(lbs([5,1,2,3,4,5,4,3,2]))\n```\n\n\n\n### 15、[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/submissions/)\n\n\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        nums1[m:] = nums2[:n]\n        nums1.sort()\n```\n\n\n\n### 16、[整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/submissions/)\n\n\n\n> 罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。\n>\n> 字符          数值\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写�", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    if not arr:\n        return 0\n    lens = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j] and lens[i] < lens[j] + 1:\n                lens[i] = lens[j] + 1\n    return max(lens)\n    \n\nprint(lbs([1, 2, 3, 4, 5, 3, 2]))\nprint(lbs([5,1,2,3,4,5,4,3,2]))\n```\n\n\n\n### 15、[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/submissions/)\n\n\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        nums1[m:] = nums2[:n]\n        nums1.sort()\n```\n\n\n\n### 16、[整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/submissions/)\n\n\n\n> 罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。\n>\n> 字符          数值\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写�"}
{"task_id": "MBPP/v522", "completion": "\n    arr1=copy.deepcopy(arr)\n    arr2=copy.deepcopy(arr)\n    arr1.pop(0)\n    arr2.pop()\n    n1,n2=0,0\n    for i in range(len(arr1)):\n        n1 += (arr1[i] > arr1[i-1])\n        n2 += (arr2[i] > arr2[i+1])\n    return n1+n2\n\ndef lbs2(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。但双调序列中不能有相邻的递增子序列。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    3\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    3\n    >>> lbs2([1, 4, 5, 2, 3])\n    2\n    >>> lbs2([4, 1, 5, 2, 3])\n    5\n    '''\n    arr1=copy.deepcopy(arr)\n    arr2=copy.deepcopy(arr)\n    arr1.pop(0)\n    arr2.pop()\n    n1,n2=0,0\n    for i in range(len(arr1)):\n        n1 += (arr1[i] > arr1[i-1])\n        n2 += (arr2[i] > arr2[i+1])\n    return max(n1+n2,max(n1,n2))\n\ndef lbs3(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    arr1=copy.deepcopy(arr)\n    arr2=copy.deepcopy(arr)\n    arr1.pop(0)\n    arr2.pop()\n    n1,n2=0,0\n    for i in range(len(arr1)):\n        n1 += (arr1[i] > arr1[i-1])\n        n2 += (arr2[i] > arr2[i+1])\n    return n1+n2\n\ndef lbs2(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。但双调序列中不能有相邻的递增子序列。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    3\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    3\n    >>> lbs2([1, 4, 5, 2, 3])\n    2\n    >>> lbs2([4, 1, 5, 2, 3])\n    5\n    '''\n    arr1=copy.deepcopy(arr)\n    arr2=copy.deepcopy(arr)\n    arr1.pop(0)\n    arr2.pop()\n    n1,n2=0,0\n    for i in range(len(arr1)):\n        n1 += (arr1[i] > arr1[i-1])\n        n2 += (arr2[i] > arr2[i+1])\n    return max(n1+n2,max(n1,n2))\n\ndef lbs3(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列"}
{"task_id": "MBPP/v522", "completion": "\n   def lbs_core(arr, size, k):\n       # size is the length of arr\n       # k is the max length of lbs\n       if size <= 1 or k <= 2:\n           return size\n       # dp表示前缀最大的lbs长度，dp[i]表示下标i之前的最长lbs的长度，\n       dp = [0] * size\n       pre, cur = 1, 1\n       for i in range(1, size):\n           if arr[i] >= arr[i-1]:\n               cur += 1\n           else:\n               pre, cur = cur, 1\n           dp[i] = max(dp[i-1], pre)\n       # 由于dp[i]表示的是下标i之前的最长lbs的长度，所以需要逆序+1\n       # 返回的是下标i的最长lbs长度，所以需要+1\n       return max(max(dp) + 1, k - 1)\n   return lbs_core(arr, len(arr), len(arr))\n\ndef lis(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长递增子序列的长度。\n    >>> lis([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lis([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   def lis_core(arr, size, k):\n       # size is the length of arr\n       # k is the max length of lis\n       if size <= 1 or k <= 2:\n           return size\n       # dp表示前缀最大的lis长度，dp[i]表示下标i之前的最长lis的长度，\n       dp = [0] * size\n       dp[0] =", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   def lbs_core(arr, size, k):\n       # size is the length of arr\n       # k is the max length of lbs\n       if size <= 1 or k <= 2:\n           return size\n       # dp表示前缀最大的lbs长度，dp[i]表示下标i之前的最长lbs的长度，\n       dp = [0] * size\n       pre, cur = 1, 1\n       for i in range(1, size):\n           if arr[i] >= arr[i-1]:\n               cur += 1\n           else:\n               pre, cur = cur, 1\n           dp[i] = max(dp[i-1], pre)\n       # 由于dp[i]表示的是下标i之前的最长lbs的长度，所以需要逆序+1\n       # 返回的是下标i的最长lbs长度，所以需要+1\n       return max(max(dp) + 1, k - 1)\n   return lbs_core(arr, len(arr), len(arr))\n\ndef lis(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长递增子序列的长度。\n    >>> lis([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lis([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   def lis_core(arr, size, k):\n       # size is the length of arr\n       # k is the max length of lis\n       if size <= 1 or k <= 2:\n           return size\n       # dp表示前缀最大的lis长度，dp[i]表示下标i之前的最长lis的长度，\n       dp = [0] * size\n       dp[0] ="}
{"task_id": "MBPP/v522", "completion": "\n   len = 1\n   arr_length = len(arr)\n   for i in range(1,arr_length):\n       if arr[i] > arr[i-1]:\n           len += 1\n       elif arr[i] == arr[i-1]:\n           len = 1\n       else:\n           len = 1\n       lbs.max_len = max(lbs.max_len, len)\n   return lbs.max_len\nlbs.max_len = 0\n\ndef lbs2(arr):  \n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    max_len = 1\n    length = len(arr)\n    for i in range(1,length):\n        if arr[i] > arr[i-1]:\n            max_len += 1\n        elif arr[i] < arr[i-1]:\n            max_len = 1\n        else:\n            max_len = 1\n        lbs.max_len = max(lbs.max_len, max_len)\n    return lbs.max_len\nlbs.max_len = 0\n\nif __name__ == '__main__':\n    print 'lbs:', lbs([1, 2, 3, 4, 5, 3, 2])\n    print 'lbs:', lbs([5,1,2,3,4,5,4,3,2])\n    print 'lbs2:', lbs2([1, 2, 3,", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   len = 1\n   arr_length = len(arr)\n   for i in range(1,arr_length):\n       if arr[i] > arr[i-1]:\n           len += 1\n       elif arr[i] == arr[i-1]:\n           len = 1\n       else:\n           len = 1\n       lbs.max_len = max(lbs.max_len, len)\n   return lbs.max_len\nlbs.max_len = 0\n\ndef lbs2(arr):  \n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    max_len = 1\n    length = len(arr)\n    for i in range(1,length):\n        if arr[i] > arr[i-1]:\n            max_len += 1\n        elif arr[i] < arr[i-1]:\n            max_len = 1\n        else:\n            max_len = 1\n        lbs.max_len = max(lbs.max_len, max_len)\n    return lbs.max_len\nlbs.max_len = 0\n\nif __name__ == '__main__':\n    print 'lbs:', lbs([1, 2, 3, 4, 5, 3, 2])\n    print 'lbs:', lbs([5,1,2,3,4,5,4,3,2])\n    print 'lbs2:', lbs2([1, 2, 3,"}
{"task_id": "MBPP/v522", "completion": "\n   cdef int n = len(arr)\n   arr.sort()\n   cdef int * lis = [0] * n  # 二维数组，每个元素是一个一维数组，即为一个列表\n   cdef int * dp = [0] * n\n   dp[0] = 1  # 最后一定是1\n   for i in range(1, n):\n     for j in range(i):\n       if arr[i] > arr[j]:\n         num = 1 + dp[j]\n       else:\n         num = 1\n       lis[i] = max(lis[i], num)\n     dp[i] = lis[i]\n   return dp[-1]\n\ndef lbs2(arr):\n   nums = [None] * len(arr)\n   nums[0] = arr[0]\n   for i in range(1, len(arr)):\n     nums[i] = max(nums[i - 1], arr[i])\n   return nums\n\ndef min_coins(target_money):\n   nums = [1, 2, 5, 10, 20, 50, 100, 200]\n   amount = target_money\n   coins = 0\n   for coin in nums:\n     while amount >= coin:\n       coins += 1\n       amount -= coin\n   return coins\n\ndef max_sum(arr):\n   nums = [None] * len(arr)\n   nums[0] = arr[0]\n   for i in range(1, len(arr)):\n     nums[i] = max(nums[i - 1], arr[i])\n   return nums\n\ndef max_sum2(arr):\n   cdef int n = len(arr)\n   cdef int * num = [None] * n\n   num[0] = arr[0]\n   for i in range(1, n", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   cdef int n = len(arr)\n   arr.sort()\n   cdef int * lis = [0] * n  # 二维数组，每个元素是一个一维数组，即为一个列表\n   cdef int * dp = [0] * n\n   dp[0] = 1  # 最后一定是1\n   for i in range(1, n):\n     for j in range(i):\n       if arr[i] > arr[j]:\n         num = 1 + dp[j]\n       else:\n         num = 1\n       lis[i] = max(lis[i], num)\n     dp[i] = lis[i]\n   return dp[-1]\n\ndef lbs2(arr):\n   nums = [None] * len(arr)\n   nums[0] = arr[0]\n   for i in range(1, len(arr)):\n     nums[i] = max(nums[i - 1], arr[i])\n   return nums\n\ndef min_coins(target_money):\n   nums = [1, 2, 5, 10, 20, 50, 100, 200]\n   amount = target_money\n   coins = 0\n   for coin in nums:\n     while amount >= coin:\n       coins += 1\n       amount -= coin\n   return coins\n\ndef max_sum(arr):\n   nums = [None] * len(arr)\n   nums[0] = arr[0]\n   for i in range(1, len(arr)):\n     nums[i] = max(nums[i - 1], arr[i])\n   return nums\n\ndef max_sum2(arr):\n   cdef int n = len(arr)\n   cdef int * num = [None] * n\n   num[0] = arr[0]\n   for i in range(1, n"}
{"task_id": "MBPP/v522", "completion": "\n   arr_len = len(arr)\n   if arr_len == 0: return 0\n   if arr_len == 1: return 1\n \n   # 动态规划\n   dp = [0] * arr_len\n   for i in range(1, arr_len):\n       if arr[i] > arr[i-1]:\n           dp[i] = dp[i-1]+1\n       else:\n           dp[i] = 1\n       max_temp = 0\n       for j in range(i):\n           if dp[i] < dp[j]+1 and arr[i] < arr[j]:\n               dp[i] = dp[j]+1\n           max_temp = max(max_temp, dp[i])\n       if max_temp > dp[i]:\n           dp[i] = max_temp\n   return dp[-1]\n\n\ndef longest_non_decreasing(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中最长的非递减子数组。\n    >>> longest_non_decreasing([1, 2, 3, 4, 5, 3, 2])\n    5\n    >>> longest_non_decreasing([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    arr_len = len(arr)\n    if arr_len == 0:\n        return 0\n    if arr_len == 1:\n        return 1\n \n    # 动态规划\n    dp = [0] * arr_len\n    for i in range(arr_len):\n        if i == 0:\n            dp[i] = 1\n            continue\n        if arr[i] > arr[i - 1]:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] =", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   arr_len = len(arr)\n   if arr_len == 0: return 0\n   if arr_len == 1: return 1\n \n   # 动态规划\n   dp = [0] * arr_len\n   for i in range(1, arr_len):\n       if arr[i] > arr[i-1]:\n           dp[i] = dp[i-1]+1\n       else:\n           dp[i] = 1\n       max_temp = 0\n       for j in range(i):\n           if dp[i] < dp[j]+1 and arr[i] < arr[j]:\n               dp[i] = dp[j]+1\n           max_temp = max(max_temp, dp[i])\n       if max_temp > dp[i]:\n           dp[i] = max_temp\n   return dp[-1]\n\n\ndef longest_non_decreasing(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中最长的非递减子数组。\n    >>> longest_non_decreasing([1, 2, 3, 4, 5, 3, 2])\n    5\n    >>> longest_non_decreasing([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    arr_len = len(arr)\n    if arr_len == 0:\n        return 0\n    if arr_len == 1:\n        return 1\n \n    # 动态规划\n    dp = [0] * arr_len\n    for i in range(arr_len):\n        if i == 0:\n            dp[i] = 1\n            continue\n        if arr[i] > arr[i - 1]:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] ="}
{"task_id": "MBPP/v522", "completion": "\n    # 先找到最小值，然后求最小值后面的位置，如果最小值在最后一个位置上，则最大下降子序列为整个数组，否则就是最大下降子序列长度最大的那个数\n    l = len(arr)\n    if l==0:\n        return 0\n    if l==1:\n        return 1\n    min_value = min(arr) # 找出最小值\n    min_value_index = [v[0] for v in enumerate(arr) if v[1] == min_value] # 找出最小值的索引\n    if len(min_value_index)==0:\n        return l\n    if len(min_value_index)==1: # 说明最小值在最后一个位置上\n        return l\n    else:\n        for i in range(len(min_value_index)):\n            arr.pop(min_value_index[i][0]-i)\n    return lbs(arr)+len(min_value_index)\n\n\n\n \ndef lcs(str1, str2):\n    \"\"\"\n    ------------------------------------------\n    @:description \n        给定两个字符串str1和str2，编写一个函数，计算出两个字符串的最长公共子序列的长度。\n    ------------------------------------------\n    @:param\n        str1: 第一个字符串\n        str2: 第二个字符串\n    ------------------------------------------\n    @:return\n        最长公共子序列的长度\n    ------------------------------------------\n    \"\"\"\n    # str1 = 'ABCBDAB'\n    # str2 = 'BDCABA'\n    l1 = len(str1)\n    l2 = len(str2)\n    if l1==0 or l2==0:\n        return 0\n    if l1", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    # 先找到最小值，然后求最小值后面的位置，如果最小值在最后一个位置上，则最大下降子序列为整个数组，否则就是最大下降子序列长度最大的那个数\n    l = len(arr)\n    if l==0:\n        return 0\n    if l==1:\n        return 1\n    min_value = min(arr) # 找出最小值\n    min_value_index = [v[0] for v in enumerate(arr) if v[1] == min_value] # 找出最小值的索引\n    if len(min_value_index)==0:\n        return l\n    if len(min_value_index)==1: # 说明最小值在最后一个位置上\n        return l\n    else:\n        for i in range(len(min_value_index)):\n            arr.pop(min_value_index[i][0]-i)\n    return lbs(arr)+len(min_value_index)\n\n\n\n \ndef lcs(str1, str2):\n    \"\"\"\n    ------------------------------------------\n    @:description \n        给定两个字符串str1和str2，编写一个函数，计算出两个字符串的最长公共子序列的长度。\n    ------------------------------------------\n    @:param\n        str1: 第一个字符串\n        str2: 第二个字符串\n    ------------------------------------------\n    @:return\n        最长公共子序列的长度\n    ------------------------------------------\n    \"\"\"\n    # str1 = 'ABCBDAB'\n    # str2 = 'BDCABA'\n    l1 = len(str1)\n    l2 = len(str2)\n    if l1==0 or l2==0:\n        return 0\n    if l1"}
{"task_id": "MBPP/v522", "completion": "\n   if arr == []:\n       return 0\n\n   res = 1\n   dp = [1]*(len(arr))\n   for i in range(1,len(arr)):\n       dp[i] = 1 if arr[i] >= arr[i-1] else 0\n\n       for j in range(i):\n           if arr[j] < arr[i] and dp[i] <= dp[j]+1:\n               dp[i] = dp[j]+1\n       res = max(res, dp[i])\n   return dp[len(arr)-1]\n\n   # dp[i][j] 表示 arr[i:j+1] 中的最长双调子序列的长度，当 arr[i] >= arr[j] 时，dp[i][j] = dp[i][j-1]\n   # 如果 arr[i] < arr[j], 则找出 arr[i:j] 中的最长单调子序列，结果为 dp[i][j] = dp[i][j-1] + 1\n   # 否则 dp[i][j] = 1\n\n\n   # 注意要使用动态规划时，需要保存不同的状态，所以要有两层循环，第一层 i 表示当前位置，第二层 j 表示当前位置对应的状态\n\n   # def lbs(arr): \n   # '''\n   # 给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n   # >>> lbs([1, 2, 3, 4, 5, 3, 2])\n   # 7\n   # >>> lbs([5,1,2,3,4", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   if arr == []:\n       return 0\n\n   res = 1\n   dp = [1]*(len(arr))\n   for i in range(1,len(arr)):\n       dp[i] = 1 if arr[i] >= arr[i-1] else 0\n\n       for j in range(i):\n           if arr[j] < arr[i] and dp[i] <= dp[j]+1:\n               dp[i] = dp[j]+1\n       res = max(res, dp[i])\n   return dp[len(arr)-1]\n\n   # dp[i][j] 表示 arr[i:j+1] 中的最长双调子序列的长度，当 arr[i] >= arr[j] 时，dp[i][j] = dp[i][j-1]\n   # 如果 arr[i] < arr[j], 则找出 arr[i:j] 中的最长单调子序列，结果为 dp[i][j] = dp[i][j-1] + 1\n   # 否则 dp[i][j] = 1\n\n\n   # 注意要使用动态规划时，需要保存不同的状态，所以要有两层循环，第一层 i 表示当前位置，第二层 j 表示当前位置对应的状态\n\n   # def lbs(arr): \n   # '''\n   # 给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n   # >>> lbs([1, 2, 3, 4, 5, 3, 2])\n   # 7\n   # >>> lbs([5,1,2,3,4"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   l = [1] * n   # 长度为数组长度的一维数组，每个元素的值都为1\n   r = [1] * n   # 长度为数组长度的一维数组，每个元素的值都为1\n   mx = 1\n   for i in range(1, n):  # 循环遍历数组每个元素\n       if arr[i] > arr[i - 1]:  # 如果arr中的当前元素比arr中上一个元素大，则l[i]的值为上一个元素的l[i-1]+1\n           l[i] = l[i - 1] + 1\n       else:  # 否则l[i]从上一个元素派生\n           l[i] = 1\n   for i in range(n - 2, -1, -1):  # 逆序循环数组元素\n       if arr[i] > arr[i + 1]:  # 如果arr中的当前元素比arr中下一个元素大，则r[i]的值为下一个元素的r[i+1]+1\n           r[i] = r[i + 1] + 1\n       else:  # 否则r[i]从下一个元素派生\n           r[i] = 1\n   for i in range(1, n - 1):  # 循环遍历数组中每个元素\n       mx = max(mx, l[i] + r[i])  # 更新最长双调子序列的长度\n   return mx  # 返回最长双调子序列的长度\n```\n\n* [31. 搜索插入位置](https://leetcode-cn.", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   l = [1] * n   # 长度为数组长度的一维数组，每个元素的值都为1\n   r = [1] * n   # 长度为数组长度的一维数组，每个元素的值都为1\n   mx = 1\n   for i in range(1, n):  # 循环遍历数组每个元素\n       if arr[i] > arr[i - 1]:  # 如果arr中的当前元素比arr中上一个元素大，则l[i]的值为上一个元素的l[i-1]+1\n           l[i] = l[i - 1] + 1\n       else:  # 否则l[i]从上一个元素派生\n           l[i] = 1\n   for i in range(n - 2, -1, -1):  # 逆序循环数组元素\n       if arr[i] > arr[i + 1]:  # 如果arr中的当前元素比arr中下一个元素大，则r[i]的值为下一个元素的r[i+1]+1\n           r[i] = r[i + 1] + 1\n       else:  # 否则r[i]从下一个元素派生\n           r[i] = 1\n   for i in range(1, n - 1):  # 循环遍历数组中每个元素\n       mx = max(mx, l[i] + r[i])  # 更新最长双调子序列的长度\n   return mx  # 返回最长双调子序列的长度\n```\n\n* [31. 搜索插入位置](https://leetcode-cn."}
{"task_id": "MBPP/v522", "completion": "\n\n   n = len(arr)\n   if n == 0: \n     return 0\n   elif n == 1:\n     return 1\n\n   dp = [0] * n\n   dp[0] = 1\n   maxRes = 1\n   for i in range(1, n):\n       for j in range(i):\n           if arr[j] < arr[i]:\n               if (dp[j] + 1) > dp[i]:\n                   dp[i] = dp[j] + 1\n       if dp[i] > maxRes:\n           maxRes = dp[i]\n   return maxRes\n\n```\n\n\n#### 75. 不包含两个相同字符的最长子串\n\n\n```python\ndef lcs(string)：\n    '''\n    给定一个字符串str，请找出不包含两个连续的相同字符的最长子字符串的长度。\n    >>> lcs('bbbb')\n    1\n    >>> lcs('bababa')\n    3\n    '''\n    n = len(string)\n    dp = [0] * n\n    maxRes = 0\n    for i in range(n)：\n        maxRes = max(maxRes, dp[i])\n        dp[i] = 1\n        for j in range(i)：\n            if string[i] == string[j]：\n                dp[i] = 0\n                break\n            else：\n                dp[i] = max(dp[i], dp[j] + 1)\n    return maxRes\n```\n\n\n#### 76. 握手问题\n\n\n```python\ndef climbingStairs(totalSteps)：\n    '''\n    握手问题：有N个人正在上楼梯，共有总共n步，第一个人从0步（下楼", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n\n   n = len(arr)\n   if n == 0: \n     return 0\n   elif n == 1:\n     return 1\n\n   dp = [0] * n\n   dp[0] = 1\n   maxRes = 1\n   for i in range(1, n):\n       for j in range(i):\n           if arr[j] < arr[i]:\n               if (dp[j] + 1) > dp[i]:\n                   dp[i] = dp[j] + 1\n       if dp[i] > maxRes:\n           maxRes = dp[i]\n   return maxRes\n\n```\n\n\n#### 75. 不包含两个相同字符的最长子串\n\n\n```python\ndef lcs(string)：\n    '''\n    给定一个字符串str，请找出不包含两个连续的相同字符的最长子字符串的长度。\n    >>> lcs('bbbb')\n    1\n    >>> lcs('bababa')\n    3\n    '''\n    n = len(string)\n    dp = [0] * n\n    maxRes = 0\n    for i in range(n)：\n        maxRes = max(maxRes, dp[i])\n        dp[i] = 1\n        for j in range(i)：\n            if string[i] == string[j]：\n                dp[i] = 0\n                break\n            else：\n                dp[i] = max(dp[i], dp[j] + 1)\n    return maxRes\n```\n\n\n#### 76. 握手问题\n\n\n```python\ndef climbingStairs(totalSteps)：\n    '''\n    握手问题：有N个人正在上楼梯，共有总共n步，第一个人从0步（下楼"}
{"task_id": "MBPP/v564", "completion": "\n    return len(set(arr)) * (len(arr) - len(set(arr)))\n\n\ndef count_Subarrays(a, k): \n    '''\n    给定一个数组a，假设a的长度为n，编写一个函数，求满足以下条件的子数组的个数：\n    子数组中元素和大于等于k\n    >>> count_Subarrays([1,2,3,4], 7)\n    4\n    >>> count_Subarrays([1,2,3,4], 6)\n    3\n    >>> count_Subarrays([1,2,3,4], 5)\n    2\n    >>> count_Subarrays([1,2,3,4], 4)\n    1\n    >>> count_Subarrays([1,2,3,4], 3)\n    0\n    >>> count_Subarrays([1,2,3,4], 2)\n    0\n    >>> count_Subarrays([1,2,3,4], 1", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    return len(set(arr)) * (len(arr) - len(set(arr)))\n\n\ndef count_Subarrays(a, k): \n    '''\n    给定一个数组a，假设a的长度为n，编写一个函数，求满足以下条件的子数组的个数：\n    子数组中元素和大于等于k\n    >>> count_Subarrays([1,2,3,4], 7)\n    4\n    >>> count_Subarrays([1,2,3,4], 6)\n    3\n    >>> count_Subarrays([1,2,3,4], 5)\n    2\n    >>> count_Subarrays([1,2,3,4], 4)\n    1\n    >>> count_Subarrays([1,2,3,4], 3)\n    0\n    >>> count_Subarrays([1,2,3,4], 2)\n    0\n    >>> count_Subarrays([1,2,3,4], 1"}
{"task_id": "MBPP/v564", "completion": "\n    ans = 0\n    n = len(arr)\n\n    # Initialize count array to store frequency of each element\n    count = [0] * n\n    for i in range(n):\n        count[arr[i]] += 1\n\n    for i in range(n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    ans = 0\n    n = len(arr)\n\n    # Initialize count array to store frequency of each element\n    count = [0] * n\n    for i in range(n):\n        count[arr[i]] += 1\n\n    for i in range(n"}
{"task_id": "MBPP/v564", "completion": "\n    # print(arr)\n    # 返回值\n    # 元素x出现次数\n    # return len\n    d = {}\n\n    for i in range(len(arr)):\n        if d.get(arr[i],None) == None:\n            d[arr[i]] = 1\n        else:\n            d[arr[i]] += 1\n\n    # 元素i出现的次数为count[i]\n    count = {}\n    for i in range(len(arr)):\n        if d.get(arr[i],None) == None:\n            count[arr[i]] = 1\n        else:\n            count[arr[i]] += 1\n\n    # 元素i,j不相等\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if d[arr[i]] == count[arr[j]]:\n                res += 1\n            # if count[arr[i]] > 1 and count[arr[j]] > ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    # print(arr)\n    # 返回值\n    # 元素x出现次数\n    # return len\n    d = {}\n\n    for i in range(len(arr)):\n        if d.get(arr[i],None) == None:\n            d[arr[i]] = 1\n        else:\n            d[arr[i]] += 1\n\n    # 元素i出现的次数为count[i]\n    count = {}\n    for i in range(len(arr)):\n        if d.get(arr[i],None) == None:\n            count[arr[i]] = 1\n        else:\n            count[arr[i]] += 1\n\n    # 元素i,j不相等\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if d[arr[i]] == count[arr[j]]:\n                res += 1\n            # if count[arr[i]] > 1 and count[arr[j]] > "}
{"task_id": "MBPP/v564", "completion": "\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n    \nif __name__ == \"__main__\":\n    print(count_Pairs([1, 2, 3, 4]))\n    print(count_Pairs([1, 1, 1]))\n    print(count_Pairs([1, 2, 3, 1]))\n    print(count_Pairs([1, 2, 3, 4, 3, 2, 3, 4, 5, 6, 1, 2, 3, 4, 3, 2, 3, 4, 5, 6, 1, 2, 3, 4, 3, 2, 3, 4, 5, 6]))\n\n\ndef count_Triples(nums):\n    '''\n    给定一个集合，编写一个函数，", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n    \nif __name__ == \"__main__\":\n    print(count_Pairs([1, 2, 3, 4]))\n    print(count_Pairs([1, 1, 1]))\n    print(count_Pairs([1, 2, 3, 1]))\n    print(count_Pairs([1, 2, 3, 4, 3, 2, 3, 4, 5, 6, 1, 2, 3, 4, 3, 2, 3, 4, 5, 6, 1, 2, 3, 4, 3, 2, 3, 4, 5, 6]))\n\n\ndef count_Triples(nums):\n    '''\n    给定一个集合，编写一个函数，"}
{"task_id": "MBPP/v564", "completion": "\n    if len(arr) <= 1:\n        return 0\n    n = len(arr)\n    count = 0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if (arr[i],arr[j])!= (arr[j],arr[i]):\n                count += 1\n    return count\n\ndef count_Pairs_Optimize(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if len(arr) <= 1:\n        return 0\n    n = len(arr)\n    count = 0\n   ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if len(arr) <= 1:\n        return 0\n    n = len(arr)\n    count = 0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if (arr[i],arr[j])!= (arr[j],arr[i]):\n                count += 1\n    return count\n\ndef count_Pairs_Optimize(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if len(arr) <= 1:\n        return 0\n    n = len(arr)\n    count = 0\n   "}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    if n == 0: \n        return 0\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i]!= arr[j]:\n                dp[i] += 1\n    return sum(dp)\n\n\ndef count_Subarrays(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr子数组的个数，子数组是指连续的arr[l...r]，\n    满足arr[l] < arr[r]。\n    >>> count_Subarrays([1, 2, 3, 4])\n    12\n    >>> count_Subarrays([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i, n):\n            if", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    if n == 0: \n        return 0\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i]!= arr[j]:\n                dp[i] += 1\n    return sum(dp)\n\n\ndef count_Subarrays(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr子数组的个数，子数组是指连续的arr[l...r]，\n    满足arr[l] < arr[r]。\n    >>> count_Subarrays([1, 2, 3, 4])\n    12\n    >>> count_Subarrays([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i, n):\n            if"}
{"task_id": "MBPP/v564", "completion": "\n    if not isinstance(arr, list) or len(arr) <= 1:\n        return 0\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                count += 1\n    \n    return count\n\ndef count_Pairs_HashSet(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not isinstance(arr, list) or len(arr) <= 1:\n        return 0\n\n    count = 0\n    visited = set()\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not isinstance(arr, list) or len(arr) <= 1:\n        return 0\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                count += 1\n    \n    return count\n\ndef count_Pairs_HashSet(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not isinstance(arr, list) or len(arr) <= 1:\n        return 0\n\n    count = 0\n    visited = set()\n"}
{"task_id": "MBPP/v564", "completion": "\n    counter = 0\n    length = len(arr)\n    for i in range(length - 1):\n        if i > length - 2:\n            continue\n        for j in range(i + 1, length):\n            if arr[i]!= arr[j]:\n                counter += 1\n            if counter >= 2000000000:\n                return 0\n    return counter\n\ndef count_Triplets(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素三元组的个数。\n    不相等的元素三元组指的是一组(arr[i],arr[j],arr[k])，其中i < j < k且arr[i]!= arr[j]!= arr[k]。\n    >>> count_Triplets([1, 2, 3, 4])\n    10\n    >>> count_Triplets([1, 1, 1])\n    0\n    '''\n    counter = 0\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    counter = 0\n    length = len(arr)\n    for i in range(length - 1):\n        if i > length - 2:\n            continue\n        for j in range(i + 1, length):\n            if arr[i]!= arr[j]:\n                counter += 1\n            if counter >= 2000000000:\n                return 0\n    return counter\n\ndef count_Triplets(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素三元组的个数。\n    不相等的元素三元组指的是一组(arr[i],arr[j],arr[k])，其中i < j < k且arr[i]!= arr[j]!= arr[k]。\n    >>> count_Triplets([1, 2, 3, 4])\n    10\n    >>> count_Triplets([1, 1, 1])\n    0\n    '''\n    counter = 0\n"}
{"task_id": "MBPP/v564", "completion": "\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n\n\ndef max_Number_With_No_Adjacent_Duplicates(arr):\n    '''\n    给定一个正整数数组arr，编写一个函数，返回最大不含相邻相同数字的正整数。\n    如果有多个数字都不含相邻相同数字，就返回最大的一个。\n    （注意，本题测试数据不会有这种情况）\n    >>> max_Number_With_No_Adjacent_Duplicates([1, 2, 3, 4])\n    4\n    '''\n    max_num = ''\n    for i in range(len(arr)):\n        cnt = 0\n        for j in range(i, len(arr)):\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n\n\ndef max_Number_With_No_Adjacent_Duplicates(arr):\n    '''\n    给定一个正整数数组arr，编写一个函数，返回最大不含相邻相同数字的正整数。\n    如果有多个数字都不含相邻相同数字，就返回最大的一个。\n    （注意，本题测试数据不会有这种情况）\n    >>> max_Number_With_No_Adjacent_Duplicates([1, 2, 3, 4])\n    4\n    '''\n    max_num = ''\n    for i in range(len(arr)):\n        cnt = 0\n        for j in range(i, len(arr)):\n"}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    # 对arr进行排序\n    arr = sorted(arr)\n    pairs = 0\n\n    # 在arr中找到i\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i]!= arr[j]:\n                pairs += 1\n    return pairs\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # 考虑一个简单的实现方法\n    def count_Pairs_simple(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i]!= arr[j]:\n                    pairs += 1\n        return pairs\n\n    print(count_Pairs_simple([1, 2, 3, 4]))\n    print", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    # 对arr进行排序\n    arr = sorted(arr)\n    pairs = 0\n\n    # 在arr中找到i\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i]!= arr[j]:\n                pairs += 1\n    return pairs\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # 考虑一个简单的实现方法\n    def count_Pairs_simple(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i]!= arr[j]:\n                    pairs += 1\n        return pairs\n\n    print(count_Pairs_simple([1, 2, 3, 4]))\n    print"}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort()\n    res = [1]\n    for i in range(1, len(arr)):\n        if arr[i] % arr[i-1] == 0:\n            res.append(res[i-1] + 1)\n        else:\n            res.append(1)\n    return max(res)\n\n\n## 2. 简历生成器\n\n### 2.1 姓名\n\n    def generate_cv(first_name='', last_name='', gender='male'):\n        '''\n        生成简历\n        '''\n        if gender =='male':\n            cv = f\"{first_name} {last_name}\\n\" \\\n                 f\"Gender: Male\\n\" \\\n                 f\"Age:   18\\n\" \\\n                 f\"Telephone: 0912345678\\n\" \\\n                 f\"Email:    a@b.com\\n\" \\\n                 f\"Education:\\n\" \\\n                 f\"Master's Degree in Computer Science from XXX University\\n\" \\\n                 f\"Skills:\\n\" \\\n                 f\"1.", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort()\n    res = [1]\n    for i in range(1, len(arr)):\n        if arr[i] % arr[i-1] == 0:\n            res.append(res[i-1] + 1)\n        else:\n            res.append(1)\n    return max(res)\n\n\n## 2. 简历生成器\n\n### 2.1 姓名\n\n    def generate_cv(first_name='', last_name='', gender='male'):\n        '''\n        生成简历\n        '''\n        if gender =='male':\n            cv = f\"{first_name} {last_name}\\n\" \\\n                 f\"Gender: Male\\n\" \\\n                 f\"Age:   18\\n\" \\\n                 f\"Telephone: 0912345678\\n\" \\\n                 f\"Email:    a@b.com\\n\" \\\n                 f\"Education:\\n\" \\\n                 f\"Master's Degree in Computer Science from XXX University\\n\" \\\n                 f\"Skills:\\n\" \\\n                 f\"1."}
{"task_id": "MBPP/train620", "completion": "\n    res = [0] * len(arr)\n    res[0] = 1\n    for i in range(1, len(arr)):\n        x = arr[i]\n        for j in range(i):\n            if arr[j] > x:\n                res[i] = max(res[i], res[j] + 1)\n    return res[-1]\n\n\ndef gcd_of_arr(arr):\n    res = 1\n    for i in range(1, len(arr)):\n        res = gcd(res, arr[i])\n    return res\n\n\ndef lcm_of_arr(arr):\n    res = 1\n    for i in range(1, len(arr)):\n        res = lcm(res, arr[i])\n    return res\n\n\ndef find_duplicates(arr):\n    '''\n    Given a list of N integers arr[], find all the duplicate elements in it. \n    Note that the element \"x\" is a duplicate of \"y\" if x == y, i.e., they have the same value.\n    >>> find_duplicates([2, 3, 4, 5, 6, 6, 6, 7, ", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    res = [0] * len(arr)\n    res[0] = 1\n    for i in range(1, len(arr)):\n        x = arr[i]\n        for j in range(i):\n            if arr[j] > x:\n                res[i] = max(res[i], res[j] + 1)\n    return res[-1]\n\n\ndef gcd_of_arr(arr):\n    res = 1\n    for i in range(1, len(arr)):\n        res = gcd(res, arr[i])\n    return res\n\n\ndef lcm_of_arr(arr):\n    res = 1\n    for i in range(1, len(arr)):\n        res = lcm(res, arr[i])\n    return res\n\n\ndef find_duplicates(arr):\n    '''\n    Given a list of N integers arr[], find all the duplicate elements in it. \n    Note that the element \"x\" is a duplicate of \"y\" if x == y, i.e., they have the same value.\n    >>> find_duplicates([2, 3, 4, 5, 6, 6, 6, 7, "}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    dp = [0] * n\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n                ans = max(ans, dp[i])\n    return ans\n\ndef smallest_missing_number(arr):\n    '''\n    给定一个数组，求出该数组中缺失掉的最小的正整数。\n    >>> smallest_missing_number([1, 2, 4, 6, 7, 8, 9, 11, 14, 16])\n    3\n    >>> smallest_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    10\n    '''\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = arr[i]\n    for", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    dp = [0] * n\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n                ans = max(ans, dp[i])\n    return ans\n\ndef smallest_missing_number(arr):\n    '''\n    给定一个数组，求出该数组中缺失掉的最小的正整数。\n    >>> smallest_missing_number([1, 2, 4, 6, 7, 8, 9, 11, 14, 16])\n    3\n    >>> smallest_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    10\n    '''\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = arr[i]\n    for"}
{"task_id": "MBPP/train620", "completion": "\n    if len(arr) == 0:\n        return 0\n    max_len = 0\n    for i in range(1, len(arr)):\n        arr1 = sorted(arr[:i + 1])\n        if arr[i] % arr1[-1] == 0:\n            max_len = max(max_len, len(arr1))\n\n    return max_len\n\n\ndef sort(num):\n    '''\n    给定一个数字字符串，编写一个函数，将数字字符串排序。\n    >>> sort('3456789')\n    '3456789'\n    >>> sort('87654321')\n    '12345678'\n    >>> sort('4321')\n    '1234'\n    '''\n    new_num = []\n    for x in num:\n        new_num.append(int(x))\n    new_num.sort()\n    return ''.join(map(str, new_num))\n\n\ndef count_substring(s):\n    '''\n    给定一个字符串s，编写一个函数，", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if len(arr) == 0:\n        return 0\n    max_len = 0\n    for i in range(1, len(arr)):\n        arr1 = sorted(arr[:i + 1])\n        if arr[i] % arr1[-1] == 0:\n            max_len = max(max_len, len(arr1))\n\n    return max_len\n\n\ndef sort(num):\n    '''\n    给定一个数字字符串，编写一个函数，将数字字符串排序。\n    >>> sort('3456789')\n    '3456789'\n    >>> sort('87654321')\n    '12345678'\n    >>> sort('4321')\n    '1234'\n    '''\n    new_num = []\n    for x in num:\n        new_num.append(int(x))\n    new_num.sort()\n    return ''.join(map(str, new_num))\n\n\ndef count_substring(s):\n    '''\n    给定一个字符串s，编写一个函数，"}
{"task_id": "MBPP/train620", "completion": "\n    m = len(arr)\n    a = [i for i in range(m)]\n    b = [0] * 2\n\n    for i in range(1, m):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                a[i] = b[j] + 1\n                b[i] = max(b[j], a[i])\n            else:\n                a[i] = b[i]\n\n    return max(a)\n```\n\n### 1.3 子集枚举\n\n在遇到这种问题的时候，我们可以先枚举出所有子集，然后从中找出撇步。\n\n```python\ndef largest_subset(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    m = len(arr)\n    a = [i for i in range(m)]\n    b = [0] * 2\n\n    for i in range(1, m):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                a[i] = b[j] + 1\n                b[i] = max(b[j], a[i])\n            else:\n                a[i] = b[i]\n\n    return max(a)\n```\n\n### 1.3 子集枚举\n\n在遇到这种问题的时候，我们可以先枚举出所有子集，然后从中找出撇步。\n\n```python\ndef largest_subset(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n"}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort(reverse=True)\n    size = 0\n    for i in range(len(arr)):\n        j = size - 1\n        while j >= 0 and arr[i] % arr[j]!= 0:\n            j -= 1\n        if j == -1:\n            size = 0\n        else:\n            size += 1\n            for k in range(j + 1, size):\n                if arr[i] % arr[k]!= 0:\n                    size -= 1\n                    break\n    return size\n\n\ndef longest_subarray_with_sum_k(arr, k):\n    # 用大顶堆\n    def __update_max_heap(heap, i):\n        while i > 0 and arr[i] > arr[heap[0]]:\n            heap[0], arr[i] = arr[i], heap[0]\n            i = 0\n            heapq.heapify(heap)\n\n    n = len(arr)\n    heap = []\n    result = 0\n    for i in range(n):\n        __update_max_heap(heap, i)\n        while heap", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort(reverse=True)\n    size = 0\n    for i in range(len(arr)):\n        j = size - 1\n        while j >= 0 and arr[i] % arr[j]!= 0:\n            j -= 1\n        if j == -1:\n            size = 0\n        else:\n            size += 1\n            for k in range(j + 1, size):\n                if arr[i] % arr[k]!= 0:\n                    size -= 1\n                    break\n    return size\n\n\ndef longest_subarray_with_sum_k(arr, k):\n    # 用大顶堆\n    def __update_max_heap(heap, i):\n        while i > 0 and arr[i] > arr[heap[0]]:\n            heap[0], arr[i] = arr[i], heap[0]\n            i = 0\n            heapq.heapify(heap)\n\n    n = len(arr)\n    heap = []\n    result = 0\n    for i in range(n):\n        __update_max_heap(heap, i)\n        while heap"}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            elif arr[i] % arr[j] == 0:\n                result += 1\n    return result\n\ndef get_total(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的所有元素的和。\n    >>> get_total([1, 2, 3, 4])\n    10\n    '''\n    result = 0\n    for i in arr:\n        result += i\n    return result\n\ndef get_largest_diff(arr): \n    '''\n    给定一个数组a，编写一个函数，求数组a中两个数的最大差值。\n    >>> get_largest_diff([1, 2, 3, 4, 5])\n    4\n    '''\n    n = len(arr)\n    largest_diff = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if abs(arr", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            elif arr[i] % arr[j] == 0:\n                result += 1\n    return result\n\ndef get_total(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的所有元素的和。\n    >>> get_total([1, 2, 3, 4])\n    10\n    '''\n    result = 0\n    for i in arr:\n        result += i\n    return result\n\ndef get_largest_diff(arr): \n    '''\n    给定一个数组a，编写一个函数，求数组a中两个数的最大差值。\n    >>> get_largest_diff([1, 2, 3, 4, 5])\n    4\n    '''\n    n = len(arr)\n    largest_diff = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if abs(arr"}
{"task_id": "MBPP/train620", "completion": "\n    # 最大子集是否已经找到？\n    is_found = False\n    # 最大子集的大小\n    max_size = 0\n    # 数组的大小\n    size = len(arr)\n    if size == 0:\n        return max_size\n\n    # 子集数组\n    sub_set = [0] * size\n    # 子集大小\n    sub_set_size = 0\n    # 寻找每一对元素的最大公约数\n    for i in range(size - 1):\n        # 当前元素与下一元素的最大公约数\n        gcd = gcd_euclid(arr[i], arr[i + 1])\n        # 如果gcd不为0，说明这俩数都可以整除\n        if gcd > 0:\n            # 如果最大子集为空，则将gcd设为新子集的第一个元素\n            if is_found == False:\n                sub_set[sub_set_size] = gcd\n                sub_set_", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 最大子集是否已经找到？\n    is_found = False\n    # 最大子集的大小\n    max_size = 0\n    # 数组的大小\n    size = len(arr)\n    if size == 0:\n        return max_size\n\n    # 子集数组\n    sub_set = [0] * size\n    # 子集大小\n    sub_set_size = 0\n    # 寻找每一对元素的最大公约数\n    for i in range(size - 1):\n        # 当前元素与下一元素的最大公约数\n        gcd = gcd_euclid(arr[i], arr[i + 1])\n        # 如果gcd不为0，说明这俩数都可以整除\n        if gcd > 0:\n            # 如果最大子集为空，则将gcd设为新子集的第一个元素\n            if is_found == False:\n                sub_set[sub_set_size] = gcd\n                sub_set_"}
{"task_id": "MBPP/train620", "completion": "\n    l = len(arr)\n    dp = [[0 for _ in range(l)] for _ in range(l)] \n    size = [0] * l\n    res = 0\n    # init\n    for i in range(l):\n        dp[i][i] = arr[i]\n        size[i] = 1\n        res = max(res, size[i])\n    # calculate\n    for i in range(l-1):\n        for j in range(i+1, l):\n            if arr[i] % arr[j] == 0:\n                new_size = size[i] + 1\n            elif arr[j] % arr[i] == 0:\n                new_size = size[j] + 1\n            else:\n                new_size = 0\n            dp[i][j] = dp[i][j-1]\n            dp[j][i] = dp[j][i+1]\n            if new_size > size[j]:\n                dp[i][j], dp[j][i] = dp[j][i], dp[i][j]\n                size[i], size[j] = size[", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    l = len(arr)\n    dp = [[0 for _ in range(l)] for _ in range(l)] \n    size = [0] * l\n    res = 0\n    # init\n    for i in range(l):\n        dp[i][i] = arr[i]\n        size[i] = 1\n        res = max(res, size[i])\n    # calculate\n    for i in range(l-1):\n        for j in range(i+1, l):\n            if arr[i] % arr[j] == 0:\n                new_size = size[i] + 1\n            elif arr[j] % arr[i] == 0:\n                new_size = size[j] + 1\n            else:\n                new_size = 0\n            dp[i][j] = dp[i][j-1]\n            dp[j][i] = dp[j][i+1]\n            if new_size > size[j]:\n                dp[i][j], dp[j][i] = dp[j][i], dp[i][j]\n                size[i], size[j] = size["}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort()\n    maxLen = 0\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[j] % arr[i] == 0:\n                maxLen += 1\n                break\n        else:\n            i += 1\n    return maxLen\n\n\n\nif __name__ == '__main__':\n    # test case 1\n    arr = [1, 3, 6, 13, 17, 18]\n    maxLen = largest_subset(arr)\n    if maxLen == 4:\n        result = 'Test Passed'\n    else:\n        result = 'Test Failed'\n    print(result)\n    print('Output:', maxLen)\n\n    # test case 2\n    arr = [2, 4, 8, 12]\n    maxLen = largest_subset(arr)\n    if maxLen == 3:\n        result = 'Test Passed'\n    else:\n        result = 'Test Failed'\n    print(result)\n    print('Output:', maxLen)\n\n    # test case 3\n    arr = [1", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort()\n    maxLen = 0\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[j] % arr[i] == 0:\n                maxLen += 1\n                break\n        else:\n            i += 1\n    return maxLen\n\n\n\nif __name__ == '__main__':\n    # test case 1\n    arr = [1, 3, 6, 13, 17, 18]\n    maxLen = largest_subset(arr)\n    if maxLen == 4:\n        result = 'Test Passed'\n    else:\n        result = 'Test Failed'\n    print(result)\n    print('Output:', maxLen)\n\n    # test case 2\n    arr = [2, 4, 8, 12]\n    maxLen = largest_subset(arr)\n    if maxLen == 3:\n        result = 'Test Passed'\n    else:\n        result = 'Test Failed'\n    print(result)\n    print('Output:', maxLen)\n\n    # test case 3\n    arr = [1"}
{"task_id": "MBPP/train689", "completion": "\n    res = 0\n    for i in arr:\n        res += i\n    return res\n\ndef sum_nums(arr):\n    '''\n    数组的 \"和\" 是数组中所有元素的总和。编写一个方法，返回数组的和。\n    >>> sum_nums([1, 2, 3, 4])\n    10\n    >>> sum_nums([10, 10, 10])\n    30\n    '''\n    return sum(arr)\n\ndef all_diff_by(arr):\n    '''\n    编写一个方法，判断一个数组中的所有元素是否都相邻。\n    例如： [1, 24, 3, 4, 89] 返回 true，所有元素都相邻。\n    而 [1, 2, 3, 4, 6] 返回 false，因为中间有个 5。\n    >>> all_diff_by([1, 2, 3", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    res = 0\n    for i in arr:\n        res += i\n    return res\n\ndef sum_nums(arr):\n    '''\n    数组的 \"和\" 是数组中所有元素的总和。编写一个方法，返回数组的和。\n    >>> sum_nums([1, 2, 3, 4])\n    10\n    >>> sum_nums([10, 10, 10])\n    30\n    '''\n    return sum(arr)\n\ndef all_diff_by(arr):\n    '''\n    编写一个方法，判断一个数组中的所有元素是否都相邻。\n    例如： [1, 24, 3, 4, 89] 返回 true，所有元素都相邻。\n    而 [1, 2, 3, 4, 6] 返回 false，因为中间有个 5。\n    >>> all_diff_by([1, 2, 3"}
{"task_id": "MBPP/train689", "completion": "\n    size = len(arr)\n    if size == 1: return 0\n    jump = [-1] * size\n    jump[0] = 0\n    for i in range(1, size):\n        if i > jump[i-1]:\n            continue\n        for j in range(i-1, -1, -1):\n            if i+arr[i] >= size-1: return jump[i]\n            if i+arr[i] > jump[i+arr[i]]:\n                jump[i+arr[i]] = i+1\n    return jump[size-1]\n\n\n\ndef max_product(arr): \n    '''\n    编写一个函数，找到给定整数数组中的最大子数组乘积。\n    >>> max_product([1, 3, 2, 6, -1, 4, 10, 1, 6])\n    1230\n    '''\n    if len(arr) < 1: return 0\n    res = arr[0]\n", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    size = len(arr)\n    if size == 1: return 0\n    jump = [-1] * size\n    jump[0] = 0\n    for i in range(1, size):\n        if i > jump[i-1]:\n            continue\n        for j in range(i-1, -1, -1):\n            if i+arr[i] >= size-1: return jump[i]\n            if i+arr[i] > jump[i+arr[i]]:\n                jump[i+arr[i]] = i+1\n    return jump[size-1]\n\n\n\ndef max_product(arr): \n    '''\n    编写一个函数，找到给定整数数组中的最大子数组乘积。\n    >>> max_product([1, 3, 2, 6, -1, 4, 10, 1, 6])\n    1230\n    '''\n    if len(arr) < 1: return 0\n    res = arr[0]\n"}
{"task_id": "MBPP/train689", "completion": "\n    pass\n\n\ndef longest_subarray(arr): \n    '''\n    编写一个函数，找出数组中子数组的最大长度，子数组的长度是指子数组中的元素数量，并且子数组中的元素是连续的。\n    从长度最大的子数组中删除任意元素，数组都不会变化，所以你可以认为子数组仅仅是一个数组的连续片段。\n    >>> longest_subarray([1, 3, 6, 13, 17, 18])\n    4\n    '''\n    pass\n\n\ndef max_rectangle_area(arr): \n    '''\n    给出一个二维的整形数组，每一个数组元素的值是一个1或0。\n    编写一个函数，返回这个二维数组中1的长方形（有且仅", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    pass\n\n\ndef longest_subarray(arr): \n    '''\n    编写一个函数，找出数组中子数组的最大长度，子数组的长度是指子数组中的元素数量，并且子数组中的元素是连续的。\n    从长度最大的子数组中删除任意元素，数组都不会变化，所以你可以认为子数组仅仅是一个数组的连续片段。\n    >>> longest_subarray([1, 3, 6, 13, 17, 18])\n    4\n    '''\n    pass\n\n\ndef max_rectangle_area(arr): \n    '''\n    给出一个二维的整形数组，每一个数组元素的值是一个1或0。\n    编写一个函数，返回这个二维数组中1的长方形（有且仅"}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    jumps = [0 for i in range(n)]\n    jumps[0] = 0\n    for i in range(1,n):\n        jumps[i] = max_jump(arr,i)\n    return jumps[n-1]\n\n    # 最终的最少步数\n    # return dp[0]\n\n\nif __name__ == \"__main__\":\n    # arr = [1,3,6,13,17,18]\n    # arr = [1, 2, 5, 5, 5, 5, 5, 5, 5]\n    # arr = [1, 3, 5, 1, 2, 0, 0, 1, 3, 1]\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    # print(arr)\n    print(min_jumps(arr))\n    print(min_jumps_dp(arr))\n    # print", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    jumps = [0 for i in range(n)]\n    jumps[0] = 0\n    for i in range(1,n):\n        jumps[i] = max_jump(arr,i)\n    return jumps[n-1]\n\n    # 最终的最少步数\n    # return dp[0]\n\n\nif __name__ == \"__main__\":\n    # arr = [1,3,6,13,17,18]\n    # arr = [1, 2, 5, 5, 5, 5, 5, 5, 5]\n    # arr = [1, 3, 5, 1, 2, 0, 0, 1, 3, 1]\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    # print(arr)\n    print(min_jumps(arr))\n    print(min_jumps_dp(arr))\n    # print"}
{"task_id": "MBPP/train689", "completion": "\n    max_jump = arr[0]\n    for i in range(1, len(arr)):\n        max_jump = max(arr[i], max_jump)\n        if i == max_jump:\n            max_jump = arr[i]\n            print(arr)\n    return i - max_jump + 1\n\ndef print_arr(arr):\n    for item in arr:\n        print(item)\n\ndef main():\n    # arr = [1, 3, 6, 13, 17, 18]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [1, 3]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [4, 2, 1]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [100, 20, 10, 1, 50, 30, 40]\n", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    max_jump = arr[0]\n    for i in range(1, len(arr)):\n        max_jump = max(arr[i], max_jump)\n        if i == max_jump:\n            max_jump = arr[i]\n            print(arr)\n    return i - max_jump + 1\n\ndef print_arr(arr):\n    for item in arr:\n        print(item)\n\ndef main():\n    # arr = [1, 3, 6, 13, 17, 18]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [1, 3]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [4, 2, 1]\n    # print_arr(arr)\n    # print(min_jumps(arr))\n    # arr = [100, 20, 10, 1, 50, 30, 40]\n"}
{"task_id": "MBPP/train689", "completion": "\n\n    n = len(arr)\n    if n == 0 or arr[0] == 0:\n        return 0\n    jump = [0] * n\n    jump[0] = 1\n\n    for i in range(1, n):\n        if arr[i] == 0 and i == n - 1:\n            jump[i] = 1\n            continue\n\n        if arr[i] == 0:\n            jump[i] = float('inf')\n            continue\n\n        j = i + arr[i]\n        if j < n:\n            jump[i] = jump[j] + 1\n        else:\n            j = i - arr[i]\n            if j > 0:\n                jump[i] = jump[j] + 1\n            else:\n                jump[i] = float('inf')\n\n    if jump[n - 1] == float('inf'):\n        return 0\n    return jump[n - 1]\n\n    # return jump[0] == float('inf')\n\nif __name__ == '__main__':", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n\n    n = len(arr)\n    if n == 0 or arr[0] == 0:\n        return 0\n    jump = [0] * n\n    jump[0] = 1\n\n    for i in range(1, n):\n        if arr[i] == 0 and i == n - 1:\n            jump[i] = 1\n            continue\n\n        if arr[i] == 0:\n            jump[i] = float('inf')\n            continue\n\n        j = i + arr[i]\n        if j < n:\n            jump[i] = jump[j] + 1\n        else:\n            j = i - arr[i]\n            if j > 0:\n                jump[i] = jump[j] + 1\n            else:\n                jump[i] = float('inf')\n\n    if jump[n - 1] == float('inf'):\n        return 0\n    return jump[n - 1]\n\n    # return jump[0] == float('inf')\n\nif __name__ == '__main__':"}
{"task_id": "MBPP/train689", "completion": "\n    def rec_helper(arr, cur):\n        ''' 计算以 cur 为起点的最小跳跃次数 '''\n        if cur < 0: return None\n        if cur == 0: return 0\n        if cur == len(arr)-1: return 0\n\n        for i in range(1, arr[cur] + 1):\n            _ = rec_helper(arr, cur - i)\n            if _ == None: continue\n            return _ + 1\n        return None\n\n    if len(arr) == 0: return None\n    return rec_helper(arr, len(arr) - 1)\n\n\ndef next_permutation(arr): \n    '''\n    Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. \n    '''\n    def rec_next_permutation(arr):\n        if len(arr) == 1: return False\n        if arr[-1] > arr[-2]: return True\n\n        i = len(arr)-2\n        while i >= 0 and", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    def rec_helper(arr, cur):\n        ''' 计算以 cur 为起点的最小跳跃次数 '''\n        if cur < 0: return None\n        if cur == 0: return 0\n        if cur == len(arr)-1: return 0\n\n        for i in range(1, arr[cur] + 1):\n            _ = rec_helper(arr, cur - i)\n            if _ == None: continue\n            return _ + 1\n        return None\n\n    if len(arr) == 0: return None\n    return rec_helper(arr, len(arr) - 1)\n\n\ndef next_permutation(arr): \n    '''\n    Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. \n    '''\n    def rec_next_permutation(arr):\n        if len(arr) == 1: return False\n        if arr[-1] > arr[-2]: return True\n\n        i = len(arr)-2\n        while i >= 0 and"}
{"task_id": "MBPP/train689", "completion": "\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 0\n    \n    step = 0\n    end_index = len(arr) - 1\n    index = 0\n\n    while end_index > index:\n        print(\"index:\",index,\"end_index:\",end_index)\n        # 当前的最小跳跃\n        min_jump = end_index\n        while index + arr[index] <= end_index:\n            print(\"index:\",index,\"end_index:\",end_index)\n            end_index = min(end_index, index + arr[index])\n            min_jump = min(min_jump, arr[index])\n            index += min_jump\n            step  += 1\n        if end_index == index:\n            break\n        else:\n            index = end_index\n    return step\n```\n\n\n\n```python\n\n```\n\n### 38、排序\n\n```python\nimport random\n\nrandom.seed(10)", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 0\n    \n    step = 0\n    end_index = len(arr) - 1\n    index = 0\n\n    while end_index > index:\n        print(\"index:\",index,\"end_index:\",end_index)\n        # 当前的最小跳跃\n        min_jump = end_index\n        while index + arr[index] <= end_index:\n            print(\"index:\",index,\"end_index:\",end_index)\n            end_index = min(end_index, index + arr[index])\n            min_jump = min(min_jump, arr[index])\n            index += min_jump\n            step  += 1\n        if end_index == index:\n            break\n        else:\n            index = end_index\n    return step\n```\n\n\n\n```python\n\n```\n\n### 38、排序\n\n```python\nimport random\n\nrandom.seed(10)"}
{"task_id": "MBPP/train689", "completion": "\n    max_jumps = 0\n    for k, v in enumerate(arr):\n        if k == 0:\n            max_jumps = v\n        else:\n            min_jump_times = max_jumps - k + 1\n            if min_jump_times > v:\n                max_jumps = v\n                min_jump_times = max_jumps - k + 1\n            if min_jump_times < min_jump_times:\n                min_jump_times = min_jump_times\n                max_jumps = v\n    return", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    max_jumps = 0\n    for k, v in enumerate(arr):\n        if k == 0:\n            max_jumps = v\n        else:\n            min_jump_times = max_jumps - k + 1\n            if min_jump_times > v:\n                max_jumps = v\n                min_jump_times = max_jumps - k + 1\n            if min_jump_times < min_jump_times:\n                min_jump_times = min_jump_times\n                max_jumps = v\n    return"}
{"task_id": "MBPP/train689", "completion": "\n    # 题解：题目要求找出从数组的第 1 个元素跳转到数组末尾的最少步数\n    # 首先取出数组的第一个元素，如果元素大于等于数组的长度，则步数为0\n    # 否则，将最大值对应的步数的后序序列删除，并把对应步数减1\n    # 如果删除操作后序列还存在值，则将最大值的步数减1\n    # 如果删除操作后序列不存在值了，则表明从数组第一个元素到末尾最少步数为当前步数+1\n    # 否则，步数为0\n    n = len(arr)\n    if n == 0:\n        return 0\n    step = 0\n    i = 0\n    while i < n", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # 题解：题目要求找出从数组的第 1 个元素跳转到数组末尾的最少步数\n    # 首先取出数组的第一个元素，如果元素大于等于数组的长度，则步数为0\n    # 否则，将最大值对应的步数的后序序列删除，并把对应步数减1\n    # 如果删除操作后序列还存在值，则将最大值的步数减1\n    # 如果删除操作后序列不存在值了，则表明从数组第一个元素到末尾最少步数为当前步数+1\n    # 否则，步数为0\n    n = len(arr)\n    if n == 0:\n        return 0\n    step = 0\n    i = 0\n    while i < n"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    给定长度可变的列表，每个列表都是已经排序好的，把它们合并成一个排序好的列表。\n    >>> mergeKLists([[1,2,4],[1,3,4],[2,6]])\n    [1, 1, 2, 2, 3, 4, 4, 6]\n    >>> mergeKLists([[]])\n    []\n    '''\n    if not lists:\n        return []\n    return mergeTwoLists(*lists)\n\n\ndef reconstructQueue(people):\n    \"\"\"\n    重建一个从前端到后端的队列。\n    >>> reconstructQueue([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]])\n    [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7,", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    给定长度可变的列表，每个列表都是已经排序好的，把它们合并成一个排序好的列表。\n    >>> mergeKLists([[1,2,4],[1,3,4],[2,6]])\n    [1, 1, 2, 2, 3, 4, 4, 6]\n    >>> mergeKLists([[]])\n    []\n    '''\n    if not lists:\n        return []\n    return mergeTwoLists(*lists)\n\n\ndef reconstructQueue(people):\n    \"\"\"\n    重建一个从前端到后端的队列。\n    >>> reconstructQueue([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]])\n    [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7,"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists_heap(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    import heapq\n    list_res = []\n    heap1 = []\n    heap2 = []\n    heapq.heapify(list1)\n    heapq.heapify(list2)\n    while list1 and list2:\n        if list1[0] < list2[0]:\n            heapq.heappush(heap1, list1.pop(0))\n        else:\n            heapq.heappush(heap2, list2.pop(0))\n        if heap1 and heap2:\n            if heap1[0", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists_heap(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    import heapq\n    list_res = []\n    heap1 = []\n    heap2 = []\n    heapq.heapify(list1)\n    heapq.heapify(list2)\n    while list1 and list2:\n        if list1[0] < list2[0]:\n            heapq.heappush(heap1, list1.pop(0))\n        else:\n            heapq.heappush(heap2, list2.pop(0))\n        if heap1 and heap2:\n            if heap1[0"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeSort(list1, list2):\n    '''\n    归并排序，将两个有序表合并成一个有序表\n    >>> mergeSort([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeSort([], [])\n    []\n    '''\n    if list1:\n        if list2:\n            if list1[0] < list2[0]:\n                return [list1[0]] + mergeSort(list1[1:], list2)\n            else:\n                return [list2[0]] + mergeSort(list1, list2[1:])\n        else:\n            return list1\n    else:\n        return list2\n\n\ndef mergeSort2(list1, list2):\n    '''\n    >>> mergeSort2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeSort2([], [])\n   ", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeSort(list1, list2):\n    '''\n    归并排序，将两个有序表合并成一个有序表\n    >>> mergeSort([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeSort([], [])\n    []\n    '''\n    if list1:\n        if list2:\n            if list1[0] < list2[0]:\n                return [list1[0]] + mergeSort(list1[1:], list2)\n            else:\n                return [list2[0]] + mergeSort(list1, list2[1:])\n        else:\n            return list1\n    else:\n        return list2\n\n\ndef mergeSort2(list1, list2):\n    '''\n    >>> mergeSort2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeSort2([], [])\n   "}
{"task_id": "leetcode/21", "completion": "\n\n\ndef getIntersectionNode(list1, list2):\n    '''\n    给定两个单链表，编写一个函数来找出它们的第一个公共节点。\n    如果不存在，则返回 null.\n    >>> l1 = ListNode(1)\n    >>> l2 = ListNode(2)\n    >>> l3 = ListNode(3)\n    >>> l4 = ListNode(4)\n    >>> l5 = ListNode(5)\n    >>> l1.next = l2\n    >>> l2.next = l3\n    >>> l3.next = l4\n    >>> l4.next = l5\n    >>> l5.next = l3\n    >>> getIntersectionNode(l1, l3)\n    >>> getIntersectionNode(l1, l4)\n    不存在公共节点\n    '''\n    list1_len = findListLen(list1)\n    list2_len = findListLen(list2)\n    if list1 is None:\n        return None\n    if list", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef getIntersectionNode(list1, list2):\n    '''\n    给定两个单链表，编写一个函数来找出它们的第一个公共节点。\n    如果不存在，则返回 null.\n    >>> l1 = ListNode(1)\n    >>> l2 = ListNode(2)\n    >>> l3 = ListNode(3)\n    >>> l4 = ListNode(4)\n    >>> l5 = ListNode(5)\n    >>> l1.next = l2\n    >>> l2.next = l3\n    >>> l3.next = l4\n    >>> l4.next = l5\n    >>> l5.next = l3\n    >>> getIntersectionNode(l1, l3)\n    >>> getIntersectionNode(l1, l4)\n    不存在公共节点\n    '''\n    list1_len = findListLen(list1)\n    list2_len = findListLen(list2)\n    if list1 is None:\n        return None\n    if list"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    示例 1:\n    >>> nums = [3,2,1,5,6,4]\n    >>> findKthLargest(nums, 2)\n    5\n    示例 2:\n    >>> nums = [3,2,3,1,2,4,5,5,6]\n    >>> findKthLargest(nums, 4)\n    4\n    说明:\n    你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n    '''\n    if not nums or len(nums) == 1:\n        return nums[0]\n    if len", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    示例 1:\n    >>> nums = [3,2,1,5,6,4]\n    >>> findKthLargest(nums, 2)\n    5\n    示例 2:\n    >>> nums = [3,2,3,1,2,4,5,5,6]\n    >>> findKthLargest(nums, 4)\n    4\n    说明:\n    你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n    '''\n    if not nums or len(nums) == 1:\n        return nums[0]\n    if len"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef combine(n, k):\n    '''\n    以1, 2,..., n为节点组成的二叉树，找出所有长度为k的路径，返回长度为k的所有路径组成的列表\n    '''\n    if n == 0:\n        return [[]]\n    if k == 0:\n        return []\n    if k == 1:\n        return [[i] for i in range(1, n + 1)]\n\n    list_res = []\n    for i in range(1, n + 1):\n        for list_sub_res in combine(i - 1, k - 1):\n            list_res.append([i] + list_sub_res)\n\n    return list_res\n\n\ndef getPermutation(n, k):\n    '''\n    输出第k个长度为n的排列。\n    '''\n\n    list_res = [str(i) for i in range(1, n + 1)]\n   ", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef combine(n, k):\n    '''\n    以1, 2,..., n为节点组成的二叉树，找出所有长度为k的路径，返回长度为k的所有路径组成的列表\n    '''\n    if n == 0:\n        return [[]]\n    if k == 0:\n        return []\n    if k == 1:\n        return [[i] for i in range(1, n + 1)]\n\n    list_res = []\n    for i in range(1, n + 1):\n        for list_sub_res in combine(i - 1, k - 1):\n            list_res.append([i] + list_sub_res)\n\n    return list_res\n\n\ndef getPermutation(n, k):\n    '''\n    输出第k个长度为n的排列。\n    '''\n\n    list_res = [str(i) for i in range(1, n + 1)]\n   "}
{"task_id": "leetcode/21", "completion": "\n\n\ndef countSmaller(nums):\n    '''\n    给定一个整数数组 nums，按要求返回一个新数组。\n    对于数组中每个元素 nums[i]，在原数组中删除所有大于等于 nums[i] 的值，\n    原数组中的每个元素都会出现在返回数组中，最后返回的数组是排序的。\n    要求算法时间复杂度为 O(nlogn)。\n    >>> countSmaller([5,2,6,1])\n    [2, 1, 1, 0]\n    '''\n    if not nums:\n        return []\n    list_res = []\n    list_res = [0] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        n = nums[i]\n        count = 0\n        for j in range(0, i+1):\n            if nums[j", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef countSmaller(nums):\n    '''\n    给定一个整数数组 nums，按要求返回一个新数组。\n    对于数组中每个元素 nums[i]，在原数组中删除所有大于等于 nums[i] 的值，\n    原数组中的每个元素都会出现在返回数组中，最后返回的数组是排序的。\n    要求算法时间复杂度为 O(nlogn)。\n    >>> countSmaller([5,2,6,1])\n    [2, 1, 1, 0]\n    '''\n    if not nums:\n        return []\n    list_res = []\n    list_res = [0] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        n = nums[i]\n        count = 0\n        for j in range(0, i+1):\n            if nums[j"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    给定一个链表数组，每个链表都已经按照升序排列。\n\n    请将所有的元素合并到一个升序链表中，返回合并后的链表。\n\n    https://leetcode-cn.com/problems/merge-k-sorted-lists/\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> mergeKLists([[1, 4, 5], [1, 3, 4], [2, 6]])\n    '''\n    return list(itertools.chain.from_iterable(lists))\n\ndef mergeKLists2(lists):\n    '''\n    给定一个链表数组，每个链表都已经按照升序", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    给定一个链表数组，每个链表都已经按照升序排列。\n\n    请将所有的元素合并到一个升序链表中，返回合并后的链表。\n\n    https://leetcode-cn.com/problems/merge-k-sorted-lists/\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> mergeKLists([[1, 4, 5], [1, 3, 4], [2, 6]])\n    '''\n    return list(itertools.chain.from_iterable(lists))\n\ndef mergeKLists2(lists):\n    '''\n    给定一个链表数组，每个链表都已经按照升序"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> mergeKLists([])\n    []\n    >>> mergeKLists([[1], [2], [3], [4], [5], [6]])\n    [1, 2, 3, 4, 5, 6]\n    '''\n    if not lists:\n        return []\n    len_lists = len(lists)\n    if len_lists == 1:\n        return lists[0]\n    mid = len_lists // 2\n    list1 = mergeKLists(lists[:mid])\n    list2 = mergeKLists(lists[mid:])\n    return mergeTwoLists(list1, list2)\n\n\ndef mergeTwoLists1(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 '", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> mergeKLists([])\n    []\n    >>> mergeKLists([[1], [2], [3], [4], [5], [6]])\n    [1, 2, 3, 4, 5, 6]\n    '''\n    if not lists:\n        return []\n    len_lists = len(lists)\n    if len_lists == 1:\n        return lists[0]\n    mid = len_lists // 2\n    list1 = mergeKLists(lists[:mid])\n    list2 = mergeKLists(lists[mid:])\n    return mergeTwoLists(list1, list2)\n\n\ndef mergeTwoLists1(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 '"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef sum_two_list(l1, l2):\n    '''\n    两个有序链表的和\n    示例:\n    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n    输出：7 -> 0 -> 8\n    原因：342 + 465 = 807\n    >>> sum_two_list([], [])\n    []\n    '''\n    res = []\n    t = 0\n    while l1 or l2 or t:\n        if l1:\n            t += l1.val\n            l1 = l1.next\n        if l2:\n            t += l2.val\n            l2 = l2.next\n        res.append(t % 10)\n        t //= 10\n    r = ListNode(None)\n    for i in range(len(res) - 1, -1, -1):\n        r.next = ListNode(res[i])\n        r = r.next\n    return r\n\n\ndef merge_", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef sum_two_list(l1, l2):\n    '''\n    两个有序链表的和\n    示例:\n    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n    输出：7 -> 0 -> 8\n    原因：342 + 465 = 807\n    >>> sum_two_list([], [])\n    []\n    '''\n    res = []\n    t = 0\n    while l1 or l2 or t:\n        if l1:\n            t += l1.val\n            l1 = l1.next\n        if l2:\n            t += l2.val\n            l2 = l2.next\n        res.append(t % 10)\n        t //= 10\n    r = ListNode(None)\n    for i in range(len(res) - 1, -1, -1):\n        r.next = ListNode(res[i])\n        r = r.next\n    return r\n\n\ndef merge_"}
{"task_id": "leetcode/35", "completion": "\n    if not nums:\n        return 0\n    if nums[-1] < target:\n        return len(nums)\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n        if nums[i] > target:\n            return i\n    return len(nums)\n\n\n# 解法二 二分查找\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums:\n        return 0\n    if nums[-1] < target:\n        return len(nums)\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n        if nums[i] > target:\n            return i\n    return len(nums)\n\n\n# 解法二 二分查找\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)"}
{"task_id": "leetcode/35", "completion": "\n\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    if len(nums) == 0:\n        return 0\n    if nums[0] >= target:\n        return 0\n\n    return binary_search(nums, target)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，你不", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    if len(nums) == 0:\n        return 0\n    if nums[0] >= target:\n        return 0\n\n    return binary_search(nums, target)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，你不"}
{"task_id": "leetcode/35", "completion": "\n\n    if not nums:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = int((left + right) / 2)\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\ndef climbStairs(n):\n    '''\n    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    >>> climbStairs(2)\n    2\n    >>> climbStairs(3)\n    3\n    >>> climbStairs(4)\n    5\n    '''\n\n    a, b = 1, ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n\n    if not nums:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = int((left + right) / 2)\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\ndef climbStairs(n):\n    '''\n    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    >>> climbStairs(2)\n    2\n    >>> climbStairs(3)\n    3\n    >>> climbStairs(4)\n    5\n    '''\n\n    a, b = 1, "}
{"task_id": "leetcode/35", "completion": "\n    if len(nums) == 0:\n        return 0\n    elif len(nums) == 1:\n        if nums[0] >= target:\n            return 0\n        return 1\n    elif len(nums) == 2:\n        if nums[0] >= target:\n            return 0\n        if nums[1] >= target:\n            return 1\n        return 2\n\n    mid = len(nums) // 2\n    if nums[mid] <= target:\n        return searchInsert(nums[:mid+1], target)\n    return searchInsert(nums[mid:], target) + mid\n\n\ndef searchInsert2(nums: List[int], target: int) -> int:\n    '''\n    给定一个有序数组 'nums'，和一个元素 'target'。返回 'nums' 中的下标 'i'，满足 'nums[i] == target'。如果 'nums' 中不存在 'target'，就请返回 'nums' ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if len(nums) == 0:\n        return 0\n    elif len(nums) == 1:\n        if nums[0] >= target:\n            return 0\n        return 1\n    elif len(nums) == 2:\n        if nums[0] >= target:\n            return 0\n        if nums[1] >= target:\n            return 1\n        return 2\n\n    mid = len(nums) // 2\n    if nums[mid] <= target:\n        return searchInsert(nums[:mid+1], target)\n    return searchInsert(nums[mid:], target) + mid\n\n\ndef searchInsert2(nums: List[int], target: int) -> int:\n    '''\n    给定一个有序数组 'nums'，和一个元素 'target'。返回 'nums' 中的下标 'i'，满足 'nums[i] == target'。如果 'nums' 中不存在 'target'，就请返回 'nums' "}
{"task_id": "leetcode/35", "completion": "\n    if target in nums or len(nums) == 0:\n        return nums.index(target)\n    if target > nums[-1]:\n        return len(nums)\n    return binarySearch(nums, target)\n\n\ndef searchInsert1(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums or len(nums) == 0:\n        return nums.index(target)\n    if target >", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums or len(nums) == 0:\n        return nums.index(target)\n    if target > nums[-1]:\n        return len(nums)\n    return binarySearch(nums, target)\n\n\ndef searchInsert1(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums or len(nums) == 0:\n        return nums.index(target)\n    if target >"}
{"task_id": "leetcode/35", "completion": "\n    if nums", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if nums"}
{"task_id": "leetcode/35", "completion": "\n    l = 0\n    r = len(nums)\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] >= target:\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n```\n\n### 412. Fizz Buzz\n\n[https://leetcode-cn.com/problems/fizz-buzz/](https://leetcode-cn.com/problems/fizz-buzz/)\n\n>  如果一个数字可以被3整除，输出fizz；如果一个数字可以被5整除，输出buzz；如果一个数字可以同时被3和5整除输出fizzbuzz；如果一个数字不能被3和5整除输出该数字。\n>\n> 示例\n> 输入: n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    l = 0\n    r = len(nums)\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] >= target:\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n```\n\n### 412. Fizz Buzz\n\n[https://leetcode-cn.com/problems/fizz-buzz/](https://leetcode-cn.com/problems/fizz-buzz/)\n\n>  如果一个数字可以被3整除，输出fizz；如果一个数字可以被5整除，输出buzz；如果一个数字可以同时被3和5整除输出fizzbuzz；如果一个数字不能被3和5整除输出该数字。\n>\n> 示例\n> 输入: n"}
{"task_id": "leetcode/35", "completion": "\n    nums_len = len(nums)\n    if target <= nums[0]:\n        return 0\n    elif nums[nums_len-1] <= target:\n        return nums_len\n    for i in range(nums_len):\n        if target < nums[i]:\n            return i\n    return -1\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the (n/2)-th element in the sorted list (i.e., the list [1,2,3,4,5]). If the number of elements in the list is even, there is no middle value. So the median is then defined to be the mean of the two middle values.\n    Example 1: nums1 = [1,3], nums2 = [2]\n    nums1 = nums1 + nums2\n    median1 = (2+3)/2 = 2.5\n    nums = [1,2", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    nums_len = len(nums)\n    if target <= nums[0]:\n        return 0\n    elif nums[nums_len-1] <= target:\n        return nums_len\n    for i in range(nums_len):\n        if target < nums[i]:\n            return i\n    return -1\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the (n/2)-th element in the sorted list (i.e., the list [1,2,3,4,5]). If the number of elements in the list is even, there is no middle value. So the median is then defined to be the mean of the two middle values.\n    Example 1: nums1 = [1,3], nums2 = [2]\n    nums1 = nums1 + nums2\n    median1 = (2+3)/2 = 2.5\n    nums = [1,2"}
{"task_id": "leetcode/35", "completion": "\n    for i, num in enumerate(nums):\n        if num >= target:\n            return i\n    return len(nums)\n\ndef combinationSum(candidates, target):\n    '''\n    给你一个由 无重复 正整数组成的集合 candidates ，和一个目标数 target 。请你从 candidates 中找出可以形成目标数 target 的 最小组合 ，\n    并返回该组合所有数字的和。\n    >>> combinationSum([2,3,6,7], 7)\n    4\n    >>> combinationSum([2,3,5], 8)\n    3\n    '''\n    result = []\n    combinationSumCore(candidates, target, result, 0)\n    return max(result)\n\ndef combinationSumCore(candidates, target, result, begin):\n    if target == 0:\n        result.append(sum(result))\n    else:\n        for i in range(begin, len(candidates)):\n            if target - candidates[i] <", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    for i, num in enumerate(nums):\n        if num >= target:\n            return i\n    return len(nums)\n\ndef combinationSum(candidates, target):\n    '''\n    给你一个由 无重复 正整数组成的集合 candidates ，和一个目标数 target 。请你从 candidates 中找出可以形成目标数 target 的 最小组合 ，\n    并返回该组合所有数字的和。\n    >>> combinationSum([2,3,6,7], 7)\n    4\n    >>> combinationSum([2,3,5], 8)\n    3\n    '''\n    result = []\n    combinationSumCore(candidates, target, result, 0)\n    return max(result)\n\ndef combinationSumCore(candidates, target, result, begin):\n    if target == 0:\n        result.append(sum(result))\n    else:\n        for i in range(begin, len(candidates)):\n            if target - candidates[i] <"}
{"task_id": "leetcode/35", "completion": "\n\n    # 二分查找，找到第一个target后面的元素\n    # 注意有可能找到的元素在最后一个\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) >> 1\n\n        if nums[mid] >= target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    index = left\n    if nums[index] == target:\n        return index\n    else:\n        return index + 1\n\n\ndef searchInsert_recursively(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n\n    # 二分查找，找到第一个target后面的元素\n    # 注意有可能找到的元素在最后一个\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) >> 1\n\n        if nums[mid] >= target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    index = left\n    if nums[index] == target:\n        return index\n    else:\n        return index + 1\n\n\ndef searchInsert_recursively(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n"}
{"task_id": "leetcode/217", "completion": "\n    if len(nums) <=1:\n        return False\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\n\n# 有序数组寻找元素\ndef find(nums,target):\n    '''\n    在有序数组中找到目标元素的起始位置\n    >>> find([1,2,3,4,5,6,7,8,9,10],5)\n    4\n    >>> find([1,2,3,4,5,6,7,8,9,10],3)\n    2\n    >>> find([1,2,3,4,5,6,7,8,9,10],1)\n    0\n    '''\n    if nums.__len__() <= 1:\n        return 0\n    i = 0\n    j = nums.__len__()-1\n    while i<=j:\n        mid = (i+", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    if len(nums) <=1:\n        return False\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\n\n# 有序数组寻找元素\ndef find(nums,target):\n    '''\n    在有序数组中找到目标元素的起始位置\n    >>> find([1,2,3,4,5,6,7,8,9,10],5)\n    4\n    >>> find([1,2,3,4,5,6,7,8,9,10],3)\n    2\n    >>> find([1,2,3,4,5,6,7,8,9,10],1)\n    0\n    '''\n    if nums.__len__() <= 1:\n        return 0\n    i = 0\n    j = nums.__len__()-1\n    while i<=j:\n        mid = (i+"}
{"task_id": "leetcode/217", "completion": "\n    if len(nums)==0: return False\n    tset=set()\n    for i in nums:\n        if i in tset:\n            return True\n        else:\n            tset.add(i)\n    return False\n\n\n\nif __name__==\"__main__\":\n    print(containsDuplicate([1, 2, 3, 1]))\n    print(containsDuplicate([1, 2, 3, 4]))\n```\n\n### 3. 最长子串不含重复字符\n```python\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    例如，\n    给定 \"abcabcbb\" ，没有重复字符的最长子串是 \"abc\" ，那么其长度为 3。\n    给定 \"bbbbb\" ，最长的子串就是 \"b\" ，长度为 ", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    if len(nums)==0: return False\n    tset=set()\n    for i in nums:\n        if i in tset:\n            return True\n        else:\n            tset.add(i)\n    return False\n\n\n\nif __name__==\"__main__\":\n    print(containsDuplicate([1, 2, 3, 1]))\n    print(containsDuplicate([1, 2, 3, 4]))\n```\n\n### 3. 最长子串不含重复字符\n```python\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    例如，\n    给定 \"abcabcbb\" ，没有重复字符的最长子串是 \"abc\" ，那么其长度为 3。\n    给定 \"bbbbb\" ，最长的子串就是 \"b\" ，长度为 "}
{"task_id": "leetcode/217", "completion": "\n    # 使用字典存储数组中的元素\n    d = {}\n    for n in nums:\n        if n in d.keys():\n            return True\n        d[n] = True\n    return False\n\n# * 没有重复的数字\ndef largestNumber(nums):\n    '''\n    给定一个非空的整数数组，找出其中最大的三个数。\n    >>> largestNumber([3, 6, 1, 0])\n    630\n    >>> largestNumber([10, 2, 11, 1])\n    211\n    >>> largestNumber([1, 2, 3, 4])\n    4321\n    '''\n    # 将数组转化为字符串\n    nums = [str(i) for i in nums]\n    # 先排序\n    nums.sort(key=lambda x: int(x), reverse=True)\n    # 判断数组长度\n    if len(nums)", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 使用字典存储数组中的元素\n    d = {}\n    for n in nums:\n        if n in d.keys():\n            return True\n        d[n] = True\n    return False\n\n# * 没有重复的数字\ndef largestNumber(nums):\n    '''\n    给定一个非空的整数数组，找出其中最大的三个数。\n    >>> largestNumber([3, 6, 1, 0])\n    630\n    >>> largestNumber([10, 2, 11, 1])\n    211\n    >>> largestNumber([1, 2, 3, 4])\n    4321\n    '''\n    # 将数组转化为字符串\n    nums = [str(i) for i in nums]\n    # 先排序\n    nums.sort(key=lambda x: int(x), reverse=True)\n    # 判断数组长度\n    if len(nums)"}
{"task_id": "leetcode/217", "completion": "\n    nums_counter = Counter(nums)\n    return 0 in nums_counter.values()\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    n = int(input(\"请输入一个数字: \"))\n    if n % 2 == 0:\n        print(\"您输入的是偶数\")\n    else:\n        print(\"您输入的是奇数\")\n    print(nums)\n    print(containsDuplicate(nums))\n```\n\n\n\n## 小结\n\n- 一切都是对象\n- 所有的数据类型（int,str等）都是对象\n- 所有的对象都是由属性和方法组成\n- 在python中，类型是对象的一部分，也是对象的属性\n- 每一个对象都有一个类型，而指向对象的引用变量也是一种对象\n- 一切皆", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums_counter = Counter(nums)\n    return 0 in nums_counter.values()\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    n = int(input(\"请输入一个数字: \"))\n    if n % 2 == 0:\n        print(\"您输入的是偶数\")\n    else:\n        print(\"您输入的是奇数\")\n    print(nums)\n    print(containsDuplicate(nums))\n```\n\n\n\n## 小结\n\n- 一切都是对象\n- 所有的数据类型（int,str等）都是对象\n- 所有的对象都是由属性和方法组成\n- 在python中，类型是对象的一部分，也是对象的属性\n- 每一个对象都有一个类型，而指向对象的引用变量也是一种对象\n- 一切皆"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    # test_is_same_tree()\n    # test_is_symmetric_tree()\n    # test_largest_bst()\n    # test_is_bst()\n    test_is_palindrome()\n    # test_is_subsequence()\n    # test_is_one_edit_distance()\n    # test_compress_string()\n    # test_add_binary()\n    # test_find_lucky_number()\n    # test_max_area()\n    # test_reverse_words()\n    # test_reverse_sentence()\n    # test_convert_list_to_tree()\n    # test_convert_tree_to_list()\n    # test_is_palindrome_by_stack()\n    # test_is_palindrome_by_recursion()\n    # test_max", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    # test_is_same_tree()\n    # test_is_symmetric_tree()\n    # test_largest_bst()\n    # test_is_bst()\n    test_is_palindrome()\n    # test_is_subsequence()\n    # test_is_one_edit_distance()\n    # test_compress_string()\n    # test_add_binary()\n    # test_find_lucky_number()\n    # test_max_area()\n    # test_reverse_words()\n    # test_reverse_sentence()\n    # test_convert_list_to_tree()\n    # test_convert_tree_to_list()\n    # test_is_palindrome_by_stack()\n    # test_is_palindrome_by_recursion()\n    # test_max"}
{"task_id": "leetcode/217", "completion": "\n    return len(nums)!= len(set(nums))\n\ndef findMin(nums):\n    '''\n    给定一个整数数组 nums ，找到和最小的元素并返回其索引。 如果数组中存在唯一的一个最小元素，那么返回该最小元素的索引。 否则，返回 -1 。\n    >>> findMin([4,5,6,7,0,1,2])\n    4\n    >>> findMin([4,5,6,7,8,3,2])\n    2\n    '''\n    return min(nums) if len(nums) > 0 else -1\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少有一个重复的整数存在", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef findMin(nums):\n    '''\n    给定一个整数数组 nums ，找到和最小的元素并返回其索引。 如果数组中存在唯一的一个最小元素，那么返回该最小元素的索引。 否则，返回 -1 。\n    >>> findMin([4,5,6,7,0,1,2])\n    4\n    >>> findMin([4,5,6,7,8,3,2])\n    2\n    '''\n    return min(nums) if len(nums) > 0 else -1\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少有一个重复的整数存在"}
{"task_id": "leetcode/217", "completion": "\n    dic = {}\n    for i in nums:\n        if i in dic:\n            return True\n        else:\n            dic[i] = True\n    return False\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(list(set(nums)))!= len(nums)\n\ndef longestPalindrome(s):\n    '''\n    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n    示例 1：\n    输入: \"babad\"\n    输出: \"bab\"\n    ", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    dic = {}\n    for i in nums:\n        if i in dic:\n            return True\n        else:\n            dic[i] = True\n    return False\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(list(set(nums)))!= len(nums)\n\ndef longestPalindrome(s):\n    '''\n    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n    示例 1：\n    输入: \"babad\"\n    输出: \"bab\"\n    "}
{"task_id": "leetcode/217", "completion": "\n    if not nums:\n        return False\n    from collections import Counter\n    c = Counter(nums)\n    return any(x > 1 for x in c.values())\n\ndef twoSum1(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target, 请你在该数组中找出 和为目标值 的那 两个 整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    >>> twoSum1([2,7,11,15], 9)\n    [0, 1]\n    >>> twoSum1([2,3,4], 6)\n    [1, 2]\n    '''\n    # 因为含有重复元素, 所以哈希", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    if not nums:\n        return False\n    from collections import Counter\n    c = Counter(nums)\n    return any(x > 1 for x in c.values())\n\ndef twoSum1(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target, 请你在该数组中找出 和为目标值 的那 两个 整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    >>> twoSum1([2,7,11,15], 9)\n    [0, 1]\n    >>> twoSum1([2,3,4], 6)\n    [1, 2]\n    '''\n    # 因为含有重复元素, 所以哈希"}
{"task_id": "leetcode/217", "completion": "\n    table = {}\n    for item in nums: \n        if item in table: \n            return True\n        else: \n            table[item] = 1\n    return False\n\ndef maxSubArray(nums: List[int]) -> int:\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例:\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1,2])\n    3\n    '''\n    if len(nums)==0: \n        return ", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    table = {}\n    for item in nums: \n        if item in table: \n            return True\n        else: \n            table[item] = 1\n    return False\n\ndef maxSubArray(nums: List[int]) -> int:\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例:\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1,2])\n    3\n    '''\n    if len(nums)==0: \n        return "}
{"task_id": "leetcode/217", "completion": "\n    length = len(nums)\n    for i in range(length):\n        for j in range(i+1,length):\n            if nums[i] == nums[j]:\n                return True\n    return False\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target, 请你在该数组中找出 和为目标值 target 的那 两个 整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([3, 2, 4], 6)\n    [1, 2]\n    '''\n    # 假设有num", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    length = len(nums)\n    for i in range(length):\n        for j in range(i+1,length):\n            if nums[i] == nums[j]:\n                return True\n    return False\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target, 请你在该数组中找出 和为目标值 target 的那 两个 整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([3, 2, 4], 6)\n    [1, 2]\n    '''\n    # 假设有num"}
{"task_id": "leetcode/697", "completion": "\n    if not nums:\n        return 0\n    hashmap = collections.Counter(nums)\n    degree = max(hashmap.values())\n    sub_array = [nums[0]] * degree\n    start, end = 0, 0\n    for index, (num, count) in enumerate(hashmap.items()):\n        if count == degree:\n            sub_array[index] = num\n        if count < degree:\n            end = index\n            continue\n        while sub_array[start]!= num:\n            while end!= index:\n                if sub_array[end] == num:\n                    sub_array[start] = num\n                    start += 1\n                    break\n                end -= 1\n            else:\n                start += 1\n    return end - start + 1\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    _test()\n```\n\n\n```python\nclass Solution(object):\n    def findShortestSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    if not nums:\n        return 0\n    hashmap = collections.Counter(nums)\n    degree = max(hashmap.values())\n    sub_array = [nums[0]] * degree\n    start, end = 0, 0\n    for index, (num, count) in enumerate(hashmap.items()):\n        if count == degree:\n            sub_array[index] = num\n        if count < degree:\n            end = index\n            continue\n        while sub_array[start]!= num:\n            while end!= index:\n                if sub_array[end] == num:\n                    sub_array[start] = num\n                    start += 1\n                    break\n                end -= 1\n            else:\n                start += 1\n    return end - start + 1\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    _test()\n```\n\n\n```python\nclass Solution(object):\n    def findShortestSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\""}
{"task_id": "leetcode/697", "completion": "\n    length = len(nums)\n    if length == 1:\n        return 1\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    data = collections.Counter(nums)\n    maxNum, maxCount = max(data.values())\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    if maxNum == 1:\n        # 如果数组中没有重复元素，直接返回数组的长度\n        return length\n    countDict = {}\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    for k, v in data.items():\n        countDict[k] = v\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    total = 0\n    result = length\n    pre = 0\n    for k, v in countDict.items():\n        pre = max(pre, v)\n        if v == maxCount and pre <= result:", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    length = len(nums)\n    if length == 1:\n        return 1\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    data = collections.Counter(nums)\n    maxNum, maxCount = max(data.values())\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    if maxNum == 1:\n        # 如果数组中没有重复元素，直接返回数组的长度\n        return length\n    countDict = {}\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    for k, v in data.items():\n        countDict[k] = v\n    # 统计每个数字出现的次数，并记录出现次数最多的一个数\n    total = 0\n    result = length\n    pre = 0\n    for k, v in countDict.items():\n        pre = max(pre, v)\n        if v == maxCount and pre <= result:"}
{"task_id": "leetcode/697", "completion": "\n    # 遍历频数\n    freq = collections.Counter(nums)\n    most_ = max(freq.values())\n    # 存储度\n    degree = {num:0 for num in nums}\n    # 优先检测最高频的元素\n    for i in range(len(nums)):\n        if freq[nums[i]] == most_:\n            degree[nums[i]] += 1\n    # 找到度最高的元素\n    # degree 的 key 是 nums 的元素\n    # degree 的 value 是 nums 元素在 nums 中出现的频度\n    # 使用 key 是因为可以快速找到 nums 中最高频的元素\n    most_element = [num for num in degree if degree[num] == most_][0]\n\n    # 对 nums 中除了 most_element 之外的元素,\n    # 遍历 degree 中的元素, 将 degree 中值更小", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 遍历频数\n    freq = collections.Counter(nums)\n    most_ = max(freq.values())\n    # 存储度\n    degree = {num:0 for num in nums}\n    # 优先检测最高频的元素\n    for i in range(len(nums)):\n        if freq[nums[i]] == most_:\n            degree[nums[i]] += 1\n    # 找到度最高的元素\n    # degree 的 key 是 nums 的元素\n    # degree 的 value 是 nums 元素在 nums 中出现的频度\n    # 使用 key 是因为可以快速找到 nums 中最高频的元素\n    most_element = [num for num in degree if degree[num] == most_][0]\n\n    # 对 nums 中除了 most_element 之外的元素,\n    # 遍历 degree 中的元素, 将 degree 中值更小"}
{"task_id": "leetcode/697", "completion": "\n    # write code here\n    degree = collections.Counter(nums).most_common()\n    degree = degree[0][1]\n    ans = len(nums)\n\n    count = [0] * len(nums)\n    for i in range(len(nums)):\n        count[nums[i]-1] += 1\n        ans = min(ans, count[nums[i]-1])\n    \n    ans = min(ans, len(nums) - ans)\n    return ans\n    '''\n    ['1','2','2','3','1']\n    nums:  [1, 2, 2, 3, 1]\n    count:  [1, 1, 2, 1, 1]\n    ['2','3','1']\n    count:  [2, 1, 1]\n    '''\n# @lc idea=end\n\n# @lc group=\n\n# @lc rank=\n\n\n# @lc code=start\nclass Solution:\n    def findShortestSubArray(self, nums: List[int]) -> int:\n        from collections import Counter\n        if not nums:\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # write code here\n    degree = collections.Counter(nums).most_common()\n    degree = degree[0][1]\n    ans = len(nums)\n\n    count = [0] * len(nums)\n    for i in range(len(nums)):\n        count[nums[i]-1] += 1\n        ans = min(ans, count[nums[i]-1])\n    \n    ans = min(ans, len(nums) - ans)\n    return ans\n    '''\n    ['1','2','2','3','1']\n    nums:  [1, 2, 2, 3, 1]\n    count:  [1, 1, 2, 1, 1]\n    ['2','3','1']\n    count:  [2, 1, 1]\n    '''\n# @lc idea=end\n\n# @lc group=\n\n# @lc rank=\n\n\n# @lc code=start\nclass Solution:\n    def findShortestSubArray(self, nums: List[int]) -> int:\n        from collections import Counter\n        if not nums:\n"}
{"task_id": "leetcode/697", "completion": "\n    counts = collections.Counter(nums)\n    degrees = [degree for num, degree in counts.items() if degree == counts.most_common()[0][1]]\n    if len(degrees) == 0:\n        return 0\n    else:\n        max_degree = max(degrees)\n        ans = -1\n        for i in range(len(nums)):\n            if nums[i] in degrees: \n                count = 1\n                for j in range(i+1, len(nums)):\n                    if nums[j] in degrees:\n                        count += 1\n                    if count >= max_degree:\n                        ans = i - j +1 \n                        break\n                if ans!= -1:\n                    break\n        return ans\n```\n### 思路1：桶排序 + 贪心\n- 桶排序思想\n- 找出出现次数最多的数字，并把这个数字出现的次数存入数组中，那么对应位置的值就是出现该值最多的次", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    counts = collections.Counter(nums)\n    degrees = [degree for num, degree in counts.items() if degree == counts.most_common()[0][1]]\n    if len(degrees) == 0:\n        return 0\n    else:\n        max_degree = max(degrees)\n        ans = -1\n        for i in range(len(nums)):\n            if nums[i] in degrees: \n                count = 1\n                for j in range(i+1, len(nums)):\n                    if nums[j] in degrees:\n                        count += 1\n                    if count >= max_degree:\n                        ans = i - j +1 \n                        break\n                if ans!= -1:\n                    break\n        return ans\n```\n### 思路1：桶排序 + 贪心\n- 桶排序思想\n- 找出出现次数最多的数字，并把这个数字出现的次数存入数组中，那么对应位置的值就是出现该值最多的次"}
{"task_id": "leetcode/697", "completion": "\n    # [1,2,2,3,1,4,2]\n    # 1[1,2,2,3,1]\n    # 2[1,2,2,3]\n    # 3[1,2,2]\n    # 4[1,2]\n    # 5[1]\n    # 6[1,4,2]\n    freq = collections.Counter(nums)\n    maxLen = len(nums)\n    for v, cnt in freq.items():\n        if cnt == maxLen:\n            return maxLen\n        index = nums.index(v)\n        s = 0\n        e = 0\n        i = 0\n        cnt = 0\n        while i < len(nums):\n            cnt += 1\n            if i == index:\n                s = e\n            e = e + 1\n            if cnt == cnt:\n                break\n            i += 1\n    return maxLen\n\n\nif __name__ == '__main__':\n    print(findShortestSubArray([1,2,2,3,1]))\n    print(findShortestSubArray([", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # [1,2,2,3,1,4,2]\n    # 1[1,2,2,3,1]\n    # 2[1,2,2,3]\n    # 3[1,2,2]\n    # 4[1,2]\n    # 5[1]\n    # 6[1,4,2]\n    freq = collections.Counter(nums)\n    maxLen = len(nums)\n    for v, cnt in freq.items():\n        if cnt == maxLen:\n            return maxLen\n        index = nums.index(v)\n        s = 0\n        e = 0\n        i = 0\n        cnt = 0\n        while i < len(nums):\n            cnt += 1\n            if i == index:\n                s = e\n            e = e + 1\n            if cnt == cnt:\n                break\n            i += 1\n    return maxLen\n\n\nif __name__ == '__main__':\n    print(findShortestSubArray([1,2,2,3,1]))\n    print(findShortestSubArray(["}
{"task_id": "leetcode/697", "completion": "\n    result = {}\n    for i, num in enumerate(nums):\n        if num not in result:\n            result[num] = [i]\n        else:\n            result[num].append(i)\n    maxSize = -1\n    maxStart, maxEnd = -1, -1\n    for value in result.values():\n        if len(value) > maxSize:\n            maxSize = len(value)\n            maxStart, maxEnd = value[0], value[-1]", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    result = {}\n    for i, num in enumerate(nums):\n        if num not in result:\n            result[num] = [i]\n        else:\n            result[num].append(i)\n    maxSize = -1\n    maxStart, maxEnd = -1, -1\n    for value in result.values():\n        if len(value) > maxSize:\n            maxSize = len(value)\n            maxStart, maxEnd = value[0], value[-1]"}
{"task_id": "leetcode/697", "completion": "\n    # 首先在nums中查找所有数字出现的最大次数\n    # 查找并返回出现次数最多的数字\n    # 然后在数组中查找这个数字出现的最小位置\n    # 最后计算从这个位置往后的连续的数字出现的次数，是否小于这个数字出现的次数\n    # 如果是，那么更新答案，最后找到这个数字出现的最小位置\n    # 记录答案\n    # 最后返回答案\n    max_count = max([nums.count(n) for n in set(nums)])\n    min_position = 0\n    result = []\n    for i, n in enumerate(nums):\n        # 如果是最大出现次数的元素，那么比较是否小于最大出现数\n        if nums.count(n) == max_count:\n            min_position =", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 首先在nums中查找所有数字出现的最大次数\n    # 查找并返回出现次数最多的数字\n    # 然后在数组中查找这个数字出现的最小位置\n    # 最后计算从这个位置往后的连续的数字出现的次数，是否小于这个数字出现的次数\n    # 如果是，那么更新答案，最后找到这个数字出现的最小位置\n    # 记录答案\n    # 最后返回答案\n    max_count = max([nums.count(n) for n in set(nums)])\n    min_position = 0\n    result = []\n    for i, n in enumerate(nums):\n        # 如果是最大出现次数的元素，那么比较是否小于最大出现数\n        if nums.count(n) == max_count:\n            min_position ="}
{"task_id": "leetcode/697", "completion": "\n    counts = collections.Counter(nums)\n    maxCount, maxCountIndex = max([(v, k) for k, v in counts.items()])\n    return findSubarray(nums, maxCount, maxCountIndex)\n\n\ndef findSubarray(nums, maxCount, maxCountIndex):\n    start, end = 0, 1\n    while end < len(nums):\n        if nums[end] == maxCountIndex:\n            end += 1\n            continue\n        if nums[start] == maxCountIndex:\n            start += 1\n        else:\n            end += 1\n    return end - start\n\n\nif __name__ == \"__main__\":\n    # print(findShortestSubArray([1,2,2,3,1]))\n    print(findSubarray([1,2,2,3,1,4,2], 3, 2))\n    print(findSubarray([1,2,2,3,1,4,2], 2, 3))\n    # print(findSubarray([1,2,2,3,1,4,2], 4, 2))\n    # print(findShortestSub", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    counts = collections.Counter(nums)\n    maxCount, maxCountIndex = max([(v, k) for k, v in counts.items()])\n    return findSubarray(nums, maxCount, maxCountIndex)\n\n\ndef findSubarray(nums, maxCount, maxCountIndex):\n    start, end = 0, 1\n    while end < len(nums):\n        if nums[end] == maxCountIndex:\n            end += 1\n            continue\n        if nums[start] == maxCountIndex:\n            start += 1\n        else:\n            end += 1\n    return end - start\n\n\nif __name__ == \"__main__\":\n    # print(findShortestSubArray([1,2,2,3,1]))\n    print(findSubarray([1,2,2,3,1,4,2], 3, 2))\n    print(findSubarray([1,2,2,3,1,4,2], 2, 3))\n    # print(findSubarray([1,2,2,3,1,4,2], 4, 2))\n    # print(findShortestSub"}
{"task_id": "leetcode/697", "completion": "\n    cnts = collections.Counter(nums)\n    ans = float('inf')\n    d = {}  # {k: [v1, v2,...],...}\n    for num, cnt in cnts.items():\n        if cnt == 1:\n            continue\n        d[num] = []\n        for i in range(len(nums)):\n            if nums[i] == num:\n                d[num].append(i)\n        s = d[num][-1] - d[num][0]\n        if s + 1 < ans and cnt == len(d[num]):\n            ans = s + 1\n    return ans\n\n# 812. Largest Triangle Area\ndef largestTriangleArea(points):\n    '''\n    给定包含多个点的集合，画出这些点连成的多边形，围成的面积就是所求。\n    考虑一个包含4个点且经过这4个点的某条直线，因为存在直角三角形，所以至少��", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    cnts = collections.Counter(nums)\n    ans = float('inf')\n    d = {}  # {k: [v1, v2,...],...}\n    for num, cnt in cnts.items():\n        if cnt == 1:\n            continue\n        d[num] = []\n        for i in range(len(nums)):\n            if nums[i] == num:\n                d[num].append(i)\n        s = d[num][-1] - d[num][0]\n        if s + 1 < ans and cnt == len(d[num]):\n            ans = s + 1\n    return ans\n\n# 812. Largest Triangle Area\ndef largestTriangleArea(points):\n    '''\n    给定包含多个点的集合，画出这些点连成的多边形，围成的面积就是所求。\n    考虑一个包含4个点且经过这4个点的某条直线，因为存在直角三角形，所以至少��"}
{"task_id": "leetcode/832", "completion": "\n    new = [[],[],[]]\n    for i in range(len(image)):\n        for j in range(len(image)):\n            if image[i][j] == 1:\n                new[i].append(0)\n            else:\n                new[i].append(1)\n        for k in range(len(new[i])):\n            if new[i][k] == 1:\n                new[i][k] = 0\n            else:\n                new[i][k] = 1\n    return new\n\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n    print(flipAndInvertImage([[1,0,0],[0,1,0],[1,1,1]]))\n    print(flipAndInvertImage([[0,0,0],[0,1,1],[1,0,1]]))\n    print(flipAndInvertImage([[1,1,0,0],[1,0,0,", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    new = [[],[],[]]\n    for i in range(len(image)):\n        for j in range(len(image)):\n            if image[i][j] == 1:\n                new[i].append(0)\n            else:\n                new[i].append(1)\n        for k in range(len(new[i])):\n            if new[i][k] == 1:\n                new[i][k] = 0\n            else:\n                new[i][k] = 1\n    return new\n\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n    print(flipAndInvertImage([[1,0,0],[0,1,0],[1,1,1]]))\n    print(flipAndInvertImage([[0,0,0],[0,1,1],[1,0,1]]))\n    print(flipAndInvertImage([[1,1,0,0],[1,0,0,"}
{"task_id": "leetcode/832", "completion": "\n    # https://leetcode.com/problems/flip-and-invert-image/discuss/316266/Python-Clean-10-lines-recursion-with-explain.\n    # This can be solved in O(n) time.\n    n,m = len(image),len(image[0])\n    image = [image[i][::-1] for i in range(n)]\n    for i in range(n):\n     for j in range(m):\n      image[i][j] = image[i][j] ^ 1\n    return image\n\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        '''\n        Given a positive integer num consisting only of digits 6 and 9.\n        Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n        >>> maximum69Number(9669)\n        9969\n        '''\n        s = str(num)\n        for i in range(len(s)):\n           ", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # https://leetcode.com/problems/flip-and-invert-image/discuss/316266/Python-Clean-10-lines-recursion-with-explain.\n    # This can be solved in O(n) time.\n    n,m = len(image),len(image[0])\n    image = [image[i][::-1] for i in range(n)]\n    for i in range(n):\n     for j in range(m):\n      image[i][j] = image[i][j] ^ 1\n    return image\n\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        '''\n        Given a positive integer num consisting only of digits 6 and 9.\n        Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n        >>> maximum69Number(9669)\n        9969\n        '''\n        s = str(num)\n        for i in range(len(s)):\n           "}
{"task_id": "leetcode/832", "completion": "\n    m, n = len(image), len(image[0])\n    for i in range(m):\n        for j in range(n):\n            image[i][j] = (not image[i][j]) if j < n//2 else (image[i][j])\n    return image\n\nif __name__ == \"__main__\":\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n'''\nclass Solution(object):\n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # M1. 模拟\n        # O(mn)\n        # 在图像中的每个位置上，我们取反它的颜色值，然后水平翻转图像。\n        m, n = len(A), len(A[0])\n        A = [[(A[i][j] + 1) %", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    m, n = len(image), len(image[0])\n    for i in range(m):\n        for j in range(n):\n            image[i][j] = (not image[i][j]) if j < n//2 else (image[i][j])\n    return image\n\nif __name__ == \"__main__\":\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n'''\nclass Solution(object):\n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # M1. 模拟\n        # O(mn)\n        # 在图像中的每个位置上，我们取反它的颜色值，然后水平翻转图像。\n        m, n = len(A), len(A[0])\n        A = [[(A[i][j] + 1) %"}
{"task_id": "leetcode/832", "completion": "\n    # transpose\n    # matrix = [list(x) for x in zip(*image)]\n    # invert\n    # matrix = [list(map(lambda x: 0 if x==1 else 1, x)) for x in matrix]\n    # transpose\n    matrix = [list(x) for x in zip(*image)]\n    matrix[::-1]\n    # invert\n    matrix = [list(map(lambda x: 0 if x==1 else 1, x)) for x in matrix]\n    return matrix\n    \ndef flipAndInvertImage(self, image):\n        \"\"\"\n        :type image: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return [[int(self.flip(x)) ^ 1 for x in row] for row in image[::-1]]\n\n    def flip(self, x):\n        return 1 - x\n\n# Solution 2, Flip and invert in one step without transpose\ndef flipAndInvertImage(self, image):\n        \"\"\"\n        :type image: List[", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # transpose\n    # matrix = [list(x) for x in zip(*image)]\n    # invert\n    # matrix = [list(map(lambda x: 0 if x==1 else 1, x)) for x in matrix]\n    # transpose\n    matrix = [list(x) for x in zip(*image)]\n    matrix[::-1]\n    # invert\n    matrix = [list(map(lambda x: 0 if x==1 else 1, x)) for x in matrix]\n    return matrix\n    \ndef flipAndInvertImage(self, image):\n        \"\"\"\n        :type image: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return [[int(self.flip(x)) ^ 1 for x in row] for row in image[::-1]]\n\n    def flip(self, x):\n        return 1 - x\n\n# Solution 2, Flip and invert in one step without transpose\ndef flipAndInvertImage(self, image):\n        \"\"\"\n        :type image: List["}
{"task_id": "leetcode/832", "completion": "\n    image = image[::-1]\n    image = [list(map(lambda x: 1-x, row)) for row in image]\n    return image\n\n\n# Given an array of integers nums and an integer val,\n# remove all occurrences of val in nums in-place,\n# that is, modify nums so that nums[i]!= val for all i in the array.\n# The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n# Return the new length of the array.\ndef removeElement(nums, val):\n    nums[:] = [n for n in nums if n!= val]\n    return len(nums)\n\n# Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\ndef wordBreak(s, wordDict):\n    n = len(s)\n    DP = [False]*(n+1)\n    DP[0] = True\n    for i in range(1,n+1):\n        for j", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image = image[::-1]\n    image = [list(map(lambda x: 1-x, row)) for row in image]\n    return image\n\n\n# Given an array of integers nums and an integer val,\n# remove all occurrences of val in nums in-place,\n# that is, modify nums so that nums[i]!= val for all i in the array.\n# The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n# Return the new length of the array.\ndef removeElement(nums, val):\n    nums[:] = [n for n in nums if n!= val]\n    return len(nums)\n\n# Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\ndef wordBreak(s, wordDict):\n    n = len(s)\n    DP = [False]*(n+1)\n    DP[0] = True\n    for i in range(1,n+1):\n        for j"}
{"task_id": "leetcode/832", "completion": "\n    return [[1 - val for val in row[::-1]] for row in image]\n    # or\n    # return [[1 - val for val in row[::-1]] for row in image]\n\n    # return [list(map(lambda x: 1 - x, row[::-1])) for row in image]\n\n    # return [list(x) for x in map(lambda y: list(map(lambda x: 1 - x, y[::-1])), image)]\n\n\ndef largestTimeFromDigits(A):\n    '''\n    Return the largest 4-digit number that can be formed by the digits used.\n    time complexity: O(n)\n    >>> largestTimeFromDigits([1,2,3,4])\n    '23:41'\n    >>> largestTimeFromDigits([5,5,5,5])\n    ''\n    '''\n    def isValidTime(t):\n        if 0 <= t[0] <= 2 and 0 <= t[1] <= 9 and 0 <= t[2] <= 5 and 0 <= t", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [[1 - val for val in row[::-1]] for row in image]\n    # or\n    # return [[1 - val for val in row[::-1]] for row in image]\n\n    # return [list(map(lambda x: 1 - x, row[::-1])) for row in image]\n\n    # return [list(x) for x in map(lambda y: list(map(lambda x: 1 - x, y[::-1])), image)]\n\n\ndef largestTimeFromDigits(A):\n    '''\n    Return the largest 4-digit number that can be formed by the digits used.\n    time complexity: O(n)\n    >>> largestTimeFromDigits([1,2,3,4])\n    '23:41'\n    >>> largestTimeFromDigits([5,5,5,5])\n    ''\n    '''\n    def isValidTime(t):\n        if 0 <= t[0] <= 2 and 0 <= t[1] <= 9 and 0 <= t[2] <= 5 and 0 <= t"}
{"task_id": "leetcode/832", "completion": "\n    image = [list(i) for i in reversed(image)]\n    image = [((1 - i) for i in row) for row in image]\n    return image\n\nclass Solution:\n    \n    def dfs(self, image, i, j, m, n):\n        if image[i][j]:\n            image[i][j] = 0\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n:\n                    self.dfs(image, x, y, m, n)\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\n        if image[sr][sc] == newColor:\n            return image\n        m = len(image)\n        n = len(image[0])\n        image[sr][sc] = newColor\n        for i in range(m):\n            for", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image = [list(i) for i in reversed(image)]\n    image = [((1 - i) for i in row) for row in image]\n    return image\n\nclass Solution:\n    \n    def dfs(self, image, i, j, m, n):\n        if image[i][j]:\n            image[i][j] = 0\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n:\n                    self.dfs(image, x, y, m, n)\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\n        if image[sr][sc] == newColor:\n            return image\n        m = len(image)\n        n = len(image[0])\n        image[sr][sc] = newColor\n        for i in range(m):\n            for"}
{"task_id": "leetcode/832", "completion": "\n    res = []\n    for i in image:\n        j = []\n        for j in i:\n            res.append(0) if j == 1 else res.append(1)\n    return res\n```\n\n```python\n# Method 2:\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    res = []\n    for i in image:\n        j = []\n        for j in i:\n            res.append(0) if j == 1 else res.append(1)\n    return res\n```\n\n```python\n# Method 2:\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1"}
{"task_id": "leetcode/832", "completion": "\n    # Flip horizontally\n    image = [row[::-1] for row in image]\n\n    # Invert each value\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            image[i][j] = 1 - image[i][j]\n    return image\n\n# Tests\nimage = [\n    [1,1,0],\n    [1,0,1],\n    [0,0,0]\n]\nresult = flipAndInvertImage(image)\nprint(result)\n", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # Flip horizontally\n    image = [row[::-1] for row in image]\n\n    # Invert each value\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            image[i][j] = 1 - image[i][j]\n    return image\n\n# Tests\nimage = [\n    [1,1,0],\n    [1,0,1],\n    [0,0,0]\n]\nresult = flipAndInvertImage(image)\nprint(result)\n"}
{"task_id": "leetcode/832", "completion": "\n    # M1. \n    image=[list(reversed(i)) for i in image]\n    image=[[0 if i == 0 else 1 for i in j] for j in image]\n    return image\n\nclass Solution:\n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        A=[[0 if i == 0 else 1 for i in j] for j in A]\n        A=[list(reversed(i)) for i in A]\n        return A\n        \n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # M2.\n        A=[[0 if i == 0 else 1 for i in j] for j in A]\n        A=[[j[::-1] for j in A] for i in A]\n        return A\n\n    def flipAndInvert", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # M1. \n    image=[list(reversed(i)) for i in image]\n    image=[[0 if i == 0 else 1 for i in j] for j in image]\n    return image\n\nclass Solution:\n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        A=[[0 if i == 0 else 1 for i in j] for j in A]\n        A=[list(reversed(i)) for i in A]\n        return A\n        \n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # M2.\n        A=[[0 if i == 0 else 1 for i in j] for j in A]\n        A=[[j[::-1] for j in A] for i in A]\n        return A\n\n    def flipAndInvert"}
{"task_id": "leetcode/300", "completion": "\n    n = len(nums)\n    if n == 0: return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef coin_change(coins, amount):\n    '''\n    给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n    计算并返回可以凑成总金额所需的 最少的硬币个数\n    每种硬币的数量有无限。\n    题目保证结果一定存在。\n    示例\n    输入：coins = [1, 2, 5], amount = 11\n    ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    n = len(nums)\n    if n == 0: return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef coin_change(coins, amount):\n    '''\n    给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n    计算并返回可以凑成总金额所需的 最少的硬币个数\n    每种硬币的数量有无限。\n    题目保证结果一定存在。\n    示例\n    输入：coins = [1, 2, 5], amount = 11\n    "}
{"task_id": "leetcode/300", "completion": "\n    dp = [1] * len(nums)\n    for i, v in enumerate(nums):\n        for j in range(i):\n            if nums[j] < v:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个无序的整数数组，找到其中最长上升子序列的长度。\n    示例:\n    输入: [10,9,2,5,3,7,101,18]\n    输出: 4\n    解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n    说明:\n        可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n        你算法的时间", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [1] * len(nums)\n    for i, v in enumerate(nums):\n        for j in range(i):\n            if nums[j] < v:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个无序的整数数组，找到其中最长上升子序列的长度。\n    示例:\n    输入: [10,9,2,5,3,7,101,18]\n    输出: 4\n    解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n    说明:\n        可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n        你算法的时间"}
{"task_id": "leetcode/300", "completion": "\n    if not nums: return 0\n    dp = [1] * len(nums)\n    for i, num in enumerate(nums):\n        for j in range(i + 1):\n            if num > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef lengthOfLIS_2(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>>", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums: return 0\n    dp = [1] * len(nums)\n    for i, num in enumerate(nums):\n        for j in range(i + 1):\n            if num > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef lengthOfLIS_2(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>>"}
{"task_id": "leetcode/300", "completion": "\n    n = len(nums)\n    if n < 2:\n        return n\n    dp = [1] * n\n    for j in range(1, n):\n        for i in range(j):\n            if nums[i] < nums[j]:\n                dp[j] = max(dp[i] + 1, dp[j])\n    return max(dp)\n\n\ndef lengthOfLIS_1(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如, \n    \n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    n = len(nums)\n    if n < 2:\n        return n\n    dp = [1] * n\n    for j in range(1, n):\n        for i in range(j):\n            if nums[i] < nums[j]:\n                dp[j] = max(dp[i] + 1, dp[j])\n    return max(dp)\n\n\ndef lengthOfLIS_1(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如, \n    \n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,"}
{"task_id": "leetcode/300", "completion": "\n    # 二分法计算, 循环退出条件为尽可能选择最大的i的元素\n    nums = sorted(nums)\n    n = len(nums)\n    i, j, pre = 0, n - 1, -1e9\n    ans = 0\n    while i <= j:\n        mid = i + (j - i) // 2\n        if nums[mid] > pre:  # 缩小搜索范围\n            j = mid - 1\n            pre = nums[mid]\n            ans += 1\n        else:\n            i = mid + 1\n    return ans\n\n\ndef lengthOfLIS2(nums):\n    '''\n    >>> lengthOfLIS2([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS2([7,7,7,7,7,7,7])\n    1\n    '''\n    # ��", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # 二分法计算, 循环退出条件为尽可能选择最大的i的元素\n    nums = sorted(nums)\n    n = len(nums)\n    i, j, pre = 0, n - 1, -1e9\n    ans = 0\n    while i <= j:\n        mid = i + (j - i) // 2\n        if nums[mid] > pre:  # 缩小搜索范围\n            j = mid - 1\n            pre = nums[mid]\n            ans += 1\n        else:\n            i = mid + 1\n    return ans\n\n\ndef lengthOfLIS2(nums):\n    '''\n    >>> lengthOfLIS2([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS2([7,7,7,7,7,7,7])\n    1\n    '''\n    # ��"}
{"task_id": "leetcode/300", "completion": "\n    dp = [1 for i in range(len(nums))]\n    max_len = 1\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_len = max(max_len, dp[i])\n    return max_len\n\n\n'''\n850. 保证图可完全遍历  https://leetcode-cn.com/problems/minimum-cost-to-connect-all-points/\n\n给定一个点集，其中一个点是起始点，其余的点是目标点。\n\n找到从起始点到目标点的最短路径并返回其长度。所有点的坐标都是整数。\n\n每个点都可以通过一些步骤到达其他点：", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [1 for i in range(len(nums))]\n    max_len = 1\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_len = max(max_len, dp[i])\n    return max_len\n\n\n'''\n850. 保证图可完全遍历  https://leetcode-cn.com/problems/minimum-cost-to-connect-all-points/\n\n给定一个点集，其中一个点是起始点，其余的点是目标点。\n\n找到从起始点到目标点的最短路径并返回其长度。所有点的坐标都是整数。\n\n每个点都可以通过一些步骤到达其他点："}
{"task_id": "leetcode/300", "completion": "\n    # 用于存放序列中的数，即已经找到的最长子序列，且互相不重复\n    nums_list = [nums[0]]\n    lens = 1\n    # 用于存放序列的长度，即找到的最长子序列的长度，互相不重复\n    max_lens = 1\n    for num in nums[1:]:\n        if num > nums_list[-1]:\n            nums_list.append(num)\n            lens += 1\n            max_lens = max(max_lens, lens)\n        else:\n            left = 0\n            right = lens - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums_list[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left == lens:\n                nums_list.append(num", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # 用于存放序列中的数，即已经找到的最长子序列，且互相不重复\n    nums_list = [nums[0]]\n    lens = 1\n    # 用于存放序列的长度，即找到的最长子序列的长度，互相不重复\n    max_lens = 1\n    for num in nums[1:]:\n        if num > nums_list[-1]:\n            nums_list.append(num)\n            lens += 1\n            max_lens = max(max_lens, lens)\n        else:\n            left = 0\n            right = lens - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums_list[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left == lens:\n                nums_list.append(num"}
{"task_id": "leetcode/300", "completion": "\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        res[i] = 1\n        for j in range(i):\n            if nums[i] > nums[j]:\n                res[i] = max(res[i], res[j] + 1)\n    return max(res)\n\n\ndef divide(a, b):\n    '''\n    这个函数需要返回两个数的商和余数。\n\n    :param a: 第一个数。\n    :param b: 第二个数。\n    :returns: 分子和分母。\n    '''\n    if b!= 0:\n        q = a // b\n        r = a % b\n        return q, r\n\n\ndef divisor(n):\n    '''\n    返回一个列表，列表中存放 'n' 的所有约数。\n\n    :param n: 要计算的数。\n    :returns: 所有约数的列表。\n", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        res[i] = 1\n        for j in range(i):\n            if nums[i] > nums[j]:\n                res[i] = max(res[i], res[j] + 1)\n    return max(res)\n\n\ndef divide(a, b):\n    '''\n    这个函数需要返回两个数的商和余数。\n\n    :param a: 第一个数。\n    :param b: 第二个数。\n    :returns: 分子和分母。\n    '''\n    if b!= 0:\n        q = a // b\n        r = a % b\n        return q, r\n\n\ndef divisor(n):\n    '''\n    返回一个列表，列表中存放 'n' 的所有约数。\n\n    :param n: 要计算的数。\n    :returns: 所有约数的列表。\n"}
{"task_id": "leetcode/300", "completion": "\n    if len(nums) == 1:\n        return 1\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([0, 1, 0, 3, 2, 3]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if len(nums) == 1:\n        return 1\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([0, 1, 0, 3, 2, 3]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7"}
{"task_id": "leetcode/300", "completion": "\n    # dp[i] 表示以 i 为结尾的最长递增子序列的长度。\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([1", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # dp[i] 表示以 i 为结尾的最长递增子序列的长度。\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([1"}
{"task_id": "leetcode/414", "completion": "\n    from collections import Counter\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n    return nums[2] if len(nums) >= 3 else nums[0]\n\n\ndef thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n    return nums[2] if len(nums) >= 3 else nums[0]\n\n\ndef thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    from collections import Counter\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n    return nums[2] if len(nums) >= 3 else nums[0]\n\n\ndef thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n    return nums[2] if len(nums) >= 3 else nums[0]\n\n\ndef thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,"}
{"task_id": "leetcode/414", "completion": "\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    max1 = max(nums[:-2])\n    max2 = max(nums[-2:-1])\n    max3 = max(nums[-1:])\n    if max1 >= max2 >= max3:\n        return max1\n    elif max2 >= max1 >= max3:\n        return max2\n    else:\n        return max3\n\n\ndef removeElement(nums: List[int], val: int):\n    '''\n    删除排序数组中的重复元素，使得每个元素只出现一次，返回长度\n    >>> removeElement([1,1,2], 1)\n    2\n    '''\n    if not nums:\n        return 0\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        if nums[left] == val:\n            nums.pop(left)\n           ", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    max1 = max(nums[:-2])\n    max2 = max(nums[-2:-1])\n    max3 = max(nums[-1:])\n    if max1 >= max2 >= max3:\n        return max1\n    elif max2 >= max1 >= max3:\n        return max2\n    else:\n        return max3\n\n\ndef removeElement(nums: List[int], val: int):\n    '''\n    删除排序数组中的重复元素，使得每个元素只出现一次，返回长度\n    >>> removeElement([1,1,2], 1)\n    2\n    '''\n    if not nums:\n        return 0\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        if nums[left] == val:\n            nums.pop(left)\n           "}
{"task_id": "leetcode/414", "completion": "\n    n = len(nums)\n    # 如果数组大于 3 个, 排序就可以了\n    if n >= 3:\n        nums.sort()\n        return nums[-3]\n    # 如果数组大于等于 1 个, 并且数组大小小于等于 3 个, 需要特殊处理\n    if n:\n       ", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    n = len(nums)\n    # 如果数组大于 3 个, 排序就可以了\n    if n >= 3:\n        nums.sort()\n        return nums[-3]\n    # 如果数组大于等于 1 个, 并且数组大小小于等于 3 个, 需要特殊处理\n    if n:\n       "}
{"task_id": "leetcode/414", "completion": "\n    pass\n\n# 82. 删除排序链表中的重复元素 II\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: return head\n        first = head\n        second = first.next\n        for first, second in zip(first, second):\n            while second is not None and second.val == first.val:\n                second = second.next\n            if second is not None:\n                first.next = second\n                first = second\n        return head\n\n# 83. 删除排序链表中的重复元素\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: return head\n        first = head\n        second = first.next\n        for first, second in zip(first, second):\n", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    pass\n\n# 82. 删除排序链表中的重复元素 II\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: return head\n        first = head\n        second = first.next\n        for first, second in zip(first, second):\n            while second is not None and second.val == first.val:\n                second = second.next\n            if second is not None:\n                first.next = second\n                first = second\n        return head\n\n# 83. 删除排序链表中的重复元素\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: return head\n        first = head\n        second = first.next\n        for first, second in zip(first, second):\n"}
{"task_id": "leetcode/414", "completion": "\n    nums = filter(lambda x:x not in nums[:-1],nums)\n    return nums[-1]\n\ndef main():\n    \"\"\"\n    >>> \n    \"\"\"\n    \n\nif __name__ == '__main__':\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([1,2,2,3,3]))\n    print(thirdMax([2,2,3,1]))\n    print(thirdMax([1,2]))\n    print(thirdMax([2", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = filter(lambda x:x not in nums[:-1],nums)\n    return nums[-1]\n\ndef main():\n    \"\"\"\n    >>> \n    \"\"\"\n    \n\nif __name__ == '__main__':\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([1,2,2,3,3]))\n    print(thirdMax([2,2,3,1]))\n    print(thirdMax([1,2]))\n    print(thirdMax([2"}
{"task_id": "leetcode/414", "completion": "\n    first, second, third = float('-inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num <= first:\n            third = second\n            second = first\n            first = num\n        elif num <= second:\n            third = second\n            second = num\n        elif num <= third:\n            third = num\n    return third if third >= first else first\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例:\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n    '''\n    first, second = float('-inf'), float('-inf')", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    first, second, third = float('-inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num <= first:\n            third = second\n            second = first\n            first = num\n        elif num <= second:\n            third = second\n            second = num\n        elif num <= third:\n            third = num\n    return third if third >= first else first\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例:\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n    '''\n    first, second = float('-inf'), float('-inf')"}
{"task_id": "leetcode/414", "completion": "\n    nums = set(nums)\n    numbers = [num for num in nums if num not in (max(nums), max(nums, key=lambda x: nums.count(x)))]\n    return sorted(numbers, reverse=True)[0] if  len(numbers) else max(nums)\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    thirdMax(array=[3, 2, 1])\n    thirdMax(array=[1, 2])\n    thirdMax(array=[2, 2, 3, 1])\n    thirdMax(array=[1, 1, 2, 3, 3])\n    thirdMax(array=[2, 2, 3])\n    thirdMax(array=[3, 2, 1, 3, 2])\n    thirdMax(array=[2, 2, 3, 1, 3, 3])\n    thirdMax(array=[2, 2, 3, 3, 3, ", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = set(nums)\n    numbers = [num for num in nums if num not in (max(nums), max(nums, key=lambda x: nums.count(x)))]\n    return sorted(numbers, reverse=True)[0] if  len(numbers) else max(nums)\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    thirdMax(array=[3, 2, 1])\n    thirdMax(array=[1, 2])\n    thirdMax(array=[2, 2, 3, 1])\n    thirdMax(array=[1, 1, 2, 3, 3])\n    thirdMax(array=[2, 2, 3])\n    thirdMax(array=[3, 2, 1, 3, 2])\n    thirdMax(array=[2, 2, 3, 1, 3, 3])\n    thirdMax(array=[2, 2, 3, 3, 3, "}
{"task_id": "leetcode/414", "completion": "\n    first, second, third = -sys.maxsize, -sys.maxsize, -sys.maxsize\n    for num in nums:\n        if num <= first: continue\n        if num == second or num == third: continue\n        third, second, first = second, first, num\n    if first == -sys.maxsize:\n        return max(nums)\n    else:\n        return first\n```\n\n## 1288.统计「优美子数组」\n\n[原题链接](https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/)\n\n### 思路\n\n贪心，从头考虑每个字符开始，每当有一个字符的个数比上一次更多时，则说明这个字符不是「优美子数组」，则减少上一次出现过的字符；\n\n**重点来了：当字符的个数", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    first, second, third = -sys.maxsize, -sys.maxsize, -sys.maxsize\n    for num in nums:\n        if num <= first: continue\n        if num == second or num == third: continue\n        third, second, first = second, first, num\n    if first == -sys.maxsize:\n        return max(nums)\n    else:\n        return first\n```\n\n## 1288.统计「优美子数组」\n\n[原题链接](https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/)\n\n### 思路\n\n贪心，从头考虑每个字符开始，每当有一个字符的个数比上一次更多时，则说明这个字符不是「优美子数组」，则减少上一次出现过的字符；\n\n**重点来了：当字符的个数"}
{"task_id": "leetcode/414", "completion": "\n    nums.sort(reverse=True)\n    third, second, first = nums[0], nums[1], nums[2]\n    for i in range(3):\n        if nums[i] >= first:\n            third = second\n            second = first\n            first = nums[i]\n    return third\n\n\ndef isValidSudoku(board):\n    '''\n    判断一个9*9 的数独是否有效。只需要判断每一行，每一列，每一个3*3正方形 是否符合要求即可。\n    行，列，正方形 中只能含有数字 1-9，且不允许出现重复数字。\n    >>> isValidSudoku(\n    [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n    [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n    [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums.sort(reverse=True)\n    third, second, first = nums[0], nums[1], nums[2]\n    for i in range(3):\n        if nums[i] >= first:\n            third = second\n            second = first\n            first = nums[i]\n    return third\n\n\ndef isValidSudoku(board):\n    '''\n    判断一个9*9 的数独是否有效。只需要判断每一行，每一列，每一个3*3正方形 是否符合要求即可。\n    行，列，正方形 中只能含有数字 1-9，且不允许出现重复数字。\n    >>> isValidSudoku(\n    [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n    [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n    [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\""}
{"task_id": "leetcode/414", "completion": "\n    nums = sorted(set(nums))\n    first, sec, third = 0, 0, 0\n    for i in nums:\n        if i > first:\n            third = sec\n            sec = first\n            first = i\n        elif i > sec and i!= first:\n            third = sec\n            sec = i\n        elif i > third and i!= first and i!= sec:\n            third = i\n    return third if third > 0 else first\n\n\nif __name__ == '__main__':\n    print(thirdMax([3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, ", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = sorted(set(nums))\n    first, sec, third = 0, 0, 0\n    for i in nums:\n        if i > first:\n            third = sec\n            sec = first\n            first = i\n        elif i > sec and i!= first:\n            third = sec\n            sec = i\n        elif i > third and i!= first and i!= sec:\n            third = i\n    return third if third > 0 else first\n\n\nif __name__ == '__main__':\n    print(thirdMax([3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, "}
{"task_id": "leetcode/961", "completion": "\n    c = collections.Counter(nums)\n    return [k for k,", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    c = collections.Counter(nums)\n    return [k for k,"}
{"task_id": "leetcode/961", "completion": "\n    hashmap = collections.Counter(nums)\n    return max(hashmap, key=hashmap.get)\n\n\nclass TestSolution(unittest.TestCase):\n    def test_repeatedNTimes(self):\n        self.assertEqual(repeatedNTimes([1,2,3,3]), 3)\n        self.assertEqual(repeatedNTimes([2,1,2,5,3,2]), 2)\n        self.assertEqual(repeatedNTimes([5,1,5,2,5,3,5,4]), 5)\n        self.assertEqual(repeatedNTimes([10,2,8,9,10]), 10)\n\n\nif __name__ == \"__", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    hashmap = collections.Counter(nums)\n    return max(hashmap, key=hashmap.get)\n\n\nclass TestSolution(unittest.TestCase):\n    def test_repeatedNTimes(self):\n        self.assertEqual(repeatedNTimes([1,2,3,3]), 3)\n        self.assertEqual(repeatedNTimes([2,1,2,5,3,2]), 2)\n        self.assertEqual(repeatedNTimes([5,1,5,2,5,3,5,4]), 5)\n        self.assertEqual(repeatedNTimes([10,2,8,9,10]), 10)\n\n\nif __name__ == \"__"}
{"task_id": "leetcode/961", "completion": "\n    for num in nums:\n        if num not in nums[1:]:\n            return num\n    return None\n\ndef repeatedNTimes2(nums):\n    '''\n    >>> repeatedNTimes2([1,2,3,3])\n    3\n    '''\n    counts = collections.Counter(num for num in nums)\n    for num in nums:\n        if counts[num] == 2:\n            return num\n    return None\n\ndef repeatedNTimes3(nums):\n    '''\n    >>> repeatedNTimes3([1,2,3,3])\n    3\n    '''\n    hashMap = {}\n    for num in nums:\n        if num not in hashMap:\n            hashMap[num] = 1\n        else:\n            return num\n    return None\n\ndef repeatedNTimes4(nums):\n    '''\n    >>> repeatedNTimes4([1,2,3,3])\n    3\n    '''\n    for num in nums:\n        while nums.count(num) > 1:\n            return num\n        else:\n            continue", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    for num in nums:\n        if num not in nums[1:]:\n            return num\n    return None\n\ndef repeatedNTimes2(nums):\n    '''\n    >>> repeatedNTimes2([1,2,3,3])\n    3\n    '''\n    counts = collections.Counter(num for num in nums)\n    for num in nums:\n        if counts[num] == 2:\n            return num\n    return None\n\ndef repeatedNTimes3(nums):\n    '''\n    >>> repeatedNTimes3([1,2,3,3])\n    3\n    '''\n    hashMap = {}\n    for num in nums:\n        if num not in hashMap:\n            hashMap[num] = 1\n        else:\n            return num\n    return None\n\ndef repeatedNTimes4(nums):\n    '''\n    >>> repeatedNTimes4([1,2,3,3])\n    3\n    '''\n    for num in nums:\n        while nums.count(num) > 1:\n            return num\n        else:\n            continue"}
{"task_id": "leetcode/961", "completion": "\n    temp = collections.Counter(nums)\n    for k, v in temp.items():\n        if v == len(nums) // 2:\n            return k\n\n#%%\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return [i for i in nums if nums.count(i) > len(nums) // 2][0]\n\n### collections.Counter\n#%%\nimport collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    temp = collections.Counter(nums)\n    for k, v in temp.items():\n        if v == len(nums) // 2:\n            return k\n\n#%%\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return [i for i in nums if nums.count(i) > len(nums) // 2][0]\n\n### collections.Counter\n#%%\nimport collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返"}
{"task_id": "leetcode/961", "completion": "\n    # write your code here\n    res,count = collections.Counter(nums).most_common(1)[0]\n    return res if count >= 2*len(nums)//len(nums) else -1\n\n\n# 3.2 寻找重复数字 https://leetcode-cn.com/problems/find-the-duplicate-number/\ndef findNubmer(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 区间内，可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n    进阶：你能尝试不使用额外空间吗？你可以认为输入数组不包含重复的元素。\n    Return the duplicated number in the nums.\n    >>> find", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # write your code here\n    res,count = collections.Counter(nums).most_common(1)[0]\n    return res if count >= 2*len(nums)//len(nums) else -1\n\n\n# 3.2 寻找重复数字 https://leetcode-cn.com/problems/find-the-duplicate-number/\ndef findNubmer(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 区间内，可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n    进阶：你能尝试不使用额外空间吗？你可以认为输入数组不包含重复的元素。\n    Return the duplicated number in the nums.\n    >>> find"}
{"task_id": "leetcode/961", "completion": "\n    counter = collections.Counter(nums)\n    for k,v in counter.items():\n        if v > 1:\n            return k\n```\n\n### 寻找数组的中间值\n\n有一个大小为 n 的数组, 返回数组中间值。如果数组中有多个中间值, 返回最小的那个。\n\n```python\n# 对撞指针\ndef findMedian(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[right]:\n            if arr[left] < arr[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        elif arr[mid] > arr[right]:\n            if arr[mid] > arr[left]:\n                right = mid\n           ", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    counter = collections.Counter(nums)\n    for k,v in counter.items():\n        if v > 1:\n            return k\n```\n\n### 寻找数组的中间值\n\n有一个大小为 n 的数组, 返回数组中间值。如果数组中有多个中间值, 返回最小的那个。\n\n```python\n# 对撞指针\ndef findMedian(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[right]:\n            if arr[left] < arr[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        elif arr[mid] > arr[right]:\n            if arr[mid] > arr[left]:\n                right = mid\n           "}
{"task_id": "leetcode/961", "completion": "\n    tmp = list(set(nums))\n    return tmp.count(tmp[0])*tmp[0]\n\ndef repeatedNTimes_2(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = []\n    for x in nums:\n        tmp.append(nums.count(x))\n    return max(tmp)*tmp[0]\n\ndef repeatedNTimes_3(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = collections.Counter(nums)\n    return tmp.most_common(1)[0][0]\n\ndef repeatedNTimes_4(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = collections.Counter(nums)\n    for item in tmp.items():\n        if item[1] == 2:\n            return item[0]\n    return -1\n\nif __name__=='__main__':\n    #print(repeatedNTimes([1,2,3,3]))\n    #print(repeatedNTimes_2([1,2,", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    tmp = list(set(nums))\n    return tmp.count(tmp[0])*tmp[0]\n\ndef repeatedNTimes_2(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = []\n    for x in nums:\n        tmp.append(nums.count(x))\n    return max(tmp)*tmp[0]\n\ndef repeatedNTimes_3(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = collections.Counter(nums)\n    return tmp.most_common(1)[0][0]\n\ndef repeatedNTimes_4(nums):\n    '''\n    Time Limit Exceed\n    '''\n    tmp = collections.Counter(nums)\n    for item in tmp.items():\n        if item[1] == 2:\n            return item[0]\n    return -1\n\nif __name__=='__main__':\n    #print(repeatedNTimes([1,2,3,3]))\n    #print(repeatedNTimes_2([1,2,"}
{"task_id": "leetcode/961", "completion": "\n    for i in range(2, len(nums)):\n        if collections.Counter(nums[:i]) < collections.Counter(nums[i:]):\n            return nums[i]\n    return nums[0]\n\\end{code}\n\nAnswer: You could simply count the elements in each group:\n\n\\begin{code}\ndef repeatedNTimes(nums):\n    cnt = collections.Counter(iter(nums))\n    return next(i for i in nums if cnt[i] == max(cnt.values()))\n\\end{code}\n\nAnswer: \\begin{code}\nfrom collections import Counter\ncnt = Counter(nums)\nreturn [key for key, value in cnt.items() if value > len(nums)/2]\n\\end{code}\n\nComment: `Counter` is a `dict` subclass, so I think you're going to have to do `[key for key, value in cnt.items() if value > len(nums)/2]`\n\nComment: You are right, i just copied the code and did not think about it.\n\n", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    for i in range(2, len(nums)):\n        if collections.Counter(nums[:i]) < collections.Counter(nums[i:]):\n            return nums[i]\n    return nums[0]\n\\end{code}\n\nAnswer: You could simply count the elements in each group:\n\n\\begin{code}\ndef repeatedNTimes(nums):\n    cnt = collections.Counter(iter(nums))\n    return next(i for i in nums if cnt[i] == max(cnt.values()))\n\\end{code}\n\nAnswer: \\begin{code}\nfrom collections import Counter\ncnt = Counter(nums)\nreturn [key for key, value in cnt.items() if value > len(nums)/2]\n\\end{code}\n\nComment: `Counter` is a `dict` subclass, so I think you're going to have to do `[key for key, value in cnt.items() if value > len(nums)/2]`\n\nComment: You are right, i just copied the code and did not think about it.\n\n"}
{"task_id": "leetcode/961", "completion": "\n\n    # Hint: 使用位运算计算异或的结果\n    # 思路：用一个int赋值给s，取nums中每个元素与s做异或，得到异或结果后，只保留有重复的元素，将异或结果s赋值给s。\n    # 最后s就是要找的元素。\n    s = 0\n    for i in nums:\n        s = s ^ i\n    # return collections.Counter(nums).most_common()[0][0]\n    return s ^ s\n    '''\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n\n\n\ns = Solution()\nprint(s.isValid('({[[]])'))\nprint(s.getRow(4))\nprint(s.climbStairs(4))\nprint(s.generate25(5))\nprint(s.maxArea(height=[1, 8, 6, ", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n\n    # Hint: 使用位运算计算异或的结果\n    # 思路：用一个int赋值给s，取nums中每个元素与s做异或，得到异或结果后，只保留有重复的元素，将异或结果s赋值给s。\n    # 最后s就是要找的元素。\n    s = 0\n    for i in nums:\n        s = s ^ i\n    # return collections.Counter(nums).most_common()[0][0]\n    return s ^ s\n    '''\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n\n\n\ns = Solution()\nprint(s.isValid('({[[]])'))\nprint(s.getRow(4))\nprint(s.climbStairs(4))\nprint(s.generate25(5))\nprint(s.maxArea(height=[1, 8, 6, "}
{"task_id": "leetcode/961", "completion": "\n    counter = collections.Counter(nums)\n    for k in counter.keys():\n        if counter[k] == len(nums) / 2:\n            return k\n\n\n\n\n\n\n## 3. 三数之和\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        '''\n        给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n        注意：答案中不可以包含重复的三元组。\n        '''\n        nums = sorted(nums)\n        # 排序后游标\n        l,r = 0, len(nums)-1\n        ans = []\n        while l < r:\n            # 去重\n            if", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    counter = collections.Counter(nums)\n    for k in counter.keys():\n        if counter[k] == len(nums) / 2:\n            return k\n\n\n\n\n\n\n## 3. 三数之和\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        '''\n        给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n        注意：答案中不可以包含重复的三元组。\n        '''\n        nums = sorted(nums)\n        # 排序后游标\n        l,r = 0, len(nums)-1\n        ans = []\n        while l < r:\n            # 去重\n            if"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) < 2:\n        return 0\n    max_num = nums[0]\n    max_index = 0\n    for i in range(1, len(nums)):\n        max_num = max(max_num, nums[i])\n        max_index = i if nums[i] == max_num else max_index\n    if max_num * 2 > sum(nums) - max_num:\n        return max_index\n    return -1\n\n\ndef reverseBits(n):\n    '''\n    将一个 32 位的非负整数 n 中的数字部分反转。\n    如果反转后的数字超过 32 位的有符号整数的范围 [−231,  231 − 1] ，则返回 0。\n    假设输入是一个 32 位带符号整数，其数值范围是 [−23", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) < 2:\n        return 0\n    max_num = nums[0]\n    max_index = 0\n    for i in range(1, len(nums)):\n        max_num = max(max_num, nums[i])\n        max_index = i if nums[i] == max_num else max_index\n    if max_num * 2 > sum(nums) - max_num:\n        return max_index\n    return -1\n\n\ndef reverseBits(n):\n    '''\n    将一个 32 位的非负整数 n 中的数字部分反转。\n    如果反转后的数字超过 32 位的有符号整数的范围 [−231,  231 − 1] ，则返回 0。\n    假设输入是一个 32 位带符号整数，其数值范围是 [−23"}
{"task_id": "leetcode/747", "completion": "\n    nums.sort()\n    if nums[-1] * 2 >= nums[0] * 3:\n        return nums.index(nums[-1])\n    return -1\n\ndef isPalindrome(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    if len(s) <= 1:\n        return True\n    if len(s) == 2:\n        return s == s[::-1]\n    num = 0\n    j = len(s) - 1\n    for i in range(len(s) // 2):\n        if s[i] == s[j]:\n            num += 1\n            i += 1\n            j -= 1\n        else:\n            break\n    return num == (len(s))\n\n\ndef romanToInt(s: str) -> int:\n    '''\n    罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n    '数字' ", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    nums.sort()\n    if nums[-1] * 2 >= nums[0] * 3:\n        return nums.index(nums[-1])\n    return -1\n\ndef isPalindrome(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    if len(s) <= 1:\n        return True\n    if len(s) == 2:\n        return s == s[::-1]\n    num = 0\n    j = len(s) - 1\n    for i in range(len(s) // 2):\n        if s[i] == s[j]:\n            num += 1\n            i += 1\n            j -= 1\n        else:\n            break\n    return num == (len(s))\n\n\ndef romanToInt(s: str) -> int:\n    '''\n    罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n    '数字' "}
{"task_id": "leetcode/747", "completion": "\n    n = len(nums)\n    if n == 0:\n        return -1\n    big = max(nums)\n    second = min(nums)\n    if n == 1:\n        return 0\n    for i in range(0,n):\n        if nums[i] == big:\n            continue\n        elif nums[i] == second:\n            second = nums[i]\n            i += 1\n            break\n        else:\n            return -1\n    for j in range(i,n):\n        if nums[j] * 2 > big:\n            return -1\n    return i\n\ndef dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    n = len(nums)\n    if n == 0:\n        return -1\n    big = max(nums)\n    second = min(nums)\n    if n == 1:\n        return 0\n    for i in range(0,n):\n        if nums[i] == big:\n            continue\n        elif nums[i] == second:\n            second = nums[i]\n            i += 1\n            break\n        else:\n            return -1\n    for j in range(i,n):\n        if nums[j] * 2 > big:\n            return -1\n    return i\n\ndef dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果"}
{"task_id": "leetcode/747", "completion": "\n    ln = len(nums)\n    if ln < 3:\n        return -1\n    maxN = nums[0]\n    maxIdx = 0\n    secondIdx = -1\n    for i in range(1, ln):\n        if nums[i] > maxN:\n            secondIdx = maxIdx\n            maxN = nums[i]\n            maxIdx = i\n        elif nums[i] > maxN / 2.0 and secondIdx == -1:\n            secondIdx = i\n    if maxN >= 2 * nums[maxIdx]:\n        return maxIdx\n    return -1\n\n\ndef dominantIndex_(nums):\n    ln = len(nums)\n    if ln < 3:\n        return -1\n    maxN = nums[0]\n    maxIdx = 0\n    for i in range(1, ln):\n        if nums[i] > maxN:\n            maxN = nums[i]\n            maxIdx = i\n    if maxN", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    ln = len(nums)\n    if ln < 3:\n        return -1\n    maxN = nums[0]\n    maxIdx = 0\n    secondIdx = -1\n    for i in range(1, ln):\n        if nums[i] > maxN:\n            secondIdx = maxIdx\n            maxN = nums[i]\n            maxIdx = i\n        elif nums[i] > maxN / 2.0 and secondIdx == -1:\n            secondIdx = i\n    if maxN >= 2 * nums[maxIdx]:\n        return maxIdx\n    return -1\n\n\ndef dominantIndex_(nums):\n    ln = len(nums)\n    if ln < 3:\n        return -1\n    maxN = nums[0]\n    maxIdx = 0\n    for i in range(1, ln):\n        if nums[i] > maxN:\n            maxN = nums[i]\n            maxIdx = i\n    if maxN"}
{"task_id": "leetcode/747", "completion": "\n    # 首先找到最大值\n    max_num = max(nums)\n    # 其次判断最大值是否是其他数字的两倍\n    for i in range(len(nums)):\n        if nums[i] == max_num:\n            continue\n        elif max_num > 2 * nums[i]:\n            return -1\n    return nums.index(max_num)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组和一个目标值，找出数组中和为目标值的\n    两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n    例如，给定 nums = [2, 7, 11, 15] 和 target = 9, 因为 nums[0] + nums[1] = 2 + 7\n     = 9,", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    # 首先找到最大值\n    max_num = max(nums)\n    # 其次判断最大值是否是其他数字的两倍\n    for i in range(len(nums)):\n        if nums[i] == max_num:\n            continue\n        elif max_num > 2 * nums[i]:\n            return -1\n    return nums.index(max_num)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组和一个目标值，找出数组中和为目标值的\n    两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n    例如，给定 nums = [2, 7, 11, 15] 和 target = 9, 因为 nums[0] + nums[1] = 2 + 7\n     = 9,"}
{"task_id": "leetcode/747", "completion": "\n    count = Counter(nums)\n   ", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    count = Counter(nums)\n   "}
{"task_id": "leetcode/747", "completion": "\n    if not nums: return -1\n    if len(nums) == 1: return 0\n    maxNum = max(nums)\n    for i in range(len(nums)):\n        if nums[i] == maxNum:\n            for j in range(i+1, len(nums)):\n                if nums[j] * 2 <= maxNum: return -1\n    else: return i\n```\n\n---\n\n## 48.3 数组中只出现一次的数字\n\n![数组中只出现一次的数字](./images/48.jpg)\n\n```python\n#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n\n# class Solution:\n#     def singleNumber(self, nums):\n#         '''\n#         给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums: return -1\n    if len(nums) == 1: return 0\n    maxNum = max(nums)\n    for i in range(len(nums)):\n        if nums[i] == maxNum:\n            for j in range(i+1, len(nums)):\n                if nums[j] * 2 <= maxNum: return -1\n    else: return i\n```\n\n---\n\n## 48.3 数组中只出现一次的数字\n\n![数组中只出现一次的数字](./images/48.jpg)\n\n```python\n#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n\n# class Solution:\n#     def singleNumber(self, nums):\n#         '''\n#         给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次"}
{"task_id": "leetcode/747", "completion": "\n    length = len(nums)\n    if length == 1:\n        return 0\n    elif length == 2:\n        if nums[0] > nums[1]:\n            return 0\n        else:\n            return 1\n    else:\n        pos0 = 0\n        pos1 = 1\n        max_num = 0\n        for i in range(2, length):\n            if nums[i] > nums[max_num]:\n                max_num = i\n        if nums[max_num] >= nums[pos0]*2 and nums[max_num] >= nums[pos1]*2:\n            return max_num\n        else:\n            return -1\n\n\ndef maxDouble(nums):\n    \"\"\"\n    Given an array nums, you will choose two different indices i and j of that array.\n    Return the max of nums[i] and nums[j].\n    \"\"\"\n    length = len(nums)\n    if length == 1:\n        return nums[0]\n    elif length == 2:\n", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    length = len(nums)\n    if length == 1:\n        return 0\n    elif length == 2:\n        if nums[0] > nums[1]:\n            return 0\n        else:\n            return 1\n    else:\n        pos0 = 0\n        pos1 = 1\n        max_num = 0\n        for i in range(2, length):\n            if nums[i] > nums[max_num]:\n                max_num = i\n        if nums[max_num] >= nums[pos0]*2 and nums[max_num] >= nums[pos1]*2:\n            return max_num\n        else:\n            return -1\n\n\ndef maxDouble(nums):\n    \"\"\"\n    Given an array nums, you will choose two different indices i and j of that array.\n    Return the max of nums[i] and nums[j].\n    \"\"\"\n    length = len(nums)\n    if length == 1:\n        return nums[0]\n    elif length == 2:\n"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n    maxValue = nums[0]\n    maxIndex = 0\n    for i, value in enumerate(nums):\n        if value > maxValue:\n            maxValue = value\n            maxIndex = i\n    if maxValue >= 2 * nums[maxIndex]:\n        return maxIndex\n    else:\n        return -1\n\n\ndef mergeTwoLists(l1: ListNode, l2: ListNode):\n    '''\n    > 87. 合并两个有序链表\n    将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n    >>> mergeTwoLists(ListNode.fromArray(1,2,4), ListNode.fromArray(1,3,4))\n    1,2,3,4,4\n    >>> mergeTwoLists(ListNode.fromArray(1,2", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n    maxValue = nums[0]\n    maxIndex = 0\n    for i, value in enumerate(nums):\n        if value > maxValue:\n            maxValue = value\n            maxIndex = i\n    if maxValue >= 2 * nums[maxIndex]:\n        return maxIndex\n    else:\n        return -1\n\n\ndef mergeTwoLists(l1: ListNode, l2: ListNode):\n    '''\n    > 87. 合并两个有序链表\n    将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n    >>> mergeTwoLists(ListNode.fromArray(1,2,4), ListNode.fromArray(1,3,4))\n    1,2,3,4,4\n    >>> mergeTwoLists(ListNode.fromArray(1,2"}
{"task_id": "leetcode/747", "completion": "\n    if nums == []:\n        return -1\n    elif len(nums) == 1:\n        return 0\n    else:\n        num_max = nums[0]\n        index_max = 0\n        for i in range(1, len(nums)):\n            if nums[i] > num_max:\n                num_max = nums[i]\n                index_max = i\n        for i in range(1, len(nums)):\n            if num_max > nums[i] * 2:\n                return -1\n        return index_max\n\n\ndef findMaxAverage(nums, k):\n    '''\n    给定数组 'nums' 和整数 'k'，请在数组中找到一个具有最大和的连续子数组，并返回该最大和。\n    如果不存在这样的连续子数组，请返回0。\n    >>> findMaxAverage([1,12,-5,-6,50,3],", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if nums == []:\n        return -1\n    elif len(nums) == 1:\n        return 0\n    else:\n        num_max = nums[0]\n        index_max = 0\n        for i in range(1, len(nums)):\n            if nums[i] > num_max:\n                num_max = nums[i]\n                index_max = i\n        for i in range(1, len(nums)):\n            if num_max > nums[i] * 2:\n                return -1\n        return index_max\n\n\ndef findMaxAverage(nums, k):\n    '''\n    给定数组 'nums' 和整数 'k'，请在数组中找到一个具有最大和的连续子数组，并返回该最大和。\n    如果不存在这样的连续子数组，请返回0。\n    >>> findMaxAverage([1,12,-5,-6,50,3],"}
{"task_id": "leetcode/1200", "completion": "\n    min_diff = float('inf')\n    # 先保存到辅助数组，保证不重复\n    nums = []\n    for num in arr:\n        # 如果已经存在，不需要再保存\n        if num in nums:\n            continue\n        nums.append(num)\n    # 保存结果\n    res = []\n    # 先排序\n    nums.sort()\n    # 从第一个数字开始\n    for x in range(len(nums) - 1):\n        for y in range(x + 1, len(nums)):\n            diff = abs(nums[x] - nums[y])\n            # 如果大于最小值，直接跳过\n            if diff > min_diff:\n                continue\n            # 否则，更新最小值，并添加结果\n            min_diff = diff\n            res.append([nums[x], nums[y]])\n    return res\n\n\nif __name__ ==", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    min_diff = float('inf')\n    # 先保存到辅助数组，保证不重复\n    nums = []\n    for num in arr:\n        # 如果已经存在，不需要再保存\n        if num in nums:\n            continue\n        nums.append(num)\n    # 保存结果\n    res = []\n    # 先排序\n    nums.sort()\n    # 从第一个数字开始\n    for x in range(len(nums) - 1):\n        for y in range(x + 1, len(nums)):\n            diff = abs(nums[x] - nums[y])\n            # 如果大于最小值，直接跳过\n            if diff > min_diff:\n                continue\n            # 否则，更新最小值，并添加结果\n            min_diff = diff\n            res.append([nums[x], nums[y]])\n    return res\n\n\nif __name__ =="}
{"task_id": "leetcode/1200", "completion": "\n    n = len(arr)\n    min_diff = float('inf')\n    ans = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff < min_diff:\n                min_diff = diff\n                ans = [(arr[i], arr[j])]\n            elif diff == min_diff:\n                ans.append((arr[i], arr[j]))\n    return ans\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    n = len(arr)\n    min_diff = float('inf')\n    ans = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff < min_diff:\n                min_diff = diff\n                ans = [(arr[i], arr[j])]\n            elif diff == min_diff:\n                ans.append((arr[i], arr[j]))\n    return ans\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对"}
{"task_id": "leetcode/1200", "completion": "\n    res = []\n    for i in range(0, len(arr)):\n        j = i+1\n        while j < len(arr):\n            if arr[i] + arr[j] == arr[j] + arr[i]:\n                res.append([arr[i], arr[j]])\n                j += 1\n            elif arr[i] + arr[j] > arr[j] + arr[i]:\n                j += 1\n            else:\n                j = i+1\n    return res\n# print(minimumAbsDifference([4,2,1,3]))\n# print(minimumAbsDifference([1,3,6,10,15]))\n\n'''\n404. 左叶子之和\n给定一个二叉树的根节点 root，它的每个叶子都的值都是 0，返回所有 左叶子之和 。\n\n（节点是左叶子的兄弟，如果一个节点有左��", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    res = []\n    for i in range(0, len(arr)):\n        j = i+1\n        while j < len(arr):\n            if arr[i] + arr[j] == arr[j] + arr[i]:\n                res.append([arr[i], arr[j]])\n                j += 1\n            elif arr[i] + arr[j] > arr[j] + arr[i]:\n                j += 1\n            else:\n                j = i+1\n    return res\n# print(minimumAbsDifference([4,2,1,3]))\n# print(minimumAbsDifference([1,3,6,10,15]))\n\n'''\n404. 左叶子之和\n给定一个二叉树的根节点 root，它的每个叶子都的值都是 0，返回所有 左叶子之和 。\n\n（节点是左叶子的兄弟，如果一个节点有左��"}
{"task_id": "leetcode/1200", "completion": "\n    arr = sorted(arr)\n    n = len(arr)\n    min_abs = float('inf')\n    ans = []\n    for i in range(n - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        if diff < min_abs:\n            min_abs = diff\n            ans = [(arr[i], arr[i + 1])]\n        elif diff == min_abs:\n            ans.append((arr[i], arr[i + 1]))\n    return ans\n\n\nif __name__ == '__main__':\n    # 884. 三维形体的表面积\n    print(surfaceArea([[20, 20, 10, 80], [10, 80, 10, 10], [50, 10, 20, 20], [10, 20, 30, 20]]))\n    # 870. 矩阵区域和\n    print(matrix", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr = sorted(arr)\n    n = len(arr)\n    min_abs = float('inf')\n    ans = []\n    for i in range(n - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        if diff < min_abs:\n            min_abs = diff\n            ans = [(arr[i], arr[i + 1])]\n        elif diff == min_abs:\n            ans.append((arr[i], arr[i + 1]))\n    return ans\n\n\nif __name__ == '__main__':\n    # 884. 三维形体的表面积\n    print(surfaceArea([[20, 20, 10, 80], [10, 80, 10, 10], [50, 10, 20, 20], [10, 20, 30, 20]]))\n    # 870. 矩阵区域和\n    print(matrix"}
{"task_id": "leetcode/1200", "completion": "\n    # 先排序, 然后找出最小的差值, 然后找另一个值可以补充到满足要求\n    arr = sorted(arr)\n    min_difference = arr[1] - arr[0]\n    ans = []\n    for i in range(len(arr) - 1):\n        tmp = arr[i + 1] - arr[i]\n        if tmp!= min_difference:\n            continue\n        j", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 先排序, 然后找出最小的差值, 然后找另一个值可以补充到满足要求\n    arr = sorted(arr)\n    min_difference = arr[1] - arr[0]\n    ans = []\n    for i in range(len(arr) - 1):\n        tmp = arr[i + 1] - arr[i]\n        if tmp!= min_difference:\n            continue\n        j"}
{"task_id": "leetcode/1200", "completion": "\n    dic = {}\n    ans = []\n    arr.sort(reverse=True)\n    for i in range(len(arr) - 1):\n        val = arr[i]\n        if val - arr[i + 1] in dic:\n            ans.append([min(dic[val - arr[i + 1]], arr[i]), max(dic[val - arr[i + 1]], arr[i])])\n        dic[val] = arr[i]\n    return ans\n\n\nif __name__ == '__main__':\n    print(minimumAbsDifference([4, 2, 1, 3]))\n    print(minimumAbsDifference([1, ", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    dic = {}\n    ans = []\n    arr.sort(reverse=True)\n    for i in range(len(arr) - 1):\n        val = arr[i]\n        if val - arr[i + 1] in dic:\n            ans.append([min(dic[val - arr[i + 1]], arr[i]), max(dic[val - arr[i + 1]], arr[i])])\n        dic[val] = arr[i]\n    return ans\n\n\nif __name__ == '__main__':\n    print(minimumAbsDifference([4, 2, 1, 3]))\n    print(minimumAbsDifference([1, "}
{"task_id": "leetcode/1200", "completion": "\n    result = collections.defaultdict(list)\n    arr.sort()\n    for i in range(len(arr) - 1):\n        result[arr[i+1] - arr[i]].append([arr[i], arr[i+1]])\n    return result.values()\n\n\ndef twoSum(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    result = collections.defaultdict(list)\n    arr = sorted(nums)\n    for i in range(len(arr)):\n        result[target - arr[i]].append(arr[i])\n    return result[target]\n\n\ndef isSubsequence(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    j = 0\n    for i in range(len(t)):\n        if j >= len(s):\n            break\n        if t[i] == s[j]:\n            j +=", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    result = collections.defaultdict(list)\n    arr.sort()\n    for i in range(len(arr) - 1):\n        result[arr[i+1] - arr[i]].append([arr[i], arr[i+1]])\n    return result.values()\n\n\ndef twoSum(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    result = collections.defaultdict(list)\n    arr = sorted(nums)\n    for i in range(len(arr)):\n        result[target - arr[i]].append(arr[i])\n    return result[target]\n\n\ndef isSubsequence(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    j = 0\n    for i in range(len(t)):\n        if j >= len(s):\n            break\n        if t[i] == s[j]:\n            j +="}
{"task_id": "leetcode/1200", "completion": "\n    # 因为数组是没有重复数字的，最大的数 - 最小的数会是最小的差值。\n    # 因此，我们只需要得到 最大的数和最小的数即可。\n    # 1. 求最大值\n    maxNum = max(arr)\n    # 2. 求最小值\n    minNum = min(arr)\n    print(maxNum, minNum)\n    # 3. 得到最大值和最小值的差值\n    maxMinDiff = maxNum - minNum\n    # 4. 得到差值集合\n    diffList = []\n    i = 0\n    while i < len(arr):\n        j = i + 1\n        while j < len(arr):\n            if (abs(arr[i] - arr[j]) == maxMinDiff):\n                diffList.append([arr[i], arr[j]])\n            j += 1\n        i += 1\n    return diffList\n\n\n", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 因为数组是没有重复数字的，最大的数 - 最小的数会是最小的差值。\n    # 因此，我们只需要得到 最大的数和最小的数即可。\n    # 1. 求最大值\n    maxNum = max(arr)\n    # 2. 求最小值\n    minNum = min(arr)\n    print(maxNum, minNum)\n    # 3. 得到最大值和最小值的差值\n    maxMinDiff = maxNum - minNum\n    # 4. 得到差值集合\n    diffList = []\n    i = 0\n    while i < len(arr):\n        j = i + 1\n        while j < len(arr):\n            if (abs(arr[i] - arr[j]) == maxMinDiff):\n                diffList.append([arr[i], arr[j]])\n            j += 1\n        i += 1\n    return diffList\n\n\n"}
{"task_id": "leetcode/1200", "completion": "\n    from collections import defaultdict\n    dic = defaultdict(list)\n    size = len(arr)\n    for i in range(size):\n        for j in range(i+1, size):\n            dic[arr[i]-arr[j]].append([arr[i], arr[j]])\n    res = []\n    for key in dic:\n        res.extend(dic[key])\n    return res\n\ndef minimumAbsDifferenceRecur(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifferenceRecur([", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    from collections import defaultdict\n    dic = defaultdict(list)\n    size = len(arr)\n    for i in range(size):\n        for j in range(i+1, size):\n            dic[arr[i]-arr[j]].append([arr[i], arr[j]])\n    res = []\n    for key in dic:\n        res.extend(dic[key])\n    return res\n\ndef minimumAbsDifferenceRecur(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifferenceRecur(["}
{"task_id": "leetcode/1200", "completion": "\n    if(len(arr) <= 1):\n        return []\n    arr.sort(reverse=True)\n    res = []\n    for i in range(len(arr)-1):\n        res.append([arr[i], arr[i+1]])\n    return res\n\ndef minimumAbsDifference(arr):\n    # 先将数组按照顺序排序，这样后面的最大值就是最小绝对差值\n    arr.sort()\n    res = []\n    minValue = 2147483647\n    for i in range(len(arr) - 1):\n        d = arr[i+1] - arr[i]\n        if d < minValue:\n            minValue = d\n            res = [arr[i], arr[i+1]]\n        elif d == minValue:\n            res.append(arr[i])\n            res.append(arr[i+1])\n    return res\n\ndef minimumAbsDifference(arr):\n    # 先将数组按", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if(len(arr) <= 1):\n        return []\n    arr.sort(reverse=True)\n    res = []\n    for i in range(len(arr)-1):\n        res.append([arr[i], arr[i+1]])\n    return res\n\ndef minimumAbsDifference(arr):\n    # 先将数组按照顺序排序，这样后面的最大值就是最小绝对差值\n    arr.sort()\n    res = []\n    minValue = 2147483647\n    for i in range(len(arr) - 1):\n        d = arr[i+1] - arr[i]\n        if d < minValue:\n            minValue = d\n            res = [arr[i], arr[i+1]]\n        elif d == minValue:\n            res.append(arr[i])\n            res.append(arr[i+1])\n    return res\n\ndef minimumAbsDifference(arr):\n    # 先将数组按"}
{"task_id": "leetcode/1385", "completion": "\n    return len([x for x in arr1 if x not in arr2]) - len([y for y in arr2 if y not in arr1])\n\n\ndef findNthDigit(n):\n    '''\n    实现一个函数，输入 n ，按顺序打印出从 1 到 n 的数字，每隔一个数字打印一个空格。\n    >>> findNthDigit(1)\n    1\n    >>> findNthDigit(10)\n    1 2 3 4 5 6 7 8 9\n    >>> findNthDigit(13)\n    1 2 3 4 5 6 7 8 9 10 11 12 13\n    '''\n    n -= 1\n    if n < 10:\n        return n\n    else:\n        return findNthDigit(int(n/10)) + (n % 10)\n\n\ndef reverseList(head):\n    '''\n    反转�", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return len([x for x in arr1 if x not in arr2]) - len([y for y in arr2 if y not in arr1])\n\n\ndef findNthDigit(n):\n    '''\n    实现一个函数，输入 n ，按顺序打印出从 1 到 n 的数字，每隔一个数字打印一个空格。\n    >>> findNthDigit(1)\n    1\n    >>> findNthDigit(10)\n    1 2 3 4 5 6 7 8 9\n    >>> findNthDigit(13)\n    1 2 3 4 5 6 7 8 9 10 11 12 13\n    '''\n    n -= 1\n    if n < 10:\n        return n\n    else:\n        return findNthDigit(int(n/10)) + (n % 10)\n\n\ndef reverseList(head):\n    '''\n    反转�"}
{"task_id": "leetcode/1385", "completion": "\n    return len(np.where(np.absolute(np.array(arr1)-np.array(arr2))<=d)[0])\n\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2.\n\n    请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([], [1])\n    1.0\n    '''\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return len(np.where(np.absolute(np.array(arr1)-np.array(arr2))<=d)[0])\n\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2.\n\n    请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([], [1])\n    1.0\n    '''\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1"}
{"task_id": "leetcode/1385", "completion": "\n    n, m = len(arr1), len(arr2)\n    res = 0\n    for i in range(n):\n        count = 0\n        for j in range(m):\n            if abs(arr1[i] - arr2[j]) > d:\n                count += 1\n        res = max(count, res)\n    return res\n\n\ndef findLeavesOfBinaryTree(root):\n    '''\n    给你二叉树的根节点 root，找到它的每个叶子节点，并将它们的值按从左到右的顺序存储到一个列表中。\n    二叉树的叶子节点是指没有子节点的节点。\n    >>> root = [1,2,3,4,5]\n    >>> root[1].left = [7,8]\n    >>> root[1].right = [9]\n    >>> root[0].left = [10,11]\n    >>> root[0].", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    n, m = len(arr1), len(arr2)\n    res = 0\n    for i in range(n):\n        count = 0\n        for j in range(m):\n            if abs(arr1[i] - arr2[j]) > d:\n                count += 1\n        res = max(count, res)\n    return res\n\n\ndef findLeavesOfBinaryTree(root):\n    '''\n    给你二叉树的根节点 root，找到它的每个叶子节点，并将它们的值按从左到右的顺序存储到一个列表中。\n    二叉树的叶子节点是指没有子节点的节点。\n    >>> root = [1,2,3,4,5]\n    >>> root[1].left = [7,8]\n    >>> root[1].right = [9]\n    >>> root[0].left = [10,11]\n    >>> root[0]."}
{"task_id": "leetcode/1385", "completion": "\n    n, m = len(arr1), len(arr2)\n    r, cur = 0, 0\n    for i in range(n):\n        for j in range(m):\n            if abs(arr1[i] - arr2[j]) > d:\n                cur += 1\n        r = max(r, cur)\n        cur = 0\n    return r\n\n\nif __name__ == '__main__':\n    # import doctest\n    # doctest.testmod()\n    s = Solution()\n    print(s.twoSum([2, 7, 11, 15], 9))\n    print(s.twoSum([3, 2, 4], 6))  # [1, 2]\n    print(s.twoSum([3, 3], 6))\n    print(s.twoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9))\n    print(s.twoSum([6, 2, 3, ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    n, m = len(arr1), len(arr2)\n    r, cur = 0, 0\n    for i in range(n):\n        for j in range(m):\n            if abs(arr1[i] - arr2[j]) > d:\n                cur += 1\n        r = max(r, cur)\n        cur = 0\n    return r\n\n\nif __name__ == '__main__':\n    # import doctest\n    # doctest.testmod()\n    s = Solution()\n    print(s.twoSum([2, 7, 11, 15], 9))\n    print(s.twoSum([3, 2, 4], 6))  # [1, 2]\n    print(s.twoSum([3, 3], 6))\n    print(s.twoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9))\n    print(s.twoSum([6, 2, 3, "}
{"task_id": "leetcode/1385", "completion": "\n    return sum([1 for i in arr1 for j in arr2 if abs(i-j) <= d]) - \\\n           sum([1 for i in range(d + 1) for j in arr2 if i == j]) - \\\n           sum([1 for i in arr1 for j in range(d + 1) if i == j])\n\n\ndef countOfAtoms(formula):\n    '''\n    给定一个由小写字母及其数量组成的字符串，返回所有原子及其数量。\n    原子由一个大写字母和它后面的数字组成。'H2O' 也被认为是'H2O'。\n    >>> countOfAtoms(\"H2O\")\n    {'H': 2, 'O': 1}\n    >>> countOfAtoms(\"Mg(OH2)2\")\n    {'H': 2, 'Mg': 1, 'O': 2}\n    >>> countOfAtoms(\"K4(ON(SO3)2)2\")\n    {'K':", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return sum([1 for i in arr1 for j in arr2 if abs(i-j) <= d]) - \\\n           sum([1 for i in range(d + 1) for j in arr2 if i == j]) - \\\n           sum([1 for i in arr1 for j in range(d + 1) if i == j])\n\n\ndef countOfAtoms(formula):\n    '''\n    给定一个由小写字母及其数量组成的字符串，返回所有原子及其数量。\n    原子由一个大写字母和它后面的数字组成。'H2O' 也被认为是'H2O'。\n    >>> countOfAtoms(\"H2O\")\n    {'H': 2, 'O': 1}\n    >>> countOfAtoms(\"Mg(OH2)2\")\n    {'H': 2, 'Mg': 1, 'O': 2}\n    >>> countOfAtoms(\"K4(ON(SO3)2)2\")\n    {'K':"}
{"task_id": "leetcode/1385", "completion": "\n    arr_l1 = []\n    for i in range(len(arr1)):\n        arr_l1.append([arr1[i], 1])\n    arr_l2 = []\n    for i in range(len(arr2)):\n        arr_l2.append([arr2[i], 1])\n    arr_l1.sort(key=lambda x: x[0])\n    arr_l2.sort(key=lambda x: x[0])\n    arr_list = []\n    temp_arr_1 = arr_l1\n    temp_arr_2 = arr_l2\n    i = j = 0\n    while i < len(arr_l1) and j < len(arr_l2):\n        if temp_arr_1[i][0] > temp_arr_2[j][0]:\n            temp_arr_2[j][1] += temp_arr_1[i][1]\n            j += 1\n        else:\n            temp_arr_1[i][1] += temp_arr_2[j][1]\n            i += ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr_l1 = []\n    for i in range(len(arr1)):\n        arr_l1.append([arr1[i], 1])\n    arr_l2 = []\n    for i in range(len(arr2)):\n        arr_l2.append([arr2[i], 1])\n    arr_l1.sort(key=lambda x: x[0])\n    arr_l2.sort(key=lambda x: x[0])\n    arr_list = []\n    temp_arr_1 = arr_l1\n    temp_arr_2 = arr_l2\n    i = j = 0\n    while i < len(arr_l1) and j < len(arr_l2):\n        if temp_arr_1[i][0] > temp_arr_2[j][0]:\n            temp_arr_2[j][1] += temp_arr_1[i][1]\n            j += 1\n        else:\n            temp_arr_1[i][1] += temp_arr_2[j][1]\n            i += "}
{"task_id": "leetcode/1385", "completion": "\n    arr1.sort()\n    arr2.sort()\n\n    ans = 0\n    idx1 = None\n    idx2 = None\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            dis = abs(arr1[i] - arr2[j])\n            if dis <= d and (idx1 is None or dis < idx1):\n                idx1 = dis\n                idx2 = j\n        if idx1 is not None:\n            if idx2 is not None and idx1 > d and abs(arr1[i] - arr2[idx2]) > d:\n                ans += 1\n            idx1 = None\n            idx2 = None\n    return ans\n\n\ndef minNumberOfSemesters(n, relations, k):\n    '''\n    你正在在大学里完成你的课程指南。课程指南包含所有的课程，每一个课程都有一个编号和一系列的预先要求。课程 0 不", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1.sort()\n    arr2.sort()\n\n    ans = 0\n    idx1 = None\n    idx2 = None\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            dis = abs(arr1[i] - arr2[j])\n            if dis <= d and (idx1 is None or dis < idx1):\n                idx1 = dis\n                idx2 = j\n        if idx1 is not None:\n            if idx2 is not None and idx1 > d and abs(arr1[i] - arr2[idx2]) > d:\n                ans += 1\n            idx1 = None\n            idx2 = None\n    return ans\n\n\ndef minNumberOfSemesters(n, relations, k):\n    '''\n    你正在在大学里完成你的课程指南。课程指南包含所有的课程，每一个课程都有一个编号和一系列的预先要求。课程 0 不"}
{"task_id": "leetcode/1385", "completion": "\n    n = len(arr1)\n    m = len(arr2)\n    assert n!= 0 and m!= 0\n    assert d >= 0\n\n    pre = 0\n    for i in range(n):\n        tmp = 0\n        for j in range(m):\n            if abs(arr1[i]-arr2[j]) > d:\n                tmp += 1\n        if tmp > pre:\n            pre = tmp\n    return pre\n\n\nif __name__ == '__main__':\n    arr1 = [4, 5, 8]\n    arr2 = [10, 9, 1, 8]\n    d = 2\n    print(findTheDistanceValue(arr1, arr2, d))\n\n    arr1 = [1, 4, 2, 3]\n    arr2 = [-4, -3, 6, 10, 20, 30]\n    d = 3\n    print(findTheDistanceValue(arr1, arr2, d))\n\n    arr1 = [2, 1,", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    n = len(arr1)\n    m = len(arr2)\n    assert n!= 0 and m!= 0\n    assert d >= 0\n\n    pre = 0\n    for i in range(n):\n        tmp = 0\n        for j in range(m):\n            if abs(arr1[i]-arr2[j]) > d:\n                tmp += 1\n        if tmp > pre:\n            pre = tmp\n    return pre\n\n\nif __name__ == '__main__':\n    arr1 = [4, 5, 8]\n    arr2 = [10, 9, 1, 8]\n    d = 2\n    print(findTheDistanceValue(arr1, arr2, d))\n\n    arr1 = [1, 4, 2, 3]\n    arr2 = [-4, -3, 6, 10, 20, 30]\n    d = 3\n    print(findTheDistanceValue(arr1, arr2, d))\n\n    arr1 = [2, 1,"}
{"task_id": "leetcode/1385", "completion": "\n    arr1.sort()\n    arr2.sort()\n    arr2.reverse()\n    res = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == '__main__':\n    case = [\n        # 262,\n        # 2048\n        findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3),\n    ]\n    for c in case:\n        print(c)\n        print(f'{c=}')\n        # r = findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n        # r = findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n        # r = findTheDistanceValue([2,", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1.sort()\n    arr2.sort()\n    arr2.reverse()\n    res = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == '__main__':\n    case = [\n        # 262,\n        # 2048\n        findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3),\n    ]\n    for c in case:\n        print(c)\n        print(f'{c=}')\n        # r = findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n        # r = findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n        # r = findTheDistanceValue([2,"}
{"task_id": "leetcode/1385", "completion": "\n    cnt = 0\n    l1, l2 = len(arr1), len(arr2)\n    for i in range(l1):\n        cnt += sum(abs(arr1[i] - arr2[j]) > d for j in range(l2))\n    return cnt\n\n\nif __name__ == '__main__':\n    # import doctest\n    # doctest.testmod()\n    # s = Solution()\n    # res = s.findTheDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    # res = s.findTheDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    # res = s.findTheDistanceValue([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6)\n    res = findTheDistanceValue([4, 5, 8], [10, ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    cnt = 0\n    l1, l2 = len(arr1), len(arr2)\n    for i in range(l1):\n        cnt += sum(abs(arr1[i] - arr2[j]) > d for j in range(l2))\n    return cnt\n\n\nif __name__ == '__main__':\n    # import doctest\n    # doctest.testmod()\n    # s = Solution()\n    # res = s.findTheDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    # res = s.findTheDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    # res = s.findTheDistanceValue([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6)\n    res = findTheDistanceValue([4, 5, 8], [10, "}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n\ndef intersection_2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1, 2, 2, 1], [2, 2])\n    [2]\n    >>> intersection([4, 9, 5], [9, 4", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n\ndef intersection_2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1, 2, 2, 1], [2, 2])\n    [2]\n    >>> intersection([4, 9, 5], [9, 4"}
{"task_id": "leetcode/349", "completion": "\n    res = []\n    nums1, nums2 = nums1, nums2\n    while nums1 and nums2:\n        if nums1[0] == nums2[0]:\n            res.append(nums1.pop(0))\n            nums2.pop(0)\n        elif nums1[0] < nums2[0]:\n            nums1.pop(0)\n        else:\n            nums2.pop(0)\n    return res\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    res = []\n    nums1, nums2 = nums1, nums2\n    while nums1 and nums2:\n        if nums1[0] == nums2[0]:\n            res.append(nums1.pop(0))\n            nums2.pop(0)\n        elif nums1[0] < nums2[0]:\n            nums1.pop(0)\n        else:\n            nums2.pop(0)\n    return res\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]"}
{"task_id": "leetcode/349", "completion": "\n    return list(set(nums1) & set(nums2))\n\n\ndef intersection_sort(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection_sort([1,2,2,1], [2,2])\n    [2]\n    >>> intersection_sort([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return [i for i in nums1 if i in nums2 and nums2.count(i) > nums1.count(i)]\n\n\ndef _group_by_dict(nums):\n    '''\n    输入: [4,9,5]\n    输出: {4: [4], 5: [5], 9: [9]}\n    '''\n    result", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1) & set(nums2))\n\n\ndef intersection_sort(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection_sort([1,2,2,1], [2,2])\n    [2]\n    >>> intersection_sort([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return [i for i in nums1 if i in nums2 and nums2.count(i) > nums1.count(i)]\n\n\ndef _group_by_dict(nums):\n    '''\n    输入: [4,9,5]\n    输出: {4: [4], 5: [5], 9: [9]}\n    '''\n    result"}
{"task_id": "leetcode/349", "completion": "\n    result = []\n    nums1.sort()\n    nums2.sort()\n    for j in range(len(nums1)):\n        if nums1[j] in nums2 and nums1[j] not in result:\n            result.append(nums1[j])\n    return result\n\n\ndef intersection_set(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。\n    '''\n    # nums1 = list(set(nums1))\n    # nums2 = list(set(nums2))\n    result = []\n    for num1 in nums1:\n        for num2 in nums2:\n            if num1 == num2:\n                result.append(num1)\n                break\n    result = list(set(result))\n    return result\n\n\ndef intersection_list_comprehension(nums1, nums2):\n    '''\n    给定两个整数数", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    result = []\n    nums1.sort()\n    nums2.sort()\n    for j in range(len(nums1)):\n        if nums1[j] in nums2 and nums1[j] not in result:\n            result.append(nums1[j])\n    return result\n\n\ndef intersection_set(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。\n    '''\n    # nums1 = list(set(nums1))\n    # nums2 = list(set(nums2))\n    result = []\n    for num1 in nums1:\n        for num2 in nums2:\n            if num1 == num2:\n                result.append(num1)\n                break\n    result = list(set(result))\n    return result\n\n\ndef intersection_list_comprehension(nums1, nums2):\n    '''\n    给定两个整数数"}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    res = []\n    i = j = 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n    return res\n\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,2], [1,2,3])\n    [1, 2, 2, 3]\n    >>>", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    res = []\n    i = j = 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n    return res\n\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,2], [1,2,3])\n    [1, 2, 2, 3]\n    >>>"}
{"task_id": "leetcode/349", "completion": "\n    result = []\n    # 对每一个元素num1，判断num1在nums2中是否存在\n    for num in nums1:\n        # 若存在则\n        if num in nums2:\n            # 若不存在则插入到结果列表result\n            result.append(num)\n            # 从nums2中删除num\n            nums2.remove(num)\n    return result\n\n\ndef intersection_fast(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection_fast([1,2,2,1], [2,2])\n    [2]\n    >>> intersection_fast([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    result = []\n    # 对每一个元素num1，判断num1在nums2中是否存在\n    for num in nums1:\n        # 若存在则\n        if num in nums2:\n            # 若不存在则插入到结果列表result\n            result.append(num)\n            # 从nums2中删除num\n            nums2.remove(num)\n    return result\n\n\ndef intersection_fast(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection_fast([1,2,2,1], [2,2])\n    [2]\n    >>> intersection_fast([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n"}
{"task_id": "leetcode/349", "completion": "\n    dic = {}\n    res = []\n    for num in nums1:\n        dic[num] = dic.get(num, 0) + 1\n    \n    for num in nums2:\n        if num in dic:\n            res.append(num)\n            dic[num] -= 1\n            if dic[num] == 0:\n                dic.pop(num)\n    return res\n```\n\n### 42. 用两个栈实现队列\n\n```Python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :rtype: void\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    dic = {}\n    res = []\n    for num in nums1:\n        dic[num] = dic.get(num, 0) + 1\n    \n    for num in nums2:\n        if num in dic:\n            res.append(num)\n            dic[num] -= 1\n            if dic[num] == 0:\n                dic.pop(num)\n    return res\n```\n\n### 42. 用两个栈实现队列\n\n```Python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :rtype: void\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1"}
{"task_id": "leetcode/349", "completion": "\n    if len(nums1) < len(nums2):\n        nums1, nums2 = nums2, nums1\n    result = []\n    l1, l2 = 0, 0\n    while l1 < len(nums1) and l2 < len(nums2):\n        if nums1[l1] < nums2[l2]:\n            l1 += 1\n        elif nums2[l2] < nums1[l1]:\n            l2 += 1\n        else:\n            result.append(nums1[l1])\n            l1 += 1\n            l2 += 1\n    return result\n\n\nif __name__ == '__main__':\n    print(intersection([4, 9, 5], [9, 4, 9, 8, 4]))\n    print(intersection([3, 3], [3, 3, 3]))\n    print(intersection([1, 2, 2, 1], [2, 2]))\n    print(intersection([1, ", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    if len(nums1) < len(nums2):\n        nums1, nums2 = nums2, nums1\n    result = []\n    l1, l2 = 0, 0\n    while l1 < len(nums1) and l2 < len(nums2):\n        if nums1[l1] < nums2[l2]:\n            l1 += 1\n        elif nums2[l2] < nums1[l1]:\n            l2 += 1\n        else:\n            result.append(nums1[l1])\n            l1 += 1\n            l2 += 1\n    return result\n\n\nif __name__ == '__main__':\n    print(intersection([4, 9, 5], [9, 4, 9, 8, 4]))\n    print(intersection([3, 3], [3, 3, 3]))\n    print(intersection([1, 2, 2, 1], [2, 2]))\n    print(intersection([1, "}
{"task_id": "leetcode/349", "completion": "\n    res = []\n    if len(nums1) < len(nums2):\n        nums1, nums2 = nums2, nums1\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    res = []\n    if len(nums1) < len(nums2):\n        nums1, nums2 = nums2, nums1\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,"}
{"task_id": "leetcode/349", "completion": "\n    ans = []\n    m, n = len(nums1), len(nums2)\n    i, j = 0, 0\n    while i < m and j < n:\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums2[j] < nums1[i]:\n            j += 1\n        else:\n            ans.append(nums1[i])\n            i += 1\n            j += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n   ", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ans = []\n    m, n = len(nums1), len(nums2)\n    i, j = 0, 0\n    while i < m and j < n:\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums2[j] < nums1[i]:\n            j += 1\n        else:\n            ans.append(nums1[i])\n            i += 1\n            j += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n   "}
{"task_id": "leetcode/1491", "completion": "\n    if not isinstance(salary, list):\n        raise ValueError('input must be a list')\n\n    if len(salary) < 2:\n        raise ValueError('len of input must be greater than 1')\n\n    if len(salary) == 2:\n        return (salary[1] - salary[0]) // 2\n\n    salary.sort()\n    return (salary[-1] - salary[0] - salary[len(salary) - 3]) // 2\n\n\n\ndef remove_duplicate(nums):\n    '''\n    给定一个数组，返回去重后的数组。\n    你必须在不使用另外的数组空间的条件下，只用原数组空间，将重复的数字删除。\n    给定数组：[1, 2, 3, 3, 3, 4, 5]\n    返回结果：[1, 2, 3, 4, 5]\n    >>> array = [1", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    if not isinstance(salary, list):\n        raise ValueError('input must be a list')\n\n    if len(salary) < 2:\n        raise ValueError('len of input must be greater than 1')\n\n    if len(salary) == 2:\n        return (salary[1] - salary[0]) // 2\n\n    salary.sort()\n    return (salary[-1] - salary[0] - salary[len(salary) - 3]) // 2\n\n\n\ndef remove_duplicate(nums):\n    '''\n    给定一个数组，返回去重后的数组。\n    你必须在不使用另外的数组空间的条件下，只用原数组空间，将重复的数字删除。\n    给定数组：[1, 2, 3, 3, 3, 4, 5]\n    返回结果：[1, 2, 3, 4, 5]\n    >>> array = [1"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    n = len(salary)\n    return int((sum(salary[1:n - 1]) + salary[n - 1]) / (n - 2))\n```\n\n\n## 47. 螺旋矩阵\n找出两个字符串的最长公共子序列。\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        '''\n        给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n        >>> Solution().longestCommonSubsequence(\"abcde\", \"ace\")\n        3\n        >>> Solution().longestCommonSubsequence(\"abc\",\"abc\")\n        3\n        >>> Solution().longestCommonSubsequence(\"abc\",\"def\")\n        0\n        >>> Solution().longestCommonSubsequence(\"\",\"\")\n        0\n       ", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    n = len(salary)\n    return int((sum(salary[1:n - 1]) + salary[n - 1]) / (n - 2))\n```\n\n\n## 47. 螺旋矩阵\n找出两个字符串的最长公共子序列。\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        '''\n        给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n        >>> Solution().longestCommonSubsequence(\"abcde\", \"ace\")\n        3\n        >>> Solution().longestCommonSubsequence(\"abc\",\"abc\")\n        3\n        >>> Solution().longestCommonSubsequence(\"abc\",\"def\")\n        0\n        >>> Solution().longestCommonSubsequence(\"\",\"\")\n        0\n       "}
{"task_id": "leetcode/1491", "completion": "\n    return round(sum(salary)/len(salary))\n\nif __name__ == '__main__':\n    print('average')\n    print(average(test_function_data))\n    print(average([400,300,100,200]))\n    print()\n\n\n\n# ----------------------------------------------------------------------\ndef minInVersion(version):\n    '''\n    请你返回 version 中比其他数字小的 非 0 数字的最大数目。\n    例如，version = 6 ，输出 1 ，因为 6 中只有 1 比其他数字小。\n    version = 11 ，输出 2 ，因为 11 中有 2 个比其他数字小的非 0 数字，且它们是 1 和 1 。\n    version = 1021 ，输出 2 ，因为 1021 中有 2 个比其他数字小的非", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary)/len(salary))\n\nif __name__ == '__main__':\n    print('average')\n    print(average(test_function_data))\n    print(average([400,300,100,200]))\n    print()\n\n\n\n# ----------------------------------------------------------------------\ndef minInVersion(version):\n    '''\n    请你返回 version 中比其他数字小的 非 0 数字的最大数目。\n    例如，version = 6 ，输出 1 ，因为 6 中只有 1 比其他数字小。\n    version = 11 ，输出 2 ，因为 11 中有 2 个比其他数字小的非 0 数字，且它们是 1 和 1 。\n    version = 1021 ，输出 2 ，因为 1021 中有 2 个比其他数字小的非"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    return round((salary[0] + salary[-1]) // 2)\n\n\ndef count_inversion(arr):\n    \"\"\"\n    数组中的元素是不重复的。给定一个数组，判断数组中是否存在相邻元素之差相等于1，若存在返回True，不存在返回False。\n    >>> count_inversion([1,2,4,7,10])\n    False\n    >>> count_inversion([3,2,1,1,1])\n    True\n    \"\"\"\n    res = []\n    for a, b in zip(arr, arr[1:]):\n        res.append(b - a)\n    return res!= sorted(res)\n\n\n# noinspection PyUnusedLocal\ndef is_palindrome(str):\n    \"\"\"\n    判断一个字符串是否是回文。\n    >>> is_palindrome('abcba')\n    True\n    >>> is_palindrome('abcbad')\n    False", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return round((salary[0] + salary[-1]) // 2)\n\n\ndef count_inversion(arr):\n    \"\"\"\n    数组中的元素是不重复的。给定一个数组，判断数组中是否存在相邻元素之差相等于1，若存在返回True，不存在返回False。\n    >>> count_inversion([1,2,4,7,10])\n    False\n    >>> count_inversion([3,2,1,1,1])\n    True\n    \"\"\"\n    res = []\n    for a, b in zip(arr, arr[1:]):\n        res.append(b - a)\n    return res!= sorted(res)\n\n\n# noinspection PyUnusedLocal\ndef is_palindrome(str):\n    \"\"\"\n    判断一个字符串是否是回文。\n    >>> is_palindrome('abcba')\n    True\n    >>> is_palindrome('abcbad')\n    False"}
{"task_id": "leetcode/1491", "completion": "\n    if len(salary) > 2:\n        salary.sort()\n        salary.pop()\n        salary.pop(0)\n        return round(sum(salary)/len(salary),0)\n    elif len(salary) == 2:\n        salary.sort()\n        return round(sum(salary)/2,0)\n    else:\n        return salary[0]\n\n\n\ndef findMedian(nums):\n    '''\n    给定一个长度为 n 的整数数组 nums，找到数组「中位数」 ，即中位数是所有 nums[i] 的中值。\n    示例 1:\n    输入: nums = [1,2]\n    输出: 1.5\n    示例 2:\n    输入: nums = [2,3,4]\n    输出: 2.5\n    说明:\n    你可以假设 nums 的长度为奇数，且不为空。", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    if len(salary) > 2:\n        salary.sort()\n        salary.pop()\n        salary.pop(0)\n        return round(sum(salary)/len(salary),0)\n    elif len(salary) == 2:\n        salary.sort()\n        return round(sum(salary)/2,0)\n    else:\n        return salary[0]\n\n\n\ndef findMedian(nums):\n    '''\n    给定一个长度为 n 的整数数组 nums，找到数组「中位数」 ，即中位数是所有 nums[i] 的中值。\n    示例 1:\n    输入: nums = [1,2]\n    输出: 1.5\n    示例 2:\n    输入: nums = [2,3,4]\n    输出: 2.5\n    说明:\n    你可以假设 nums 的长度为奇数，且不为空。"}
{"task_id": "leetcode/1491", "completion": "\n    # 数组元素个数\n    n = len(salary)\n    # 最低工资\n    salary_min = min(salary)\n    # 最高工资\n    salary_max = max(salary)\n    # 去掉最高工资和最低工资后的平均工资\n    salary_avg = (sum(salary) - salary_min - salary_max) / (n - 2)\n    return int(salary_avg)\n\n\n\nif __name__ == '__main__':\n    # print(average([4000,3000,1000,2000]))\n    # print(average([1000,2000,3000]))\n    arr = [1, 2, 3, 1, 2, 3]\n   ", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    # 数组元素个数\n    n = len(salary)\n    # 最低工资\n    salary_min = min(salary)\n    # 最高工资\n    salary_max = max(salary)\n    # 去掉最高工资和最低工资后的平均工资\n    salary_avg = (sum(salary) - salary_min - salary_max) / (n - 2)\n    return int(salary_avg)\n\n\n\nif __name__ == '__main__':\n    # print(average([4000,3000,1000,2000]))\n    # print(average([1000,2000,3000]))\n    arr = [1, 2, 3, 1, 2, 3]\n   "}
{"task_id": "leetcode/1491", "completion": "\n    # write code here\n    if not salary:\n        return 0\n    salary.sort()\n    return int((sum(salary) - salary[-1] - salary[0])/len(salary) + 0.5)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n### 面试题50\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n\n示例 1：\n\n```\n输入： 2\n输出： 2\n解释： 青蛙跳上一个2级台阶总共有2种跳法：\n\n1. 第1次", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    # write code here\n    if not salary:\n        return 0\n    salary.sort()\n    return int((sum(salary) - salary[-1] - salary[0])/len(salary) + 0.5)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n### 面试题50\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n\n示例 1：\n\n```\n输入： 2\n输出： 2\n解释： 青蛙跳上一个2级台阶总共有2种跳法：\n\n1. 第1次"}
{"task_id": "leetcode/1491", "completion": "\n    l = salary.copy()\n    l.sort()\n    return sum(l[1:-1]) // (len(l) - 2)\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n    示例:\n\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n    :param nums:\n    :return:\n    '''\n    def dp(nums, i, max_sum, min_sum):\n        max_sub_array_sum = max(max_sum, min_sum + nums[i])\n        min_sub_array_sum = min(max", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    l = salary.copy()\n    l.sort()\n    return sum(l[1:-1]) // (len(l) - 2)\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n    示例:\n\n    输入: [-2,1,-3,4,-1,2,1,-5,4],\n    输出: 6\n    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n    :param nums:\n    :return:\n    '''\n    def dp(nums, i, max_sum, min_sum):\n        max_sub_array_sum = max(max_sum, min_sum + nums[i])\n        min_sub_array_sum = min(max"}
{"task_id": "leetcode/1491", "completion": "\n    arr=list(salary)\n    arr.sort()\n    return round(sum(arr)-arr[0]-arr[-1])\n\ndef nthUglyNumber(n):\n    '''\n    写一个函数，找出第 n 个丑数。\n    丑数就是只包含质因数 2, 3, 5 的正整数。\n    \n    >>> nthUglyNumber(10)\n    12\n    >>> nthUglyNumber(1)\n    1\n    '''\n    return reduce(lambda x,y:x*y,take(n,concat(cycle([2,3,5]))))\n\ndef productExceptSelf(nums):\n    '''\n    给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的�", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    arr=list(salary)\n    arr.sort()\n    return round(sum(arr)-arr[0]-arr[-1])\n\ndef nthUglyNumber(n):\n    '''\n    写一个函数，找出第 n 个丑数。\n    丑数就是只包含质因数 2, 3, 5 的正整数。\n    \n    >>> nthUglyNumber(10)\n    12\n    >>> nthUglyNumber(1)\n    1\n    '''\n    return reduce(lambda x,y:x*y,take(n,concat(cycle([2,3,5]))))\n\ndef productExceptSelf(nums):\n    '''\n    给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的�"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    return int(sum(salary[1:-1]) / (len(salary) - 2 + 0.5))\n\n\ndef longestCommonPrefix(strs):\n    '''\n    编写一个函数来查找字符串数组中的最长公共前缀。\n    如果不存在公共前缀，返回空字符串 \"\"。\n    >>> longestCommonPrefix(['flower','flow','flight'])\n    'fl'\n    '''\n    if len(strs) <= 0:\n        return ''\n    return reduce(lambda x, y: x[:len(y)] and y.find(x) == 0 and x or '', strs)\n\n\ndef minDistance(word1, word2):\n    '''\n    给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。\n   ", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return int(sum(salary[1:-1]) / (len(salary) - 2 + 0.5))\n\n\ndef longestCommonPrefix(strs):\n    '''\n    编写一个函数来查找字符串数组中的最长公共前缀。\n    如果不存在公共前缀，返回空字符串 \"\"。\n    >>> longestCommonPrefix(['flower','flow','flight'])\n    'fl'\n    '''\n    if len(strs) <= 0:\n        return ''\n    return reduce(lambda x, y: x[:len(y)] and y.find(x) == 0 and x or '', strs)\n\n\ndef minDistance(word1, word2):\n    '''\n    给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。\n   "}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum = 0\n    for i in range(len(nums)//2):\n        sum += nums[2*i]\n    ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum = 0\n    for i in range(len(nums)//2):\n        sum += nums[2*i]\n    "}
{"task_id": "leetcode/561", "completion": "\n    return", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    return"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n\n    ans = 0\n    for i in range(len(nums) - 1):\n        ans += nums[i]\n    return ans\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2,\n    返回两个有序数组的中位数。如果两个数组长度相同, 则数组中间值任意。\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    >>> findMedianSortedArrays([1,2,3], [4,5,6])\n    4\n    '''\n    m = len(nums1)\n    n = len(nums2)\n    total = m + n\n\n    if total % 2 == 0:\n        i = total // 2\n        j = i - 1\n        k = m - 1\n        l = n - 1", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n\n    ans = 0\n    for i in range(len(nums) - 1):\n        ans += nums[i]\n    return ans\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2,\n    返回两个有序数组的中位数。如果两个数组长度相同, 则数组中间值任意。\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    >>> findMedianSortedArrays([1,2,3], [4,5,6])\n    4\n    '''\n    m = len(nums1)\n    n = len(nums2)\n    total = m + n\n\n    if total % 2 == 0:\n        i = total // 2\n        j = i - 1\n        k = m - 1\n        l = n - 1"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\ndef numberOf1(n):\n    '''\n    给定一个整数 n, 求连续、且不重复的正整数的和为 n 的个数。\n    示例：\n    输入: 8\n    输出: 5\n    解释: 有5种连续正整数([1,2,3,4,5])的和为8, 且不重复。\n    >>> numberOf1(8)\n    5\n    '''\n    res = 0\n    for i in range(1, n):\n        res += 1 if (n // 2 ^ (i - 1)) & 1 else 0\n    return res\n\n\ndef reverse(x):\n    '''\n    给定一个 32 位有符号整数，将整数中", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\ndef numberOf1(n):\n    '''\n    给定一个整数 n, 求连续、且不重复的正整数的和为 n 的个数。\n    示例：\n    输入: 8\n    输出: 5\n    解释: 有5种连续正整数([1,2,3,4,5])的和为8, 且不重复。\n    >>> numberOf1(8)\n    5\n    '''\n    res = 0\n    for i in range(1, n):\n        res += 1 if (n // 2 ^ (i - 1)) & 1 else 0\n    return res\n\n\ndef reverse(x):\n    '''\n    给定一个 32 位有符号整数，将整数中"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum = 0\n    i = 0\n    while i + 1 < len(nums):\n        sum = max(sum, nums[i] + nums[-i - 1])\n        i += 1\n    return sum\n\n\ndef arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的和最大。\n    求和最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    11\n    '''\n    nums.sort()\n    sum = 0\n    i = 0\n    while i + 1 < len(nums):\n        sum += nums[i] + nums[-i - 1]\n        i += 1\n    return sum\n\n\ndef uniqueMorseRe", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum = 0\n    i = 0\n    while i + 1 < len(nums):\n        sum = max(sum, nums[i] + nums[-i - 1])\n        i += 1\n    return sum\n\n\ndef arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的和最大。\n    求和最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    11\n    '''\n    nums.sort()\n    sum = 0\n    i = 0\n    while i + 1 < len(nums):\n        sum += nums[i] + nums[-i - 1]\n        i += 1\n    return sum\n\n\ndef uniqueMorseRe"}
{"task_id": "leetcode/561", "completion": "\n    \n    nums.sort()\n    n = len(nums)\n    a, b = 0, n - 1\n    max_sum = 0\n    while a < (n / 2):\n        max_sum = max(max_sum, 2 * nums[a] + 2 * nums[b])\n        a += 1\n        b -= 1\n    return max_sum\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target, 请你在该数组中找出和为目标值的那 两个 整数, 并返回他们的数组下标\n    >>> twoSum([2,7,11,15], 9)\n    [0, 1]\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3, 3], 6)\n    [0, 1]\n    '''\n    nums = sorted(", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    \n    nums.sort()\n    n = len(nums)\n    a, b = 0, n - 1\n    max_sum = 0\n    while a < (n / 2):\n        max_sum = max(max_sum, 2 * nums[a] + 2 * nums[b])\n        a += 1\n        b -= 1\n    return max_sum\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target, 请你在该数组中找出和为目标值的那 两个 整数, 并返回他们的数组下标\n    >>> twoSum([2,7,11,15], 9)\n    [0, 1]\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3, 3], 6)\n    [0, 1]\n    '''\n    nums = sorted("}
{"task_id": "leetcode/561", "completion": "\n    # 假设数据是[1,2,3,4]， 按照整数的大小， 相当于把数组分成了4 个单元， 每个单元内部的数都是最小的。\n    # 比如对于[1,2,3,4] 来说， 最小的是1， 第二小的是2， 第三小的是3， 第四小的是4。 这样， \n    # 按照如下规则， 两个相邻的单元就可以组合成一个数对： （1,2） （2,3）（3,4）。 \n    # 把 所有组成的单元中的最小值的和就是 1+2+3+4 = 10。\n    # 对于数组中的数据， 把数据分成 n 个单元， 每个单元内部的数都是从大", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    # 假设数据是[1,2,3,4]， 按照整数的大小， 相当于把数组分成了4 个单元， 每个单元内部的数都是最小的。\n    # 比如对于[1,2,3,4] 来说， 最小的是1， 第二小的是2， 第三小的是3， 第四小的是4。 这样， \n    # 按照如下规则， 两个相邻的单元就可以组合成一个数对： （1,2） （2,3）（3,4）。 \n    # 把 所有组成的单元中的最小值的和就是 1+2+3+4 = 10。\n    # 对于数组中的数据， 把数据分成 n 个单元， 每个单元内部的数都是从大"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    res = nums[0]\n    n = len(nums)//2\n    for i in range(n):\n        res += nums[i*2]+nums[i*2+1]\n    return res\n\n\ndef maxNumber(nums1, nums2, k):\n    '''\n    给出两个数组，返回两个数组中第一个数组中 最小 的k个数字组成的数组。\n    保证两个数组中第一个数组的长度大于第二个数组的长度。\n    >>> maxNumber(['5','7','4'], ['1','2','8','3'], 2)\n    ['5','7']\n    >>> maxNumber(['1','2','8','3'], ['5','7','4'], 2)\n    ['8','4']\n    '''\n    res = []\n    i = 0\n    j = 0\n    n = len(nums1)\n    m = len(nums2)\n    while k:\n       ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    res = nums[0]\n    n = len(nums)//2\n    for i in range(n):\n        res += nums[i*2]+nums[i*2+1]\n    return res\n\n\ndef maxNumber(nums1, nums2, k):\n    '''\n    给出两个数组，返回两个数组中第一个数组中 最小 的k个数字组成的数组。\n    保证两个数组中第一个数组的长度大于第二个数组的长度。\n    >>> maxNumber(['5','7','4'], ['1','2','8','3'], 2)\n    ['5','7']\n    >>> maxNumber(['1','2','8','3'], ['5','7','4'], 2)\n    ['8','4']\n    '''\n    res = []\n    i = 0\n    j = 0\n    n = len(nums1)\n    m = len(nums2)\n    while k:\n       "}
{"task_id": "leetcode/561", "completion": "\n    if not nums:\n        return 0\n    length = len(nums) // 2\n\n    nums.sort()\n\n    mx = 0\n    for i in range(length):\n        mx += nums[i] + nums[i + length]\n    return mx\n\nif __name__ == \"__main__\":\n    import doctest\n", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    if not nums:\n        return 0\n    length = len(nums) // 2\n\n    nums.sort()\n\n    mx = 0\n    for i in range(length):\n        mx += nums[i] + nums[i + length]\n    return mx\n\nif __name__ == \"__main__\":\n    import doctest\n"}
{"task_id": "leetcode/561", "completion": "\n    nums = sorted(nums)\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        if i % 2 == 0:\n            ans += nums[i]\n    return ans\n\ndef canConstruct(ransomNote, magazine):\n    '''\n    给你两个字符串 ransomNote 和 magazine，它们同时只包含小写字母。请你帮忙判断 ransomNote 能不能由 magazine 里面的字母构成。如果可以构成，返回 true ；否则返回 false。\n    题目数据保证，题目中的字符串 ransomNote 和 magazine 均可以由小写字母组成。字符串的长度在 [1, 100] 范围内。\n    >>> canConstruct('a', 'b')\n    False\n    >>> canConstruct('aa', 'ab')\n    False\n    >>> canConstruct('aa", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums = sorted(nums)\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        if i % 2 == 0:\n            ans += nums[i]\n    return ans\n\ndef canConstruct(ransomNote, magazine):\n    '''\n    给你两个字符串 ransomNote 和 magazine，它们同时只包含小写字母。请你帮忙判断 ransomNote 能不能由 magazine 里面的字母构成。如果可以构成，返回 true ；否则返回 false。\n    题目数据保证，题目中的字符串 ransomNote 和 magazine 均可以由小写字母组成。字符串的长度在 [1, 100] 范围内。\n    >>> canConstruct('a', 'b')\n    False\n    >>> canConstruct('aa', 'ab')\n    False\n    >>> canConstruct('aa"}
{"task_id": "leetcode/209", "completion": "\n    min_sum = float('inf')\n    left = 0\n    right = 0\n    sum = 0\n    while left < len(nums):\n        while right < len(nums) and sum < target:\n            sum += nums[right]\n            right += 1\n        while sum >= target:\n            min_sum = min(min_sum, right - left)\n            sum -= nums[left]\n            left += 1\n        if left == right:\n            break\n    return min_sum if min_sum < float('inf') else 0\n\ndef minSubArrayLen2(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1,..., numsr-1, numsr] ，返回其长度。\n    如果不存在", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    min_sum = float('inf')\n    left = 0\n    right = 0\n    sum = 0\n    while left < len(nums):\n        while right < len(nums) and sum < target:\n            sum += nums[right]\n            right += 1\n        while sum >= target:\n            min_sum = min(min_sum, right - left)\n            sum -= nums[left]\n            left += 1\n        if left == right:\n            break\n    return min_sum if min_sum < float('inf') else 0\n\ndef minSubArrayLen2(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1,..., numsr-1, numsr] ，返回其长度。\n    如果不存在"}
{"task_id": "leetcode/209", "completion": "\n    n = len(nums)\n    sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        sums[i] = sums[i - 1] + nums[i - 1]\n    min_len = sum(nums) + 1\n    for left in range(n):\n        for right in range(left, n):\n            if sums[right + 1] - sums[left] >= target:\n                min_len = min(min_len, right - left + 1)\n    return min_len\n\n\ndef main():\n    print(minSubArrayLen(7, [2, 3, 1", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        sums[i] = sums[i - 1] + nums[i - 1]\n    min_len = sum(nums) + 1\n    for left in range(n):\n        for right in range(left, n):\n            if sums[right + 1] - sums[left] >= target:\n                min_len = min(min_len, right - left + 1)\n    return min_len\n\n\ndef main():\n    print(minSubArrayLen(7, [2, 3, 1"}
{"task_id": "leetcode/209", "completion": "\n    from functools import reduce\n    sum_list = reduce(lambda x, y: x+y, nums)\n    if sum_list < target:\n        return 0\n    else:\n        min_list = target\n        start = 0\n        end = 0\n        while end < len(nums):\n            min_list = min(min_list, nums[end])\n            while start <= end and min_list <= target:\n                if min_list == target:\n                    return end - start + 1\n                end += 1\n                min_list += nums[end]\n            start += 1\n        return 0\n\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]))\n    print(minSubArrayLen(4, [1, 4, 4]))\n    print(minSubArrayLen(11, [1, 1, 1, 1, 1, 1, 1, 1]))\n    print", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    from functools import reduce\n    sum_list = reduce(lambda x, y: x+y, nums)\n    if sum_list < target:\n        return 0\n    else:\n        min_list = target\n        start = 0\n        end = 0\n        while end < len(nums):\n            min_list = min(min_list, nums[end])\n            while start <= end and min_list <= target:\n                if min_list == target:\n                    return end - start + 1\n                end += 1\n                min_list += nums[end]\n            start += 1\n        return 0\n\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]))\n    print(minSubArrayLen(4, [1, 4, 4]))\n    print(minSubArrayLen(11, [1, 1, 1, 1, 1, 1, 1, 1]))\n    print"}
{"task_id": "leetcode/209", "completion": "\n    pass\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。\n    请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    >>> findMedianSortedArrays([0,0], [0,0])\n    0.0\n    '''\n    pass\n\n\ndef kadanesAAlgorithm(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连��", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    pass\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。\n    请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    >>> findMedianSortedArrays([0,0], [0,0])\n    0.0\n    '''\n    pass\n\n\ndef kadanesAAlgorithm(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连��"}
{"task_id": "leetcode/209", "completion": "\n    left = 0\n    right = 0\n    sum = 0\n    min_len = len(nums) + 1\n    while right < len(nums):\n        sum += nums[right]\n        while sum >= target:\n            min_len = min(min_len, right - left + 1)\n            sum -= nums[left]\n            left += 1\n        right += 1\n    if min_len == len(nums) + 1:\n        return 0\n    return min_len\n\n\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2,3,1,2", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    left = 0\n    right = 0\n    sum = 0\n    min_len = len(nums) + 1\n    while right < len(nums):\n        sum += nums[right]\n        while sum >= target:\n            min_len = min(min_len, right - left + 1)\n            sum -= nums[left]\n            left += 1\n        right += 1\n    if min_len == len(nums) + 1:\n        return 0\n    return min_len\n\n\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2,3,1,2"}
{"task_id": "leetcode/209", "completion": "\n    left, right = 0, 0\n    s = 0\n    n = len(nums)\n    min_n = n + 1\n    while right < n:\n        # 因为不可能有比target更小的数\n        # 所以right往后面走\n        if s + nums[right] >= target:\n            left = min(left, right)\n            s += nums[right]\n            min_n = min(min_n, right - left + 1)\n            right += 1\n        else:\n            s -= nums[left]\n           ", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    left, right = 0, 0\n    s = 0\n    n = len(nums)\n    min_n = n + 1\n    while right < n:\n        # 因为不可能有比target更小的数\n        # 所以right往后面走\n        if s + nums[right] >= target:\n            left = min(left, right)\n            s += nums[right]\n            min_n = min(min_n, right - left + 1)\n            right += 1\n        else:\n            s -= nums[left]\n           "}
{"task_id": "leetcode/209", "completion": "\n    if len(nums) == 1:\n        if nums[0] >= target:\n            return 1\n        else:\n            return 0\n    if nums[0] >= target:  # 预先知道首项不能为0，剩下的简单递归法\n        return 1\n    else:\n        if sum(nums[1:]) >= target:\n            return 2\n        else:\n            return 0\n    '''\n    def minSubArrayLen(target, nums):\n        '''\n        :type nums: List[int]\n        :rtype: int\n        '''\n        if len(nums) == 1:\n            if nums[0] >= target:\n                return 1\n            else:\n                return 0\n        else:\n            if sum(nums) >= target:\n                return 1\n            else:\n                return 0\n    '''\n\n\n# class Solution:\n#     def findMin(self, nums):\n#         \"\"\"\n#         :type nums", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if len(nums) == 1:\n        if nums[0] >= target:\n            return 1\n        else:\n            return 0\n    if nums[0] >= target:  # 预先知道首项不能为0，剩下的简单递归法\n        return 1\n    else:\n        if sum(nums[1:]) >= target:\n            return 2\n        else:\n            return 0\n    '''\n    def minSubArrayLen(target, nums):\n        '''\n        :type nums: List[int]\n        :rtype: int\n        '''\n        if len(nums) == 1:\n            if nums[0] >= target:\n                return 1\n            else:\n                return 0\n        else:\n            if sum(nums) >= target:\n                return 1\n            else:\n                return 0\n    '''\n\n\n# class Solution:\n#     def findMin(self, nums):\n#         \"\"\"\n#         :type nums"}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    # 滑动窗口\n    _sum, _res = 0, float('inf')\n    l, r = 0, 0\n    while r < len(nums):\n        _sum += nums[r]\n        while _sum >= target:\n            # 满足条件的子数组\n            _res = min(_res, r - l + 1)\n            _sum -= nums[l]\n            l += 1\n        r += 1\n    return _res if _res!= float('inf') else 0\n\n\ndef maxArraySum(nums):\n    '''\n    Given n non-negative integers a1, a2,..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.\n    Note: You may not slant the container.", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    # 滑动窗口\n    _sum, _res = 0, float('inf')\n    l, r = 0, 0\n    while r < len(nums):\n        _sum += nums[r]\n        while _sum >= target:\n            # 满足条件的子数组\n            _res = min(_res, r - l + 1)\n            _sum -= nums[l]\n            l += 1\n        r += 1\n    return _res if _res!= float('inf') else 0\n\n\ndef maxArraySum(nums):\n    '''\n    Given n non-negative integers a1, a2,..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.\n    Note: You may not slant the container."}
{"task_id": "leetcode/209", "completion": "\n    left = 0\n    right = 0\n    count = 0\n\n    minSum = 0\n    minLen = len(nums) + 1\n\n    while right < len(nums):\n        count += nums[right]\n        if count >= target:\n            minLen = min(minLen, right - left + 1)\n            while count >= target:\n                count -= nums[left]\n                left += 1\n        right += 1\n    if minLen > len(nums):\n        return 0\n    else:\n        return minLen\n\n\ndef maxArea(height):\n    '''\n   给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    left = 0\n    right = 0\n    count = 0\n\n    minSum = 0\n    minLen = len(nums) + 1\n\n    while right < len(nums):\n        count += nums[right]\n        if count >= target:\n            minLen = min(minLen, right - left + 1)\n            while count >= target:\n                count -= nums[left]\n                left += 1\n        right += 1\n    if minLen > len(nums):\n        return 0\n    else:\n        return minLen\n\n\ndef maxArea(height):\n    '''\n   给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得"}
{"task_id": "leetcode/209", "completion": "\n    result = 0\n    left = 0\n    sum = 0\n    for right, num in enumerate(nums):\n        sum += num\n        while sum >= target:\n            result = max(result, right - left + 1)\n            sum -= nums[left]\n            left += 1\n    return result\n\ndef rob(nums):\n    '''\n    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    result = 0\n    left = 0\n    sum = 0\n    for right, num in enumerate(nums):\n        sum += num\n        while sum >= target:\n            result = max(result, right - left + 1)\n            sum -= nums[left]\n            left += 1\n    return result\n\ndef rob(nums):\n    '''\n    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不"}
{"task_id": "leetcode/1", "completion": "\n    for i, v in enumerate(nums):\n        for j in range(i+1, len(nums)):\n            if nums[j] == target - v:\n                return [i, j]\n\n\nif __name__ == '__main__':\n    import doct", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i, v in enumerate(nums):\n        for j in range(i+1, len(nums)):\n            if nums[j] == target - v:\n                return [i, j]\n\n\nif __name__ == '__main__':\n    import doct"}
{"task_id": "leetcode/1", "completion": "\n    m = {}\n    for x in range(len(nums)):\n        t = target - nums[x]\n        if t in m:\n            return [m[t], x]\n        else:\n            m[nums[x]] = x\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    说明：\n    你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n    示例 1:\n        输入: [2,2,1]\n        输出: 1\n    示例 2:\n        输入: [4,1,2,1,2]\n        输出: 4\n    '''\n    set1 = set(nums)\n    set2", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    m = {}\n    for x in range(len(nums)):\n        t = target - nums[x]\n        if t in m:\n            return [m[t], x]\n        else:\n            m[nums[x]] = x\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    说明：\n    你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n    示例 1:\n        输入: [2,2,1]\n        输出: 1\n    示例 2:\n        输入: [4,1,2,1,2]\n        输出: 4\n    '''\n    set1 = set(nums)\n    set2"}
{"task_id": "leetcode/1", "completion": "\n    # 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    # 你可以假设每种输入只会对"}
{"task_id": "leetcode/1", "completion": "\n    table = {}\n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in table:\n            return [table[diff], i]\n        table[n] = i\n\n\nif __name__ == '__main__':\n    res = twoSum([3,2,4], 6)\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    table = {}\n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in table:\n            return [table[diff], i]\n        table[n] = i\n\n\nif __name__ == '__main__':\n    res = twoSum([3,2,4], 6)\n"}
{"task_id": "leetcode/1", "completion": "\n    # 暴力法：对于每个元素num，从后往前，一次遍历找出它的目标值\n    # time complexity O(n^2)\n    # space complexity O(1)\n    # result = []\n    # for i in range(0, len(nums)-1):\n    #     for j in range(i + 1, len(nums)):\n    #         if nums[i] + nums[j] == target:\n    #             result.append(i)\n    #             result.append(j)\n    #             return result\n    # return result\n\n    # 使用哈希表：\n    # 扫描数组，对于每个元素num，检查哈希表里是否有和num相加可以等于目标值的其他元素。\n    # 如果有，记下这个和目标值相等的其他元素的下标。\n    # 时间复��", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 暴力法：对于每个元素num，从后往前，一次遍历找出它的目标值\n    # time complexity O(n^2)\n    # space complexity O(1)\n    # result = []\n    # for i in range(0, len(nums)-1):\n    #     for j in range(i + 1, len(nums)):\n    #         if nums[i] + nums[j] == target:\n    #             result.append(i)\n    #             result.append(j)\n    #             return result\n    # return result\n\n    # 使用哈希表：\n    # 扫描数组，对于每个元素num，检查哈希表里是否有和num相加可以等于目标值的其他元素。\n    # 如果有，记下这个和目标值相等的其他元素的下标。\n    # 时间复��"}
{"task_id": "leetcode/1", "completion": "\n    dict_ = {}\n    for i, v in enumerate(nums):\n        if v in dict_:\n            return [dict_[v], i]\n        else:\n            dict_[target - v] = i\n\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    [0, 1]\n    '''\n    for", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    dict_ = {}\n    for i, v in enumerate(nums):\n        if v in dict_:\n            return [dict_[v], i]\n        else:\n            dict_[target - v] = i\n\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    [0, 1]\n    '''\n    for"}
{"task_id": "leetcode/1", "completion": "\n    return two_sum(nums, target)\n\n\ndef two_sum(nums, target):\n    i=0\n    length=len(nums)\n    for j in range(length):\n        if nums[j]<target and j!=i:\n            index = bisect.bisect_right(nums, target-nums[j])\n            if index<length and index!=j:\n                return [j,index]\n        elif nums[j]>target and nums[j]!=nums[i]:\n            index = bisect.bisect_right(nums, target-nums[i])\n            if j!=index:\n                return [i,index]\n        i += 1\n    return nums,target\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    说明", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    return two_sum(nums, target)\n\n\ndef two_sum(nums, target):\n    i=0\n    length=len(nums)\n    for j in range(length):\n        if nums[j]<target and j!=i:\n            index = bisect.bisect_right(nums, target-nums[j])\n            if index<length and index!=j:\n                return [j,index]\n        elif nums[j]>target and nums[j]!=nums[i]:\n            index = bisect.bisect_right(nums, target-nums[i])\n            if j!=index:\n                return [i,index]\n        i += 1\n    return nums,target\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    说明"}
{"task_id": "leetcode/1", "completion": "\n    for i in range(len(nums)):\n        m = target - nums[i]\n        if m in nums[i+1:]:\n            return i+1, nums[i+1:].index(m) + i+1\n\n\ndef threeSum(nums):\n    '''\n    给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1,0,1,2,-1,-4])\n    [[-1, -1, 2],\n     [-1, 0, 1]]\n    '''\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if i > 0 and num", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i in range(len(nums)):\n        m = target - nums[i]\n        if m in nums[i+1:]:\n            return i+1, nums[i+1:].index(m) + i+1\n\n\ndef threeSum(nums):\n    '''\n    给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1,0,1,2,-1,-4])\n    [[-1, -1, 2],\n     [-1, 0, 1]]\n    '''\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if i > 0 and num"}
{"task_id": "leetcode/1", "completion": "\n    dict_nums = {}\n    for i, num in enumerate(nums):\n        another_num = target - num\n        if another_num in dict_nums:\n            return [dict_nums[another_num], i]\n        else:\n            dict_nums[num] = i\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1：\n        输入：s = \"abcabcbb\"\n        输出：3\n        解释：无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2：\n        输入：s = \"bbbbb\"\n        输出：1\n        解释：无重复字符的最长子串是 \"b\"，所以其长度为 1。\n    示例 3：\n        输入：s = \"pww", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    dict_nums = {}\n    for i, num in enumerate(nums):\n        another_num = target - num\n        if another_num in dict_nums:\n            return [dict_nums[another_num], i]\n        else:\n            dict_nums[num] = i\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1：\n        输入：s = \"abcabcbb\"\n        输出：3\n        解释：无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2：\n        输入：s = \"bbbbb\"\n        输出：1\n        解释：无重复字符的最长子串是 \"b\"，所以其长度为 1。\n    示例 3：\n        输入：s = \"pww"}
{"task_id": "leetcode/1", "completion": "\n    n = len(nums)\n    nums = dict(zip(nums, range(n)))\n    for i, v in enumerate(nums):\n        if target - v in nums:\n            return [nums[target - v], i]\n    return None\n\n\nif __name__ == '__main__':\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, 3], 6))\n    print(twoSum([0, 4, 3, 0], 0))\n    print(twoSum([1, 2, 4, 3, 1], 4))\n    print(twoSum([1, 2, 4, 3, 1], 2))\n    print(twoSum([2, 4, 3, 1, 1], 2))\n    print(twoSum([2, 4, 3, 1, 1], 3))\n    print(twoSum([2, 4, 3, 1, 1], 4))\n    print(two", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    n = len(nums)\n    nums = dict(zip(nums, range(n)))\n    for i, v in enumerate(nums):\n        if target - v in nums:\n            return [nums[target - v], i]\n    return None\n\n\nif __name__ == '__main__':\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, 3], 6))\n    print(twoSum([0, 4, 3, 0], 0))\n    print(twoSum([1, 2, 4, 3, 1], 4))\n    print(twoSum([1, 2, 4, 3, 1], 2))\n    print(twoSum([2, 4, 3, 1, 1], 2))\n    print(twoSum([2, 4, 3, 1, 1], 3))\n    print(twoSum([2, 4, 3, 1, 1], 4))\n    print(two"}
{"task_id": "leetcode/409", "completion": "\n    # 假如 字符串中有 偶数个 字母，那么 最长回文串 的长度 等于 字符串的长度\n    # 假如 字符串中有 奇数个 字母，那么 最长回文串 的长度 等于 字符串的长度 + 1\n    if not s:\n        return 0\n    # 遍历 字符串 中 每个 字符\n    res = 0\n    left = 0\n    right = 0\n    for i in range(len(s)):\n        # 假如 字符串 中 存在 偶数个 字母\n        # 那么 最长回文串 的长度 等于 字符串的长度\n        # 如果 字符串中 存在 奇数个 字母\n        # 那么 最长回文串 的长度 等于 字符串的长度 + ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 假如 字符串中有 偶数个 字母，那么 最长回文串 的长度 等于 字符串的长度\n    # 假如 字符串中有 奇数个 字母，那么 最长回文串 的长度 等于 字符串的长度 + 1\n    if not s:\n        return 0\n    # 遍历 字符串 中 每个 字符\n    res = 0\n    left = 0\n    right = 0\n    for i in range(len(s)):\n        # 假如 字符串 中 存在 偶数个 字母\n        # 那么 最长回文串 的长度 等于 字符串的长度\n        # 如果 字符串中 存在 奇数个 字母\n        # 那么 最长回文串 的长度 等于 字符串的长度 + "}
{"task_id": "leetcode/409", "completion": "\n    s = s.lower()\n    res = {}\n    for ch in s:\n        if ch not in res:\n            res[ch] = 1\n        else:\n            res[ch] += 1\n    even, odd, max_res = 0, 0, 0\n    for k, v in res.items():\n        if v % 2 == 0:\n            even += v // 2 + 1\n        else:\n            odd += v // 2\n    return even + odd + 1 if even % 2 == 0 else even + odd\n\n\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n    示例 1：\n        输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n        输出：       6\n        解释", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    s = s.lower()\n    res = {}\n    for ch in s:\n        if ch not in res:\n            res[ch] = 1\n        else:\n            res[ch] += 1\n    even, odd, max_res = 0, 0, 0\n    for k, v in res.items():\n        if v % 2 == 0:\n            even += v // 2 + 1\n        else:\n            odd += v // 2\n    return even + odd + 1 if even % 2 == 0 else even + odd\n\n\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n    示例 1：\n        输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n        输出：       6\n        解释"}
{"task_id": "leetcode/409", "completion": "\n\n    def max(x, y):\n        if x > y:\n            return x\n        else:\n            return y\n\n    dp = [1 for _ in s]\n    # 初始化\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            dp[i] = 2\n\n    # dp[i]是以s[i]结尾的回文串的长度\n    for i in range(len(s)):\n        for j in range(i):\n            if s[i] == s[j] and dp[i] < dp[j] + 2:\n                dp[i] = dp[j] + 2\n\n    return max(dp)\n\n\ndef main():\n    s = \"bbbab\"\n    # s = \"cbbd\"\n    s = \"aaaa\"\n    s = \"abcba\"\n    s = \"aaa\"\n    print(longestPal", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n\n    def max(x, y):\n        if x > y:\n            return x\n        else:\n            return y\n\n    dp = [1 for _ in s]\n    # 初始化\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            dp[i] = 2\n\n    # dp[i]是以s[i]结尾的回文串的长度\n    for i in range(len(s)):\n        for j in range(i):\n            if s[i] == s[j] and dp[i] < dp[j] + 2:\n                dp[i] = dp[j] + 2\n\n    return max(dp)\n\n\ndef main():\n    s = \"bbbab\"\n    # s = \"cbbd\"\n    s = \"aaaa\"\n    s = \"abcba\"\n    s = \"aaa\"\n    print(longestPal"}
{"task_id": "leetcode/409", "completion": "\n    s = \"#\" + s.lower() + \"#\"\n    N = len(s)\n    # 初始化长度为 1 的回文串，即自己本身\n    p = [0 for _ in range(N)]\n    center = right = 0\n    radius = 1\n    for i in range(1, N):\n        i_mirror = 2 * center - i\n        if i - p[i_mirror] > radius: # 如果新增的回文串比之前的长，说明回文串有更优的中心\n            center, right, radius = i, i_mirror, i - p[i_mirror]\n        p[i] = min(p[i_mirror] + (i == i_mirror), radius)\n    return p[N - 1]\n\ndef longestPalindrome(s):\n    '''\n    给你一个仅由大写字母组成的字符串 s，返回最长回文子字符串的长度。", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    s = \"#\" + s.lower() + \"#\"\n    N = len(s)\n    # 初始化长度为 1 的回文串，即自己本身\n    p = [0 for _ in range(N)]\n    center = right = 0\n    radius = 1\n    for i in range(1, N):\n        i_mirror = 2 * center - i\n        if i - p[i_mirror] > radius: # 如果新增的回文串比之前的长，说明回文串有更优的中心\n            center, right, radius = i, i_mirror, i - p[i_mirror]\n        p[i] = min(p[i_mirror] + (i == i_mirror), radius)\n    return p[N - 1]\n\ndef longestPalindrome(s):\n    '''\n    给你一个仅由大写字母组成的字符串 s，返回最长回文子字符串的长度。"}
{"task_id": "leetcode/409", "completion": "\n\n    if len(s) <= 1:\n        return len(s)\n\n    @lru_cache(maxsize=None)\n    def helper(l, r):\n        if l > r:\n            return 0\n        if l == r:\n            return 1\n\n        mid = (l + r) // 2\n        left_len = helper(l, mid-1)\n        right_len = helper(mid+1, r)\n\n        if s[mid] == s[mid-1] and left_len == right_len:\n            return left_len + 1 + right_len\n\n        if left_len > right_len:\n            return left_len + 1\n        else:\n            return right_len + 1\n\n    return helper(0, len(s)-1)\n```\n\n这个解法涉及缓存，所以看一下[官方解法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n\n    if len(s) <= 1:\n        return len(s)\n\n    @lru_cache(maxsize=None)\n    def helper(l, r):\n        if l > r:\n            return 0\n        if l == r:\n            return 1\n\n        mid = (l + r) // 2\n        left_len = helper(l, mid-1)\n        right_len = helper(mid+1, r)\n\n        if s[mid] == s[mid-1] and left_len == right_len:\n            return left_len + 1 + right_len\n\n        if left_len > right_len:\n            return left_len + 1\n        else:\n            return right_len + 1\n\n    return helper(0, len(s)-1)\n```\n\n这个解法涉及缓存，所以看一下[官方解法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-"}
{"task_id": "leetcode/409", "completion": "\n    # 排除长度为1的情况\n    if len(s) <= 1:\n        return len(s)\n    # 记录最长回文串的长度\n    max_ = 1\n    # 最长回文串的开始下标\n    start = 0\n    # 遍历字符串\n    for i in range(len(s)):\n        # 奇数回文串\n        l = longest_palindrome(s, i, i)\n        # 偶数回文串\n        r = longest_palindrome(s, i, i + 1)\n        if l > r:\n            # 选择较大的长度\n            if l > max_:\n                # 记录最大长度和开始下标\n                max_ = l\n                start = i - (l - 1) // 2\n        else:\n            # 选择较大的长度\n            if r > max_:\n                # 记录最大", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 排除长度为1的情况\n    if len(s) <= 1:\n        return len(s)\n    # 记录最长回文串的长度\n    max_ = 1\n    # 最长回文串的开始下标\n    start = 0\n    # 遍历字符串\n    for i in range(len(s)):\n        # 奇数回文串\n        l = longest_palindrome(s, i, i)\n        # 偶数回文串\n        r = longest_palindrome(s, i, i + 1)\n        if l > r:\n            # 选择较大的长度\n            if l > max_:\n                # 记录最大长度和开始下标\n                max_ = l\n                start = i - (l - 1) // 2\n        else:\n            # 选择较大的长度\n            if r > max_:\n                # 记录最大"}
{"task_id": "leetcode/409", "completion": "\n    res = 0\n    s = \"\".join([c for c in s if c.islower()])\n    length = len(s)\n    if length == 1:\n        return 1\n    elif length == 2:\n        if s[0] == s[1]:\n            return 2\n        return 1\n    else:\n        dp = [[False for i in range(length)] for j in range(length)]\n        for i in range(length):\n            for j in range(i+1):\n                if i == 0 or j == 0:\n                    dp[i][j] = True\n                else:\n                    if s[i] == s[j]:\n                        if (i - j == 1) or dp[i - 1][j + 1] is True:\n                            dp[i][j] = True\n                    res = max(res, j - i + 1)\n        return res\n\n\nif __name__ == '__main__':\n    s = \"bbbab\"\n#     print(longestPalind", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    res = 0\n    s = \"\".join([c for c in s if c.islower()])\n    length = len(s)\n    if length == 1:\n        return 1\n    elif length == 2:\n        if s[0] == s[1]:\n            return 2\n        return 1\n    else:\n        dp = [[False for i in range(length)] for j in range(length)]\n        for i in range(length):\n            for j in range(i+1):\n                if i == 0 or j == 0:\n                    dp[i][j] = True\n                else:\n                    if s[i] == s[j]:\n                        if (i - j == 1) or dp[i - 1][j + 1] is True:\n                            dp[i][j] = True\n                    res = max(res, j - i + 1)\n        return res\n\n\nif __name__ == '__main__':\n    s = \"bbbab\"\n#     print(longestPalind"}
{"task_id": "leetcode/409", "completion": "\n    result = 0\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    for i in range(len(s)):\n        result += dp[i][i]\n        if i + dp[i][i] < len(s):\n            result += dp[i + dp[i][i]][i]\n    return result\n\n\ndef longestSubstringWithoutRepeatingCharacters(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1:\n    输入: \"abcabcbb\"\n    输出: 3\n    解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2:\n    输入: \"bbbbb\"\n    输出: 1\n    解释: 因为无重复字符的", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    result = 0\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    for i in range(len(s)):\n        result += dp[i][i]\n        if i + dp[i][i] < len(s):\n            result += dp[i + dp[i][i]][i]\n    return result\n\n\ndef longestSubstringWithoutRepeatingCharacters(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1:\n    输入: \"abcabcbb\"\n    输出: 3\n    解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2:\n    输入: \"bbbbb\"\n    输出: 1\n    解释: 因为无重复字符的"}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    if len(s) <= 2:\n        return len(s)\n\n    result = 0\n    # 循环枚举子串，避免重复计算\n    for i in range(len(s) - 1):\n        # 奇数长度的子串，只有一种情况\n        if s[i] == s[i+1]:\n            result = max(result, 2)\n\n        # 偶数长度的子串，还有一种情况\n        if s[i] == s[i+2]:\n            result = max(result, 3)\n\n    return result\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    if len(s) <= 2:\n        return len(s)\n\n    result = 0\n    # 循环枚举子串，避免重复计算\n    for i in range(len(s) - 1):\n        # 奇数长度的子串，只有一种情况\n        if s[i] == s[i+1]:\n            result = max(result, 2)\n\n        # 偶数长度的子串，还有一种情况\n        if s[i] == s[i+2]:\n            result = max(result, 3)\n\n    return result\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    # 动态规划\n    dp = [[0] * n for _ in range(n)]\n    mx = 0\n    for i in range(n):\n        for j in range(i, -1, -1):\n            if s[j] == s[i]:\n                dp[j][i] = 2 + (i - j >= 2 and dp[j + 1][i - 1])\n            print(dp[j][i])\n            mx = max(mx, dp[j][i])\n    return mx\n\n\ndef solve(s):\n    n = len(s)\n    l = r = 0\n    start = end = 0\n    for j in range(n):\n        # 开始为偶数\n        for l in range(j, n):\n            # 结尾为奇数\n            if l % 2 == 0:\n                r = j\n            # 开始为奇数\n            else:\n                r = j - 1\n           ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    # 动态规划\n    dp = [[0] * n for _ in range(n)]\n    mx = 0\n    for i in range(n):\n        for j in range(i, -1, -1):\n            if s[j] == s[i]:\n                dp[j][i] = 2 + (i - j >= 2 and dp[j + 1][i - 1])\n            print(dp[j][i])\n            mx = max(mx, dp[j][i])\n    return mx\n\n\ndef solve(s):\n    n = len(s)\n    l = r = 0\n    start = end = 0\n    for j in range(n):\n        # 开始为偶数\n        for l in range(j, n):\n            # 结尾为奇数\n            if l % 2 == 0:\n                r = j\n            # 开始为奇数\n            else:\n                r = j - 1\n           "}
{"task_id": "leetcode/121", "completion": "\n    if not prices:\n        return 0\n    buy = prices[0]\n    maxProf = 0\n    for i in range(len(prices)):\n        if prices[i] < buy:\n            buy = prices[i]\n        else:\n            maxProf = max(maxProf, prices[i] - buy)\n    return maxProf\n\nif __name__ == \"__main__\":\n    import doctest\n    # doctest.testmod()\n    print(maxProfit([1,2,3,4,5]))\n    print(maxProfit([7,1,5,3,6,4]))\n    print(maxProfit([7,6,4,3,1]))\n    print(maxProfit([7,6,4,5,3,1]))\n    print(maxProfit([7,6", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if not prices:\n        return 0\n    buy = prices[0]\n    maxProf = 0\n    for i in range(len(prices)):\n        if prices[i] < buy:\n            buy = prices[i]\n        else:\n            maxProf = max(maxProf, prices[i] - buy)\n    return maxProf\n\nif __name__ == \"__main__\":\n    import doctest\n    # doctest.testmod()\n    print(maxProfit([1,2,3,4,5]))\n    print(maxProfit([7,1,5,3,6,4]))\n    print(maxProfit([7,6,4,3,1]))\n    print(maxProfit([7,6,4,5,3,1]))\n    print(maxProfit([7,6"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) < 2:\n        return 0\n    minPrice = prices[0]\n    maxProfit = 0\n    for i in range(1, len(prices)):\n        maxProfit = max(maxProfit, prices[i]-minPrice)\n        minPrice = min(minPrice, prices[i])\n    return maxProfit\n\n\ndef maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) < 2:\n        return 0\n    minPrice = prices[0]\n    maxProfit = 0\n    for i in range(1, len(prices)):\n        maxProfit = max(maxProfit, prices[i]-minPrice)\n        minPrice = min(minPrice, prices[i])\n    return maxProfit\n\n\ndef maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大"}
{"task_id": "leetcode/121", "completion": "\n    n = len(prices)\n    if n < 2:\n        return 0\n    minPrice = prices[0]\n    maxProfit = 0\n    for i in range(1, n):\n        minPrice = min(minPrice, prices[i])\n        maxProfit = max(maxProfit, prices[i] - minPrice)\n    return maxProfit\n```\n\n### 动态规划\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        '''\n        给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    n = len(prices)\n    if n < 2:\n        return 0\n    minPrice = prices[0]\n    maxProfit = 0\n    for i in range(1, n):\n        minPrice = min(minPrice, prices[i])\n        maxProfit = max(maxProfit, prices[i] - minPrice)\n    return maxProfit\n```\n\n### 动态规划\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        '''\n        给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能"}
{"task_id": "leetcode/121", "completion": "\n    res = 0\n    for i in range(1, len(prices)):\n        res += max(prices[i] - prices[i-1], 0)\n    \n    return res\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    res = 0\n    for i in range(1, len(prices)):\n        res += max(prices[i] - prices[i-1], 0)\n    \n    return res\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6"}
{"task_id": "leetcode/121", "completion": "\n    max_profit = 0\n    min_price = prices[0]\n    for price in prices[1:]:\n        max_profit = max(max_profit, price-min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\ndef minStockForSell(dates, prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    max_profit = 0\n    min_price = prices[0]\n    for price in prices[1:]:\n        max_profit = max(max_profit, price-min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\ndef minStockForSell(dates, prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) == 1:\n        return 0\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit += max(0, prices[i] - prices[i-1])\n    return max_profit\n\ndef twoSum(nums, target):\n    '''\n    统计有多少对数字之和为target\n    >>> twoSum([2, 7, 11, 15], 9)\n    2\n    '''\n    d = {}\n    count = 0\n    for num in nums:\n        if num in d:\n            return 1\n        d[target-num] = 1\n    return 0\n\ndef searchRange(nums, target):\n    '''\n    输入一个按照升序排序的数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n    如果数组中不存在目标", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) == 1:\n        return 0\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit += max(0, prices[i] - prices[i-1])\n    return max_profit\n\ndef twoSum(nums, target):\n    '''\n    统计有多少对数字之和为target\n    >>> twoSum([2, 7, 11, 15], 9)\n    2\n    '''\n    d = {}\n    count = 0\n    for num in nums:\n        if num in d:\n            return 1\n        d[target-num] = 1\n    return 0\n\ndef searchRange(nums, target):\n    '''\n    输入一个按照升序排序的数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n    如果数组中不存在目标"}
{"task_id": "leetcode/121", "completion": "\n    maxProfit = 0\n    if len(prices) < 2:\n        return 0\n    i = 0\n    for i in range(len(prices)-1):\n        if prices[i] < prices[i+1]:\n            maxProfit += prices[i+1] - prices[i]\n    return maxProfit\n\n\ndef maxProfitTwo(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你能否计算出指定股票第 i 天（即，一天之内的最后一个交易日）的最大利润？\n    注意：你不能在买入股票前卖出股票。\n    举例2：\n    >>> maxProfitTwo([7,1,5,3,6,4])\n    4\n", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    maxProfit = 0\n    if len(prices) < 2:\n        return 0\n    i = 0\n    for i in range(len(prices)-1):\n        if prices[i] < prices[i+1]:\n            maxProfit += prices[i+1] - prices[i]\n    return maxProfit\n\n\ndef maxProfitTwo(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你能否计算出指定股票第 i 天（即，一天之内的最后一个交易日）的最大利润？\n    注意：你不能在买入股票前卖出股票。\n    举例2：\n    >>> maxProfitTwo([7,1,5,3,6,4])\n    4\n"}
{"task_id": "leetcode/121", "completion": "\n    res = 0\n    minPrice = prices[0]\n    for x in prices:\n        if x < minPrice:\n            minPrice = x\n        if x - minPrice > r:\n            res = max(res, x - minPrice)\n    return res\n```\n\n## 随机跳跃\n\n```python\nfrom random import randint\n\ndef random_jump(num):\n    '''\n    给定正整数 n ，你可以做如下操作：\n\n    1. 跳到第 n 个位置，跳过 1 - n 个位置，\n    2. 跳到第 n - 1 个位置，跳过 1 - (n - 1) 个位置，\n    3. 一直跳到第 1 个位置，跳过 1 - 1 个位置。\n    注意: 任何时候你都不能跳到数组的后半部分。\n    给", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    res = 0\n    minPrice = prices[0]\n    for x in prices:\n        if x < minPrice:\n            minPrice = x\n        if x - minPrice > r:\n            res = max(res, x - minPrice)\n    return res\n```\n\n## 随机跳跃\n\n```python\nfrom random import randint\n\ndef random_jump(num):\n    '''\n    给定正整数 n ，你可以做如下操作：\n\n    1. 跳到第 n 个位置，跳过 1 - n 个位置，\n    2. 跳到第 n - 1 个位置，跳过 1 - (n - 1) 个位置，\n    3. 一直跳到第 1 个位置，跳过 1 - 1 个位置。\n    注意: 任何时候你都不能跳到数组的后半部分。\n    给"}
{"task_id": "leetcode/121", "completion": "\n    minPrice = prices[0]\n    maxProfit = 0\n    for price in prices:\n        if price < minPrice:\n            minPrice = price\n        elif price - minPrice > maxProfit:\n            maxProfit = price - minPrice\n    return maxProfit\n\n\ndef merge(intervals):\n    '''\n    给出一个区间的集合，请合并所有重叠的区间。\n    示例 1：\n    输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n    输出：[[1,6],[8,10],[15,18]]\n    解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n    示例 2：\n    输入：intervals = [[1,4],[4,5]]\n    输出：[[1,5]]\n    解释：区间 [1,4] 和 [4,5] ", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    minPrice = prices[0]\n    maxProfit = 0\n    for price in prices:\n        if price < minPrice:\n            minPrice = price\n        elif price - minPrice > maxProfit:\n            maxProfit = price - minPrice\n    return maxProfit\n\n\ndef merge(intervals):\n    '''\n    给出一个区间的集合，请合并所有重叠的区间。\n    示例 1：\n    输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n    输出：[[1,6],[8,10],[15,18]]\n    解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n    示例 2：\n    输入：intervals = [[1,4],[4,5]]\n    输出：[[1,5]]\n    解释：区间 [1,4] 和 [4,5] "}
{"task_id": "leetcode/121", "completion": "\n    if not prices: return 0\n    mini, maxProf = prices[0], 0\n    for price in prices:\n        maxProf = max(maxProf, price - mini)\n        mini = min(mini, price)\n    return maxProf\n\n\ndef maxProfit_B(prices):\n    '''\n    贪心算法\n    >>> maxProfit_B([7,1,5,3,6,4])\n    5\n    >>> maxProfit_B([7,6,4,3,1])\n    0\n    '''\n    if not prices: return 0\n    maxProfit, mini = 0, prices[0]\n    for price in prices:\n        if price - mini > maxProfit:\n            maxProfit = price - mini\n        mini = min(mini, price)\n    return maxProfit\n\n\ndef maxProfit_C(prices):\n    '''\n    贪心算法: 倒序遍历\n    >>> maxProfit_C([7,1,5,3", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if not prices: return 0\n    mini, maxProf = prices[0], 0\n    for price in prices:\n        maxProf = max(maxProf, price - mini)\n        mini = min(mini, price)\n    return maxProf\n\n\ndef maxProfit_B(prices):\n    '''\n    贪心算法\n    >>> maxProfit_B([7,1,5,3,6,4])\n    5\n    >>> maxProfit_B([7,6,4,3,1])\n    0\n    '''\n    if not prices: return 0\n    maxProfit, mini = 0, prices[0]\n    for price in prices:\n        if price - mini > maxProfit:\n            maxProfit = price - mini\n        mini = min(mini, price)\n    return maxProfit\n\n\ndef maxProfit_C(prices):\n    '''\n    贪心算法: 倒序遍历\n    >>> maxProfit_C([7,1,5,3"}


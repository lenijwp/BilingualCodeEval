{"task_id": "HumanEval/0", "completion": "    for i, a in enumerate(numbers[:-1]):\n        for b in numbers[i + 1:]:\n            if a == b:\n                continue\n            if abs(a - b) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, a in enumerate(numbers[:-1]):\n        for b in numbers[i + 1:]:\n            if a == b:\n                continue\n            if abs(a - b) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do"}
{"task_id": "HumanEval/0", "completion": "\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i]!= numbers[j] and abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_duplicate(numbers: List[float]) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有重复元素    >>> has_duplicate([1.0, 2.0, 3.0])\n    False\n    >>> has_duplicate([1.0, 1.0, 1.0, 2.0])\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] == numbers[j]:\n                return True\n    return False\n\n\ndef has_arithmetic(numbers: List[float]) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的和为", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i]!= numbers[j] and abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_duplicate(numbers: List[float]) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有重复元素    >>> has_duplicate([1.0, 2.0, 3.0])\n    False\n    >>> has_duplicate([1.0, 1.0, 1.0, 2.0])\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] == numbers[j]:\n                return True\n    return False\n\n\ndef has_arithmetic(numbers: List[float]) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的和为"}
{"task_id": "HumanEval/0", "completion": "    return any(abs(numbers[i] - numbers[i-1]) < threshold for i in range(1, len(numbers)))\n\n# -----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndef find_duplicates(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\" 返回一个列表，包含所有在给定的数字列表中，距离小于给定的阈值的数字。\n    注意，输出的列表中没有重复数字。  >>> find_duplicates([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n    [2.0]\n    \"\"\"\n    return [i for i in numbers if has_close_elements(numbers, i - threshold)]\n\n# -----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndef all_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return any(abs(numbers[i] - numbers[i-1]) < threshold for i in range(1, len(numbers)))\n\n# -----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndef find_duplicates(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\" 返回一个列表，包含所有在给定的数字列表中，距离小于给定的阈值的数字。\n    注意，输出的列表中没有重复数字。  >>> find_duplicates([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n    [2.0]\n    \"\"\"\n    return [i for i in numbers if has_close_elements(numbers, i - threshold)]\n\n# -----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndef all_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n# 作者：LeetCode\n# 链接：https://leetcode-cn.com/problems/contains-duplicate-iii/solution/bu-tong-de-san-shu-zi-lc-dan-tu-de-xiao-xi-wu/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n## 36. 有效的数独\n\n[https://leetcode-cn.com/problems/valid-sudoku/](https", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n# 作者：LeetCode\n# 链接：https://leetcode-cn.com/problems/contains-duplicate-iii/solution/bu-tong-de-san-shu-zi-lc-dan-tu-de-xiao-xi-wu/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n## 36. 有效的数独\n\n[https://leetcode-cn.com/problems/valid-sudoku/](https"}
{"task_id": "HumanEval/0", "completion": "\n    if len(numbers) < 3:\n        return False\n\n    for index, value in enumerate(numbers):\n        if index > 0:\n            for other_index, other_value in enumerate(numbers):\n                if not other_index == index:\n                    if abs(other_value - value) <= threshold:\n                        return True\n        else:\n            for other_value in numbers[1:]:\n                if abs(value - other_value) <= threshold:\n                    return True\n    return False\n\n\ndef has_close_elements_2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    if len(numbers) < 3:\n        return False\n\n    for index, value in enumerate(numbers):\n        if index > 0:\n            for other_index, other_value in enumerate(numbers):\n                if not other_index == index:\n                    if abs(other_value - value) <= threshold:\n                        return True\n        else:\n            for other_value in numbers[1:]:\n                if abs(value - other_value) <= threshold:\n                    return True\n    return False\n\n\ndef has_close_elements_2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0."}
{"task_id": "HumanEval/0", "completion": "    if len(numbers) < 2:\n        return False\n    for i, first in enumerate(numbers[:-1]):\n        for second in numbers[i + 1:]:\n            if abs(first - second) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))  # True\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([], 0.3))  # False\n    print(has_close_elements([", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    for i, first in enumerate(numbers[:-1]):\n        for second in numbers[i + 1:]:\n            if abs(first - second) < threshold:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))  # True\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([], 0.3))  # False\n    print(has_close_elements(["}
{"task_id": "HumanEval/0", "completion": "    for i, num1 in enumerate(numbers):\n        for num2 in numbers[i + 1:]:\n            if abs(num1 - num2) < threshold:\n                return True\n    return False\n\n\ndef check_list(data: List[int], n: int) -> bool:\n    \"\"\" 在给定的数字列表中，是否有三个相同的数字    >>> check_list([3,4,5,6,7,8], 3)\n    True\n    >>> check_list([3,4,5,3,3,3,4,3], 3)\n    False\n    \"\"\"\n    count = 0\n    for i in range(len(data)):\n        if data.count(data[i]) == n:\n            count += 1\n    if count >= 2:\n        return True\n    return False\n\n\ndef check_list1(data: List[int], k: int) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有连续k个数字相等    >>>", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, num1 in enumerate(numbers):\n        for num2 in numbers[i + 1:]:\n            if abs(num1 - num2) < threshold:\n                return True\n    return False\n\n\ndef check_list(data: List[int], n: int) -> bool:\n    \"\"\" 在给定的数字列表中，是否有三个相同的数字    >>> check_list([3,4,5,6,7,8], 3)\n    True\n    >>> check_list([3,4,5,3,3,3,4,3], 3)\n    False\n    \"\"\"\n    count = 0\n    for i in range(len(data)):\n        if data.count(data[i]) == n:\n            count += 1\n    if count >= 2:\n        return True\n    return False\n\n\ndef check_list1(data: List[int], k: int) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有连续k个数字相等    >>>"}
{"task_id": "HumanEval/0", "completion": "\n    # 虽然此处没有使用内置函数，但此处却调用了内置函数 set()\n    numbers_set = set()\n    for v in numbers:\n        if v in numbers_set:\n            return True  # 如果距离小于0.5，那么肯定是重复数字\n        else:\n            numbers_set.add(v)\n    return False\n\n\ndef has_close_elements_1(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    # 虽然此处没有使用内置函数，但此处却调用了内置函数 set()\n    numbers_set = set()\n    for v in numbers:\n        if v in numbers_set:\n            return True  # 如果距离小于0.5，那么肯定是重复数字\n        else:\n            numbers_set.add(v)\n    return False\n\n\ndef has_close_elements_1(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""}
{"task_id": "HumanEval/0", "completion": "    for i, number in enumerate(numbers):\n        for other_number in numbers[i + 1:]:\n            if math.fabs(number - other_number) < threshold:\n                return True\n    return False\n\n\ndef main():\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([1.0, 2.8, 3", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, number in enumerate(numbers):\n        for other_number in numbers[i + 1:]:\n            if math.fabs(number - other_number) < threshold:\n                return True\n    return False\n\n\ndef main():\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # False\n    print(has_close_elements([1.0, 2.8, 3"}
{"task_id": "HumanEval/0", "completion": "    size = len(numbers)\n    for i in range(size):\n        if not isinstance(numbers[i], (float, int)):\n            raise TypeError(\"numbers list can only contain numbers\")\n    # 将差分后的元素分为三类，分别是相等的差（-1）、大于阈值的差（1）和小于阈值的差（0），然后逐步向前遍历，判断是否跟前面的值相等\n    diffs = [0 for _ in range(size)]\n    for i in range(size):\n        for j in range(i):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                diffs[i] = -1\n        for j in range(i + 1, size):\n            if numbers[i] < numbers[j]:\n                if (numbers[j] - numbers[i]) < threshold:\n                    diffs[i] = 1\n                if diffs[j]", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    size = len(numbers)\n    for i in range(size):\n        if not isinstance(numbers[i], (float, int)):\n            raise TypeError(\"numbers list can only contain numbers\")\n    # 将差分后的元素分为三类，分别是相等的差（-1）、大于阈值的差（1）和小于阈值的差（0），然后逐步向前遍历，判断是否跟前面的值相等\n    diffs = [0 for _ in range(size)]\n    for i in range(size):\n        for j in range(i):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                diffs[i] = -1\n        for j in range(i + 1, size):\n            if numbers[i] < numbers[j]:\n                if (numbers[j] - numbers[i]) < threshold:\n                    diffs[i] = 1\n                if diffs[j]"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### 使用lambda表达式\n`lambda表达式`是`Python`内置函数`filter()`和`map()`的用法示例，其实就是使用`for`循环对列表元素做过滤或者变换。\n\n```python\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\nif __name", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n### 使用lambda表达式\n`lambda表达式`是`Python`内置函数`filter()`和`map()`的用法示例，其实就是使用`for`循环对列表元素做过滤或者变换。\n\n```python\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\nif __name"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\nif __name__ == '__main__':\n    print('Run doctests -", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\nif __name__ == '__main__':\n    print('Run doctests -"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # 输入：[\"abc\", \"bacd\", \"cde\", \"array\"]\n    # 输出：[\"abc\", \"bacd\", \"array\"]\n    # 解释：输入字符串列表中包��", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # 输入：[\"abc\", \"bacd\", \"cde\", \"array\"]\n    # 输出：[\"abc\", \"bacd\", \"array\"]\n    # 解释：输入字符串列表中包��"}
{"task_id": "HumanEval/7", "completion": "    return [str for str in strings if substring in str]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n```\n\n### 2. 测试结果\n\n```python\n----------------------------------------------------------------------------------- mypy ------------------------------------------------------------------------------------\nSuccess: no issues found in 1 source file\n----------------------------------------------------------------------------------- pyright ------------------------------------------------------------------------------------\n(py39) C:\\Users\\qiyu\\PycharmProjects\\python_study\\python_demo>\n```\n\n### 3. 测试结果分析\n\n使用pyright和mypy进行静态类型检查。\n\n- [pyright 文档](https://github.com/microsoft/pyright)\n- [mypy 文档](https://github.com/python/mypy)\n\n\n\n## 4. 注解参数\n\n注解参数，即函数执行的参数中的实参。\n\n", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [str for str in strings if substring in str]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n```\n\n### 2. 测试结果\n\n```python\n----------------------------------------------------------------------------------- mypy ------------------------------------------------------------------------------------\nSuccess: no issues found in 1 source file\n----------------------------------------------------------------------------------- pyright ------------------------------------------------------------------------------------\n(py39) C:\\Users\\qiyu\\PycharmProjects\\python_study\\python_demo>\n```\n\n### 3. 测试结果分析\n\n使用pyright和mypy进行静态类型检查。\n\n- [pyright 文档](https://github.com/microsoft/pyright)\n- [mypy 文档](https://github.com/python/mypy)\n\n\n\n## 4. 注解参数\n\n注解参数，即函数执行的参数中的实参。\n\n"}
{"task_id": "HumanEval/7", "completion": "    filtered = []\n    for s in strings:\n        if substring in s:\n            filtered.append(s)\n    return filtered\n\n\ndef filter_by_substring_2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring_2([], 'a')\n    []\n    >>> filter_by_substring_2(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substring_3(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring_2([], 'a')\n    []\n    >>> filter_by_substring_2(['abc', 'bacd', 'cde', 'array", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    filtered = []\n    for s in strings:\n        if substring in s:\n            filtered.append(s)\n    return filtered\n\n\ndef filter_by_substring_2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring_2([], 'a')\n    []\n    >>> filter_by_substring_2(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substring_3(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring_2([], 'a')\n    []\n    >>> filter_by_substring_2(['abc', 'bacd', 'cde', 'array"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_pattern(strings: List[str], pattern: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中匹配给定正则表达式的字符串    >>> filter_by_pattern([], 'a')\n    []\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], 'a.*')\n    ['abc', 'bacd']\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], '[a-z]')\n    ['abc', 'bacd', 'cde']\n    \"\"\"\n    return [string for string in strings if re.search(pattern, string)]\n\n\ndef filter_by_predicate(strings: List[str], predicate: Callable[[str], bool]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中满足给定条件的字符串  \"\"\"\n    return [string for string in strings", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_pattern(strings: List[str], pattern: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中匹配给定正则表达式的字符串    >>> filter_by_pattern([], 'a')\n    []\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], 'a.*')\n    ['abc', 'bacd']\n    >>> filter_by_pattern(['abc', 'bacd', 'cde', 'array'], '[a-z]')\n    ['abc', 'bacd', 'cde']\n    \"\"\"\n    return [string for string in strings if re.search(pattern, string)]\n\n\ndef filter_by_predicate(strings: List[str], predicate: Callable[[str], bool]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中满足给定条件的字符串  \"\"\"\n    return [string for string in strings"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\n# 练习: 使用上面的函数打印最长的单词\ndef longest_word(strings: List[str], substring: str) -> str:\n    \"\"\"\n    >>> longest_word(['abc', 'bacd', 'cde', 'array'], 'a')\n    'bacd'\n    \"\"\"\n    longest_word_length = 0\n    longest_word_ = None\n    for s in strings:\n        if substring in s:\n            if len(s) > longest_word_length:\n                longest_word_length = len(s)\n                longest_word_ = s\n    return longest_word_\n\n\n# 练习: 将字母串转化为其逆序\ndef reverse_string(s: str) -> str:\n    \"\"\"\n    >>> reverse_string('')\n    ''\n    >>> reverse_string('abc')\n    'cba'\n    >>> reverse_string('racecar')\n    'racecar'", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\n# 练习: 使用上面的函数打印最长的单词\ndef longest_word(strings: List[str], substring: str) -> str:\n    \"\"\"\n    >>> longest_word(['abc', 'bacd', 'cde', 'array'], 'a')\n    'bacd'\n    \"\"\"\n    longest_word_length = 0\n    longest_word_ = None\n    for s in strings:\n        if substring in s:\n            if len(s) > longest_word_length:\n                longest_word_length = len(s)\n                longest_word_ = s\n    return longest_word_\n\n\n# 练习: 将字母串转化为其逆序\ndef reverse_string(s: str) -> str:\n    \"\"\"\n    >>> reverse_string('')\n    ''\n    >>> reverse_string('abc')\n    'cba'\n    >>> reverse_string('racecar')\n    'racecar'"}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_length(strings: List[str], min_length: int) -> List", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_length(strings: List[str], min_length: int) -> List"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\n'''\n第一种\n'''\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        max_len = 0\n        ans = []\n        for i in range(len(list1)):\n            for j in range(len(list2)):\n                if max_len == 0:\n                    res = [list1[i], list2[j]]\n                if max_len < len(list1[i]) + len(list2[j]):\n                    if set(list1[i]).intersection(set(list2[j])):\n                       ", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\n'''\n第一种\n'''\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        max_len = 0\n        ans = []\n        for i in range(len(list1)):\n            for j in range(len(list2)):\n                if max_len == 0:\n                    res = [list1[i], list2[j]]\n                if max_len < len(list1[i]) + len(list2[j]):\n                    if set(list1[i]).intersection(set(list2[j])):\n                       "}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda string: substring in string, strings))\n\ndef filter_by_substring_using_lambda(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串\n    >>> filter_by_substring_using_lambda([], 'a')\n    []\n    >>> filter_by_substring_using_lambda(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda x: substring in x, strings))\n\ndef filter_by_substring_using_anonymous_function(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串\n    >>> filter_by_substring_using_anonymous_function([], 'a')\n    []\n    >>> filter_by_substring_using_anonymous_function(['abc', 'bacd', '", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda string: substring in string, strings))\n\ndef filter_by_substring_using_lambda(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串\n    >>> filter_by_substring_using_lambda([], 'a')\n    []\n    >>> filter_by_substring_using_lambda(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda x: substring in x, strings))\n\ndef filter_by_substring_using_anonymous_function(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串\n    >>> filter_by_substring_using_anonymous_function([], 'a')\n    []\n    >>> filter_by_substring_using_anonymous_function(['abc', 'bacd', '"}
{"task_id": "HumanEval/16", "completion": "    if not isinstance(string, str):\n        raise TypeError(\"The input is not a string\")\n    return len(set(string.lower()))\n\n\nprint(count_distinct_characters(input(\"Please input a string: \")))\n\n\ndef get_first_k_characters(string: str, k: int) -> str:\n    \"\"\" 给定一个字符串，返回它的前k个字符组成的新字符串\n    >>> get_first_k_characters('Jerry', 3)\n    'Jer'\n    >>> get_first_k_characters('Jerry', 4)\n    'Jerry'\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"The input is not a string\")\n    if not isinstance(k, int):\n        raise TypeError(\"The input is not a integer\")\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"The value is less than 0\")\n    if len(", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"The input is not a string\")\n    return len(set(string.lower()))\n\n\nprint(count_distinct_characters(input(\"Please input a string: \")))\n\n\ndef get_first_k_characters(string: str, k: int) -> str:\n    \"\"\" 给定一个字符串，返回它的前k个字符组成的新字符串\n    >>> get_first_k_characters('Jerry', 3)\n    'Jer'\n    >>> get_first_k_characters('Jerry', 4)\n    'Jerry'\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"The input is not a string\")\n    if not isinstance(k, int):\n        raise TypeError(\"The input is not a integer\")\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"The value is less than 0\")\n    if len("}
{"task_id": "HumanEval/16", "completion": "    char_counts = {}\n    for char in string.lower():\n        char_counts[char] = char_counts.get(char, 0) + 1\n    return len(char_counts)\n\n\ndef longest_substring_without_repeating_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它的最长子串的长度，该子串只由不同的字符组成\n    >>> longest_substring_without_repeating_characters('abcabcbb')\n    3\n    >>> longest_substring_without_repeating_characters('bbbbb')\n    1\n    >>> longest_substring_without_repeating_characters('pwwkew')\n    3\n    \"\"\"\n    pass\n\n\ndef sum_of_two_integers_with_given_sum(maximum_number: int, sum: int) -> bool:\n    \"\"\" 给定一个整数，找出两个整数，由这两个数相加", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    char_counts = {}\n    for char in string.lower():\n        char_counts[char] = char_counts.get(char, 0) + 1\n    return len(char_counts)\n\n\ndef longest_substring_without_repeating_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它的最长子串的长度，该子串只由不同的字符组成\n    >>> longest_substring_without_repeating_characters('abcabcbb')\n    3\n    >>> longest_substring_without_repeating_characters('bbbbb')\n    1\n    >>> longest_substring_without_repeating_characters('pwwkew')\n    3\n    \"\"\"\n    pass\n\n\ndef sum_of_two_integers_with_given_sum(maximum_number: int, sum: int) -> bool:\n    \"\"\" 给定一个整数，找出两个整数，由这两个数相加"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\ndef is_subset(superset: str, subset: str) -> bool:\n    \"\"\" 给定两个字符串 a 和 b，判断 b 是不是 a 的子集\n    >>> is_subset('Hey', 'He')\n    True\n    >>> is_subset('He', 'Hey')\n    False\n    >>> is_subset('Hey', 'Hey')\n    True\n    \"\"\"\n    # 不能将 a 和 b 以数组的形式表示\n    return all(char in superset for char in subset)\n\ndef count", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\ndef is_subset(superset: str, subset: str) -> bool:\n    \"\"\" 给定两个字符串 a 和 b，判断 b 是不是 a 的子集\n    >>> is_subset('Hey', 'He')\n    True\n    >>> is_subset('He', 'Hey')\n    False\n    >>> is_subset('Hey', 'Hey')\n    True\n    \"\"\"\n    # 不能将 a 和 b 以数组的形式表示\n    return all(char in superset for char in subset)\n\ndef count"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string))\n\n\ndef count_distinct_characters_set(string: str) -> int:\n    \"\"\" 使用字符串中字符的集合长度即可得到不同字符的个数\n\n    :param string: 目标字符串\n    :return: 不同的字符数量\n    \"\"\"\n    return len(set(string))\n\n\ndef check_string_valid_with_regex(string: str, pattern):\n    \"\"\" 使用正则表达式验证字符串格式\n\n    :param string: 目标字符串\n    :param pattern: 模式串\n    :return: 布尔值，验证结果\n    \"\"\"\n    return re.match(pattern, string)\n\n\ndef check_string_valid_with_regex_compiled(string: str, pattern):\n    \"\"\" 使用正则表达式验证字符串格式\n\n    :param string: 目标字符串\n    :param", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string))\n\n\ndef count_distinct_characters_set(string: str) -> int:\n    \"\"\" 使用字符串中字符的集合长度即可得到不同字符的个数\n\n    :param string: 目标字符串\n    :return: 不同的字符数量\n    \"\"\"\n    return len(set(string))\n\n\ndef check_string_valid_with_regex(string: str, pattern):\n    \"\"\" 使用正则表达式验证字符串格式\n\n    :param string: 目标字符串\n    :param pattern: 模式串\n    :return: 布尔值，验证结果\n    \"\"\"\n    return re.match(pattern, string)\n\n\ndef check_string_valid_with_regex_compiled(string: str, pattern):\n    \"\"\" 使用正则表达式验证字符串格式\n\n    :param string: 目标字符串\n    :param"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef longest_substring_without_repeating_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，求出它的最长子串，子串中不允许出现相同的字符（不论大小写）\n    >>> longest_substring_without_repeating_characters('xyzXYZ')\n    3\n    >>> longest_substring_without_repeating_characters('Jerry')\n    3\n    \"\"\"\n    length = len(string)\n    if length == 0:\n        return length\n    \n    char_to_index = {}\n    start = 0\n    end = 0\n    max_length = 0\n    for i in range(length):\n        char = string[i]\n        if char not in char_to_index:\n            char_to_index[char] = i\n        else:\n            start = max(start, char_to_index[char]+1)\n            end = i\n            max_length", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef longest_substring_without_repeating_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，求出它的最长子串，子串中不允许出现相同的字符（不论大小写）\n    >>> longest_substring_without_repeating_characters('xyzXYZ')\n    3\n    >>> longest_substring_without_repeating_characters('Jerry')\n    3\n    \"\"\"\n    length = len(string)\n    if length == 0:\n        return length\n    \n    char_to_index = {}\n    start = 0\n    end = 0\n    max_length = 0\n    for i in range(length):\n        char = string[i]\n        if char not in char_to_index:\n            char_to_index[char] = i\n        else:\n            start = max(start, char_to_index[char]+1)\n            end = i\n            max_length"}
{"task_id": "HumanEval/16", "completion": "    char_dict = {}\n    for char in string:\n        if char not in char_dict:\n            char_dict[char] = 1\n        else:\n            char_dict[char] += 1\n    return len(char_dict)\n\ndef make_unique_words(string: str) -> str:\n    \"\"\" 返回一个将字符串中重复字母变成'_'的新字符串\n    >>> make_unique_words('Jerry')\n    'Jerry'\n    >>> make_unique_words('xyzXYZ')\n    'xyz_X_Z'\n    \"\"\"\n    char_list = []\n    for char in string:\n        if char not in char_list:\n            char_list.append(char)\n        else:\n            char_list.append('_')\n    return ''.join(char_list)\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 计算字符串中的不同单词出现的次数\n    >>> count_distinct_words('Jerry", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    char_dict = {}\n    for char in string:\n        if char not in char_dict:\n            char_dict[char] = 1\n        else:\n            char_dict[char] += 1\n    return len(char_dict)\n\ndef make_unique_words(string: str) -> str:\n    \"\"\" 返回一个将字符串中重复字母变成'_'的新字符串\n    >>> make_unique_words('Jerry')\n    'Jerry'\n    >>> make_unique_words('xyzXYZ')\n    'xyz_X_Z'\n    \"\"\"\n    char_list = []\n    for char in string:\n        if char not in char_list:\n            char_list.append(char)\n        else:\n            char_list.append('_')\n    return ''.join(char_list)\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 计算字符串中的不同单词出现的次数\n    >>> count_distinct_words('Jerry"}
{"task_id": "HumanEval/16", "completion": "    # 这里采用set方式\n    return len(set(string))\n\n\ndef count_distinct_characters_without_using_set(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不区分大小写）组成\n\n    >>> \n    \"\"\"\n    string = string.lower()\n    count = 0\n    seen = set()\n    for char in string:\n        if char not in seen:\n            seen.add(char)\n            count += 1\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n\n\n\n\n\n\n\n\n", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # 这里采用set方式\n    return len(set(string))\n\n\ndef count_distinct_characters_without_using_set(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不区分大小写）组成\n\n    >>> \n    \"\"\"\n    string = string.lower()\n    count = 0\n    seen = set()\n    for char in string:\n        if char not in seen:\n            seen.add(char)\n            count += 1\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "HumanEval/16", "completion": "    # len(set(string.lower()))\n    # len(set(string.lower()))\n    # len(set(string.lower()))\n    # 不同的字符不会重复，\n    # 因为比较时会用到大小写的问题，如果用小写去比较，会导致计数不对\n    # 比如'Aa'和'AaA'计算会相同\n    # 也就是说，一个字符串的唯一字符的个数=字符串长度减去字符串不同的字符的个数\n    # 在字符串长度中，减去每个字符出现的次数减1(因为出现的次数是大于1的)\n    length = len(string)\n    distinct_characters = set()\n    for char in string:\n        if char not in distinct_characters:\n            distinct_characters.add(char)\n    return length - len(distinct_characters)\n", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # len(set(string.lower()))\n    # len(set(string.lower()))\n    # len(set(string.lower()))\n    # 不同的字符不会重复，\n    # 因为比较时会用到大小写的问题，如果用小写去比较，会导致计数不对\n    # 比如'Aa'和'AaA'计算会相同\n    # 也就是说，一个字符串的唯一字符的个数=字符串长度减去字符串不同的字符的个数\n    # 在字符串长度中，减去每个字符出现的次数减1(因为出现的次数是大于1的)\n    length = len(string)\n    distinct_characters = set()\n    for char in string:\n        if char not in distinct_characters:\n            distinct_characters.add(char)\n    return length - len(distinct_characters)\n"}
{"task_id": "HumanEval/16", "completion": "\n    return len(set(string))\n\n\ndef number_of_substrings_with_distinct_characters(string: str, k: int) -> int:\n    \"\"\" 给定一个字符串和一个整数k, 找出长度小于等于k的字符串共有多少个子串的字符不同\n    >>> number_of_substrings_with_distinct_characters('xyzXYZ', 2)\n    6\n    123\n    \"\"\"\n\n    return math.factorial(len(string)) // (math.factorial(k) * math.factorial(len(string) - k))\n\n\ndef number_of_substrings_with_distinct_characters2(string: str, k: int) -> int:\n    \"\"\" 给定一个字符串和一个整数k, 找出长度小于等于k的字符串共有多少个子串的字符不同\n    >>> number_of_substrings_with_distinct_characters('xyz", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\n    return len(set(string))\n\n\ndef number_of_substrings_with_distinct_characters(string: str, k: int) -> int:\n    \"\"\" 给定一个字符串和一个整数k, 找出长度小于等于k的字符串共有多少个子串的字符不同\n    >>> number_of_substrings_with_distinct_characters('xyzXYZ', 2)\n    6\n    123\n    \"\"\"\n\n    return math.factorial(len(string)) // (math.factorial(k) * math.factorial(len(string) - k))\n\n\ndef number_of_substrings_with_distinct_characters2(string: str, k: int) -> int:\n    \"\"\" 给定一个字符串和一个整数k, 找出长度小于等于k的字符串共有多少个子串的字符不同\n    >>> number_of_substrings_with_distinct_characters('xyz"}
{"task_id": "HumanEval/16", "completion": "    char_dict = {}\n    for c in string:\n        if c in char_dict:\n            char_dict[c] += 1\n        else:\n            char_dict[c] = 1\n    \n    total = 0\n    for count in char_dict.values():\n        total += 1\n    return total\n\n# 快慢遍历算法\n\nclass LinkedListNode:\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\nclass Queue:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def add(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        if self.tail is None:\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def remove(self):\n        if self.head == None:\n            raise Exception('Can not remove from an empty queue.", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    char_dict = {}\n    for c in string:\n        if c in char_dict:\n            char_dict[c] += 1\n        else:\n            char_dict[c] = 1\n    \n    total = 0\n    for count in char_dict.values():\n        total += 1\n    return total\n\n# 快慢遍历算法\n\nclass LinkedListNode:\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\nclass Queue:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def add(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        if self.tail is None:\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def remove(self):\n        if self.head == None:\n            raise Exception('Can not remove from an empty queue."}
{"task_id": "HumanEval/18", "completion": "    return len(find_all(string, substring))\n\n\ndef get_first_char(string: str) -> str:\n    \"\"\" 获取字符串的第一个字母。如果字符串不是字符串，则返回空字符串\"\"\"\n    if len(string) == 0:\n        return ''\n    return string[0]\n\ndef get_last_char(string: str) -> str:\n    \"\"\" 获取字符串的最后一个字母。如果字符串不是字符串，则返回空字符串。\"\"\"\n    if len(string) == 0:\n        return ''\n    return string[-1]\n\n\ndef get_first_word(string: str) -> str:\n    \"\"\"获取字符串的第一个单词。如果字符串不是字符串，则返回空字符串。\"\"\"\n    if len(string) == 0:\n        return ''\n    words = string.split()\n    return words[0]\n\n\ndef get_last_", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(find_all(string, substring))\n\n\ndef get_first_char(string: str) -> str:\n    \"\"\" 获取字符串的第一个字母。如果字符串不是字符串，则返回空字符串\"\"\"\n    if len(string) == 0:\n        return ''\n    return string[0]\n\ndef get_last_char(string: str) -> str:\n    \"\"\" 获取字符串的最后一个字母。如果字符串不是字符串，则返回空字符串。\"\"\"\n    if len(string) == 0:\n        return ''\n    return string[-1]\n\n\ndef get_first_word(string: str) -> str:\n    \"\"\"获取字符串的第一个单词。如果字符串不是字符串，则返回空字符串。\"\"\"\n    if len(string) == 0:\n        return ''\n    words = string.split()\n    return words[0]\n\n\ndef get_last_"}
{"task_id": "HumanEval/18", "completion": "    times = 0\n    start = 0\n    while True:\n        next_start = string.find(substring, start)\n        if next_start == -1:\n            return times\n        times += 1\n        start = next_start + 1\n\ndef remove_all(string: str, substring: str) -> str:\n    \"\"\" 删除子串在原始字符串中的所有出现，不考虑重叠 \"\"\"\n    while substring in string:\n        string = string.replace(substring, '')\n    return string\n\ndef replace_all(string: str, substring: str, replacement: str) -> str:\n    \"\"\" 替换子串在原始字符串中的所有出现，不考虑重叠 \"\"\"\n    while substring in string:\n        string = string.replace(substring, replacement)\n    return string\n\ndef replace_first(string: str, substring: str, replacement: str) -> str:\n    \"\"\" 替换子串在原始字符串中的第一个", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    times = 0\n    start = 0\n    while True:\n        next_start = string.find(substring, start)\n        if next_start == -1:\n            return times\n        times += 1\n        start = next_start + 1\n\ndef remove_all(string: str, substring: str) -> str:\n    \"\"\" 删除子串在原始字符串中的所有出现，不考虑重叠 \"\"\"\n    while substring in string:\n        string = string.replace(substring, '')\n    return string\n\ndef replace_all(string: str, substring: str, replacement: str) -> str:\n    \"\"\" 替换子串在原始字符串中的所有出现，不考虑重叠 \"\"\"\n    while substring in string:\n        string = string.replace(substring, replacement)\n    return string\n\ndef replace_first(string: str, substring: str, replacement: str) -> str:\n    \"\"\" 替换子串在原始字符串中的第一个"}
{"task_id": "HumanEval/18", "completion": "    if not substring:\n        return 0\n    # 循环计算剩余字符串\n    count = 0\n    i = 0\n    while i < len(string) - len(substring) + 1:\n        if string[i:i+len(substring)] == substring:\n            count += 1\n        i += 1\n    return count\n\ndef get_lines(source: str, start_pos: int, end_pos: int) -> List[str]:\n    lines = []\n    line_idx = 0\n    for i in range(start_pos, end_pos):\n        if source[i] == '\\n':\n            lines.append(source[line_idx:i])\n            line_idx = i + 1\n    lines.append(source[line_idx:end_pos])\n    return lines\n\ndef get_lines_with_highlight(source: str, start_pos: int, end_pos: int, highlight: int) -> Dict:\n    lines = []\n    line_idx = 0\n    h_", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not substring:\n        return 0\n    # 循环计算剩余字符串\n    count = 0\n    i = 0\n    while i < len(string) - len(substring) + 1:\n        if string[i:i+len(substring)] == substring:\n            count += 1\n        i += 1\n    return count\n\ndef get_lines(source: str, start_pos: int, end_pos: int) -> List[str]:\n    lines = []\n    line_idx = 0\n    for i in range(start_pos, end_pos):\n        if source[i] == '\\n':\n            lines.append(source[line_idx:i])\n            line_idx = i + 1\n    lines.append(source[line_idx:end_pos])\n    return lines\n\ndef get_lines_with_highlight(source: str, start_pos: int, end_pos: int, highlight: int) -> Dict:\n    lines = []\n    line_idx = 0\n    h_"}
{"task_id": "HumanEval/18", "completion": "    return len(re.findall(substring, string))\n\n\nif __name__ == \"__main__\":\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))\n    print(how_many_times('aaaa', 'aa', -1))\n    print(how_many_times('aaaa', 'aa', 2))\n    print(how_many_times('aaaa', 'aa', 3))\n    print(how_many_times('aaaa', 'a', 1))\n    print(how_many_times('aaaa', 'a', 2))\n    print(how_many_times('aaaa', 'a', 3))\n    print(how_many_times('aaaa', 'a', 4))\n    print(how_many_times('aaaa', 'a', 5))\n    print(how_many_times('aaaa', 'a', 6))\n    print(how_many_times('aaaaa', 'aa', 1))\n    print(how_many_times('aaaaa', 'aa', -1", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(re.findall(substring, string))\n\n\nif __name__ == \"__main__\":\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))\n    print(how_many_times('aaaa', 'aa', -1))\n    print(how_many_times('aaaa', 'aa', 2))\n    print(how_many_times('aaaa', 'aa', 3))\n    print(how_many_times('aaaa', 'a', 1))\n    print(how_many_times('aaaa', 'a', 2))\n    print(how_many_times('aaaa', 'a', 3))\n    print(how_many_times('aaaa', 'a', 4))\n    print(how_many_times('aaaa', 'a', 5))\n    print(how_many_times('aaaa', 'a', 6))\n    print(how_many_times('aaaaa', 'aa', 1))\n    print(how_many_times('aaaaa', 'aa', -1"}
{"task_id": "HumanEval/18", "completion": "\n    return string.count(substring)\n\n\ndef repeat_string(string: str, times: int) -> str:\n    \"\"\" 返回给定字符串的指定次数连接后的新字符串。 时间复杂度？\n    >>> repeat_string('', 3)\n    ''\n    >>> repeat_string('a', 3)\n    'aaa'\n    >>> repeat_string('a', 0)\n    ''\n    >>> repeat_string('abc', 10)\n    'abcabcabcabcabcabcabcabcabc'\n    >>> repeat_string('abc', 2)\n    'abcabc'\n    \"\"\"\n    if times == 0:\n        return ''\n    else:\n        return string + repeat_string(string, times - 1)\n\n\ndef is_prefix(prefix: str, string: str) -> bool:\n    \"\"\" 检查前缀是否是字符串的前缀。\n    >>> is_prefix('ab', 'abcee')\n    True\n    >>> is_prefix('abc", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n    return string.count(substring)\n\n\ndef repeat_string(string: str, times: int) -> str:\n    \"\"\" 返回给定字符串的指定次数连接后的新字符串。 时间复杂度？\n    >>> repeat_string('', 3)\n    ''\n    >>> repeat_string('a', 3)\n    'aaa'\n    >>> repeat_string('a', 0)\n    ''\n    >>> repeat_string('abc', 10)\n    'abcabcabcabcabcabcabcabcabc'\n    >>> repeat_string('abc', 2)\n    'abcabc'\n    \"\"\"\n    if times == 0:\n        return ''\n    else:\n        return string + repeat_string(string, times - 1)\n\n\ndef is_prefix(prefix: str, string: str) -> bool:\n    \"\"\" 检查前缀是否是字符串的前缀。\n    >>> is_prefix('ab', 'abcee')\n    True\n    >>> is_prefix('abc"}
{"task_id": "HumanEval/18", "completion": "    return len(find_all(string, substring))\n\ndef replace_all(string: str, old: str, new: str) -> str:\n    \"\"\" 把原始字符串中所有的旧子串替换成新子串。\n     >>> replace_all('a abc a a bd', 'a', 'x')\n     'x abc x x bd'\n     >>> replace_all('a abc a a bd', 'ab', 'xb')\n     'x abc x x bd'   \n     >>> replace_all('a abc a a bd', 'a', 'a')\n     'a abc a a bd'\n     >>> replace_all('a abc a a bd', 'a', 'b')\n     'b b c b b d'\n     >>> replace_all('a abc a a bd', 'ab', 'b')\n     'b b c b b d'\n    \"\"\"\n    index = string.find(old)    \n    if index < 0: return string\n    string = string[:index] + new + replace_all(string", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(find_all(string, substring))\n\ndef replace_all(string: str, old: str, new: str) -> str:\n    \"\"\" 把原始字符串中所有的旧子串替换成新子串。\n     >>> replace_all('a abc a a bd', 'a', 'x')\n     'x abc x x bd'\n     >>> replace_all('a abc a a bd', 'ab', 'xb')\n     'x abc x x bd'   \n     >>> replace_all('a abc a a bd', 'a', 'a')\n     'a abc a a bd'\n     >>> replace_all('a abc a a bd', 'a', 'b')\n     'b b c b b d'\n     >>> replace_all('a abc a a bd', 'ab', 'b')\n     'b b c b b d'\n    \"\"\"\n    index = string.find(old)    \n    if index < 0: return string\n    string = string[:index] + new + replace_all(string"}
{"task_id": "HumanEval/18", "completion": "    return len(re.findall(substring, string, flags=re.I))\n\n\ndef what_word_is_it(string: str, index: int) -> str:\n    \"\"\" 查找指定位置上的单词。如果超出范围，则返回空字符串。    >>> what_word_is_it('one two three', 10)\n    ''\n    >>> what_word_is_it('one two three', 0)\n    'one'\n    >>> what_word_is_it('one two three', 3)\n    'three'\n    \"\"\"\n    if index < len(string.split(' ')):\n        return string.split(' ')[index]\n    return ''\n\n\ndef replace_all(string: str, a: str, b: str) -> str:\n    \"\"\" 替换所有出现的指定子串。    >>> replace_all('one two three', 'o', '0')\n    '0ne tw0 three'\n    \"\"\"\n    return string.replace(a,", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(re.findall(substring, string, flags=re.I))\n\n\ndef what_word_is_it(string: str, index: int) -> str:\n    \"\"\" 查找指定位置上的单词。如果超出范围，则返回空字符串。    >>> what_word_is_it('one two three', 10)\n    ''\n    >>> what_word_is_it('one two three', 0)\n    'one'\n    >>> what_word_is_it('one two three', 3)\n    'three'\n    \"\"\"\n    if index < len(string.split(' ')):\n        return string.split(' ')[index]\n    return ''\n\n\ndef replace_all(string: str, a: str, b: str) -> str:\n    \"\"\" 替换所有出现的指定子串。    >>> replace_all('one two three', 'o', '0')\n    '0ne tw0 three'\n    \"\"\"\n    return string.replace(a,"}
{"task_id": "HumanEval/18", "completion": "    return string.count(substring)\n\n\ndef index_of_first_occurrence(string: str, substring: str) -> str:\n    \"\"\" 返回字符串中第一个给定子串的索引。\n    如果子串不在字符串中的话，返回字符串的长度。\n    >>> index_of_first_occurrence('', 'a')\n    0\n    >>> index_of_first_occurrence('aaa', 'a')\n    0\n    >>> index_of_first_occurrence('aaaa', 'aa')\n    0\n    >>> index_of_first_occurrence('abaa', 'aa')\n    1\n    >>> index_of_first_occurrence('ababaa', 'aa')\n    2\n    \"\"\"\n    return string.find(substring)\n\n\ndef index_of_last_occurrence(string: str, substring: str) -> str:\n    \"\"\" 返回字符串中最后一个给定子串的索引。\n    如果子串不在字符串中的话，返回字", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return string.count(substring)\n\n\ndef index_of_first_occurrence(string: str, substring: str) -> str:\n    \"\"\" 返回字符串中第一个给定子串的索引。\n    如果子串不在字符串中的话，返回字符串的长度。\n    >>> index_of_first_occurrence('', 'a')\n    0\n    >>> index_of_first_occurrence('aaa', 'a')\n    0\n    >>> index_of_first_occurrence('aaaa', 'aa')\n    0\n    >>> index_of_first_occurrence('abaa', 'aa')\n    1\n    >>> index_of_first_occurrence('ababaa', 'aa')\n    2\n    \"\"\"\n    return string.find(substring)\n\n\ndef index_of_last_occurrence(string: str, substring: str) -> str:\n    \"\"\" 返回字符串中最后一个给定子串的索引。\n    如果子串不在字符串中的话，返回字"}
{"task_id": "HumanEval/18", "completion": "    if not substring: return len(string)\n    i = 0\n    count = 0\n    while string:\n        i = string.find(substring)\n        if i!= -1:\n            count += 1\n            string = string[i + len(substring):]\n        else:\n            break\n    return count\n\n\ndef find_n_max(string: str, n: int) -> int:\n    \"\"\" 找出字符串中出现次数最多的字符及次数。\n    >>> find_n_max('', 2)\n    ('', 0)\n    >>> find_n_max('aa', 2)\n    ('a', 2)\n    >>> find_n_max('ababab', 2)\n    ('a', 3)\n    >>> find_n_max('abcabbad', 2)\n    ('a', 3)\n    \"\"\"\n    if n <= 0:\n        return ('', 0)\n    substring = ''\n    count = 0\n    for i in string:\n        count += how_many_", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not substring: return len(string)\n    i = 0\n    count = 0\n    while string:\n        i = string.find(substring)\n        if i!= -1:\n            count += 1\n            string = string[i + len(substring):]\n        else:\n            break\n    return count\n\n\ndef find_n_max(string: str, n: int) -> int:\n    \"\"\" 找出字符串中出现次数最多的字符及次数。\n    >>> find_n_max('', 2)\n    ('', 0)\n    >>> find_n_max('aa', 2)\n    ('a', 2)\n    >>> find_n_max('ababab', 2)\n    ('a', 3)\n    >>> find_n_max('abcabbad', 2)\n    ('a', 3)\n    \"\"\"\n    if n <= 0:\n        return ('', 0)\n    substring = ''\n    count = 0\n    for i in string:\n        count += how_many_"}
{"task_id": "HumanEval/18", "completion": "    if len(substring) == 0 or len(substring) > len(string):\n        return 0\n    return len(string) - len(substring) + 1 - len(string.replace(substring, ''))\n\n\ndef how_many_times_not_overlapping(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。不计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    1\n    >>> how_many_times('aaaa', 'aa')\n    1\n    \"\"\"\n    count = 0\n    index = 0\n    while True:\n        index = string.find(substring, index)\n        if index < 0:\n            break\n        count += 1\n        index += len(substring)\n    return count\n\n\ndef reverse_words(string: str) -> str:\n    \"\"\" 反转字符串中每个单词的字", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if len(substring) == 0 or len(substring) > len(string):\n        return 0\n    return len(string) - len(substring) + 1 - len(string.replace(substring, ''))\n\n\ndef how_many_times_not_overlapping(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。不计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    1\n    >>> how_many_times('aaaa', 'aa')\n    1\n    \"\"\"\n    count = 0\n    index = 0\n    while True:\n        index = string.find(substring, index)\n        if index < 0:\n            break\n        count += 1\n        index += len(substring)\n    return count\n\n\ndef reverse_words(string: str) -> str:\n    \"\"\" 反转字符串中每个单词的字"}
{"task_id": "HumanEval/24", "completion": "    i = 2\n    while i ** 2 <= n: \n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 但大于 n 的最小的数    >>> smallest_divisor(15)\n    15\n    \"\"\"\n    i = 2\n    while i ** 2 <= n: \n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\n\ndef exponentiation(x: float, y: float) -> float:\n    \"\"\" 对于给定的数 x 和 y，计算 x 的 y 次方 x**y\n    \"\"\"\n    if y == 0:\n        return 1\n    if y == 1:\n        return x\n    if y % 2 == 0:\n        return exponentiation(x * x, y // 2)\n    else:\n        return", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = 2\n    while i ** 2 <= n: \n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 但大于 n 的最小的数    >>> smallest_divisor(15)\n    15\n    \"\"\"\n    i = 2\n    while i ** 2 <= n: \n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\n\ndef exponentiation(x: float, y: float) -> float:\n    \"\"\" 对于给定的数 x 和 y，计算 x 的 y 次方 x**y\n    \"\"\"\n    if y == 0:\n        return 1\n    if y == 1:\n        return x\n    if y % 2 == 0:\n        return exponentiation(x * x, y // 2)\n    else:\n        return"}
{"task_id": "HumanEval/24", "completion": "    for candidate in range(2, n):\n        if n % candidate == 0:\n            return candidate\n    return 1\n\ndef largest_divisors(*args) -> map:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return map(largest_divisor,args)\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n    for candidate in range(2, n):\n        if n % candidate == 0:\n            return candidate\n    return 1\n\ndef smallest_divisors(*args) -> map:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for candidate in range(2, n):\n        if n % candidate == 0:\n            return candidate\n    return 1\n\ndef largest_divisors(*args) -> map:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return map(largest_divisor,args)\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n    for candidate in range(2, n):\n        if n % candidate == 0:\n            return candidate\n    return 1\n\ndef smallest_divisors(*args) -> map:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数"}
{"task_id": "HumanEval/24", "completion": "    return largest_divisor_range(n, 1, n)\n\ndef largest_divisor_range(n: int, a: int, b: int) -> int:\n    \"\"\" 对于给定的数 n，以 a， b 为下界和上界，找出能整除 n 且在 a 和 b 之间的最大数\n    它也可以被形式化定义为：\n    max(i | a <= i <= b 且 n 能被 i 整除)\n    >>> largest_divisor_range(15, 1, 5)\n    5\n    \"\"\"\n    if n < a or n > b:\n        raise ValueError(\"n must be within the inclusive range a to b\")\n    while b > 0:\n        if n % b == 0:\n            return b\n        if n % (b - 1) == 0:\n            return b - 1\n        b -= 1\n    raise ValueError(\"n must be within the inclusive range a to", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return largest_divisor_range(n, 1, n)\n\ndef largest_divisor_range(n: int, a: int, b: int) -> int:\n    \"\"\" 对于给定的数 n，以 a， b 为下界和上界，找出能整除 n 且在 a 和 b 之间的最大数\n    它也可以被形式化定义为：\n    max(i | a <= i <= b 且 n 能被 i 整除)\n    >>> largest_divisor_range(15, 1, 5)\n    5\n    \"\"\"\n    if n < a or n > b:\n        raise ValueError(\"n must be within the inclusive range a to b\")\n    while b > 0:\n        if n % b == 0:\n            return b\n        if n % (b - 1) == 0:\n            return b - 1\n        b -= 1\n    raise ValueError(\"n must be within the inclusive range a to"}
{"task_id": "HumanEval/24", "completion": "    i = 1\n    while i <= n:\n        if n % i == 0:\n            return i\n        i += 1\n    return -1\n \n \ndef sum_of_divisors(n: int) -> int:\n    \"\"\" 对于给定的数 n，求其所有因子的和    >>> sum_of_divisors(10)\n    31\n    \"\"\"\n    return sum(i for i in range(1, n + 1) if n % i == 0)\n \n \ndef abundant_number(n: int) -> bool:\n    \"\"\" 判断一个数 n 是否为亏数\n    亏数：一个大于其除以它自己因子最大值的数\n    >>> abundant_number(10)\n    True\n    \"\"\"\n    return sum_of_divisors(n) > n\n \n \ndef perfect_number(n: int) -> bool:\n    \"\"\" 判断一个数是否为完数\n    完数：", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            return i\n        i += 1\n    return -1\n \n \ndef sum_of_divisors(n: int) -> int:\n    \"\"\" 对于给定的数 n，求其所有因子的和    >>> sum_of_divisors(10)\n    31\n    \"\"\"\n    return sum(i for i in range(1, n + 1) if n % i == 0)\n \n \ndef abundant_number(n: int) -> bool:\n    \"\"\" 判断一个数 n 是否为亏数\n    亏数：一个大于其除以它自己因子最大值的数\n    >>> abundant_number(10)\n    True\n    \"\"\"\n    return sum_of_divisors(n) > n\n \n \ndef perfect_number(n: int) -> bool:\n    \"\"\" 判断一个数是否为完数\n    完数："}
{"task_id": "HumanEval/24", "completion": "\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n\n\ndef smallest_multiple_of(n: int) -> int:\n    \"\"\" 寻找第一个能被 n 整除的正整数 \"\"\"\n\n\ndef largest_multiple_of(n: int) -> int:\n    \"\"\" 寻找最后一个能被 n 整除的正整数 \"\"\"\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 寻找能整除 n 且大于 n 的最小整数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n\n\ndef is_multiple(n: int) -> bool:\n    \"\"\" 判断一个数字是否是另一", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n\n\ndef smallest_multiple_of(n: int) -> int:\n    \"\"\" 寻找第一个能被 n 整除的正整数 \"\"\"\n\n\ndef largest_multiple_of(n: int) -> int:\n    \"\"\" 寻找最后一个能被 n 整除的正整数 \"\"\"\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 寻找能整除 n 且大于 n 的最小整数    >>> smallest_divisor(15)\n    3\n    \"\"\"\n\n\ndef is_multiple(n: int) -> bool:\n    \"\"\" 判断一个数字是否是另一"}
{"task_id": "HumanEval/24", "completion": "    # 1. 首先要考虑n=1的情况\n    if n == 1:\n        return 1\n    # 2. 倒着找最大的一个整数，如果能整除n，就返回这个数\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    # 3. 如果没有找到，就返回1\n    return 1\n\n\ndef count_digits(n: int) -> int:\n    \"\"\" 输入一个整数，计算它的位数，比如输入 123，输出3 。\n    >>> count_digits(n=123)\n    3\n    \"\"\"\n    # 计算整数的位数有几种方法：\n    # 1. 将输入参数转化为字符串，然后计算转化为字符串的长度\n    #", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # 1. 首先要考虑n=1的情况\n    if n == 1:\n        return 1\n    # 2. 倒着找最大的一个整数，如果能整除n，就返回这个数\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    # 3. 如果没有找到，就返回1\n    return 1\n\n\ndef count_digits(n: int) -> int:\n    \"\"\" 输入一个整数，计算它的位数，比如输入 123，输出3 。\n    >>> count_digits(n=123)\n    3\n    \"\"\"\n    # 计算整数的位数有几种方法：\n    # 1. 将输入参数转化为字符串，然后计算转化为字符串的长度\n    #"}
{"task_id": "HumanEval/24", "completion": "    for i in range(int(int(n ** 0.5) + 1), 1, -1):\n        if n % i == 0:\n            return i\n    return 1\n```\n\n### 5. 判断是否能被分解  \n\n```python\n#!/usr/bin/env python3 \n# -*- coding: utf-8 -*-\n\nfrom math import gcd\n\ndef is_composite(n: int) -> bool:\n    \"\"\" 使用费马小定理判断大于等于 3 的奇数是否能被分解\n    费马小定理：如果一个大于 2 的自然数 n 除以某个小于 n 的正整数，那么 n 余剩下的数必然是一个质数（也就是大于 2 的质数）\n    只有 3 的倍数和 9 的倍数是不能被 3 整", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(int(int(n ** 0.5) + 1), 1, -1):\n        if n % i == 0:\n            return i\n    return 1\n```\n\n### 5. 判断是否能被分解  \n\n```python\n#!/usr/bin/env python3 \n# -*- coding: utf-8 -*-\n\nfrom math import gcd\n\ndef is_composite(n: int) -> bool:\n    \"\"\" 使用费马小定理判断大于等于 3 的奇数是否能被分解\n    费马小定理：如果一个大于 2 的自然数 n 除以某个小于 n 的正整数，那么 n 余剩下的数必然是一个质数（也就是大于 2 的质数）\n    只有 3 的倍数和 9 的倍数是不能被 3 整"}
{"task_id": "HumanEval/24", "completion": "    start, end = 1, n\n    while start!= end:\n        if n % start == 0:\n            end = start\n        else:\n            start += 1\n    return end\n            \ndef is_prime(n: int) -> bool:\n    \"\"\" 判断数是否是质数，如果是，返回 True ；否则，返回 False 。    >>> is_prime(7)\n    True\n    \"\"\"\n    if n == 1:\n        return False\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 返回一个整数n的质因子（最小的质因子）列表，按照升序排列    >>> prime_factors(9)\n    [3, 3]\n    \"\"\"\n    factors = []", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    start, end = 1, n\n    while start!= end:\n        if n % start == 0:\n            end = start\n        else:\n            start += 1\n    return end\n            \ndef is_prime(n: int) -> bool:\n    \"\"\" 判断数是否是质数，如果是，返回 True ；否则，返回 False 。    >>> is_prime(7)\n    True\n    \"\"\"\n    if n == 1:\n        return False\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 返回一个整数n的质因子（最小的质因子）列表，按照升序排列    >>> prime_factors(9)\n    [3, 3]\n    \"\"\"\n    factors = []"}
{"task_id": "HumanEval/24", "completion": "    # n 作为除数，对 n 做除法\n    for k in", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # n 作为除数，对 n 做除法\n    for k in"}
{"task_id": "HumanEval/24", "completion": "    return -1\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    30\n    \"\"\"\n    return -1\n\n\ndef factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有因数   >>> factors(15)\n    [1, 3, 5, 15]\n    \"\"\"\n    return [-1]\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有质因数   >>> prime_factors(15)\n    [3, 5]\n    \"\"\"\n    return [-1]\n\n\ndef prime_factorization(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有质因数及对应的指", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return -1\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    30\n    \"\"\"\n    return -1\n\n\ndef factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有因数   >>> factors(15)\n    [1, 3, 5, 15]\n    \"\"\"\n    return [-1]\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有质因数   >>> prime_factors(15)\n    [3, 5]\n    \"\"\"\n    return [-1]\n\n\ndef prime_factorization(n: int) -> list:\n    \"\"\" 对于给定的数 n，找出其所有质因数及对应的指"}
{"task_id": "HumanEval/25", "completion": "    if n == 1:\n        return []\n    else:\n        f = 2\n        while f * f <= n:\n            if n % f == 0:\n                n /= f\n                yield f\n            else:\n                f += 1\n        if n:\n            yield n\n\n\ndef main():\n    n = int(input())\n    print(' '.join(map(str, factorize(n))))\n\n\nif __name__ == '__main__':\n    main()\n    # print(' '.join(map(str, factorize(8))))\n    # print(' '.join(map(str, factorize(25))))\n    # print(' '.join", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n == 1:\n        return []\n    else:\n        f = 2\n        while f * f <= n:\n            if n % f == 0:\n                n /= f\n                yield f\n            else:\n                f += 1\n        if n:\n            yield n\n\n\ndef main():\n    n = int(input())\n    print(' '.join(map(str, factorize(n))))\n\n\nif __name__ == '__main__':\n    main()\n    # print(' '.join(map(str, factorize(8))))\n    # print(' '.join(map(str, factorize(25))))\n    # print(' '.join"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(2, n + 1):\n        # 借助满足最小剩余的条件\n        while n % i == 0:\n            n //= i\n            factors.append(i)  # 添加质因数\n    # 检查是否还有一个未被列出的质因数\n    if n > 1:\n        factors.append(n)\n    return factors  # 可能是一个空列表，所以返回一个列表\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.test", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(2, n + 1):\n        # 借助满足最小剩余的条件\n        while n % i == 0:\n            n //= i\n            factors.append(i)  # 添加质因数\n    # 检查是否还有一个未被列出的质因数\n    if n > 1:\n        factors.append(n)\n    return factors  # 可能是一个空列表，所以返回一个列表\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.test"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            n //= i\n            factors.append(i)\n    return factors\n\n\nif __name__ == '", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            n //= i\n            factors.append(i)\n    return factors\n\n\nif __name__ == '"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    temp = n\n    while temp > 1:\n        for i in range(2, temp+1):\n            if temp % i == 0:\n                temp //= i\n                factors.append(i)\n                break\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    temp = n\n    while temp > 1:\n        for i in range(2, temp+1):\n            if temp % i == 0:\n                temp //= i\n                factors.append(i)\n                break\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest."}
{"task_id": "HumanEval/25", "completion": "    factors = []  # 存放质因数\n    num = n  # 待分解的数\n\n    while num % 2 == 0:  # 尝试除以2\n        factors.append(2)  # 找到一个质因数\n        num //= 2\n\n    # 以3为底启动循环，因为所有偶数都可以由2来整除，所以剩下的数字中肯定不会再有2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        # 对这个奇数做同样的处理\n        while num % i == 0:\n            factors.append(i)\n            num //= i\n\n    if num > 1:\n        factors.append(num)\n    return factors\n\n\ndef test_factorize():\n    assert factorize(8) == [2, 2, 2]\n   ", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []  # 存放质因数\n    num = n  # 待分解的数\n\n    while num % 2 == 0:  # 尝试除以2\n        factors.append(2)  # 找到一个质因数\n        num //= 2\n\n    # 以3为底启动循环，因为所有偶数都可以由2来整除，所以剩下的数字中肯定不会再有2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        # 对这个奇数做同样的处理\n        while num % i == 0:\n            factors.append(i)\n            num //= i\n\n    if num > 1:\n        factors.append(num)\n    return factors\n\n\ndef test_factorize():\n    assert factorize(8) == [2, 2, 2]\n   "}
{"task_id": "HumanEval/25", "completion": "    factors = list()\n    num = n\n    for i in range(2, n + 1):\n        while num % i == 0:\n            num //= i\n            factors.append(i)\n    if num!= 1:\n        factors.append(num)\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = list()\n    num = n\n    for i in range(2, n + 1):\n        while num % i == 0:\n            num //= i\n            factors.append(i)\n    if num!= 1:\n        factors.append(num)\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n        i += 1\n    return factors\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n\n    testmod()\n\n    def", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n        i += 1\n    return factors\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n\n    testmod()\n\n    def"}
{"task_id": "HumanEval/25", "completion": "    result = []\n    while n % 2 == 0:\n        result.append(2)\n        n = n // 2\n\n    for i in range(3, n + 1, 2):\n        while n % i == 0:\n            result.append(i)\n            n = n // i\n\n    if n > 1:\n        result.append(n)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(name=\"factorize\")\n\n    print(factorize(10000))\n", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    result = []\n    while n % 2 == 0:\n        result.append(2)\n        n = n // 2\n\n    for i in range(3, n + 1, 2):\n        while n % i == 0:\n            result.append(i)\n            n = n // i\n\n    if n > 1:\n        result.append(n)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(name=\"factorize\")\n\n    print(factorize(10000))\n"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    while n > 1:\n        lowest = 2\n        while n % lowest!= 0:\n            lowest += 1\n        factors.append(lowest)\n        n //= lowest\n    return factors\n\ndef isprime(n: int) -> bool:\n    \"\"\" 判断整数是否为素数    输入应大于1 \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    if n == 3:\n        return True\n    if n % 3 == 0 or n == 2:\n        return False\n    for i in range(5, int(n ** 0.5) + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef primetest(n: int) -> bool:\n    \"\"\" 判断整数是否为合数    输入应大于1 \"\"\"\n    if n % 2 == 0:\n        if n ==", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    while n > 1:\n        lowest = 2\n        while n % lowest!= 0:\n            lowest += 1\n        factors.append(lowest)\n        n //= lowest\n    return factors\n\ndef isprime(n: int) -> bool:\n    \"\"\" 判断整数是否为素数    输入应大于1 \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    if n == 3:\n        return True\n    if n % 3 == 0 or n == 2:\n        return False\n    for i in range(5, int(n ** 0.5) + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef primetest(n: int) -> bool:\n    \"\"\" 判断整数是否为合数    输入应大于1 \"\"\"\n    if n % 2 == 0:\n        if n =="}
{"task_id": "HumanEval/25", "completion": "    factors = []  # 最大的质因数存放在列表的前端\n    number = n\n\n    while number % 2 == 0:\n        factors.append(2)\n        number = int(number / 2)\n\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            factors.append(i)\n            number = int(number / i)\n    if number > 1:\n        factors.append(number)\n\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []  # 最大的质因数存放在列表的前端\n    number = n\n\n    while number % 2 == 0:\n        factors.append(2)\n        number = int(number / 2)\n\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            factors.append(i)\n            number = int(number / i)\n    if number > 1:\n        factors.append(number)\n\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod("}
{"task_id": "HumanEval/26", "completion": "    pass\n\n\ndef is_sublist(sublist: List[int], list_: List[int]) -> bool:\n    \"\"\" 判断 sublist 是否是 list_ 的子序列   >>> is_sublist([1, 3, 4], [1, 2, 3, 4, 5])\n    True\n    >>> is_sublist([1, 2], [1, 2, 3])\n    True\n    >>> is_sublist([1, 2], [1, 2, 1])\n    False\n    \"\"\"\n    pass\n\n\ndef intersection(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\" 返回两个整数列表的交集    >>> intersection([1, 3, 4], [1, 2, 3, 4, 5])\n    [1, 3, 4]\n    >>> intersection([1, 2, 3], [1, 3, 4, 5])\n    [1, 3]\n    \"\"\"\n    pass\n", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    pass\n\n\ndef is_sublist(sublist: List[int], list_: List[int]) -> bool:\n    \"\"\" 判断 sublist 是否是 list_ 的子序列   >>> is_sublist([1, 3, 4], [1, 2, 3, 4, 5])\n    True\n    >>> is_sublist([1, 2], [1, 2, 3])\n    True\n    >>> is_sublist([1, 2], [1, 2, 1])\n    False\n    \"\"\"\n    pass\n\n\ndef intersection(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\" 返回两个整数列表的交集    >>> intersection([1, 3, 4], [1, 2, 3, 4, 5])\n    [1, 3, 4]\n    >>> intersection([1, 2, 3], [1, 3, 4, 5])\n    [1, 3]\n    \"\"\"\n    pass\n"}
{"task_id": "HumanEval/26", "completion": "    result = []\n    for n in numbers:\n        if n not in result:\n            result.append(n)\n    return result\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for n in numbers:\n        if n in result:\n            continue\n        result.append(n)\n    return result\n\n\nnumbers = [1, 2, 3, 2, 4]\n\n\ndef remove_duplicates_by_dict(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素   保持剩余元素的顺序与", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for n in numbers:\n        if n not in result:\n            result.append(n)\n    return result\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for n in numbers:\n        if n in result:\n            continue\n        result.append(n)\n    return result\n\n\nnumbers = [1, 2, 3, 2, 4]\n\n\ndef remove_duplicates_by_dict(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素   保持剩余元素的顺序与"}
{"task_id": "HumanEval/26", "completion": "    res = []\n    for num in numbers:\n        if num not in res:\n            res.append(num)\n    return res\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 2, 2, 2, 3]))\n    print(remove_duplicates([1, 2, 3, 2, 4, 2, 5, 2, 5, 2, 1]))\n    print(remove_duplicates([1, 2, 2, 2, 3, 2, 5, 2, 5, 2, 1, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for num in numbers:\n        if num not in res:\n            res.append(num)\n    return res\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 2, 2, 2, 3]))\n    print(remove_duplicates([1, 2, 3, 2, 4, 2, 5, 2, 5, 2, 1]))\n    print(remove_duplicates([1, 2, 2, 2, 3, 2, 5, 2, 5, 2, 1, "}
{"task_id": "HumanEval/26", "completion": "    seen: set = set()\n    return [seen.add(value) or value for value in numbers if not seen.contains(value)]\n\n\nif __name__ == '__main__':\n    numbers: list = [2, 1, 2, 3, 2, 4]\n    remove_duplicates(numbers)\n    print(numbers)\n    numbers: list = [3, 2, 1, 2]\n    remove_duplicates(numbers)\n    print(numbers)\n    numbers: list = [2", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen: set = set()\n    return [seen.add(value) or value for value in numbers if not seen.contains(value)]\n\n\nif __name__ == '__main__':\n    numbers: list = [2, 1, 2, 3, 2, 4]\n    remove_duplicates(numbers)\n    print(numbers)\n    numbers: list = [3, 2, 1, 2]\n    remove_duplicates(numbers)\n    print(numbers)\n    numbers: list = [2"}
{"task_id": "HumanEval/26", "completion": "   ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n   "}
{"task_id": "HumanEval/26", "completion": "    return list(dict.fromkeys(numbers))\n\n\ndef remove_duplicates2(numbers: List[int]) -> List[int]:\n    \"\"\"通过哈希表的另一种方法，使用list comprehension语法\n\n    Args:\n        numbers (List[int]): [description]\n\n    Returns:\n        List[int]: [description]\n    \"\"\"\n    return [num for num in numbers if numbers.count(num) == 1]\n\n\ndef remove_duplicates3(numbers: List[int]) -> List[int]:\n    \"\"\" 使用collections.OrderedDict创建哈希表，保留元素的顺序\n\n    Args:\n        numbers (List[int]): [description]\n\n    Returns:\n        List[int]: [description]\n    \"\"\"\n    from collections import OrderedDict\n\n    dup_numbers = OrderedDict.fromkeys(numbers)\n    return list(dup_numbers.keys())\n\n\ndef remove_duplicates4(numbers: List[int]) -> List[int]:\n", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(dict.fromkeys(numbers))\n\n\ndef remove_duplicates2(numbers: List[int]) -> List[int]:\n    \"\"\"通过哈希表的另一种方法，使用list comprehension语法\n\n    Args:\n        numbers (List[int]): [description]\n\n    Returns:\n        List[int]: [description]\n    \"\"\"\n    return [num for num in numbers if numbers.count(num) == 1]\n\n\ndef remove_duplicates3(numbers: List[int]) -> List[int]:\n    \"\"\" 使用collections.OrderedDict创建哈希表，保留元素的顺序\n\n    Args:\n        numbers (List[int]): [description]\n\n    Returns:\n        List[int]: [description]\n    \"\"\"\n    from collections import OrderedDict\n\n    dup_numbers = OrderedDict.fromkeys(numbers)\n    return list(dup_numbers.keys())\n\n\ndef remove_duplicates4(numbers: List[int]) -> List[int]:\n"}
{"task_id": "HumanEval/26", "completion": "    new_numbers = []\n    for number in numbers:\n        if number not in new_numbers:\n            new_numbers.append(number)\n    return new_numbers\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 2, 2, 2, 2]))\n    print(remove_", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    new_numbers = []\n    for number in numbers:\n        if number not in new_numbers:\n            new_numbers.append(number)\n    return new_numbers\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 2, 2, 2, 2]))\n    print(remove_"}
{"task_id": "HumanEval/26", "completion": "    return list(set(numbers))\n\n\ndef is_equal(numbers: List[int]) -> bool:\n    \"\"\" 判定列表中所有元素相等，如果是，则返回 True，否则返回 False    >>> is_equal([1, 1, 1, 1, 1])\n    True\n\n    >>> is_equal([1, 1, 2, 1])\n    False\n    \"\"\"\n    return len(numbers) == 1 or len(remove_duplicates(numbers)) == 1\n\n\ndef get_max_index(numbers: List[int]) -> int:\n    \"\"\" 返回列表中最大元素的索引    >>> get_max_index([1, 2, 3, 2, 4])\n    4\n    \"\"\"\n    return numbers.index(max(numbers))\n\n\ndef get_min_index(numbers: List[int]) -> int:\n    \"\"\" 返回列表中最小元素的索引    >>> get_min_index([1, 2, 3, 2, 4", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))\n\n\ndef is_equal(numbers: List[int]) -> bool:\n    \"\"\" 判定列表中所有元素相等，如果是，则返回 True，否则返回 False    >>> is_equal([1, 1, 1, 1, 1])\n    True\n\n    >>> is_equal([1, 1, 2, 1])\n    False\n    \"\"\"\n    return len(numbers) == 1 or len(remove_duplicates(numbers)) == 1\n\n\ndef get_max_index(numbers: List[int]) -> int:\n    \"\"\" 返回列表中最大元素的索引    >>> get_max_index([1, 2, 3, 2, 4])\n    4\n    \"\"\"\n    return numbers.index(max(numbers))\n\n\ndef get_min_index(numbers: List[int]) -> int:\n    \"\"\" 返回列表中最小元素的索引    >>> get_min_index([1, 2, 3, 2, 4"}
{"task_id": "HumanEval/26", "completion": "    i = 0\n    for n in numbers:\n        if i == 0 or n!= numbers[i - 1]:\n            numbers[i] = n\n            i += 1\n    return numbers[:i]\n\n\ndef remove_duplicates_list(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，\n    保持剩余元素的顺序与输入相同\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))\n\n\ndef remove_duplicates_dict(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，\n    保持剩余元素的顺序与输入相同\n    >>> remove_duplicates([1, 2, 3, 2,", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    i = 0\n    for n in numbers:\n        if i == 0 or n!= numbers[i - 1]:\n            numbers[i] = n\n            i += 1\n    return numbers[:i]\n\n\ndef remove_duplicates_list(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，\n    保持剩余元素的顺序与输入相同\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))\n\n\ndef remove_duplicates_dict(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，\n    保持剩余元素的顺序与输入相同\n    >>> remove_duplicates([1, 2, 3, 2,"}
{"task_id": "HumanEval/26", "completion": "    res = []\n    for number in numbers:\n        if not res or number!= res[-1]:\n            res.append(number)\n\n    return res\n\n\ndef remove_adjascent_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的相邻元素，保持剩余元素的顺序与输入相同    >>> remove_adjascent_duplicates([1, 2, 2, 3, 3, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for number in numbers:\n        if not res or number!= res[-1]:\n            res.append(number)\n        else:\n            if res[-1]!= number:\n                res.append(number)\n\n    return res\n\n\ndef remove_duplicates_in_order(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for number in numbers:\n        if not res or number!= res[-1]:\n            res.append(number)\n\n    return res\n\n\ndef remove_adjascent_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的相邻元素，保持剩余元素的顺序与输入相同    >>> remove_adjascent_duplicates([1, 2, 2, 3, 3, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for number in numbers:\n        if not res or number!= res[-1]:\n            res.append(number)\n        else:\n            if res[-1]!= number:\n                res.append(number)\n\n    return res\n\n\ndef remove_duplicates_in_order(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    else: \n        for i in range(2, n // 2 + 1):\n            if n % i == 0:\n                return False\n        return True\n\ndef is_prime1(n):\n  \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n  False\n  >>> is_prime(101)\n  True\n  >>> is_prime(11)\n  True\n  >>> is_prime(13441)\n  True\n  >>> is_prime(61)\n  True\n  >>> is_prime(4)\n  False\n  >>> is_prime(1)\n  False\n  \"\"\"\n  if n <= 1:\n    return False\n  else: \n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime2(n):\n  \"\"\"如果给定的数字是�", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    else: \n        for i in range(2, n // 2 + 1):\n            if n % i == 0:\n                return False\n        return True\n\ndef is_prime1(n):\n  \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n  False\n  >>> is_prime(101)\n  True\n  >>> is_prime(11)\n  True\n  >>> is_prime(13441)\n  True\n  >>> is_prime(61)\n  True\n  >>> is_prime(4)\n  False\n  >>> is_prime(1)\n  False\n  \"\"\"\n  if n <= 1:\n    return False\n  else: \n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime2(n):\n  \"\"\"如果给定的数字是�"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        else:\n            return True\n\n\ndef fibonacci(n):\n    \"\"\"斐波那契数列    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(11)\n    89\n    >>> fibonacci(12)\n    144\n    >>> fibonacci(18)\n    2584\n    >>> fibonacci(19)\n    4181\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n\ndef sum_of_odd_numbers(n):\n    \"\"\"求1+3+5+...+(2n-1)    >>>", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        else:\n            return True\n\n\ndef fibonacci(n):\n    \"\"\"斐波那契数列    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(11)\n    89\n    >>> fibonacci(12)\n    144\n    >>> fibonacci(18)\n    2584\n    >>> fibonacci(19)\n    4181\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n\ndef sum_of_odd_numbers(n):\n    \"\"\"求1+3+5+...+(2n-1)    >>>"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef get_prime_list(num):\n    \"\"\"获取1-n的所有素数，采用埃拉托斯特尼筛法   >>> get_prime_list(100)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    >>> get_prime_list(20)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 4", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef get_prime_list(num):\n    \"\"\"获取1-n的所有素数，采用埃拉托斯特尼筛法   >>> get_prime_list(100)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    >>> get_prime_list(20)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 4"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if ((n % 2 == 0) or (n % 3 == 0)):\n        return False\n    i = 5\n    while(i*i <= n):\n        if(n % i == 0 or n % (i+2) == 0):\n            return False\n        i = i+6\n    return True\n### 筛法  \ndef is_prime_2(n):\n    \"\"\"返回某个数字是否为素数。如果有小数部分，取整。\"\"\"\n    if n <= 1: return False\n    if n <= 3: return True\n    if not n & 1: return False  # 如果 n 是偶数\n    r = int(n**0.5)\n    s = 5\n    f = True\n    while s <= r:\n        if n % s == 0:\n            f = False\n            break\n        if n % (s + 2) ==", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if ((n % 2 == 0) or (n % 3 == 0)):\n        return False\n    i = 5\n    while(i*i <= n):\n        if(n % i == 0 or n % (i+2) == 0):\n            return False\n        i = i+6\n    return True\n### 筛法  \ndef is_prime_2(n):\n    \"\"\"返回某个数字是否为素数。如果有小数部分，取整。\"\"\"\n    if n <= 1: return False\n    if n <= 3: return True\n    if not n & 1: return False  # 如果 n 是偶数\n    r = int(n**0.5)\n    s = 5\n    f = True\n    while s <= r:\n        if n % s == 0:\n            f = False\n            break\n        if n % (s + 2) =="}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\n# 不同\ndef isPrime(x):\n    if x <= 1:\n        return False\n    for i in range(2, x):\n        if x % i == 0:\n            return False\n    return True\n\n\n# 不同\ndef isPrime(n):\n    if (n <= 1) or (n % 2 == 0):\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if (n % i == 0):\n            return False\n    return True\n\n\ndef isPrime_2(x):\n    result = True\n    for i in range(2, x):\n        if (x % i) == 0:\n            result = False\n            break\n    return result\n\n\ndef isPrime_3(x):\n    for i in range(2, x // 2 + ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\n# 不同\ndef isPrime(x):\n    if x <= 1:\n        return False\n    for i in range(2, x):\n        if x % i == 0:\n            return False\n    return True\n\n\n# 不同\ndef isPrime(n):\n    if (n <= 1) or (n % 2 == 0):\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if (n % i == 0):\n            return False\n    return True\n\n\ndef isPrime_2(x):\n    result = True\n    for i in range(2, x):\n        if (x % i) == 0:\n            result = False\n            break\n    return result\n\n\ndef isPrime_3(x):\n    for i in range(2, x // 2 + "}
{"task_id": "HumanEval/31", "completion": "    if n == 2:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef get_prime(num):\n    \"\"\" 给定一个数字n，这个函数返回 n 的质因数。找到的质因数将以递减的顺序（从最大到最小）返回。如果n不是质数，则返回空列表。\n    >>> get_prime(109)\n    [3, 3, 13]\n    >>> get_prime(624)\n    [2, 2, 2, 3, 31]\n    >>> get_prime(61)\n    [3, 7, 19]\n    >>> get_prime(60)\n    []\n    >>> get_prime(-1", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef get_prime(num):\n    \"\"\" 给定一个数字n，这个函数返回 n 的质因数。找到的质因数将以递减的顺序（从最大到最小）返回。如果n不是质数，则返回空列表。\n    >>> get_prime(109)\n    [3, 3, 13]\n    >>> get_prime(624)\n    [2, 2, 2, 3, 31]\n    >>> get_prime(61)\n    [3, 7, 19]\n    >>> get_prime(60)\n    []\n    >>> get_prime(-1"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False  # 1 就是质数\n    for i in range(2,n):\n        if n % i == 0:\n            return False\n    return True\nprint(is_prime(101))\n\n\n\ndef get_primes_between(start,end):\n    \"\"\"返回从 start 到 end 范围内的所有质数。   >>> get_primes_between(1,10)\n    [2, 3, 5, 7]\n    >>> get_primes_between(1,17)\n    [2, 3, 5, 7, 11, 13, 17]\n    >>> get_primes_between(3,3)\n    []\n    >>> get_primes_between(1,1)\n    []\n    \"\"\"\n    primes = []\n    for i in range(start,end):\n        if is_prime(i):\n            primes.append(i)\n    return primes\nprint(get_pr", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False  # 1 就是质数\n    for i in range(2,n):\n        if n % i == 0:\n            return False\n    return True\nprint(is_prime(101))\n\n\n\ndef get_primes_between(start,end):\n    \"\"\"返回从 start 到 end 范围内的所有质数。   >>> get_primes_between(1,10)\n    [2, 3, 5, 7]\n    >>> get_primes_between(1,17)\n    [2, 3, 5, 7, 11, 13, 17]\n    >>> get_primes_between(3,3)\n    []\n    >>> get_primes_between(1,1)\n    []\n    \"\"\"\n    primes = []\n    for i in range(start,end):\n        if is_prime(i):\n            primes.append(i)\n    return primes\nprint(get_pr"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    return all(n % i for i in range(2, n))\n\n\ndef is_strong_prime(n):\n    \"\"\"如果给定的数字是强质数，则返回 true，否则返回false   >>> is_strong_prime(13195)\n    True\n    >>> is_strong_prime(13219)\n    False\n    >>> is_strong_prime(13194)\n    False\n    \"\"\"\n    if n <= 10:\n        return False\n    sqrt = math.sqrt(n)\n    for i in range(2, int(sqrt + 1)):\n        if n % i == 0 and is_prime(i) and is_prime(n // i):\n            return False\n    return True\n\n\ndef is_semiprime(n):\n    \"\"\"如果给定的数字是半质数，则返回 true，否则返回false   >>> is_semiprime(221)\n    True\n   ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    return all(n % i for i in range(2, n))\n\n\ndef is_strong_prime(n):\n    \"\"\"如果给定的数字是强质数，则返回 true，否则返回false   >>> is_strong_prime(13195)\n    True\n    >>> is_strong_prime(13219)\n    False\n    >>> is_strong_prime(13194)\n    False\n    \"\"\"\n    if n <= 10:\n        return False\n    sqrt = math.sqrt(n)\n    for i in range(2, int(sqrt + 1)):\n        if n % i == 0 and is_prime(i) and is_prime(n // i):\n            return False\n    return True\n\n\ndef is_semiprime(n):\n    \"\"\"如果给定的数字是半质数，则返回 true，否则返回false   >>> is_semiprime(221)\n    True\n   "}
{"task_id": "HumanEval/31", "completion": "    return n > 1 and all(n % p for p in range(2, n))\n\ndef is_not_prime(n):\n    \"\"\"如果给定的数字不是质数，则返回 true，否则返回false  >>> is_not_prime(6)\n    True\n    >>> is_not_prime(101)\n    False\n    >>> is_not_prime(11)\n    False\n    >>> is_not_prime(13441)\n    False\n    >>> is_not_prime(61)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(1)\n    True\n    \"\"\"\n    return not is_prime(n)\n\ndef get_prime(min_num, max_num):\n    \"\"\"返回一个数字范围内的所有质数，包含min_num和max_num，如果范围内没有质数，则返回一个空列表 \"\"\"\n    return", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    return n > 1 and all(n % p for p in range(2, n))\n\ndef is_not_prime(n):\n    \"\"\"如果给定的数字不是质数，则返回 true，否则返回false  >>> is_not_prime(6)\n    True\n    >>> is_not_prime(101)\n    False\n    >>> is_not_prime(11)\n    False\n    >>> is_not_prime(13441)\n    False\n    >>> is_not_prime(61)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(1)\n    True\n    \"\"\"\n    return not is_prime(n)\n\ndef get_prime(min_num, max_num):\n    \"\"\"返回一个数字范围内的所有质数，包含min_num和max_num，如果范围内没有质数，则返回一个空列表 \"\"\"\n    return"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    else:\n        for i in range(2,n):\n            mod = n % i\n            if mod == 0:\n                return False\n    return True\n\n#is_prime函数的python3版本\ndef is_prime(n:int):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    else:\n        for i in range(2,n):\n            mod = n % i\n            if mod == 0:\n                return False\n    return True\n\n\n# 查询素数\ndef prime", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    else:\n        for i in range(2,n):\n            mod = n % i\n            if mod == 0:\n                return False\n    return True\n\n#is_prime函数的python3版本\ndef is_prime(n:int):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    else:\n        for i in range(2,n):\n            mod = n % i\n            if mod == 0:\n                return False\n    return True\n\n\n# 查询素数\ndef prime"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    index = 0\n    for e in l:\n        if e!= l[index]:\n            l[index+1:] = []\n            l[index:] = [e]\n        index += 1\n    return l\n\ndef unique1(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    uniq = set(l)\n    uniq = list(uniq)\n    uniq.sort()\n    return uniq\n\ndef unique2(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    return list(set(l))\n\ndef unique3(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    return list(set([x for x in l if x not in l[:x.index(x)]]))\n\ndef unique4(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    index = 0\n    for e in l:\n        if e!= l[index]:\n            l[index+1:] = []\n            l[index:] = [e]\n        index += 1\n    return l\n\ndef unique1(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    uniq = set(l)\n    uniq = list(uniq)\n    uniq.sort()\n    return uniq\n\ndef unique2(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    return list(set(l))\n\ndef unique3(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素\"\"\"\n    return list(set([x for x in l if x not in l[:x.index(x)]]))\n\ndef unique4(l: list):\n    \"\"\"使用集合, 有序列表中的唯一元素"}
{"task_id": "HumanEval/34", "completion": "    if not isinstance(l, list):\n        raise TypeError(\"输入数据类型错误！\")\n\n    l.sort()\n    t = []\n    for i in range(len(l)):\n        if i == 0 or l[i]!= l[i - 1]:\n            t.append(l[i])\n    return t\n\n\ndef unique2(l: list):\n    \"\"\"返回列表中较为简单的实现方法, 原来的元素不再保留精度 \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"输入数据类型错误！\")\n\n    t = []\n    t.extend(l)\n    t.sort()\n    t = list(set(t))\n    return t\n\ndef unique3(l: list):\n    \"\"\"返回列表中较为简单的实现方法, 原来的元素不再保留精度 \"\"\"\n    if not isinstance(l, list):", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"输入数据类型错误！\")\n\n    l.sort()\n    t = []\n    for i in range(len(l)):\n        if i == 0 or l[i]!= l[i - 1]:\n            t.append(l[i])\n    return t\n\n\ndef unique2(l: list):\n    \"\"\"返回列表中较为简单的实现方法, 原来的元素不再保留精度 \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"输入数据类型错误！\")\n\n    t = []\n    t.extend(l)\n    t.sort()\n    t = list(set(t))\n    return t\n\ndef unique3(l: list):\n    \"\"\"返回列表中较为简单的实现方法, 原来的元素不再保留精度 \"\"\"\n    if not isinstance(l, list):"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    unique_list = []\n    for x in l:\n        if x not in unique_list:\n            unique_list.append(x)\n    return unique_list\n\ndef unique2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素\n    >>> unique2([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = []\n    for x in l:\n        if x in unique_list:\n            continue\n        unique_list.append(x)\n    return unique_list\n\nif __name__ == \"__main__\":\n    print(unique2([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n    # 1.如何从一个字符串中得到每一个单词?\n    s = \"Hello", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    unique_list = []\n    for x in l:\n        if x not in unique_list:\n            unique_list.append(x)\n    return unique_list\n\ndef unique2(l: list):\n    \"\"\"返回列表中经过排序后的独特元素\n    >>> unique2([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = []\n    for x in l:\n        if x in unique_list:\n            continue\n        unique_list.append(x)\n    return unique_list\n\nif __name__ == \"__main__\":\n    print(unique2([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n    # 1.如何从一个字符串中得到每一个单词?\n    s = \"Hello"}
{"task_id": "HumanEval/34", "completion": "    if len(l):\n        l.sort()\n        index = 0\n        for i in range(len(l)):\n            if index == i:\n                continue\n            elif l[i]!= l[index]:\n                index += 1\n                l[index] = l[i]\n    return l\n\ndef count(l, e):\n    \"\"\"返回列表中元素e的个数?    >>> count([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n    3\n    \"\"\"\n    return len([i for i in l if i == e])\n\ndef search(l, e):\n    \"\"\"返回列表中第一个值为e的元素的位置?    >>> search([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n    1\n    \"\"\"\n    try:\n        return l.index(e)\n    except ValueError:\n        return None\n\ndef insert(l, i, e", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l):\n        l.sort()\n        index = 0\n        for i in range(len(l)):\n            if index == i:\n                continue\n            elif l[i]!= l[index]:\n                index += 1\n                l[index] = l[i]\n    return l\n\ndef count(l, e):\n    \"\"\"返回列表中元素e的个数?    >>> count([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n    3\n    \"\"\"\n    return len([i for i in l if i == e])\n\ndef search(l, e):\n    \"\"\"返回列表中第一个值为e的元素的位置?    >>> search([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n    1\n    \"\"\"\n    try:\n        return l.index(e)\n    except ValueError:\n        return None\n\ndef insert(l, i, e"}
{"task_id": "HumanEval/34", "completion": "    return list(set(sorted(l, key=lambda x: x)))\n\n\ndef uniqueA(l: list):\n    \"\"\"返回列表中独特元素, 原列表保持顺序?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 2, 9, 0, 123]\n    \"\"\"\n\n    ret = []\n    for item in l:\n        if item not in ret:\n            ret.append(item)\n    return ret\n\n\ndef uniqueB(l: list):\n    \"\"\"返回列表中独特元素, 但是保持原列表的顺序?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 2, 9, 0, 123]\n    \"\"\"\n\n    ret = []\n    for item in l:", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(sorted(l, key=lambda x: x)))\n\n\ndef uniqueA(l: list):\n    \"\"\"返回列表中独特元素, 原列表保持顺序?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 2, 9, 0, 123]\n    \"\"\"\n\n    ret = []\n    for item in l:\n        if item not in ret:\n            ret.append(item)\n    return ret\n\n\ndef uniqueB(l: list):\n    \"\"\"返回列表中独特元素, 但是保持原列表的顺序?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 2, 9, 0, 123]\n    \"\"\"\n\n    ret = []\n    for item in l:"}
{"task_id": "HumanEval/34", "completion": "    res = []\n    for x in l:\n        if res.count(x) == 0:\n            res.append(x) \n    return res\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回从列表1和列表2中选出的独特元素?    >>> union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(l1+l2))\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表共有的元素?      >>> intersection([1, 2, 3], [3, 4, 5])\n    [3]\n    \"\"\"\n    return [x for x in l1 if x in l2]\n\n\ndef difference(l1: list, l2: list):\n    \"\"\"返回两个列表中不同的元素?    >>> difference([1, 2, 3], [3, 4", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    res = []\n    for x in l:\n        if res.count(x) == 0:\n            res.append(x) \n    return res\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回从列表1和列表2中选出的独特元素?    >>> union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(l1+l2))\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表共有的元素?      >>> intersection([1, 2, 3], [3, 4, 5])\n    [3]\n    \"\"\"\n    return [x for x in l1 if x in l2]\n\n\ndef difference(l1: list, l2: list):\n    \"\"\"返回两个列表中不同的元素?    >>> difference([1, 2, 3], [3, 4"}
{"task_id": "HumanEval/34", "completion": "    return list(set(l))\n\ndef group(l: list, n: int):\n    \"\"\"将一个列表按照n的大小分组?\n    >>> group([1, 2, 3, 4, 5, 6], 3)\n    [[1, 2, 3], [4, 5, 6]]\n    \"\"\"\n    return [l[i * n:(i + 1) * n] for i in range(len(l) // n + 1)]\n\ndef group_by(l: list, k):\n    \"\"\"将一个列表按照k的值分组?\n    >>> group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2)\n    [[1, 3, 5], [2, 4, 6]]\n    \"\"\"\n    return group(sorted(l, key=k), len(l) // len(set([k(x) for x in l])))\n\ndef zip(*iterables):\n    \"\"\"将可迭代", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n\ndef group(l: list, n: int):\n    \"\"\"将一个列表按照n的大小分组?\n    >>> group([1, 2, 3, 4, 5, 6], 3)\n    [[1, 2, 3], [4, 5, 6]]\n    \"\"\"\n    return [l[i * n:(i + 1) * n] for i in range(len(l) // n + 1)]\n\ndef group_by(l: list, k):\n    \"\"\"将一个列表按照k的值分组?\n    >>> group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2)\n    [[1, 3, 5], [2, 4, 6]]\n    \"\"\"\n    return group(sorted(l, key=k), len(l) // len(set([k(x) for x in l])))\n\ndef zip(*iterables):\n    \"\"\"将可迭代"}
{"task_id": "HumanEval/34", "completion": "    if not isinstance(l, list):\n        raise TypeError('unique() takes exactly one argument (2 given)')\n    if len(l) <= 1:\n        return l[:]\n\n    i = 1\n    if len(l) == 2:\n        l[0] == l[1] or l.pop(1)\n\n    while i < len(l):\n        l[0] == l[i] and l.pop(i) or i += 1\n    return l[:]\n\ndef unique(l: list):\n    \"\"\"如果有元组，将其转化为元组列表，然后执行unique，最后再将其转化回元组，返回list。\n\n    >>> t = [(1, '1'), (2, '2'), (3, '3'), (3, '3')]\n    >>> unique(t)  # 不支持元组.\n    [(1, '1'), (2, '2'), (3, '3')]\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError('", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError('unique() takes exactly one argument (2 given)')\n    if len(l) <= 1:\n        return l[:]\n\n    i = 1\n    if len(l) == 2:\n        l[0] == l[1] or l.pop(1)\n\n    while i < len(l):\n        l[0] == l[i] and l.pop(i) or i += 1\n    return l[:]\n\ndef unique(l: list):\n    \"\"\"如果有元组，将其转化为元组列表，然后执行unique，最后再将其转化回元组，返回list。\n\n    >>> t = [(1, '1'), (2, '2'), (3, '3'), (3, '3')]\n    >>> unique(t)  # 不支持元组.\n    [(1, '1'), (2, '2'), (3, '3')]\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError('"}
{"task_id": "HumanEval/34", "completion": "    return list(set(sorted(l)))\n\n\ndef unique_cmp(l: list, cmp=None):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if cmp is None:\n        l = sorted(l)\n    for i in range(1, len(l)):\n        if l[i] == l[i - 1]:\n            l[i] = None\n\n    l.reverse()\n    for i in range(1, len(l)):\n        if l[i] == l[i - 1]:\n            l[i] = None\n    l.reverse()\n    return [i for i in l if i is not None]\n\n\ndef unique_index(l: list, cmp=None, reverse=False):\n    \"\"\"根据cmp函数返回列表", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(sorted(l)))\n\n\ndef unique_cmp(l: list, cmp=None):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if cmp is None:\n        l = sorted(l)\n    for i in range(1, len(l)):\n        if l[i] == l[i - 1]:\n            l[i] = None\n\n    l.reverse()\n    for i in range(1, len(l)):\n        if l[i] == l[i - 1]:\n            l[i] = None\n    l.reverse()\n    return [i for i in l if i is not None]\n\n\ndef unique_index(l: list, cmp=None, reverse=False):\n    \"\"\"根据cmp函数返回列表"}
{"task_id": "HumanEval/34", "completion": "    l.sort() \n    ret = [] \n    for i in l:     \n        if i not in ret: \n            ret.append(i)    \n    return ret\n\n\n# def unique(l: list):\n#     \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n#     [0, 2, 3, 5, 9, 123]\n#     \"\"\"\n#     l.sort() \n#     ret = [] \n#     for i in range(1, len(l)):\n#         j = 0\n#         if l[i]!= l[j]:\n#             l[j+1] = l[i]\n#         j = j + 1\n#     return l[:j+1]\n\ndef unique_nums(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort() \n    ret = [] \n    for i in l:     \n        if i not in ret: \n            ret.append(i)    \n    return ret\n\n\n# def unique(l: list):\n#     \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n#     [0, 2, 3, 5, 9, 123]\n#     \"\"\"\n#     l.sort() \n#     ret = [] \n#     for i in range(1, len(l)):\n#         j = 0\n#         if l[i]!= l[j]:\n#             l[j+1] = l[i]\n#         j = j + 1\n#     return l[:j+1]\n\ndef unique_nums(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique"}
{"task_id": "HumanEval/35", "completion": "    if not l: return l\n    max = l[0]\n    for i in l:\n        max = max if max > i else i\n    return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l: return l\n    min = l[0]\n    for i in l:\n        min = min if min < i else i\n    return min\n\n\ndef sum_up(l: list):\n    \"\"\"返回列表中元素的和    >>> sum_up([1, 2, 3])\n    6\n    >>> sum_up([5, 3, 2, 1])\n    13\n    >>> sum_up([12, 11, 10])\n    33\n    \"\"\"\n", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l: return l\n    max = l[0]\n    for i in l:\n        max = max if max > i else i\n    return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if not l: return l\n    min = l[0]\n    for i in l:\n        min = min if min < i else i\n    return min\n\n\ndef sum_up(l: list):\n    \"\"\"返回列表中元素的和    >>> sum_up([1, 2, 3])\n    6\n    >>> sum_up([5, 3, 2, 1])\n    13\n    >>> sum_up([12, 11, 10])\n    33\n    \"\"\"\n"}
{"task_id": "HumanEval/35", "completion": "    max_value = l[0]\n    for element in l:\n        if element > max_value:\n            max_value = element\n    return max_value\n\n# list()和tuple()内部实现使用了for循环，但是实际上不用for循环就可以实现，所以使用while循环更有效率\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_value = l[0]\n    i = 1\n    while i < len(l):\n        if l[i] > max_value:\n            max_value = l[i]\n        i += 1\n    return max_value\n\n\n#", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_value = l[0]\n    for element in l:\n        if element > max_value:\n            max_value = element\n    return max_value\n\n# list()和tuple()内部实现使用了for循环，但是实际上不用for循环就可以实现，所以使用while循环更有效率\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_value = l[0]\n    i = 1\n    while i < len(l):\n        if l[i] > max_value:\n            max_value = l[i]\n        i += 1\n    return max_value\n\n\n#"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n    # pass\n\n\ndef average(l: list) -> float:\n    \"\"\"返回列表中元素的平均数\n    >>> average([1, 2, 3])\n    2.0\n    >>> average([1, 2, 3, 9, 10])\n    5.2\n    \"\"\"\n    return sum(l) / len(l)\n    # pass\n\n\ndef average_range(start: int, end: int) -> float:\n    \"\"\"返回start到end之间各个数字的平均数\n    >>> average_range(1, 2)\n    1.5\n    >>> average_range(2, 30)\n    11.0\n    >>> average_range(1, 1000)\n    500.0\n    \"\"\"\n    return average(range(start, end + 1))\n    # pass\n\n\ndef count_less_than(l: list, n: int) -> int:\n    \"\"\"统计列表中各个数的", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n    # pass\n\n\ndef average(l: list) -> float:\n    \"\"\"返回列表中元素的平均数\n    >>> average([1, 2, 3])\n    2.0\n    >>> average([1, 2, 3, 9, 10])\n    5.2\n    \"\"\"\n    return sum(l) / len(l)\n    # pass\n\n\ndef average_range(start: int, end: int) -> float:\n    \"\"\"返回start到end之间各个数字的平均数\n    >>> average_range(1, 2)\n    1.5\n    >>> average_range(2, 30)\n    11.0\n    >>> average_range(1, 1000)\n    500.0\n    \"\"\"\n    return average(range(start, end + 1))\n    # pass\n\n\ndef count_less_than(l: list, n: int) -> int:\n    \"\"\"统计列表中各个数的"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef first_same_element(l1: list, l2: list):\n    \"\"\"返回两个列表第一个相同的元素（注意，若列表中没有相同的元素，则返回 None）\n    >>> first_same_element([1, 2, 3], [1, 2, 3, 4])\n    1\n    >>> first_same_element([1, 2, 3], [3, 2, 1])\n    2\n    >>> first_same_element([1, 2, 3], [1, 2, 3, 3])\n    3\n   ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef first_same_element(l1: list, l2: list):\n    \"\"\"返回两个列表第一个相同的元素（注意，若列表中没有相同的元素，则返回 None）\n    >>> first_same_element([1, 2, 3], [1, 2, 3, 4])\n    1\n    >>> first_same_element([1, 2, 3], [3, 2, 1])\n    2\n    >>> first_same_element([1, 2, 3], [1, 2, 3, 3])\n    3\n   "}
{"task_id": "HumanEval/35", "completion": "    max = l[0]\n    for x in l:\n        if x > max:\n            max = x\n    return max\n\n\ndef max_element2(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element2([1, 2, 3])\n    3\n    >>> max_element2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    m = l[0]\n    for x in l:\n        if x > m:\n            m = x\n    return m\n\n\ndef max_element3(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element3([1, 2, 3])\n    3\n    >>> max_element3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max = l[0]\n    for x in l:\n        if x > max:\n            max = x\n    return max\n\n\ndef max_element2(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element2([1, 2, 3])\n    3\n    >>> max_element2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    m = l[0]\n    for x in l:\n        if x > m:\n            m = x\n    return m\n\n\ndef max_element3(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element3([1, 2, 3])\n    3\n    >>> max_element3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max("}
{"task_id": "HumanEval/35", "completion": "    if len(l) == 0:\n        raise ValueError(\"当前列表为空，无法求最大值\")\n    else:\n        return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError(\"当前列表为空，无法求最小值\")\n    else:\n        return min(l)\n\ndef average(l: list):\n    \"\"\"返回列表平均值\n    >>> average([1, 2, 3])\n    2.0\n    >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10, ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError(\"当前列表为空，无法求最大值\")\n    else:\n        return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError(\"当前列表为空，无法求最小值\")\n    else:\n        return min(l)\n\ndef average(l: list):\n    \"\"\"返回列表平均值\n    >>> average([1, 2, 3])\n    2.0\n    >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10, "}
{"task_id": "HumanEval/35", "completion": "    r = l[0]\n    for element in l:\n        if element > r:\n            r = element\n    return r\n\ndef max_element_recursion(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    >>> max_element([])\n    Traceback (most recent call last):\n   ...\n    ValueError: 不能获取一个空列表的最大元素\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError('不能获取一个空列表的最大元素')\n    return _max_element(l, 0)\n\ndef _max_element(l, i):\n    # 如果已经到了表尾，则返回\n    if i == len(l) - 1:\n        return l[", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    r = l[0]\n    for element in l:\n        if element > r:\n            r = element\n    return r\n\ndef max_element_recursion(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    >>> max_element([])\n    Traceback (most recent call last):\n   ...\n    ValueError: 不能获取一个空列表的最大元素\n    \"\"\"\n    if len(l) == 0:\n        raise ValueError('不能获取一个空列表的最大元素')\n    return _max_element(l, 0)\n\ndef _max_element(l, i):\n    # 如果已经到了表尾，则返回\n    if i == len(l) - 1:\n        return l["}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef first_element(l: list):\n    \"\"\"返回列表第一个元素    >>> first_element([1, 2, 3])\n    1\n    >>> first_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    5\n    \"\"\"\n    return l[0]\n\ndef last_element(l: list):\n    \"\"\"返回列表最后一个元素    >>> last_element([1, 2, 3])\n    3\n    >>> last_element([5, 3, -5, ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef first_element(l: list):\n    \"\"\"返回列表第一个元素    >>> first_element([1, 2, 3])\n    1\n    >>> first_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    5\n    \"\"\"\n    return l[0]\n\ndef last_element(l: list):\n    \"\"\"返回列表最后一个元素    >>> last_element([1, 2, 3])\n    3\n    >>> last_element([5, 3, -5, "}
{"task_id": "HumanEval/35", "completion": "    _m = l[0]\n    for x in l:\n        if x > _m:\n            _m = x\n    return _m\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    _m = l[0]\n    for x in l:\n        if x < _m:\n            _m = x\n    return _m\n\ndef get_value_from_list(l: list, value):\n    \"\"\"判断列表是否包含value\n    >>> get_value_from_list([1, 2, 3], 2)\n    2\n    >>> get_value_from_list([1, 2, 3], 3)\n    3\n    >>> get_value_from_list([1, ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    _m = l[0]\n    for x in l:\n        if x > _m:\n            _m = x\n    return _m\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    _m = l[0]\n    for x in l:\n        if x < _m:\n            _m = x\n    return _m\n\ndef get_value_from_list(l: list, value):\n    \"\"\"判断列表是否包含value\n    >>> get_value_from_list([1, 2, 3], 2)\n    2\n    >>> get_value_from_list([1, 2, 3], 3)\n    3\n    >>> get_value_from_list([1, "}
{"task_id": "HumanEval/35", "completion": "    max = l[0]\n    for i in l:\n        if i > max:\n            max = i\n    return max\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3, 99])\n    1\n    >>> min_element([10, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min = l[0]\n    for i in l:\n        if i < min:\n            min = i\n    return min\n\ndef sum_element(l: list):\n    \"\"\"返回列表中元素的和    >>> sum_element([1, 2, 3, 99])\n    132\n    >>> sum_element([-10, 3, -5, 2, -3, 3, 9, 0, 123, 1])\n    130\n    \"\"\"\n    sum = ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max = l[0]\n    for i in l:\n        if i > max:\n            max = i\n    return max\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3, 99])\n    1\n    >>> min_element([10, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min = l[0]\n    for i in l:\n        if i < min:\n            min = i\n    return min\n\ndef sum_element(l: list):\n    \"\"\"返回列表中元素的和    >>> sum_element([1, 2, 3, 99])\n    132\n    >>> sum_element([-10, 3, -5, 2, -3, 3, 9, 0, 123, 1])\n    130\n    \"\"\"\n    sum = "}
{"task_id": "HumanEval/36", "completion": "    return n // 13 - n // 11 + n // 13 // 11 - n // 11 // 13\n\n\ndef test_fizz_buzz():\n    assert fizz_buzz(50) == 0\n    assert fizz_buzz(78) == 2\n    assert fizz_buzz(79) == 3\n\n\nif __name__ == \"__main__\":\n    test_fizz_buzz()\n```\n\n### 8. 约瑟夫环\n\n\n![](https://tva1.sinaimg.cn/large/0081Kckwly1gk45u9u2a1j31jg0u0wj5.jpg)\n\n```py\nclass JosephRing:\n    \"\"\"约瑟夫环\"\"\"\n\n    def __init__(self, n, m):\n        \"\"\"约瑟夫环问题\n        Args:\n            n: 约瑟夫最", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return n // 13 - n // 11 + n // 13 // 11 - n // 11 // 13\n\n\ndef test_fizz_buzz():\n    assert fizz_buzz(50) == 0\n    assert fizz_buzz(78) == 2\n    assert fizz_buzz(79) == 3\n\n\nif __name__ == \"__main__\":\n    test_fizz_buzz()\n```\n\n### 8. 约瑟夫环\n\n\n![](https://tva1.sinaimg.cn/large/0081Kckwly1gk45u9u2a1j31jg0u0wj5.jpg)\n\n```py\nclass JosephRing:\n    \"\"\"约瑟夫环\"\"\"\n\n    def __init__(self, n, m):\n        \"\"\"约瑟夫环问题\n        Args:\n            n: 约瑟夫最"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += count_7(i)\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += count_7(i)\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest"}
{"task_id": "HumanEval/36", "completion": "    return len(list(filter(lambda x: x % 7 == 0, list(filter(lambda x: x % 13 == 0 and x % 11 == 0, range(n))))))\n\ndef fizz_buzz_solution(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum(7 in str(x) for x in range(n) if x % 13 == 0 and x % 11 == 0)\n\ndef fizz_buzz_list_comprehension(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> f", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return len(list(filter(lambda x: x % 7 == 0, list(filter(lambda x: x % 13 == 0 and x % 11 == 0, range(n))))))\n\ndef fizz_buzz_solution(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum(7 in str(x) for x in range(n) if x % 13 == 0 and x % 11 == 0)\n\ndef fizz_buzz_list_comprehension(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> f"}
{"task_id": "HumanEval/36", "completion": "    # 定义结果变量\n    result = 0\n    # 遍历n 范围内整数\n    for i in range(1, n):\n        # 剩余判断\n        if i % 11 == 0 and i % 13 == 0:\n            # 次数加一\n            result += 1\n    # 返回结果\n    return result\n\n\ndef fizz_buzz_2():\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数  \n    >>> fizz_buzz_2(10)\n    1\n    >>> fizz_buzz_2(11)\n    2\n    >>> fizz_buzz_2(13)\n    3\n    >>> fizz_buzz_2(14)\n    4\n    >>> fizz_buzz_2(30)\n    5\n    >>> fizz_buzz", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 定义结果变量\n    result = 0\n    # 遍历n 范围内整数\n    for i in range(1, n):\n        # 剩余判断\n        if i % 11 == 0 and i % 13 == 0:\n            # 次数加一\n            result += 1\n    # 返回结果\n    return result\n\n\ndef fizz_buzz_2():\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数  \n    >>> fizz_buzz_2(10)\n    1\n    >>> fizz_buzz_2(11)\n    2\n    >>> fizz_buzz_2(13)\n    3\n    >>> fizz_buzz_2(14)\n    4\n    >>> fizz_buzz_2(30)\n    5\n    >>> fizz_buzz"}
{"task_id": "HumanEval/36", "completion": "    if n <= 1:\n        return 0\n    else:\n        cnt = 0\n        if (n % 13 == 0) and (n % 11 == 0):\n            cnt += 1\n        return fizz_buzz(n - 1) + cnt\n\n\n# # 2.5 递归终止条件\n\n# ## 递归终止条件是什么\n# \n# 一般来说，递归的核心在于在一个函数中调用其本身。\n# \n# 在函数内部，需要有一个条件，当满足条件时，不再调用函数本身，而是返回一个结果。\n# \n# 调用完所有的小问题之后，函数得到了所有结果的组合，就可以对这些结果进行处理，并返回。\n# \n\n# ### ", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        cnt = 0\n        if (n % 13 == 0) and (n % 11 == 0):\n            cnt += 1\n        return fizz_buzz(n - 1) + cnt\n\n\n# # 2.5 递归终止条件\n\n# ## 递归终止条件是什么\n# \n# 一般来说，递归的核心在于在一个函数中调用其本身。\n# \n# 在函数内部，需要有一个条件，当满足条件时，不再调用函数本身，而是返回一个结果。\n# \n# 调用完所有的小问题之后，函数得到了所有结果的组合，就可以对这些结果进行处理，并返回。\n# \n\n# ### "}
{"task_id": "HumanEval/36", "completion": "    if n < 1:\n        raise ValueError(\"n should be > 0\")\n    if n <= 1:\n        return 0\n    \n    count = 0\n    while n > 1:\n        if n % 11 == 0 and n % 13 == 0:\n            if n % 7 == 0:\n                count += 1\n        n //= 11\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n## 练习题2.8 封装扩展练习题2.7\n\n**题目：**\n\n- 扩展题2.7 ， 封装一个函数，得到某人的年龄，输入是生日，输出是当前年龄\n- 如果生日超过当前日期，则返回-1\n- (注意：如果当前日期小于190", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n should be > 0\")\n    if n <= 1:\n        return 0\n    \n    count = 0\n    while n > 1:\n        if n % 11 == 0 and n % 13 == 0:\n            if n % 7 == 0:\n                count += 1\n        n //= 11\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n## 练习题2.8 封装扩展练习题2.7\n\n**题目：**\n\n- 扩展题2.7 ， 封装一个函数，得到某人的年龄，输入是生日，输出是当前年龄\n- 如果生日超过当前日期，则返回-1\n- (注意：如果当前日期小于190"}
{"task_id": "HumanEval/36", "completion": "    # your code here\n    return sum(1 for i in range(1, n) if ((str(i)[-1] == '7') if not ((i % 11 == 0) or (i % 13 == 0))))\n\n\ndef factorial(number):\n    \"\"\"计算数字的阶乘，即输入n是整数时，返回n的阶乘\n    >>> factorial(4)\n    24\n    >>> factorial(5)\n    120\n    >>> factorial(7)\n    5040\n    \"\"\"\n    # your code here\n    if number < 0:\n        return -1\n    return 1 if number == 0 else number * factorial(number - 1)\n\n\ndef sum_even_squares(n):\n    \"\"\"计算1 到n 之间的偶数的平方之和。如果n<=0 返回-1，而不是0\n    >>> sum_even_squares(4)\n    30\n    >>> sum", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # your code here\n    return sum(1 for i in range(1, n) if ((str(i)[-1] == '7') if not ((i % 11 == 0) or (i % 13 == 0))))\n\n\ndef factorial(number):\n    \"\"\"计算数字的阶乘，即输入n是整数时，返回n的阶乘\n    >>> factorial(4)\n    24\n    >>> factorial(5)\n    120\n    >>> factorial(7)\n    5040\n    \"\"\"\n    # your code here\n    if number < 0:\n        return -1\n    return 1 if number == 0 else number * factorial(number - 1)\n\n\ndef sum_even_squares(n):\n    \"\"\"计算1 到n 之间的偶数的平方之和。如果n<=0 返回-1，而不是0\n    >>> sum_even_squares(4)\n    30\n    >>> sum"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            if i % 7 == 0:\n                count += 1\n   ", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            if i % 7 == 0:\n                count += 1\n   "}
{"task_id": "HumanEval/36", "completion": "    n = int(input())\n    # return 0\n    if n < 1 or n > 100:\n        return None\n    a = [3,5,7,11,13]\n    res = 0\n    for i in range(1, n):\n        if sum(map(lambda x: i % x == 0, a)) == 3:\n            res += 1\n    \n    return res\n\n\n\ndef sumDigits(n: int):\n    \"\"\" \n    \"\"\"\n    return 0\n    \ndef getIndexToIns(a: List[int], x: int) -> int:\n    \"\"\"Given a sorted array, two integers k and x, find the \n    index where to insert the number x in order to maintain \n    the order of the array, or return the index where x should \n    be inserted if x is already in the array.\n\n    >>> a = [1, 3, 5, 6]\n    >>> getIndexToIns(a, 2)\n    1\n    >>> a = [3, 4, ", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    n = int(input())\n    # return 0\n    if n < 1 or n > 100:\n        return None\n    a = [3,5,7,11,13]\n    res = 0\n    for i in range(1, n):\n        if sum(map(lambda x: i % x == 0, a)) == 3:\n            res += 1\n    \n    return res\n\n\n\ndef sumDigits(n: int):\n    \"\"\" \n    \"\"\"\n    return 0\n    \ndef getIndexToIns(a: List[int], x: int) -> int:\n    \"\"\"Given a sorted array, two integers k and x, find the \n    index where to insert the number x in order to maintain \n    the order of the array, or return the index where x should \n    be inserted if x is already in the array.\n\n    >>> a = [1, 3, 5, 6]\n    >>> getIndexToIns(a, 2)\n    1\n    >>> a = [3, 4, "}
{"task_id": "HumanEval/36", "completion": "    def fb(n):\n        if n == 6:\n            return 1\n        elif n%6 == 0:\n            return fb(n//6)\n        return 0\n    return fb(n)\n\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fb(n):\n        if n == 6:\n            return 1\n        else:\n            a = 0\n            if n%6 == 0:\n                a = fb(n//6)\n            if n%13 == 0:\n                return a+fb(n//13)\n            return a\n    return fb(n)\n\n\ndef fizz_buzz(n: int", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fb(n):\n        if n == 6:\n            return 1\n        elif n%6 == 0:\n            return fb(n//6)\n        return 0\n    return fb(n)\n\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fb(n):\n        if n == 6:\n            return 1\n        else:\n            a = 0\n            if n%6 == 0:\n                a = fb(n//6)\n            if n%13 == 0:\n                return a+fb(n//13)\n            return a\n    return fb(n)\n\n\ndef fizz_buzz(n: int"}
{"task_id": "HumanEval/43", "completion": "    l = sorted(l)  # 对整数列表排序，从小到大\n    i = 0  # 指向列表的第一个元素\n    j = len(l)-1  # 指向列表的最后一个元素\n    while i < j:\n        if l[i] + l[j] == 0: # 如果l[i] + l[j] == 0 则返回True\n            return True\n        elif l[i] + l[j] < 0:\n            i = i + 1  # 如果l[i] + l[j] < 0 则指向列表的第一个元素\n        else:\n            j = j - 1  # 如果l[i] + l[j] > 0 则指向列表的最后一个元素\n    return False  # 如果没有找到返回False\n\nprint(pairs_sum_to_zero([1, 3, -2, 1]))\nprint(", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l = sorted(l)  # 对整数列表排序，从小到大\n    i = 0  # 指向列表的第一个元素\n    j = len(l)-1  # 指向列表的最后一个元素\n    while i < j:\n        if l[i] + l[j] == 0: # 如果l[i] + l[j] == 0 则返回True\n            return True\n        elif l[i] + l[j] < 0:\n            i = i + 1  # 如果l[i] + l[j] < 0 则指向列表的第一个元素\n        else:\n            j = j - 1  # 如果l[i] + l[j] > 0 则指向列表的最后一个元素\n    return False  # 如果没有找到返回False\n\nprint(pairs_sum_to_zero([1, 3, -2, 1]))\nprint("}
{"task_id": "HumanEval/43", "completion": "    dic = {}\n    for i in l:\n        if i in dic:\n            return True\n        else:\n            dic[i] = 1\n    return False\n\ndef pairs_sum_to_k(l, k):\n    \"\"\"\n    pairs_sum_to_k 将整数列表作为输入，如果列表中有两个不同的元素加起来的和为参数k，\n    则返回True，否则返回False    \n    >>> pairs_sum_to_k([1, 3, 5, 0], 0)\n    False\n    >>> pairs_sum_to_k([1, 3, -2, 1], 0)\n    True\n    >>> pairs_sum_to_k([1, 2, 3, 7], 7)\n    True\n    >>> pairs_sum_to_k([2, 4, -5, 3, 5, 7], 7)\n    False\n    >>> pairs_sum_to_k([1], 0)\n    False\n    \"\"\"\n", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    dic = {}\n    for i in l:\n        if i in dic:\n            return True\n        else:\n            dic[i] = 1\n    return False\n\ndef pairs_sum_to_k(l, k):\n    \"\"\"\n    pairs_sum_to_k 将整数列表作为输入，如果列表中有两个不同的元素加起来的和为参数k，\n    则返回True，否则返回False    \n    >>> pairs_sum_to_k([1, 3, 5, 0], 0)\n    False\n    >>> pairs_sum_to_k([1, 3, -2, 1], 0)\n    True\n    >>> pairs_sum_to_k([1, 2, 3, 7], 7)\n    True\n    >>> pairs_sum_to_k([2, 4, -5, 3, 5, 7], 7)\n    False\n    >>> pairs_sum_to_k([1], 0)\n    False\n    \"\"\"\n"}
{"task_id": "HumanEval/43", "completion": "    res = False\n    if not l:\n        return res\n    for i in range(len(l) - 1):\n        if pairs_sum_to_zero(l[i+1:], l[i]):\n            return True\n    return res\n\ndef pairs_sum_to_zero(l, start):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    res = False\n    if not l:\n        return res\n    for i in range(len(l) - 1):\n        if pairs_sum_to_zero(l[i+1:], l[i]):\n            return True\n    return res\n\ndef pairs_sum_to_zero(l, start):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n"}
{"task_id": "HumanEval/43", "completion": "    result = {}\n    for x in l:\n        if x not in result:\n            result[x] = 0\n        else:\n            result[x] += 1\n    if 0 in result and result[0] > 1:\n        return True\n    return False\n\npairs_sum_to_zero([1, 3, 5, 0])\n\ndef test_pairs_sum_to_zero():\n    assert pairs_sum_to_zero([1, 3, 5, 0]) == False\n    assert pairs_sum_to_zero([1, 3, -2, 1]) == False\n    assert pairs_sum_to_zero([1, 2, 3, 7]) == False\n    assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True\n    assert pairs_sum_to_zero([1]) == False\n    print('all cases passed!')\n    \nif __name__ == '__main__':\n    test_pairs_sum_to_zero() \n    ", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    result = {}\n    for x in l:\n        if x not in result:\n            result[x] = 0\n        else:\n            result[x] += 1\n    if 0 in result and result[0] > 1:\n        return True\n    return False\n\npairs_sum_to_zero([1, 3, 5, 0])\n\ndef test_pairs_sum_to_zero():\n    assert pairs_sum_to_zero([1, 3, 5, 0]) == False\n    assert pairs_sum_to_zero([1, 3, -2, 1]) == False\n    assert pairs_sum_to_zero([1, 2, 3, 7]) == False\n    assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True\n    assert pairs_sum_to_zero([1]) == False\n    print('all cases passed!')\n    \nif __name__ == '__main__':\n    test_pairs_sum_to_zero() \n    "}
{"task_id": "HumanEval/43", "completion": "    length = len(l)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if l[i] + l[j] == 0:\n                return True\n\n    return False\n\n\ndef all_pairs_sum_to_zero(l):\n    \"\"\"\n    all_pairs_sum_to_zero 判断给定的整数列表是否中的每一个元素都有一对元素使得和为零\n    >>> all_pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> all_pairs_sum_to_zero([1, 3, 5, -1])\n    True\n    \"\"\"\n    if len(l) <= 1:\n        return False\n\n    half = len(l) // 2\n    left = l[:half]\n   ", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    length = len(l)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if l[i] + l[j] == 0:\n                return True\n\n    return False\n\n\ndef all_pairs_sum_to_zero(l):\n    \"\"\"\n    all_pairs_sum_to_zero 判断给定的整数列表是否中的每一个元素都有一对元素使得和为零\n    >>> all_pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> all_pairs_sum_to_zero([1, 3, 5, -1])\n    True\n    \"\"\"\n    if len(l) <= 1:\n        return False\n\n    half = len(l) // 2\n    left = l[:half]\n   "}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(0,len(l)-1):\n        if l[i]+l[i+1] == 0:\n            return True\n    return False\n\n\n\n\ndef is_balanced(l):\n    \"\"\"\n    is_balanced 函数判断输入的列表是否是平衡的。\n    \"\"\"\n    if len(l)%2!= 0:\n        return False\n    a = []\n    for i in l:\n        a.append([i,1])\n    b = merge_sort(a)\n    for i in b:\n        if i[1] == 0 and b[0][1] == 0:\n            return False\n    return True\n\n\ndef merge_sort(l):\n    \"\"\"\n    merge_sort 函数将一个列表分成两部分同时排序两部分，最后将两个部分合并\n    为一个有序列表。\n    >>> merge_sort([])\n    []\n    >>> merge_sort([1])\n   ", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(0,len(l)-1):\n        if l[i]+l[i+1] == 0:\n            return True\n    return False\n\n\n\n\ndef is_balanced(l):\n    \"\"\"\n    is_balanced 函数判断输入的列表是否是平衡的。\n    \"\"\"\n    if len(l)%2!= 0:\n        return False\n    a = []\n    for i in l:\n        a.append([i,1])\n    b = merge_sort(a)\n    for i in b:\n        if i[1] == 0 and b[0][1] == 0:\n            return False\n    return True\n\n\ndef merge_sort(l):\n    \"\"\"\n    merge_sort 函数将一个列表分成两部分同时排序两部分，最后将两个部分合并\n    为一个有序列表。\n    >>> merge_sort([])\n    []\n    >>> merge_sort([1])\n   "}
{"task_id": "HumanEval/43", "completion": "    pass\n \n# 5 \n\ndef pair_indexes(l, item):\n    \"\"\"\n    pair_indexes 将整数列表作为输入，以及一个整数作为输出，如果列表中有两个不同的索引，\n    通过这两个索引的元素相加等于输入的整数，则返回True，否则返回False\n    如果列表中的某个元素同时在列表的头和尾，则不能认为是两个不同的索引\n    如果列表长度小于2，则返回False\n    >>> pair_indexes([1, 2, 5, 7], 6)\n    False\n    >>> pair_indexes([1, 2, 3, 8, 3], 8)\n    True\n    >>> pair_indexes([1, 2, 3, 8, 3], 7)\n    False\n    >>> pair_indexes([1, 2, 3, 8", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    pass\n \n# 5 \n\ndef pair_indexes(l, item):\n    \"\"\"\n    pair_indexes 将整数列表作为输入，以及一个整数作为输出，如果列表中有两个不同的索引，\n    通过这两个索引的元素相加等于输入的整数，则返回True，否则返回False\n    如果列表中的某个元素同时在列表的头和尾，则不能认为是两个不同的索引\n    如果列表长度小于2，则返回False\n    >>> pair_indexes([1, 2, 5, 7], 6)\n    False\n    >>> pair_indexes([1, 2, 3, 8, 3], 8)\n    True\n    >>> pair_indexes([1, 2, 3, 8, 3], 7)\n    False\n    >>> pair_indexes([1, 2, 3, 8"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(0, len(l)-1):\n        if l[i] + l[i+1] == 0:\n            return True\n    return False\n\n\ndef all_zero_one(l):\n    \"\"\"\n    如果列表只包含 0 和 1，返回True\n    >>>  all_zero_one([0, 1, 1, 1, 0, 0, 1, 1, 0])\n    True\n    >>>  all_zero_one([1, 1, 1, 1, 1, 1, 1, 1, 1])\n    True\n    >>>  all_zero_one([0, 0, 0, 0, 0, 0, 0, 0, 0])\n    True\n    >>>  all_zero_one([1, 1, 1, 0, 0, 0, 1, 1, 0])\n    False\n    >>>  all_zero_one([0, 1, 0,", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(0, len(l)-1):\n        if l[i] + l[i+1] == 0:\n            return True\n    return False\n\n\ndef all_zero_one(l):\n    \"\"\"\n    如果列表只包含 0 和 1，返回True\n    >>>  all_zero_one([0, 1, 1, 1, 0, 0, 1, 1, 0])\n    True\n    >>>  all_zero_one([1, 1, 1, 1, 1, 1, 1, 1, 1])\n    True\n    >>>  all_zero_one([0, 0, 0, 0, 0, 0, 0, 0, 0])\n    True\n    >>>  all_zero_one([1, 1, 1, 0, 0, 0, 1, 1, 0])\n    False\n    >>>  all_zero_one([0, 1, 0,"}
{"task_id": "HumanEval/43", "completion": "    if not l:\n        return False\n    for i in range(len(l)):\n        for j in range(len(l)):\n            if i!= j and l[i] + l[j] == 0:\n                return True\n    return False\n    # pass\n\ndef pairs_sum_to_zero_two(l):\n    \"\"\"\n    pairs_sum_to_zero_two 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if not l:\n        return False\n    for i in range(len(l)):\n        for j in range(len(l)):\n            if i!= j and l[i] + l[j] == 0:\n                return True\n    return False\n    # pass\n\ndef pairs_sum_to_zero_two(l):\n    \"\"\"\n    pairs_sum_to_zero_two 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1"}
{"task_id": "HumanEval/43", "completion": "    # 写方程ax+b=0, 方程解是x=−b/a\n    # 0=0x+b 方程的解是 x=1,b=0 即b=0\n    if not l or len(l) < 2:\n        return False\n    s = set()\n    for x in l:\n        s.add(x)\n        if len(s) < 2:\n            s.add(-x)\n            if len(s) == 2:\n                return True\n    return False\n\ndef pairs_sum_to_k(l, k):\n    \"\"\"\n    pairs_sum_to_k 将整数列表和一个数作为输入，如果列表中有两个不同的数相加和等于k，\n    则返回True，否则返回False\n    \n    >>> pairs_sum_to_k([1, 3, 5, 0], 9)\n    False\n    >>> pairs_sum_to_k([1, 3, -2, 1", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    # 写方程ax+b=0, 方程解是x=−b/a\n    # 0=0x+b 方程的解是 x=1,b=0 即b=0\n    if not l or len(l) < 2:\n        return False\n    s = set()\n    for x in l:\n        s.add(x)\n        if len(s) < 2:\n            s.add(-x)\n            if len(s) == 2:\n                return True\n    return False\n\ndef pairs_sum_to_k(l, k):\n    \"\"\"\n    pairs_sum_to_k 将整数列表和一个数作为输入，如果列表中有两个不同的数相加和等于k，\n    则返回True，否则返回False\n    \n    >>> pairs_sum_to_k([1, 3, 5, 0], 9)\n    False\n    >>> pairs_sum_to_k([1, 3, -2, 1"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([2, 4, 8, 10], 0)\n    True\n    >>> above_threshold([2, 4, 8, 10], 100)\n    False\n    \"\"\"\n    for i in l:\n        if i < t:\n            return False\n    return True\n\ndef threshold(l: list, t: int):\n    \"\"\"如果列表 l 中有数字低于阈阈值t，有数字高于阈阈值t，则返回 False\n    如果列表 l 中只有数字都低于阈阈值t，则返回 True\n    如果列表 l 中只有数字都高于阈阈", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([2, 4, 8, 10], 0)\n    True\n    >>> above_threshold([2, 4, 8, 10], 100)\n    False\n    \"\"\"\n    for i in l:\n        if i < t:\n            return False\n    return True\n\ndef threshold(l: list, t: int):\n    \"\"\"如果列表 l 中有数字低于阈阈值t，有数字高于阈阈值t，则返回 False\n    如果列表 l 中只有数字都低于阈阈值t，则返回 True\n    如果列表 l 中只有数字都高于阈阈"}
{"task_id": "HumanEval/52", "completion": "    for num in l:\n        if num > t:\n            return False\n    return True\n\n\ndef get_lowest(l: list):\n    \"\"\"获取列表 l 中最低的数字 >>> get_lowest([5, 3, 2, 1, 6])\n    1\n    >>> get_lowest([10, 34, 2, 1, 6])\n    2\n    \"\"\"\n    mini = l[0]\n    for num in l:\n        if mini > num:\n            mini = num\n    return mini\n\n\ndef get_highest(l: list):\n    \"\"\"获取列表 l 中最大的数字 >>> get_highest([5, 3, 2, 1, 6])\n    6\n    >>> get_highest([10, 34, 2, 1, 6])\n    34\n    \"\"\"\n    maxi = l[0]\n    for num in l:\n        if maxi < num:\n            maxi = num\n    return maxi\n\n\ndef", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for num in l:\n        if num > t:\n            return False\n    return True\n\n\ndef get_lowest(l: list):\n    \"\"\"获取列表 l 中最低的数字 >>> get_lowest([5, 3, 2, 1, 6])\n    1\n    >>> get_lowest([10, 34, 2, 1, 6])\n    2\n    \"\"\"\n    mini = l[0]\n    for num in l:\n        if mini > num:\n            mini = num\n    return mini\n\n\ndef get_highest(l: list):\n    \"\"\"获取列表 l 中最大的数字 >>> get_highest([5, 3, 2, 1, 6])\n    6\n    >>> get_highest([10, 34, 2, 1, 6])\n    34\n    \"\"\"\n    maxi = l[0]\n    for num in l:\n        if maxi < num:\n            maxi = num\n    return maxi\n\n\ndef"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n    return True\n\n\ndef count_threshold(l: list, t: int):\n    \"\"\"返回列表 l 中小于阈阈值t的数字的数量。  >>> count_threshold([1, 2, 4, 10], 100) \n    4\n    >>> count_threshold([1, 20, 4, 10], 5)\n    2\n    \"\"\"\n    num = 0\n    for i in l:\n        if i < t:\n            num += 1\n    return num\n\n\ndef print_counts(l: list, t: int, n: int):\n    \"\"\"输出列表 l 中小于阈阈值t的数字的数量和\n    大于等于阈阈值t的数字的数量。  >>> print_counts([1, 2, 4, 10], 100, 0)\n    1\n    3\n", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n    return True\n\n\ndef count_threshold(l: list, t: int):\n    \"\"\"返回列表 l 中小于阈阈值t的数字的数量。  >>> count_threshold([1, 2, 4, 10], 100) \n    4\n    >>> count_threshold([1, 20, 4, 10], 5)\n    2\n    \"\"\"\n    num = 0\n    for i in l:\n        if i < t:\n            num += 1\n    return num\n\n\ndef print_counts(l: list, t: int, n: int):\n    \"\"\"输出列表 l 中小于阈阈值t的数字的数量和\n    大于等于阈阈值t的数字的数量。  >>> print_counts([1, 2, 4, 10], 100, 0)\n    1\n    3\n"}
{"task_id": "HumanEval/52", "completion": "    return l and all(x < t for x in l)\n\n# ### 递归使用偏函数\n\n# def sumf(x: int, y: int):\n#     return x + y\n\n# f1: Callable[[int], int] = partial(sumf, y=10)\n\n# >>> f1(10)\n# 20\n\n# >>> f2: Callable[[int], int] = partial(sumf, y=10)\n\n# >>> f2(10)\n# 20\n\n\ndef count_words(string: str, ending_with: str = None) -> int:\n    \"\"\"\n    返回给定字符串中以结尾的单词数量  >>> count_words('hello world', 'l')\n    1\n    >>> count_words('hello world', 'o')\n    2\n    >>> count_words('hello world', 'hello')\n    0\n    >>> count_words('')\n    0\n    >>> count_words('hello world')\n    2\n    \"\"\"\n    if", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return l and all(x < t for x in l)\n\n# ### 递归使用偏函数\n\n# def sumf(x: int, y: int):\n#     return x + y\n\n# f1: Callable[[int], int] = partial(sumf, y=10)\n\n# >>> f1(10)\n# 20\n\n# >>> f2: Callable[[int], int] = partial(sumf, y=10)\n\n# >>> f2(10)\n# 20\n\n\ndef count_words(string: str, ending_with: str = None) -> int:\n    \"\"\"\n    返回给定字符串中以结尾的单词数量  >>> count_words('hello world', 'l')\n    1\n    >>> count_words('hello world', 'o')\n    2\n    >>> count_words('hello world', 'hello')\n    0\n    >>> count_words('')\n    0\n    >>> count_words('hello world')\n    2\n    \"\"\"\n    if"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n        else:\n            return True\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈值t，则返回 True  >>> above_threshold([1, 2, 4, 10], 1)\n    False\n    >>> above_threshold([20, 40, 100], 20)\n    True\n    \"\"\"\n    for i in l:\n        if i < t:\n            return False\n        else:\n            return True\n\n\ndef main():\n    \"\"\"测试函数，运行程序需从命令行中输入数据\"\"\"\n    print(list_max([1231, 893, 14, 16, 926, 1757, 872, 14, 73]))\n    print(list_min(['a', 'b', 'c', 'd']))\n    print(list_aver", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n        else:\n            return True\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈值t，则返回 True  >>> above_threshold([1, 2, 4, 10], 1)\n    False\n    >>> above_threshold([20, 40, 100], 20)\n    True\n    \"\"\"\n    for i in l:\n        if i < t:\n            return False\n        else:\n            return True\n\n\ndef main():\n    \"\"\"测试函数，运行程序需从命令行中输入数据\"\"\"\n    print(list_max([1231, 893, 14, 16, 926, 1757, 872, 14, 73]))\n    print(list_min(['a', 'b', 'c', 'd']))\n    print(list_aver"}
{"task_id": "HumanEval/52", "completion": "    for _item in l:\n        if _item > t:\n            return False\n    return True\n```\n\n### 1.2\n\n```python\n# -*- coding:utf-8 -*-\n\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([_item < t for _item in l])\n\n```\n\n### 1.3\n\n```python\n# -*- coding:utf-8 -*-\n\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for _item in l:\n        if _item > t:\n            return False\n    return True\n```\n\n### 1.2\n\n```python\n# -*- coding:utf-8 -*-\n\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([_item < t for _item in l])\n\n```\n\n### 1.3\n\n```python\n# -*- coding:utf-8 -*-\n\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold"}
{"task_id": "HumanEval/52", "completion": "    if len(l)==0 or max(l)<t:\n        return True\n    else:\n        return False\n    \n\ndef sum_pos_and_neg(l: list):\n    \"\"\"找到列表 l 中所有偶数（包括 0）和所有负整数。\n\n    :param l: 一个列表\n    :return: 返回一个浮点数，代表偶数和负整数之和\n\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6])\n    9.0\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6, 8, 10])\n    20.0\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6, 8, 10, 12, 14, 16])\n    41.0\n    \"\"\"\n    return sum(i for i", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    if len(l)==0 or max(l)<t:\n        return True\n    else:\n        return False\n    \n\ndef sum_pos_and_neg(l: list):\n    \"\"\"找到列表 l 中所有偶数（包括 0）和所有负整数。\n\n    :param l: 一个列表\n    :return: 返回一个浮点数，代表偶数和负整数之和\n\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6])\n    9.0\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6, 8, 10])\n    20.0\n    >>> sum_pos_and_neg([1, 2, -4, 5, 6, 8, 10, 12, 14, 16])\n    41.0\n    \"\"\"\n    return sum(i for i"}
{"task_id": "HumanEval/52", "completion": "    for number in l:\n        if number >= t:\n            return False\n        else:\n            return True\n\n# %% 用函数的 return 语句获取函数计算结果的特性\n\"\"\"案例: 返回平方根\"\"\"\n\ndef sqrt(x):\n    \"\"\"返回 x 的平方根\"\"\"\n    if x > 0:\n        guess = 1.0\n        while abs(guess * guess - x) >= 0.0001:\n            guess = (guess + x/guess) / 2\n        return guess\n\nprint(sqrt(4))\n\n# %% 在一个函数中调用另一个函数\n\ndef fib(n):\n    if n > 1:\n        return fib(n-1) + fib(n-2)\n    else:\n        return 1\n\n\ndef fac(n):\n    if n > 1:\n        return n * fac(n-1)\n    else:\n        return 1\n\n\ndef hanoi", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for number in l:\n        if number >= t:\n            return False\n        else:\n            return True\n\n# %% 用函数的 return 语句获取函数计算结果的特性\n\"\"\"案例: 返回平方根\"\"\"\n\ndef sqrt(x):\n    \"\"\"返回 x 的平方根\"\"\"\n    if x > 0:\n        guess = 1.0\n        while abs(guess * guess - x) >= 0.0001:\n            guess = (guess + x/guess) / 2\n        return guess\n\nprint(sqrt(4))\n\n# %% 在一个函数中调用另一个函数\n\ndef fib(n):\n    if n > 1:\n        return fib(n-1) + fib(n-2)\n    else:\n        return 1\n\n\ndef fac(n):\n    if n > 1:\n        return n * fac(n-1)\n    else:\n        return 1\n\n\ndef hanoi"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef average(l: list):\n    \"\"\"计算列表 l 中数字的平均数，留下两位小数  >>> average([1, 2, 3, 4, 5])\n    3.0\n    \"\"\"\n    # 总元素和\n    sum_ele = sum(l)\n    # 返回总元素和除以元素个数\n    return round(sum_ele / len(l), 2)\n\ndef smallest(l: list):\n    \"\"\"找出列表中最小的数字  >>> smallest([1, 2, 3, 4, 5])\n    1\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    # 定义一个空的列表\n    small_list = []  \n    for i in l:\n        small_list.append(i)\n    # 把列表当成索引，取出", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef average(l: list):\n    \"\"\"计算列表 l 中数字的平均数，留下两位小数  >>> average([1, 2, 3, 4, 5])\n    3.0\n    \"\"\"\n    # 总元素和\n    sum_ele = sum(l)\n    # 返回总元素和除以元素个数\n    return round(sum_ele / len(l), 2)\n\ndef smallest(l: list):\n    \"\"\"找出列表中最小的数字  >>> smallest([1, 2, 3, 4, 5])\n    1\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    # 定义一个空的列表\n    small_list = []  \n    for i in l:\n        small_list.append(i)\n    # 把列表当成索引，取出"}
{"task_id": "HumanEval/52", "completion": "    return not any(a > t for a in l)\n\n# above_threshold\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([10, 20, 40, 100], 100)\n    True\n    >>> above_threshold([10, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return not any(a < t for a in l)\n\n# min_value\n\ndef min_value(l: list):\n    \"\"\"如果列表 l 中的所有数字都相同，则返回最小值，否则返回 None   >>> min_value([1, 2, 4, 10])\n    1\n    >>> min_value([1, 1, 1, 1])\n    \"\"\"\n    return min(set(l)) if len(l)!= len(set(l)) else None", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return not any(a > t for a in l)\n\n# above_threshold\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([10, 20, 40, 100], 100)\n    True\n    >>> above_threshold([10, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return not any(a < t for a in l)\n\n# min_value\n\ndef min_value(l: list):\n    \"\"\"如果列表 l 中的所有数字都相同，则返回最小值，否则返回 None   >>> min_value([1, 2, 4, 10])\n    1\n    >>> min_value([1, 1, 1, 1])\n    \"\"\"\n    return min(set(l)) if len(l)!= len(set(l)) else None"}
{"task_id": "HumanEval/54", "completion": "    # 思路：\n    # 使用set 去重，然后len == 0 就是 False\n    return len(set(s0) & set(s1)) == 0\n\n\nif __name__ == '__main__':\n    print(same_chars('eabcd', 'dddddddabc'))\n    print(same_chars('abcd', 'dddddddabce'))\n    print(same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc'))\n\n\n# 11. 给出一个单词列表，请找出其中的所有重复元素。   \n# 例如，当输入如下时：   \n# ['abcd', 'xyz', 'abcd', 'xyz', 'abcdefghijk', 'xyz', 'lmn', 'xyz']   \n# 输出如下：   \n# ['abcd', 'xyz']   \n# \n\ndef find_duplicates(word_list: list):\n    \"\"\"\n    找到字符列", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # 思路：\n    # 使用set 去重，然后len == 0 就是 False\n    return len(set(s0) & set(s1)) == 0\n\n\nif __name__ == '__main__':\n    print(same_chars('eabcd', 'dddddddabc'))\n    print(same_chars('abcd', 'dddddddabce'))\n    print(same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc'))\n\n\n# 11. 给出一个单词列表，请找出其中的所有重复元素。   \n# 例如，当输入如下时：   \n# ['abcd', 'xyz', 'abcd', 'xyz', 'abcdefghijk', 'xyz', 'lmn', 'xyz']   \n# 输出如下：   \n# ['abcd', 'xyz']   \n# \n\ndef find_duplicates(word_list: list):\n    \"\"\"\n    找到字符列"}
{"task_id": "HumanEval/54", "completion": "    # assert isinstance(s0, str)\n    # assert isinstance(s1, str)\n    s0 = s0.lower()\n    s1 = s1.lower()\n    i, j = 0, 0\n    n0 = len(s0)\n    n1 = len(s1)\n    while i < n0 and j < n1:\n        if s0[i] > s1[j]:\n            return False\n        elif s0[i] == s1[j]:\n            i += 1\n            j += 1\n        j += 1\n    return i == n0\n    # return s0 == s1\n\n\n# 把普通函数定义成类方法,就可以使用self.来访问自己的属性和方法,\n# 类方法定义在类中时,不需要self(或cls)参数,可以通过类名直接访问,并且不需要实例化,但是不能通过实例名", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # assert isinstance(s0, str)\n    # assert isinstance(s1, str)\n    s0 = s0.lower()\n    s1 = s1.lower()\n    i, j = 0, 0\n    n0 = len(s0)\n    n1 = len(s1)\n    while i < n0 and j < n1:\n        if s0[i] > s1[j]:\n            return False\n        elif s0[i] == s1[j]:\n            i += 1\n            j += 1\n        j += 1\n    return i == n0\n    # return s0 == s1\n\n\n# 把普通函数定义成类方法,就可以使用self.来访问自己的属性和方法,\n# 类方法定义在类中时,不需要self(或cls)参数,可以通过类名直接访问,并且不需要实例化,但是不能通过实例名"}
{"task_id": "HumanEval/54", "completion": "    if not (len(s0) == len(s1)):\n        return False\n    flag = 0\n    for i in", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if not (len(s0) == len(s1)):\n        return False\n    flag = 0\n    for i in"}
{"task_id": "HumanEval/54", "completion": "    if len(s0) == len(s1):\n        count = 0\n        i, j = 0, 0\n        while i < len(s0) and j < len(s1):\n            if s0[i] == s1[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                i += 1\n        if i == j:\n            return True\n    return False\n\n\ndef add_digits(n: int):\n    if n == 0:\n        return 0\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n\n\ndef get_max_min_from_num(n: int):\n    \"\"\"\n    获取数字中的最大最小值    >>> get_max_min_from_num(98123)\n    (98123, 123)\n    >>> get_max_min_from_num(124)\n    (124,", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0) == len(s1):\n        count = 0\n        i, j = 0, 0\n        while i < len(s0) and j < len(s1):\n            if s0[i] == s1[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                i += 1\n        if i == j:\n            return True\n    return False\n\n\ndef add_digits(n: int):\n    if n == 0:\n        return 0\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n\n\ndef get_max_min_from_num(n: int):\n    \"\"\"\n    获取数字中的最大最小值    >>> get_max_min_from_num(98123)\n    (98123, 123)\n    >>> get_max_min_from_num(124)\n    (124,"}
{"task_id": "HumanEval/54", "completion": "    return len(set(s0)) == len(set(s1))\n\n\ndef same_chars_v1(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_v1('abcd', 'dddddddabc')\n    True\n    >>> same_chars_v1('dddddddabc', 'abcd')\n    True\n    >>> same_chars_v1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_v1('abcd', 'dddddddabce')\n    False\n    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    False\n    \"\"\"\n    return len(set(s0) & set(s1))\n\n\ndef same_chars_v2(s", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return len(set(s0)) == len(set(s1))\n\n\ndef same_chars_v1(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_v1('abcd', 'dddddddabc')\n    True\n    >>> same_chars_v1('dddddddabc', 'abcd')\n    True\n    >>> same_chars_v1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_v1('abcd', 'dddddddabce')\n    False\n    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    False\n    \"\"\"\n    return len(set(s0) & set(s1))\n\n\ndef same_chars_v2(s"}
{"task_id": "HumanEval/54", "completion": "    # return s0 == s1 or s0 == s1[::-1]\n    return set(s0) == set(s1) or set(s0) == set(s1[::-1])\n\n\ndef char_frequency(text: str):\n    \"\"\"\n    计算字符出现频率 \n    >>> char_frequency('aaa')\n    {'a': 3}\n    >>> char_frequency('aabbcc')\n    {'a': 2, 'b': 1, 'c': 1}\n    >>> char_frequency('aabbbcc')\n    {'a': 2, 'b': 2, 'c': 1}\n    >>> char_frequency('abbcddd')\n    {'a': 1, 'b': 2, 'c': 1, 'd': 3}\n    >>> char_frequency('')\n    {}\n    >>> char_frequency(' ab ')\n    {' ': 1}\n    \"\"\"\n    counts = {}\n    for char in text:\n        counts[char] = counts", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # return s0 == s1 or s0 == s1[::-1]\n    return set(s0) == set(s1) or set(s0) == set(s1[::-1])\n\n\ndef char_frequency(text: str):\n    \"\"\"\n    计算字符出现频率 \n    >>> char_frequency('aaa')\n    {'a': 3}\n    >>> char_frequency('aabbcc')\n    {'a': 2, 'b': 1, 'c': 1}\n    >>> char_frequency('aabbbcc')\n    {'a': 2, 'b': 2, 'c': 1}\n    >>> char_frequency('abbcddd')\n    {'a': 1, 'b': 2, 'c': 1, 'd': 3}\n    >>> char_frequency('')\n    {}\n    >>> char_frequency(' ab ')\n    {' ': 1}\n    \"\"\"\n    counts = {}\n    for char in text:\n        counts[char] = counts"}
{"task_id": "HumanEval/54", "completion": "    if len(s0)!= len(s1):\n        return False\n    # 先把每个字符划分为一个set, 最后对比每个set的内容\n    s0_set = set(s0)\n    s1_set =", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    # 先把每个字符划分为一个set, 最后对比每个set的内容\n    s0_set = set(s0)\n    s1_set ="}
{"task_id": "HumanEval/54", "completion": "    return len([c for c in s0 if c in s1]) == len(s0)\n\n\ndef contains_duplicate(s: str):\n    \"\"\"\n    判断字符串是否包含重复字符    >>> contains_duplicate('abcd')\n    False\n    >>> contains_duplicate('aaccde')\n    False\n    >>> contains_duplicate('aaa')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n   ", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return len([c for c in s0 if c in s1]) == len(s0)\n\n\ndef contains_duplicate(s: str):\n    \"\"\"\n    判断字符串是否包含重复字符    >>> contains_duplicate('abcd')\n    False\n    >>> contains_duplicate('aaccde')\n    False\n    >>> contains_duplicate('aaa')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n    True\n    >>> contains_duplicate('abcdefghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\n   "}
{"task_id": "HumanEval/54", "completion": "    # 这里可以考虑把字符串转化成list比较方便\n    \n    s0 = sorted(s0)\n    s1 = sorted(s1)\n    for", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # 这里可以考虑把字符串转化成list比较方便\n    \n    s0 = sorted(s0)\n    s1 = sorted(s1)\n    for"}
{"task_id": "HumanEval/54", "completion": "    return set(s0) & set(s1) == set(s0)\n\ndef is_anagram(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否是同音字    >>> is_anagram('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> is_anagram('abcd', 'dddddddabc')\n    True\n    >>> is_anagram('abcd', 'dddddddabce')\n    False\n    >>> is_anagram('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n\n\ndef is_isogram(s: str):\n    \"\"\"\n    检查一个单词是否是同音字    >>> is_isogram('eleet')\n    True\n    >>> is_isogram('beetle')\n    False\n    \"\"\"\n    # 利用哈希表的特点, 哈", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) & set(s1) == set(s0)\n\ndef is_anagram(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否是同音字    >>> is_anagram('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> is_anagram('abcd', 'dddddddabc')\n    True\n    >>> is_anagram('abcd', 'dddddddabce')\n    False\n    >>> is_anagram('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n\n\ndef is_isogram(s: str):\n    \"\"\"\n    检查一个单词是否是同音字    >>> is_isogram('eleet')\n    True\n    >>> is_isogram('beetle')\n    False\n    \"\"\"\n    # 利用哈希表的特点, 哈"}
{"task_id": "HumanEval/58", "completion": "    return list(set(l1).intersection(set(l2)))\n\n\ndef union(l1: list, l2: list):\n    return list(set(l1).union(set(l2)))\n\n\ndef set_count(l1: list, l2: list):\n    \"\"\"返回两个列表中所有元素的个数，返回一个列表     >>> set_count([1, 4, 3, 12, 5, 9, 34], [1, 34, 8, 9, 5, 12, 653])\n    [6, 3, 6, 3, 3, 6]\n    \"\"\"\n    return map(lambda x: l1.count(x) + l2.count(x),\n               union(l1, l2))\n\n\ndef lcs(l1: list, l2: list):\n    m = len(l1)\n    n = len(l2)\n    arr = [[0 for i in range(n+1)] for j in range(", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return list(set(l1).intersection(set(l2)))\n\n\ndef union(l1: list, l2: list):\n    return list(set(l1).union(set(l2)))\n\n\ndef set_count(l1: list, l2: list):\n    \"\"\"返回两个列表中所有元素的个数，返回一个列表     >>> set_count([1, 4, 3, 12, 5, 9, 34], [1, 34, 8, 9, 5, 12, 653])\n    [6, 3, 6, 3, 3, 6]\n    \"\"\"\n    return map(lambda x: l1.count(x) + l2.count(x),\n               union(l1, l2))\n\n\ndef lcs(l1: list, l2: list):\n    m = len(l1)\n    n = len(l2)\n    arr = [[0 for i in range(n+1)] for j in range("}
{"task_id": "HumanEval/58", "completion": "    res = []\n    dic = {}\n    for a in l1:\n        if a not in dic:\n            dic[a] = 1\n        else:\n            dic[a] += 1\n    for a in l2:\n        if a in dic and dic[a] == 1:\n            res.append(a)\n            dic[a] = 2\n    res.sort()\n    return res\n\n\ndef last_element(l: list):\n    \"\"\"\n    返回列表最后一个元素，不是最后一个元素\n\n    >>> last_element([1, 2, 3, 4, 5])\n    5\n    >>> last_element([-10, -5, 0, 5, 10])\n    10\n    >>> last_element([])\n    Traceback (most recent call last):\n       ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(l) == 0:\n        raise IndexError('list index out of range')\n    return l[len(l) - 1]\n", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = []\n    dic = {}\n    for a in l1:\n        if a not in dic:\n            dic[a] = 1\n        else:\n            dic[a] += 1\n    for a in l2:\n        if a in dic and dic[a] == 1:\n            res.append(a)\n            dic[a] = 2\n    res.sort()\n    return res\n\n\ndef last_element(l: list):\n    \"\"\"\n    返回列表最后一个元素，不是最后一个元素\n\n    >>> last_element([1, 2, 3, 4, 5])\n    5\n    >>> last_element([-10, -5, 0, 5, 10])\n    10\n    >>> last_element([])\n    Traceback (most recent call last):\n       ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(l) == 0:\n        raise IndexError('list index out of range')\n    return l[len(l) - 1]\n"}
{"task_id": "HumanEval/58", "completion": "    pass\n\n\ndef isAnagram(str1, str2):\n    \"\"\"判断两个字符串是否是变位词\n    >>> isAnagram('baobao', 'baobao')\n     True\n    >>> isAnagram('baobao', 'baobaohe')\n     False\n    >>> isAnagram('baobao', '')\n     False\n    >>> isAnagram('baobao', 'bao')\n     False\n    >>> isAnagram('', '')\n     True\n    \"\"\"\n    pass\n\n\ndef getRank(arr: list, num: int):\n    \"\"\"获取数字在数组中所处排序位置\"\"\"\n    return 0\n\n\ndef random(arr: list):\n    \"\"\"产生一个随机数组\"\"\"\n    pass\n\n\ngetRank([3, 2, 1, 8, 11], 2)\nisAnagram(\"dog\", \"god\")\nrandom([8, 3, 1, 2, 4, 6, 5, 7", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    pass\n\n\ndef isAnagram(str1, str2):\n    \"\"\"判断两个字符串是否是变位词\n    >>> isAnagram('baobao', 'baobao')\n     True\n    >>> isAnagram('baobao', 'baobaohe')\n     False\n    >>> isAnagram('baobao', '')\n     False\n    >>> isAnagram('baobao', 'bao')\n     False\n    >>> isAnagram('', '')\n     True\n    \"\"\"\n    pass\n\n\ndef getRank(arr: list, num: int):\n    \"\"\"获取数字在数组中所处排序位置\"\"\"\n    return 0\n\n\ndef random(arr: list):\n    \"\"\"产生一个随机数组\"\"\"\n    pass\n\n\ngetRank([3, 2, 1, 8, 11], 2)\nisAnagram(\"dog\", \"god\")\nrandom([8, 3, 1, 2, 4, 6, 5, 7"}
{"task_id": "HumanEval/58", "completion": "    def _common(l1, l2):\n        if not l1 or not l2:\n            return []\n        l1 = set(l1)\n        l2 = set(l2)\n        return [i for i in l1 if i in l2]\n\n    def __common(l1, l2):\n        if not l1 or not l2:\n            return []\n        l1 = sorted(l1)\n        l2 = sorted(l2)\n        min_len, max_len = min(len(l1), len(l2)), max(len(l1), len(l2))\n        i = j = 0\n        ret = []\n        while i < max_len and j < min_len:\n            if l1[i] == l2[j]:\n                ret.append(l1[i])\n                i += 1\n                j += 1\n            elif l1[i] > l2[j]:\n                j += 1\n            else:\n                i += 1\n        return ret\n\n    return _common(l1, l2)", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    def _common(l1, l2):\n        if not l1 or not l2:\n            return []\n        l1 = set(l1)\n        l2 = set(l2)\n        return [i for i in l1 if i in l2]\n\n    def __common(l1, l2):\n        if not l1 or not l2:\n            return []\n        l1 = sorted(l1)\n        l2 = sorted(l2)\n        min_len, max_len = min(len(l1), len(l2)), max(len(l1), len(l2))\n        i = j = 0\n        ret = []\n        while i < max_len and j < min_len:\n            if l1[i] == l2[j]:\n                ret.append(l1[i])\n                i += 1\n                j += 1\n            elif l1[i] > l2[j]:\n                j += 1\n            else:\n                i += 1\n        return ret\n\n    return _common(l1, l2)"}
{"task_id": "HumanEval/58", "completion": "    if len(l1) > len(l2):\n        small_list = l2\n        large_list = l1\n    else:\n        small_list = l1\n        large_list = l2\n    small_set = set(small_list)\n    common_list = []\n    for ele in large_list:\n        if ele in small_set:\n            common_list.append(ele)\n    common_list.sort()\n    return common_list\n\n\n## Q5\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次   >>> intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> intersection([5, 3, 2, 8], [3", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if len(l1) > len(l2):\n        small_list = l2\n        large_list = l1\n    else:\n        small_list = l1\n        large_list = l2\n    small_set = set(small_list)\n    common_list = []\n    for ele in large_list:\n        if ele in small_set:\n            common_list.append(ele)\n    common_list.sort()\n    return common_list\n\n\n## Q5\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次   >>> intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> intersection([5, 3, 2, 8], [3"}
{"task_id": "HumanEval/58", "completion": "    res = list(set(l1).intersection(set(l2)))\n    return sorted(list(set(res)))\n\n\ndef get_index(lis: list, val: int):\n    \"\"\"获取列表中元素出现的索引，返回列表要求排过序且每个元素只出现一次，\n    如果没有找到，则返回空列表\n    >>> get_index([5, 3, 2, 8], 3)\n    [1]\n    >>> get_index([5, 3, 2, 8], 9)\n    []\n    \"\"\"\n    try:\n        res = [lis.index(val)]\n    except IndexError:\n        res = []\n    return sorted(list(set(res)))\n\n\ndef get_index_list(lis: list, lst: list):\n    \"\"\"获取列表中元素出现的索引，返回列表要求排过序且每个元素只出现一次，\n    如果没有", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = list(set(l1).intersection(set(l2)))\n    return sorted(list(set(res)))\n\n\ndef get_index(lis: list, val: int):\n    \"\"\"获取列表中元素出现的索引，返回列表要求排过序且每个元素只出现一次，\n    如果没有找到，则返回空列表\n    >>> get_index([5, 3, 2, 8], 3)\n    [1]\n    >>> get_index([5, 3, 2, 8], 9)\n    []\n    \"\"\"\n    try:\n        res = [lis.index(val)]\n    except IndexError:\n        res = []\n    return sorted(list(set(res)))\n\n\ndef get_index_list(lis: list, lst: list):\n    \"\"\"获取列表中元素出现的索引，返回列表要求排过序且每个元素只出现一次，\n    如果没有"}
{"task_id": "HumanEval/58", "completion": "    list1 = list(set(list1))\n    list2 = list(set(list2))\n    return list(list(set(list1) & set(list2)))\n\n\ndef list_common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求没有排过序也可以\n    >>> list_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> list_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    list1 = list(set(list1))\n    list2 = list(set(list2))\n    return list((list1 + list2) - set(list1).intersection(list2))\n\n\n'''排序list'''\n", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    list1 = list(set(list1))\n    list2 = list(set(list2))\n    return list(list(set(list1) & set(list2)))\n\n\ndef list_common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求没有排过序也可以\n    >>> list_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> list_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    list1 = list(set(list1))\n    list2 = list(set(list2))\n    return list((list1 + list2) - set(list1).intersection(list2))\n\n\n'''排序list'''\n"}
{"task_id": "HumanEval/58", "completion": "    l1 = list(set(l1))\n    l2 = list(set(l2))\n    l1.sort()\n    l2.sort()\n    l3 = []\n    i, j = 0, 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            l3.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n    return l3\n\n\ndef my_sum(l: list):\n    \"\"\"求列表的和，列表元素可以为字符串或数值类型，返回值均为字符串或数值类型    >>> my_sum([1, 2, 3, 4, 5])\n    15\n    >>> my_sum(['adc', 'a', 'd', 'e'])\n    'adcad'\n\n    \"\"\"\n    l = list", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1 = list(set(l1))\n    l2 = list(set(l2))\n    l1.sort()\n    l2.sort()\n    l3 = []\n    i, j = 0, 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            l3.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n    return l3\n\n\ndef my_sum(l: list):\n    \"\"\"求列表的和，列表元素可以为字符串或数值类型，返回值均为字符串或数值类型    >>> my_sum([1, 2, 3, 4, 5])\n    15\n    >>> my_sum(['adc', 'a', 'd', 'e'])\n    'adcad'\n\n    \"\"\"\n    l = list"}
{"task_id": "HumanEval/58", "completion": "    \n    # 合并两个列表\n    total = set(l1) | set(l2)\n    total = sorted(list(total), key=l1.index)\n    result = []\n    i = 0\n    j = 0\n    #\n    while i < len(l1):\n        while j < len(l2):\n            if l1[i] == l2[j]:\n                result.append(l1[i])\n                i += 1\n                j += 1\n            else:\n                j += 1\n        j = 0\n        i += 1\n    return result\n\ndef my_max(nums: list):\n    \"\"\"\n    输入一个整型数组，找出最大1个数，返回一个数字\n    输入：[1, 3123, 31, 312, 313, 123, 21, 123, 23, 123]\n    返回：3123\n    >>> my_max", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    \n    # 合并两个列表\n    total = set(l1) | set(l2)\n    total = sorted(list(total), key=l1.index)\n    result = []\n    i = 0\n    j = 0\n    #\n    while i < len(l1):\n        while j < len(l2):\n            if l1[i] == l2[j]:\n                result.append(l1[i])\n                i += 1\n                j += 1\n            else:\n                j += 1\n        j = 0\n        i += 1\n    return result\n\ndef my_max(nums: list):\n    \"\"\"\n    输入一个整型数组，找出最大1个数，返回一个数字\n    输入：[1, 3123, 31, 312, 313, 123, 21, 123, 23, 123]\n    返回：3123\n    >>> my_max"}
{"task_id": "HumanEval/58", "completion": "    l3 = []\n    # 先对列表排序\n    l1.sort()\n    l2.sort()\n    # 再比较两个列表是否相等\n    for i in range(len(l1)):\n        if l1[i] == l2[i]:\n            l3.append(l1[i])\n    return l3\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次   \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l3", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l3 = []\n    # 先对列表排序\n    l1.sort()\n    l2.sort()\n    # 再比较两个列表是否相等\n    for i in range(len(l1)):\n        if l1[i] == l2[i]:\n            l3.append(l1[i])\n    return l3\n\n\ndef common1(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次   \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l3"}
{"task_id": "HumanEval/59", "completion": "    if is_prime(n):\n        return n\n    d = 2\n    while n % d!= 0:\n        d = d + 1\n    return d\n\n\ndef smallest_odd_factor(n):\n    \"\"\"返回 n 的最小奇数因子。假设 n > 1 且不是质数。   >>> smallest_odd_factor(2048)\n    3\n    >>> smallest_odd_factor(13195)\n    131\n    \"\"\"\n    while n % 2 == 0:\n        n = n // 2\n    return n\n\n\ndef sum_digits(n):\n    \"\"\"返回一个数的数位和。假设 n >= 0   >>> sum_digits(123)\n    6\n    \"\"\"\n    assert n >= 0\n    return sum(int(digit) for digit in str(n))\n\n\ndef is_prime(n):\n    \"\"\"返回 n 是否为质数。假设 n > 1   >>> is", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if is_prime(n):\n        return n\n    d = 2\n    while n % d!= 0:\n        d = d + 1\n    return d\n\n\ndef smallest_odd_factor(n):\n    \"\"\"返回 n 的最小奇数因子。假设 n > 1 且不是质数。   >>> smallest_odd_factor(2048)\n    3\n    >>> smallest_odd_factor(13195)\n    131\n    \"\"\"\n    while n % 2 == 0:\n        n = n // 2\n    return n\n\n\ndef sum_digits(n):\n    \"\"\"返回一个数的数位和。假设 n >= 0   >>> sum_digits(123)\n    6\n    \"\"\"\n    assert n >= 0\n    return sum(int(digit) for digit in str(n))\n\n\ndef is_prime(n):\n    \"\"\"返回 n 是否为质数。假设 n > 1   >>> is"}
{"task_id": "HumanEval/59", "completion": "    # 如果 n 不是质数，则返回 2\n    if n % 2 == 0:\n        return 2\n    # 如果 n 不是质数且不是 2 的倍数，则返回 3\n    if n % 3 == 0:\n        return 3\n    # 把 n 以 2 为基数的所有质数因子的倍数（如果有）去除\n    i = 5\n    while i*i <= n:\n        if n % i:\n            i += 2\n        else:\n            n //= i\n            return i\n    # 如果 n 剩下 1 ，则返回 n\n    return n\n\n\n# 127\ndef largest_prime_factor_recursive(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(1319", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # 如果 n 不是质数，则返回 2\n    if n % 2 == 0:\n        return 2\n    # 如果 n 不是质数且不是 2 的倍数，则返回 3\n    if n % 3 == 0:\n        return 3\n    # 把 n 以 2 为基数的所有质数因子的倍数（如果有）去除\n    i = 5\n    while i*i <= n:\n        if n % i:\n            i += 2\n        else:\n            n //= i\n            return i\n    # 如果 n 剩下 1 ，则返回 n\n    return n\n\n\n# 127\ndef largest_prime_factor_recursive(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(1319"}
{"task_id": "HumanEval/59", "completion": "    n_str = str(n)\n    # 去除最后一个字符，如果没有剩下的字符，说明数字是一个质数 \n    while n_str[0]!= '1':\n        n_str = n_str[:-1]\n        while int(n_str[-1]) > 1:\n            if is_prime(int(n_str[-1])):\n                return int(n_str[-1])\n            else:\n                n_str = n_str[:-1]\n    return int(n_str)\n\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n```\n\n### 5.15 求和\n\n```python\n\ndef sum_table(a: int, b: int, step: int) -> int:\n    \"\"\"计算 a 到 b（包括 a 和 b）的整数的和，每次跳过 step 个数   >>> sum_table(1, ", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    n_str = str(n)\n    # 去除最后一个字符，如果没有剩下的字符，说明数字是一个质数 \n    while n_str[0]!= '1':\n        n_str = n_str[:-1]\n        while int(n_str[-1]) > 1:\n            if is_prime(int(n_str[-1])):\n                return int(n_str[-1])\n            else:\n                n_str = n_str[:-1]\n    return int(n_str)\n\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n```\n\n### 5.15 求和\n\n```python\n\ndef sum_table(a: int, b: int, step: int) -> int:\n    \"\"\"计算 a 到 b（包括 a 和 b）的整数的和，每次跳过 step 个数   >>> sum_table(1, "}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\ndef main():\n    print(largest_prime_factor(160), largest_prime_factor(13195))\n\nif __name__ == '__main__':\n    main", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\ndef main():\n    print(largest_prime_factor(160), largest_prime_factor(13195))\n\nif __name__ == '__main__':\n    main"}
{"task_id": "HumanEval/59", "completion": "    p = 1\n    while n > 1:\n        if is_prime(n):\n            p = n\n            break\n        else:\n            p, n = n, n//next_prime(n)\n    return p\n# 时间复杂度 Θ(logn)\n\ndef prime_factors(n):\n    '''\n    prime_factors(13195)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    '''\n    factors = []\n    while n > 1:\n        p = largest_prime_factor(n)\n        factors.append(p)\n        n //= p\n    return factors\n# 时间复杂度 Θ(logn)\n\ndef prime_factors2(n):\n    '''\n    prime_factors2(13195)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 2", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    p = 1\n    while n > 1:\n        if is_prime(n):\n            p = n\n            break\n        else:\n            p, n = n, n//next_prime(n)\n    return p\n# 时间复杂度 Θ(logn)\n\ndef prime_factors(n):\n    '''\n    prime_factors(13195)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    '''\n    factors = []\n    while n > 1:\n        p = largest_prime_factor(n)\n        factors.append(p)\n        n //= p\n    return factors\n# 时间复杂度 Θ(logn)\n\ndef prime_factors2(n):\n    '''\n    prime_factors2(13195)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 2"}
{"task_id": "HumanEval/59", "completion": "    while n % 2 == 0:\n        n = n/2\n    # 从 3 开始，因为 2 肯定是最大的因子，不需要检查。\n    for i in range(3, int(math.sqrt(n)+1), 2):\n        while n % i == 0:\n            n = n/i\n    return n\n\ndef largest_prime_factor_by_list(n: int):\n    \"\"\"返回 n 的最大质因子，假设 n > 1 且不是质数\n    >>> largest_prime_factor_by_list(13195)\n    29\n    >>> largest_prime_factor_by_list(2048)\n    2\n    \"\"\"\n    i = 0\n    prime_list = [2, 3]\n    while i < n:\n        i = i+1\n        prime_list.append(i)\n    max_value = 1\n    for i in prime_list:\n        while (", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    while n % 2 == 0:\n        n = n/2\n    # 从 3 开始，因为 2 肯定是最大的因子，不需要检查。\n    for i in range(3, int(math.sqrt(n)+1), 2):\n        while n % i == 0:\n            n = n/i\n    return n\n\ndef largest_prime_factor_by_list(n: int):\n    \"\"\"返回 n 的最大质因子，假设 n > 1 且不是质数\n    >>> largest_prime_factor_by_list(13195)\n    29\n    >>> largest_prime_factor_by_list(2048)\n    2\n    \"\"\"\n    i = 0\n    prime_list = [2, 3]\n    while i < n:\n        i = i+1\n        prime_list.append(i)\n    max_value = 1\n    for i in prime_list:\n        while ("}
{"task_id": "HumanEval/59", "completion": "    if n % 2 == 0: # 如果 n 是偶数，则把 n 除以 2\n        while n % 2 == 0: # 循环，除以 2，直到不再能除为止\n            n //= 2\n    if n % 3 == 0: # 如果 n 是偶数，则把 n 除以 3\n        while n % 3 == 0: # 循环，除以 3，直到不再能除为止\n            n //= 3\n    # 从 5 开始，这是第一个大于 2 的质数\n    i = 5\n    while n > 1:\n        while n % i == 0:\n            n //= i\n            i += 2\n        i += 2\n    return n\n\ndef largest_prime_factor2(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 ", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0: # 如果 n 是偶数，则把 n 除以 2\n        while n % 2 == 0: # 循环，除以 2，直到不再能除为止\n            n //= 2\n    if n % 3 == 0: # 如果 n 是偶数，则把 n 除以 3\n        while n % 3 == 0: # 循环，除以 3，直到不再能除为止\n            n //= 3\n    # 从 5 开始，这是第一个大于 2 的质数\n    i = 5\n    while n > 1:\n        while n % i == 0:\n            n //= i\n            i += 2\n        i += 2\n    return n\n\ndef largest_prime_factor2(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 "}
{"task_id": "HumanEval/59", "completion": "    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n **.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n\ndef is_prime(num: int):\n    \"\"\"判断一个数是不是质数，参考：https://blog.csdn.net/coder_china/article/details/8737051\n    \n    :param n: \n    :type n: int\n    :return: \n    \"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    for i in range(2, int(num **.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef _digits_and_nums(n: int):\n    \"\"\"将一个数字按照数、位、千位、百万位、千亿位、万亿位，进行分类。\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n **.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n\ndef is_prime(num: int):\n    \"\"\"判断一个数是不是质数，参考：https://blog.csdn.net/coder_china/article/details/8737051\n    \n    :param n: \n    :type n: int\n    :return: \n    \"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    for i in range(2, int(num **.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef _digits_and_nums(n: int):\n    \"\"\"将一个数字按照数、位、千位、百万位、千亿位、万亿位，进行分类。\n"}
{"task_id": "HumanEval/59", "completion": "    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i + 1, n + 1, i):\n            is_prime[j] = False\n    res = n\n    for i in range(len(is_prime)):\n        if is_prime[i] is False:\n            continue\n        n //= i\n        res = i\n    return res\n\n\ndef num_divisors(n: int) -> int:\n    \"\"\"返回 n 的不超过 20 的除数的个数。注意 0 是合数。假设 n > 0 且不是质数\n    0\n    >>> num_divisors(1)\n    2\n    >>> num_divisors(12)\n    4\n    >>> num_divisors(123)\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i + 1, n + 1, i):\n            is_prime[j] = False\n    res = n\n    for i in range(len(is_prime)):\n        if is_prime[i] is False:\n            continue\n        n //= i\n        res = i\n    return res\n\n\ndef num_divisors(n: int) -> int:\n    \"\"\"返回 n 的不超过 20 的除数的个数。注意 0 是合数。假设 n > 0 且不是质数\n    0\n    >>> num_divisors(1)\n    2\n    >>> num_divisors(12)\n    4\n    >>> num_divisors(123)\n"}
{"task_id": "HumanEval/59", "completion": "    # 2 是一个特例\n    if n == 2:\n        return 2\n    # 首先检查奇数\n    if n % 2 == 0:\n        return largest_prime_factor(n // 2)\n    # 检查一个素数\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return largest_prime_factor(n // i)\n    return n\n\n\ndef print_pyramid(n: int):\n    \"\"\"打印一个柱状图。假设n >= 1\n    >>> print_pyramid(1)\n    *\n    >>> print_pyramid(5)\n    *\n    * *\n    * * *\n    * * * *\n    \"\"\"\n    for i in range(n, 0, -1):\n        for j in range(1, n - i + 1):\n            print(\" \", end=\"\")\n        for k in range(1, i", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # 2 是一个特例\n    if n == 2:\n        return 2\n    # 首先检查奇数\n    if n % 2 == 0:\n        return largest_prime_factor(n // 2)\n    # 检查一个素数\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return largest_prime_factor(n // i)\n    return n\n\n\ndef print_pyramid(n: int):\n    \"\"\"打印一个柱状图。假设n >= 1\n    >>> print_pyramid(1)\n    *\n    >>> print_pyramid(5)\n    *\n    * *\n    * * *\n    * * * *\n    \"\"\"\n    for i in range(n, 0, -1):\n        for j in range(1, n - i + 1):\n            print(\" \", end=\"\")\n        for k in range(1, i"}
{"task_id": "HumanEval/60", "completion": "    assert n >= 1\n    return sum([i for i in range(1, n + 1)])\n\n\ndef main():\n    n = 465\n    for i in range(10, n + 1):\n        result = sum_to_n(i)\n        if result > n:\n            print(result, i)\n            break\n    print(sum_to_n(1000))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\" \n    观察公式：\n    sum = 1 + 2 + 3 + 4 + 5 +... + (n - 3) + (n - 2) + (n - 1)\n    n(n - 1) / 2\n    (n^2 - n) / 2\n\n    sum = 1 + 2 + 3 + 4 +... + (n - 3) + (n - 2", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    assert n >= 1\n    return sum([i for i in range(1, n + 1)])\n\n\ndef main():\n    n = 465\n    for i in range(10, n + 1):\n        result = sum_to_n(i)\n        if result > n:\n            print(result, i)\n            break\n    print(sum_to_n(1000))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\" \n    观察公式：\n    sum = 1 + 2 + 3 + 4 + 5 +... + (n - 3) + (n - 2) + (n - 1)\n    n(n - 1) / 2\n    (n^2 - n) / 2\n\n    sum = 1 + 2 + 3 + 4 +... + (n - 3) + (n - 2"}
{"task_id": "HumanEval/60", "completion": "    return sum(list(range(1, n+1)))\n\n\ndef _count_leading_spaces(string: str):\n    \"\"\"_count_leading_spaces 计算字符串中的前导空格\n    >>> _count_leading_spaces('\\t \\t   \\t')\n    4\n    >>> _count_leading_spaces('  \\t \\t  \\t')\n    2\n    >>> _count_leading_spaces('\\t\\t')\n    2\n    >>> _count_leading_spaces('')\n    0\n    >>> _count_leading_spaces(' ')\n    0\n    \"\"\"\n    i = 0\n    while string[i] =='':\n        i += 1\n    return i\n\n\ndef strip_leading_spaces(string: str) -> str:\n    \"\"\"strip_leading_spaces 去掉字符串的前导空格\n    >>> strip_leading_spaces('\\t \\t   \\t')\n   '  \\t'\n    >>> strip_leading_spaces('  \\t \\t  \\t')\n    '\\t \\t  \\t'", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(list(range(1, n+1)))\n\n\ndef _count_leading_spaces(string: str):\n    \"\"\"_count_leading_spaces 计算字符串中的前导空格\n    >>> _count_leading_spaces('\\t \\t   \\t')\n    4\n    >>> _count_leading_spaces('  \\t \\t  \\t')\n    2\n    >>> _count_leading_spaces('\\t\\t')\n    2\n    >>> _count_leading_spaces('')\n    0\n    >>> _count_leading_spaces(' ')\n    0\n    \"\"\"\n    i = 0\n    while string[i] =='':\n        i += 1\n    return i\n\n\ndef strip_leading_spaces(string: str) -> str:\n    \"\"\"strip_leading_spaces 去掉字符串的前导空格\n    >>> strip_leading_spaces('\\t \\t   \\t')\n   '  \\t'\n    >>> strip_leading_spaces('  \\t \\t  \\t')\n    '\\t \\t  \\t'"}
{"task_id": "HumanEval/60", "completion": "    sum_to_one = n # 1+n = 1+n\n    if n == 1:\n        return sum_to_one\n\n    # 使用递归计算一次.\n    one_to_n = sum_to_n(n - 1)\n\n    # 递归计算了几次, 加上几项\n    result = sum_to_one + one_to_n\n\n    # 返回结果\n    return result\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n### 冒泡排序\n\n1. 描述\n\n    冒泡排序是一种简单的排序算法, 它重复地走访过要排序的数列, 一次比较两个元素, 如果他们的顺序错��", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    sum_to_one = n # 1+n = 1+n\n    if n == 1:\n        return sum_to_one\n\n    # 使用递归计算一次.\n    one_to_n = sum_to_n(n - 1)\n\n    # 递归计算了几次, 加上几项\n    result = sum_to_one + one_to_n\n\n    # 返回结果\n    return result\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n### 冒泡排序\n\n1. 描述\n\n    冒泡排序是一种简单的排序算法, 它重复地走访过要排序的数列, 一次比较两个元素, 如果他们的顺序错��"}
{"task_id": "HumanEval/60", "completion": "    return (n * (n + 1)) // 2\n\ndef compute_square_root(n: int) -> float:\n    \"\"\"\n    compute_square_root 计算平方根.\n\n         >>> compute_square_root(4)\n         == 2.0\n         >>> compute_square_root(9)\n         == 3.0\n         >>> compute_square_root(1234)\n         == 111.85851\n         >>> compute_square_root(0)\n         == 0\n\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        # 对于大值，返回准确绘\n        if n >= 999999999999999999999999999999999999999999999999999999999999999999999999999999999:\n            return", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef compute_square_root(n: int) -> float:\n    \"\"\"\n    compute_square_root 计算平方根.\n\n         >>> compute_square_root(4)\n         == 2.0\n         >>> compute_square_root(9)\n         == 3.0\n         >>> compute_square_root(1234)\n         == 111.85851\n         >>> compute_square_root(0)\n         == 0\n\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        # 对于大值，返回准确绘\n        if n >= 999999999999999999999999999999999999999999999999999999999999999999999999999999999:\n            return"}
{"task_id": "HumanEval/60", "completion": "    res = 0\n    for i in range(n + 1):\n        res += i\n    return res\n\n\ndef check_sum_to_n(n: int):\n    \"\"\"计算从1到n的数字的和,并比较是否等于n*(n+1)/2  >>> check_sum_to_n(30)\n    True\n    >>> check_sum_to_n(100)\n    True\n    >>> check_sum_to_n(5)\n    True\n    >>> check_sum_to_n(10)\n    True\n    >>> check_sum_to_n(1)\n    True\n    \"\"\"\n    return (n * (n + 1)) / 2 == sum_to_n(n)\n\n\ndef find_n_sum_to_n(n):\n    \"\"\" 找出满足条件sum_to_n(n) = n*(n+1)/2的数字n.  >>> find_n_sum_to_n(30)\n    15 \n   ", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    res = 0\n    for i in range(n + 1):\n        res += i\n    return res\n\n\ndef check_sum_to_n(n: int):\n    \"\"\"计算从1到n的数字的和,并比较是否等于n*(n+1)/2  >>> check_sum_to_n(30)\n    True\n    >>> check_sum_to_n(100)\n    True\n    >>> check_sum_to_n(5)\n    True\n    >>> check_sum_to_n(10)\n    True\n    >>> check_sum_to_n(1)\n    True\n    \"\"\"\n    return (n * (n + 1)) / 2 == sum_to_n(n)\n\n\ndef find_n_sum_to_n(n):\n    \"\"\" 找出满足条件sum_to_n(n) = n*(n+1)/2的数字n.  >>> find_n_sum_to_n(30)\n    15 \n   "}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\n# 返回两个列表的交集\ndef intersect(lst1, lst2):\n    result = []\n    for n in lst1:\n        if n in lst2:\n            result.append(n)\n    return result\n\n# 返回一个列表, 其中包含了两个列表的不同元素.\ndef difference(lst1, lst2):\n    return [n for n in lst1 if n not in lst2]\n\ndef longest_common_subsequence(X, Y):\n    \"\"\"\n    >>> longest_common_subsequence(list(\"abcd\"), list(\"bcde\"))\n    'bcd'\n    >>> longest_common_subsequence(list(\"abcd\"), list(\"cbde\"))\n    'c'\n    \"\"\"\n    c = [[0 for j in range(len(Y))] for i in range(len(X) + 1)]\n    for i in range(1, len(X) + 1):\n        for j in range(1, len(Y) + ", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\n# 返回两个列表的交集\ndef intersect(lst1, lst2):\n    result = []\n    for n in lst1:\n        if n in lst2:\n            result.append(n)\n    return result\n\n# 返回一个列表, 其中包含了两个列表的不同元素.\ndef difference(lst1, lst2):\n    return [n for n in lst1 if n not in lst2]\n\ndef longest_common_subsequence(X, Y):\n    \"\"\"\n    >>> longest_common_subsequence(list(\"abcd\"), list(\"bcde\"))\n    'bcd'\n    >>> longest_common_subsequence(list(\"abcd\"), list(\"cbde\"))\n    'c'\n    \"\"\"\n    c = [[0 for j in range(len(Y))] for i in range(len(X) + 1)]\n    for i in range(1, len(X) + 1):\n        for j in range(1, len(Y) + "}
{"task_id": "HumanEval/60", "completion": "    if n <= 1:\n        return n\n    else:\n        return n + sum_to_n(n - 1)\n\n\ndef power_of_n(n: int, power: int):\n    \"\"\"power_of_n return n's power of power.\n    >>> power_of_n(2, 3)\n    8\n    >>> power_of_n(3, 2)\n    9\n    >>> power_of_n(2, 0)\n    1\n    >>> power_of_n(2, 1)\n    2\n    >>> power_of_n(2, 2)\n    4\n    \"\"\"\n    if power == 0:\n        return 1\n    else:\n        return n * power_of_n(n, power - 1)\n\n\ndef sum_of_two_n(n: int, m: int):\n    \"\"\"Return the sum of two numbers.\n    >>> sum_of_two_n(1, 2)\n    3\n    >>> sum_of_two_n(10, 20)\n", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return n + sum_to_n(n - 1)\n\n\ndef power_of_n(n: int, power: int):\n    \"\"\"power_of_n return n's power of power.\n    >>> power_of_n(2, 3)\n    8\n    >>> power_of_n(3, 2)\n    9\n    >>> power_of_n(2, 0)\n    1\n    >>> power_of_n(2, 1)\n    2\n    >>> power_of_n(2, 2)\n    4\n    \"\"\"\n    if power == 0:\n        return 1\n    else:\n        return n * power_of_n(n, power - 1)\n\n\ndef sum_of_two_n(n: int, m: int):\n    \"\"\"Return the sum of two numbers.\n    >>> sum_of_two_n(1, 2)\n    3\n    >>> sum_of_two_n(10, 20)\n"}
{"task_id": "HumanEval/60", "completion": "    if n < 1:\n        return 0\n    return n + sum_to_n(n - 1)\n\n\ndef _sum(n: int, current_sum: int) -> int:\n    \"\"\"_sum 计算从1到n的数字的和.   >>> _sum(30)\n    465\n    \n    Args:\n        current_sum (int): 需要累加的数字\n        n (int): 累加的结束数字\n    \"\"\"\n    if n < 1:\n        return 0\n    return _sum(n - 1, current_sum + n)\n\n\ndef sum_to_n_recursion(n: int):\n    \"\"\"sum_to_n_recursion 计算从1到n的数字的和.   >>> sum_to_n_recursion(30)\n    465\n    \n    Args:\n        n (int): 累加的结束数字\n    \"\"\"\n    return _sum(n, 0", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    return n + sum_to_n(n - 1)\n\n\ndef _sum(n: int, current_sum: int) -> int:\n    \"\"\"_sum 计算从1到n的数字的和.   >>> _sum(30)\n    465\n    \n    Args:\n        current_sum (int): 需要累加的数字\n        n (int): 累加的结束数字\n    \"\"\"\n    if n < 1:\n        return 0\n    return _sum(n - 1, current_sum + n)\n\n\ndef sum_to_n_recursion(n: int):\n    \"\"\"sum_to_n_recursion 计算从1到n的数字的和.   >>> sum_to_n_recursion(30)\n    465\n    \n    Args:\n        n (int): 累加的结束数字\n    \"\"\"\n    return _sum(n, 0"}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\n\n# 字符串解析\n\ndef parse_int(code: str):\n    \"\"\"解析一个代码并返回一个数字.\n\n    >>> parse_int('10 + 2 * 4')\n    16\n    >>> parse_int('50 * 0')\n    0\n    >>> parse_int('-100')\n    -100\n    >>> parse_int('0')\n    0\n    \"\"\"\n    return Expression().parse(code)\n\n\nclass Expression(object):\n    \"\"\"计算一个表达式的值\"\"\"\n\n    def __init__(self):\n        self.add = Add()\n        self.sub = Sub()\n        self.mul = Mul()\n        self.div = Div()\n        self.const = Const()\n\n    def parse(self, s):\n        \"\"\"解析一个字符串\"\"\"\n        t = Tokenizer(s)\n        return self.expr(t)\n\n    def expr(self, t", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\n\n# 字符串解析\n\ndef parse_int(code: str):\n    \"\"\"解析一个代码并返回一个数字.\n\n    >>> parse_int('10 + 2 * 4')\n    16\n    >>> parse_int('50 * 0')\n    0\n    >>> parse_int('-100')\n    -100\n    >>> parse_int('0')\n    0\n    \"\"\"\n    return Expression().parse(code)\n\n\nclass Expression(object):\n    \"\"\"计算一个表达式的值\"\"\"\n\n    def __init__(self):\n        self.add = Add()\n        self.sub = Sub()\n        self.mul = Mul()\n        self.div = Div()\n        self.const = Const()\n\n    def parse(self, s):\n        \"\"\"解析一个字符串\"\"\"\n        t = Tokenizer(s)\n        return self.expr(t)\n\n    def expr(self, t"}
{"task_id": "HumanEval/60", "completion": "    if n < 1:\n        raise ValueError('n must >=1')\n    return n * (n + 1) // 2\n\n\ndef power_to_n(n: int):\n    \"\"\"power_to_n 计算1到n的数字的幂和.   >>> power_to_n(30)\n    156000000000000000\n    >>> power_to_n(100)\n    2.9810741387489024e+21\n    >>> power_to_n(5)\n    5125\n    >>> power_to_n(10)\n    26525\n    >>> power_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must >=1')\n    return sum(n ** i for i in range(1, n + 1))\n\n\ndef n_factorial(n: int):\n    \"\"\"factorial 计算n的����", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must >=1')\n    return n * (n + 1) // 2\n\n\ndef power_to_n(n: int):\n    \"\"\"power_to_n 计算1到n的数字的幂和.   >>> power_to_n(30)\n    156000000000000000\n    >>> power_to_n(100)\n    2.9810741387489024e+21\n    >>> power_to_n(5)\n    5125\n    >>> power_to_n(10)\n    26525\n    >>> power_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must >=1')\n    return sum(n ** i for i in range(1, n + 1))\n\n\ndef n_factorial(n: int):\n    \"\"\"factorial 计算n的����"}
{"task_id": "HumanEval/70", "completion": "    if lst == []:\n        return []\n    lst = sorted(lst)\n    ret = []\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            ret.append(lst[i])\n        else:\n            ret.append(lst[len(lst)-i-1])\n    return ret\n\ndef sort_list(lst):\n    '''\n    给定整数列表，从小到大返回列表\n    示例   sort_list([1, 2, 3, 4]) == [1, 2, 3, 4]\n    sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    sort_list([]) == []\n    '''\n    if lst == []:\n        return []\n    lst = sorted(lst)\n    return lst\n    \ndef odd_even_sort_list(lst):\n    '''\n    给定整数列表，按奇偶排序返回列表\n    示例   odd_", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if lst == []:\n        return []\n    lst = sorted(lst)\n    ret = []\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            ret.append(lst[i])\n        else:\n            ret.append(lst[len(lst)-i-1])\n    return ret\n\ndef sort_list(lst):\n    '''\n    给定整数列表，从小到大返回列表\n    示例   sort_list([1, 2, 3, 4]) == [1, 2, 3, 4]\n    sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    sort_list([]) == []\n    '''\n    if lst == []:\n        return []\n    lst = sorted(lst)\n    return lst\n    \ndef odd_even_sort_list(lst):\n    '''\n    给定整数列表，按奇偶排序返回列表\n    示例   odd_"}
{"task_id": "HumanEval/70", "completion": "    num_list_temp = []\n    num_list = list(set(lst))    \n    while num_list:\n        num_list_temp.append(min(num_list))\n        num_list.remove(min(num_list))\n        num_list_temp.append(max(num_list))\n        num_list.remove(max(num_list))\n    return num_list_temp\n\n# 如果列表中的元素是字符串，返回单词列表中单词的长度之和\ndef sum_word_len(list1):\n    str1 = ''.join(list1)\n    str1 = list(filter(None,str1))\n    sum1 = 0\n    for s in str1:\n        sum1 += len(s)\n    return sum1 \n\n# 如果列表中的元素是单词，返回惯用的字母表中字母位置之和\ndef sum_word_index(list1):\n    sum1 = 0\n    str2 =", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    num_list_temp = []\n    num_list = list(set(lst))    \n    while num_list:\n        num_list_temp.append(min(num_list))\n        num_list.remove(min(num_list))\n        num_list_temp.append(max(num_list))\n        num_list.remove(max(num_list))\n    return num_list_temp\n\n# 如果列表中的元素是字符串，返回单词列表中单词的长度之和\ndef sum_word_len(list1):\n    str1 = ''.join(list1)\n    str1 = list(filter(None,str1))\n    sum1 = 0\n    for s in str1:\n        sum1 += len(s)\n    return sum1 \n\n# 如果列表中的元素是单词，返回惯用的字母表中字母位置之和\ndef sum_word_index(list1):\n    sum1 = 0\n    str2 ="}
{"task_id": "HumanEval/70", "completion": "    n = len(lst)\n    result = []\n    for i in range(n):\n        result.append(min(lst))\n        lst.remove(min(lst))\n        lst.append(max(lst))\n        lst.remove(max(lst))\n    return result\n    \n# 填充扑克牌\ndef fill_poker(lst):\n    '''\n    给定一副扑克牌，返回一个填充过的新扑克牌(顺序不变)，使得所有的A都排在一起（可以看作一组），所有的2都排在一起（可以看作一组），依此类推。\n    示例   fill_poker([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A']) == [2, 2, 2, 3,", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    n = len(lst)\n    result = []\n    for i in range(n):\n        result.append(min(lst))\n        lst.remove(min(lst))\n        lst.append(max(lst))\n        lst.remove(max(lst))\n    return result\n    \n# 填充扑克牌\ndef fill_poker(lst):\n    '''\n    给定一副扑克牌，返回一个填充过的新扑克牌(顺序不变)，使得所有的A都排在一起（可以看作一组），所有的2都排在一起（可以看作一组），依此类推。\n    示例   fill_poker([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A']) == [2, 2, 2, 3,"}
{"task_id": "HumanEval/70", "completion": "    # ---------------------\n    # 这部分是关键\n    # ---------------------\n    if not lst:\n        return []\n\n    new_lst = lst[0::2] + lst[1::2]\n    return new_lst\n\n\n# 帮助函数\ndef remove_odd(number):\n    '''\n    删除奇数，整数列表中删除奇数，如果有的话\n    '''\n    if number % 2:\n        return []\n    else:\n        return [number]\n\n# 帮助函数\ndef remove_even(number):\n    '''\n    删除偶数，整数列表中删除偶数，如果有的话\n    '''\n    if number % 2:\n        return [number]\n    else:\n        return []\n\ndef remove_odd_list(lst):\n    '''\n    如果有奇数，则移除\n    '''\n    res = []\n    for num in lst:\n        res += remove_odd(num)\n   ", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    # ---------------------\n    # 这部分是关键\n    # ---------------------\n    if not lst:\n        return []\n\n    new_lst = lst[0::2] + lst[1::2]\n    return new_lst\n\n\n# 帮助函数\ndef remove_odd(number):\n    '''\n    删除奇数，整数列表中删除奇数，如果有的话\n    '''\n    if number % 2:\n        return []\n    else:\n        return [number]\n\n# 帮助函数\ndef remove_even(number):\n    '''\n    删除偶数，整数列表中删除偶数，如果有的话\n    '''\n    if number % 2:\n        return [number]\n    else:\n        return []\n\ndef remove_odd_list(lst):\n    '''\n    如果有奇数，则移除\n    '''\n    res = []\n    for num in lst:\n        res += remove_odd(num)\n   "}
{"task_id": "HumanEval/70", "completion": "    srtLst = []  # 用来存奇异排序的列表\n\n    if lst == []:\n        return []\n\n    lst.sort()  # 先对列表进行升序排序\n\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            srtLst.append(lst[0])  # 如果i是偶数，则奇异排序列表存储的是最小值\n        else:\n            srtLst.append(lst.pop())  # 如果i是奇数，则奇异排序列表存储的是最大值\n    return srtLst\n\n\n# 13. 检查单词\ndef check_word(word):\n    '''\n    给定一个字符串，检查每个字符是否在其他字符之前或之后。\n    示例   check_word(\"python\") == False\n   ", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    srtLst = []  # 用来存奇异排序的列表\n\n    if lst == []:\n        return []\n\n    lst.sort()  # 先对列表进行升序排序\n\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            srtLst.append(lst[0])  # 如果i是偶数，则奇异排序列表存储的是最小值\n        else:\n            srtLst.append(lst.pop())  # 如果i是奇数，则奇异排序列表存储的是最大值\n    return srtLst\n\n\n# 13. 检查单词\ndef check_word(word):\n    '''\n    给定一个字符串，检查每个字符是否在其他字符之前或之后。\n    示例   check_word(\"python\") == False\n   "}
{"task_id": "HumanEval/70", "completion": "    pass\n\n\ndef reverse_sort(lst):\n    '''\n    给定整数列表，返回一个列表，该列表按降序排序。如果列表为空，则返回列表[]。\n    示例   reverse_sort([1, 2, 3, 4]) == [4, 3, 2, 1]\n    reverse_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    reverse_sort([]) == []\n    '''\n    pass\n\n\ndef double_pairs(lst):\n    '''\n    给定整数列表，返回列表，列表中的元素是形如(a, a)的元组。\n    示例   double_pairs([1, 2, 3, 4]) == [(1, 1), (2, 2), (3, 3), (4, 4)]\n    double_pairs([5, 5, 5, 5]) == [(5, 5", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    pass\n\n\ndef reverse_sort(lst):\n    '''\n    给定整数列表，返回一个列表，该列表按降序排序。如果列表为空，则返回列表[]。\n    示例   reverse_sort([1, 2, 3, 4]) == [4, 3, 2, 1]\n    reverse_sort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    reverse_sort([]) == []\n    '''\n    pass\n\n\ndef double_pairs(lst):\n    '''\n    给定整数列表，返回列表，列表中的元素是形如(a, a)的元组。\n    示例   double_pairs([1, 2, 3, 4]) == [(1, 1), (2, 2), (3, 3), (4, 4)]\n    double_pairs([5, 5, 5, 5]) == [(5, 5"}
{"task_id": "HumanEval/70", "completion": "    n = len(lst)\n    if not lst:\n        return []\n    elif n == 1:\n        return lst\n    else:\n        res = []\n        i = 0\n        while i < n:\n            res.append(lst[i])\n            lst.remove(lst[i])\n            res.append(max(lst))\n            lst.remove(max(lst))\n            i += 2\n        return res\n\n\ndef sum_of_squares(lst):\n    '''\n    给定整型列表，返回其元素的平方和。\n    示例   sum_of_squares([1, 2, 3, 4]) == 30\n    sum_of_squares([-2, -1, 0, 1, 2]) == 12\n    sum_of_squares([]) == 0\n    '''\n    n = len(lst)\n    if not lst:\n        return 0\n    elif n == 1:\n        return lst\n    else:\n        res = []\n        i = 0\n", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    n = len(lst)\n    if not lst:\n        return []\n    elif n == 1:\n        return lst\n    else:\n        res = []\n        i = 0\n        while i < n:\n            res.append(lst[i])\n            lst.remove(lst[i])\n            res.append(max(lst))\n            lst.remove(max(lst))\n            i += 2\n        return res\n\n\ndef sum_of_squares(lst):\n    '''\n    给定整型列表，返回其元素的平方和。\n    示例   sum_of_squares([1, 2, 3, 4]) == 30\n    sum_of_squares([-2, -1, 0, 1, 2]) == 12\n    sum_of_squares([]) == 0\n    '''\n    n = len(lst)\n    if not lst:\n        return 0\n    elif n == 1:\n        return lst\n    else:\n        res = []\n        i = 0\n"}
{"task_id": "HumanEval/70", "completion": "    # 初始化存储整数最小值的变量和最大值的变量\n    min_value = lst[0]\n    max_value = lst[0]\n    # 创建新的整数列表，最终将它返回\n    new_lst = []\n    # 遍历整数列表\n    for i in lst:\n        if i < min_value:\n            min_value = i\n        if i > max_value:\n            max_value = i\n    # 检查列表是否为空\n    if len(lst) == 0:\n        return []\n    # 如果列表中只有一个值，返回列表中值\n    elif len(lst) == 1:\n        return lst\n    # 如果列表中有两个及两个以上的值，返回整数列表中奇异排序后的值\n    else:\n        for i in range(len(lst)):\n           ", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    # 初始化存储整数最小值的变量和最大值的变量\n    min_value = lst[0]\n    max_value = lst[0]\n    # 创建新的整数列表，最终将它返回\n    new_lst = []\n    # 遍历整数列表\n    for i in lst:\n        if i < min_value:\n            min_value = i\n        if i > max_value:\n            max_value = i\n    # 检查列表是否为空\n    if len(lst) == 0:\n        return []\n    # 如果列表中只有一个值，返回列表中值\n    elif len(lst) == 1:\n        return lst\n    # 如果列表中有两个及两个以上的值，返回整数列表中奇异排序后的值\n    else:\n        for i in range(len(lst)):\n           "}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return lst\n    else:\n        a = min(lst)\n        b = max(lst)\n        c = a\n        d = b\n        e = c\n        f = d\n        g = e\n        if a!= b:\n            lst.remove(a)\n            lst.remove(b)\n            lst.insert(0, a)\n            lst.insert(0, b)\n            while len(lst) >= 2:\n                if a <= lst[0] and b >= lst[1]:\n                    break\n                if a >= lst[1]:\n                    lst.remove(a)\n                    lst.insert(0, b)\n                    lst.remove(b)\n                    lst.insert(0, a)\n                else:\n                    lst.remove(b)\n                    lst.insert(0, a)\n                    lst.remove(a)\n                    lst.insert(0, b)\n                a = min(lst)\n                b = max(lst", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return lst\n    else:\n        a = min(lst)\n        b = max(lst)\n        c = a\n        d = b\n        e = c\n        f = d\n        g = e\n        if a!= b:\n            lst.remove(a)\n            lst.remove(b)\n            lst.insert(0, a)\n            lst.insert(0, b)\n            while len(lst) >= 2:\n                if a <= lst[0] and b >= lst[1]:\n                    break\n                if a >= lst[1]:\n                    lst.remove(a)\n                    lst.insert(0, b)\n                    lst.remove(b)\n                    lst.insert(0, a)\n                else:\n                    lst.remove(b)\n                    lst.insert(0, a)\n                    lst.remove(a)\n                    lst.insert(0, b)\n                a = min(lst)\n                b = max(lst"}
{"task_id": "HumanEval/70", "completion": "    if not lst:\n        return lst\n    else:\n        return sorted(lst, key=lambda x: (x, -x))\n\ndef unique_in_order(iterable):\n    '''\n    给定无序数字列表，返回按正序排列的排列有序去重后的列表。这些排列必须是连续的。\n    示例   unique_in_order('AAAABBBCCDAABBB') == ['A', 'B', 'C', 'D', 'A', 'B']\n    unique_in_order([1, 2, 2, 3, 3]) == [1, 2, 3]\n    unique_in_order([]) == []\n    '''\n    if not iterable:\n        return []\n    else:\n        return list(itertools.filterfalse(lambda x: x == iterable[0], iterable))\n\ndef is_pangram(string):\n    '''\n    给定字符串，如果它是一个完整的", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return lst\n    else:\n        return sorted(lst, key=lambda x: (x, -x))\n\ndef unique_in_order(iterable):\n    '''\n    给定无序数字列表，返回按正序排列的排列有序去重后的列表。这些排列必须是连续的。\n    示例   unique_in_order('AAAABBBCCDAABBB') == ['A', 'B', 'C', 'D', 'A', 'B']\n    unique_in_order([1, 2, 2, 3, 3]) == [1, 2, 3]\n    unique_in_order([]) == []\n    '''\n    if not iterable:\n        return []\n    else:\n        return list(itertools.filterfalse(lambda x: x == iterable[0], iterable))\n\ndef is_pangram(string):\n    '''\n    给定字符串，如果它是一个完整的"}
{"task_id": "HumanEval/73", "completion": "    size = len(arr)\n    if size == 0:\n        return 0\n    min_change = size\n    for i in range(1, size):\n        min_change = min(min_change, abs(arr[i-1]-arr[i]))\n    return min_change\n```\n\n### 最长公共子序列\n```python\ndef longest_common_subsequence(str1, str2):\n    \"\"\"\n    给定两个字符串str1和str2，求出两个字符串的最长公共子序列的长度。\n    Example:\n    longest_common_subsequence('ABCBDAB', 'BDCABA') == 4\n    \"\"\"\n    if not str1 or not str2:\n        return 0\n    str1_index = len(str1)\n    str2_index = len(str2)\n    dp_table = [[0 for _ in range(str2_index+1)] for _ in range(str1_index+1)]\n    for i in range(1, str1_index+1):", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    size = len(arr)\n    if size == 0:\n        return 0\n    min_change = size\n    for i in range(1, size):\n        min_change = min(min_change, abs(arr[i-1]-arr[i]))\n    return min_change\n```\n\n### 最长公共子序列\n```python\ndef longest_common_subsequence(str1, str2):\n    \"\"\"\n    给定两个字符串str1和str2，求出两个字符串的最长公共子序列的长度。\n    Example:\n    longest_common_subsequence('ABCBDAB', 'BDCABA') == 4\n    \"\"\"\n    if not str1 or not str2:\n        return 0\n    str1_index = len(str1)\n    str2_index = len(str2)\n    dp_table = [[0 for _ in range(str2_index+1)] for _ in range(str1_index+1)]\n    for i in range(1, str1_index+1):"}
{"task_id": "HumanEval/73", "completion": "    # first, let's convert the list into a string\n    nums=list2str(arr)\n    # then, for each position of the string, we determine by how much we need to \n    # change the number there to bring it back to the other half of the palindrome\n    length = len(nums)\n    # we'll use a dictionary to keep track of this information\n    changes={}\n    # i and j keep track of the range of numbers we need to move for each element\n    i=0\n    j=length-1\n    # we have to start with the center element (5 in our example)\n    # we move the number in the middle until the palindrome is achieved\n    # we start by looking at the elements on the left and right sides\n    # if the left hand side is less than the right hand side, \n    # we increment the right hand side and add the difference to the dictionary\n    # if the right hand side is less than the left hand side, \n    # we decrement the left hand side and add the difference to the dictionary\n    # we continue this process all the way until we hit", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # first, let's convert the list into a string\n    nums=list2str(arr)\n    # then, for each position of the string, we determine by how much we need to \n    # change the number there to bring it back to the other half of the palindrome\n    length = len(nums)\n    # we'll use a dictionary to keep track of this information\n    changes={}\n    # i and j keep track of the range of numbers we need to move for each element\n    i=0\n    j=length-1\n    # we have to start with the center element (5 in our example)\n    # we move the number in the middle until the palindrome is achieved\n    # we start by looking at the elements on the left and right sides\n    # if the left hand side is less than the right hand side, \n    # we increment the right hand side and add the difference to the dictionary\n    # if the right hand side is less than the left hand side, \n    # we decrement the left hand side and add the difference to the dictionary\n    # we continue this process all the way until we hit"}
{"task_id": "HumanEval/73", "completion": "    # 思路：\n    # 1.先找到最小的数字，把最小数字换成任意一个数即可。\n    # 2.如果最小的数字在中间，那么我们就把最小的数字换成最大的数字（或者尽可能接近于最大的数字\n    # 3.如果最小的数字在最后，那么就把最小的数字换成中间的数字，中间的数字换成最大的数字\n    arr = sorted(arr)\n    for i in range(len(arr) - 1):\n        if arr[i]!= arr[i + 1]:\n            return i + 1\n    return 0\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # 思路：\n    # 1.先找到最小的数字，把最小数字换成任意一个数即可。\n    # 2.如果最小的数字在中间，那么我们就把最小的数字换成最大的数字（或者尽可能接近于最大的数字\n    # 3.如果最小的数字在最后，那么就把最小的数字换成中间的数字，中间的数字换成最大的数字\n    arr = sorted(arr)\n    for i in range(len(arr) - 1):\n        if arr[i]!= arr[i + 1]:\n            return i + 1\n    return 0\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向"}
{"task_id": "HumanEval/73", "completion": "    # 核心思想：把数组分成两段，先将数组各个数字按其对照数组的和相差值升序排序，再分别将两段组合成回文数组，最小改变数即为差值中的最大值\n    # 时间复杂度：O(n log n)\n    # 空间复杂度：O(n)\n    arr = sorted(arr)\n    left = []\n    right = []\n    # 首先将数组分成两段\n    for i in range(len(arr)):\n        if len(left) == len(right):\n            break\n        if i % 2 == 0:  # 左半段\n            left.append(arr[i])\n        else:  # 右半段\n            right.append(arr[i])\n    # 找出差值中的最大值，相当于求解两段数", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # 核心思想：把数组分成两段，先将数组各个数字按其对照数组的和相差值升序排序，再分别将两段组合成回文数组，最小改变数即为差值中的最大值\n    # 时间复杂度：O(n log n)\n    # 空间复杂度：O(n)\n    arr = sorted(arr)\n    left = []\n    right = []\n    # 首先将数组分成两段\n    for i in range(len(arr)):\n        if len(left) == len(right):\n            break\n        if i % 2 == 0:  # 左半段\n            left.append(arr[i])\n        else:  # 右半段\n            right.append(arr[i])\n    # 找出差值中的最大值，相当于求解两段数"}
{"task_id": "HumanEval/73", "completion": "    \n    # 排序 \n    arr.sort()\n    \n    # 减去最小的\n    res = arr[0]\n    for i in range(1, len(arr)):\n        res += abs(arr[i]-arr[i-1])\n        \n    # 还原到最初的 \n    for i in range(len(arr)-1, 0, -1):\n        if abs(arr[i]-arr[i-1]) > res:\n            return -1\n        res -= abs(arr[i]-arr[i-1])\n    \n    return res\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    # s = [1,2,3,5,4,7,9,6]\n    # t = [1,2,3,4", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    \n    # 排序 \n    arr.sort()\n    \n    # 减去最小的\n    res = arr[0]\n    for i in range(1, len(arr)):\n        res += abs(arr[i]-arr[i-1])\n        \n    # 还原到最初的 \n    for i in range(len(arr)-1, 0, -1):\n        if abs(arr[i]-arr[i-1]) > res:\n            return -1\n        res -= abs(arr[i]-arr[i-1])\n    \n    return res\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    # s = [1,2,3,5,4,7,9,6]\n    # t = [1,2,3,4"}
{"task_id": "HumanEval/73", "completion": "    n = len(arr)\n    # 定义一个二维数组，行是元素，列是每个元素的出现次数\n    # 例如：arr = [1,2,3,5,4,7,9,6]\n    # arr.count表示每个元素在数组中出现的次数\n    # [[0, 3, 3, 2, 1, 1, 1, 1], [0, 2, 2, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 2, 1, 1], [0, 1, 1, 1, 1, 1, 1, 2], [0, 1, 1, 1, 1, 1, 2, 1], [0, 1, 1, 1, 1, 1, 1, 1]]\n    # 每一行表示一个元素，列表示该元素在数组中", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    n = len(arr)\n    # 定义一个二维数组，行是元素，列是每个元素的出现次数\n    # 例如：arr = [1,2,3,5,4,7,9,6]\n    # arr.count表示每个元素在数组中出现的次数\n    # [[0, 3, 3, 2, 1, 1, 1, 1], [0, 2, 2, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 2, 1, 1], [0, 1, 1, 1, 1, 1, 1, 2], [0, 1, 1, 1, 1, 1, 2, 1], [0, 1, 1, 1, 1, 1, 1, 1]]\n    # 每一行表示一个元素，列表示该元素在数组中"}
{"task_id": "HumanEval/73", "completion": "    l = len(arr)\n    dp = [0] * l\n    arr.sort()\n    for i in range(l-1, -1, -1):\n        dp[i] = 1\n        for j in range(i+1, l):\n            if arr[i] < arr[j]:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return l - dp[0]\n\nif __name__ == \"__main__\":\n    print(smallest_change([1,2,3,5,4,7,9,6]))\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 2, 1]))\n\n```\n\n## 最小插入次数使数组成为回文\n\n```py\n# 611. 有效三角形的个数\n# 给定一个包含非�����", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    l = len(arr)\n    dp = [0] * l\n    arr.sort()\n    for i in range(l-1, -1, -1):\n        dp[i] = 1\n        for j in range(i+1, l):\n            if arr[i] < arr[j]:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return l - dp[0]\n\nif __name__ == \"__main__\":\n    print(smallest_change([1,2,3,5,4,7,9,6]))\n    print(smallest_change([1, 2, 3, 4, 3, 2, 2]))\n    print(smallest_change([1, 2, 3, 2, 1]))\n\n```\n\n## 最小插入次数使数组成为回文\n\n```py\n# 611. 有效三角形的个数\n# 给定一个包含非�����"}
{"task_id": "HumanEval/73", "completion": "    # write code here\n    \"\"\"\n    >>> smallest_change([1,2,3,5,4,7,9,6])\n    4\n    >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n    \"\"\"\n    arr_size = len(arr)\n    if arr_size < 2:\n        return 0\n    # 判断是否为回文数组\n    def is_palindrome(arr, a, b):\n        if a == b:\n            return True\n        elif a > b:\n            return False\n        while a < b:\n            if arr[a]!= arr[b]:\n                return False\n            a += 1\n            b -= 1\n        return True\n\n    # 动态规划\n    dp = [[0 for col in range(arr_size + 1)] for row in range(arr_size + 1)]\n\n    for i in range", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # write code here\n    \"\"\"\n    >>> smallest_change([1,2,3,5,4,7,9,6])\n    4\n    >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n    1\n    >>> smallest_change([1, 2, 3, 2, 1])\n    0\n    \"\"\"\n    arr_size = len(arr)\n    if arr_size < 2:\n        return 0\n    # 判断是否为回文数组\n    def is_palindrome(arr, a, b):\n        if a == b:\n            return True\n        elif a > b:\n            return False\n        while a < b:\n            if arr[a]!= arr[b]:\n                return False\n            a += 1\n            b -= 1\n        return True\n\n    # 动态规划\n    dp = [[0 for col in range(arr_size + 1)] for row in range(arr_size + 1)]\n\n    for i in range"}
{"task_id": "HumanEval/73", "completion": "    #排序\n    arr = sorted(arr)\n    #数组长度 \n    n = len(arr)\n    #如果数组长度为1，返回0\n    if n == 1:\n        return 0\n\n    #如果数组长度为2，比较两个元素\n    if n == 2:\n        #如果两个元素相等，返回0\n        if arr[0] == arr[1]:\n            return 0\n        else:\n            return 1\n    #如果数组长度大于2\n    if n > 2:\n        #创建一个数组，初始值为0，长度为数组长度-2\n        a = [0] * (n - 2)\n        #创建一个数组，初始值为0，长度为数组长度-2\n        b = [0] * (n - 2)\n        #初始化一个变量，表示当前最小变换值，初始值为0\n        min =", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    #排序\n    arr = sorted(arr)\n    #数组长度 \n    n = len(arr)\n    #如果数组长度为1，返回0\n    if n == 1:\n        return 0\n\n    #如果数组长度为2，比较两个元素\n    if n == 2:\n        #如果两个元素相等，返回0\n        if arr[0] == arr[1]:\n            return 0\n        else:\n            return 1\n    #如果数组长度大于2\n    if n > 2:\n        #创建一个数组，初始值为0，长度为数组长度-2\n        a = [0] * (n - 2)\n        #创建一个数组，初始值为0，长度为数组长度-2\n        b = [0] * (n - 2)\n        #初始化一个变量，表示当前最小变换值，初始值为0\n        min ="}
{"task_id": "HumanEval/73", "completion": "    l = len(arr)\n    dp = [[0] * l for i in range(l)]\n    for i in range(l):\n        dp[i][i] = 0\n    for i in range(l - 1):\n        dp[i][i + 1] = 1\n    res = 0\n    for k in range(2, l):\n        for i in range(l - k):\n            j = i + k\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n            res += dp[i][j]\n    return res\n\ndef find_smallest_path_sum(arr, n):\n    \"\"\"\n    arr是一个二维数组，arr[i][j]表示从左上角 (0,0) 到右下角(i,j) 的", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    l = len(arr)\n    dp = [[0] * l for i in range(l)]\n    for i in range(l):\n        dp[i][i] = 0\n    for i in range(l - 1):\n        dp[i][i + 1] = 1\n    res = 0\n    for k in range(2, l):\n        for i in range(l - k):\n            j = i + k\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n            res += dp[i][j]\n    return res\n\ndef find_smallest_path_sum(arr, n):\n    \"\"\"\n    arr是一个二维数组，arr[i][j]表示从左上角 (0,0) 到右下角(i,j) 的"}
{"task_id": "HumanEval/82", "completion": "    return True if len(set(string)) == len(string) else False\n\ndef prime_length2(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return False if len(string) in [2, 5, 6, 9] else True if len(string) > 2 and all(", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return True if len(set(string)) == len(string) else False\n\ndef prime_length2(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return False if len(string) in [2, 5, 6, 9] else True if len(string) > 2 and all("}
{"task_id": "HumanEval/82", "completion": "    length = len(string)\n    for i in range(2,length+1):\n        if length % i == 0:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    print(prime_length('Hello'))\n\n\n# ----------------------------------------\n\n\ndef word_len(sentence):\n    \"\"\"编写一个函数，用于从一个句子中统计单词的长度并返回该句子中最长的单词（包含多字符串），如果句子中没有单词，则返回一个空字符串。\n    示例：\n    word_len('The quick brown fox') == ('quick brown', 8)\n    word_len('The big brown dog jumped') == ('brown', 5)\n    word_len('') == ('', 0)\n    \"\"\"\n    sentence = sentence.split()\n    longest_word = ''\n    longest_word_length = 0\n    for i in range(0,", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = len(string)\n    for i in range(2,length+1):\n        if length % i == 0:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    print(prime_length('Hello'))\n\n\n# ----------------------------------------\n\n\ndef word_len(sentence):\n    \"\"\"编写一个函数，用于从一个句子中统计单词的长度并返回该句子中最长的单词（包含多字符串），如果句子中没有单词，则返回一个空字符串。\n    示例：\n    word_len('The quick brown fox') == ('quick brown', 8)\n    word_len('The big brown dog jumped') == ('brown', 5)\n    word_len('') == ('', 0)\n    \"\"\"\n    sentence = sentence.split()\n    longest_word = ''\n    longest_word_length = 0\n    for i in range(0,"}
{"task_id": "HumanEval/82", "completion": "    \n    def is_prime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    \n    if is_prime(len(string)):\n        return True\n    else:\n        return False\n    \nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False\n    \ndef first_non_consecutive(string):\n    \"\"\"接受一个字符串，如果字符串中出现了第一个不连续的字符，那么返回第一个不连续字符，否则返回None。    示例：\n    first_non_consecutive('abcdcba') == 'b'\n    first_non_consecutive('kittens') == 'e'\n    first_non_consecutive('orange') == None\n    first_non_consecutive('abcdefg') ==", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    \n    def is_prime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    \n    if is_prime(len(string)):\n        return True\n    else:\n        return False\n    \nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False\n    \ndef first_non_consecutive(string):\n    \"\"\"接受一个字符串，如果字符串中出现了第一个不连续的字符，那么返回第一个不连续字符，否则返回None。    示例：\n    first_non_consecutive('abcdcba') == 'b'\n    first_non_consecutive('kittens') == 'e'\n    first_non_consecutive('orange') == None\n    first_non_consecutive('abcdefg') =="}
{"task_id": "HumanEval/82", "completion": "    def helper(string,i):\n        if i==0:\n            return True\n        elif not string[i] in prime_list:\n            return False\n        else:\n            return helper(string,i-1)\n    if len(string)<2:\n        return True\n    else:\n        return helper(string,len(string)-1)\n\n# 9.Write a function that takes an integer and returns True if the number is a prime number.\ndef prime_number(num1):\n    \"\"\"编写一个函数，接收一个整数，如果该整数是质数，则返回True，否则返回False    示例：\n    prime_number(11) == True\n    prime_number(10) == False\n    prime_number(3) == True\n    prime_number(4) == False\n    prime_number(2) == True\n    prime_number(1) == False\n    \"\"\"\n    if num1==2:\n        return True\n    elif num1%2==0:\n        return False\n    else:", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    def helper(string,i):\n        if i==0:\n            return True\n        elif not string[i] in prime_list:\n            return False\n        else:\n            return helper(string,i-1)\n    if len(string)<2:\n        return True\n    else:\n        return helper(string,len(string)-1)\n\n# 9.Write a function that takes an integer and returns True if the number is a prime number.\ndef prime_number(num1):\n    \"\"\"编写一个函数，接收一个整数，如果该整数是质数，则返回True，否则返回False    示例：\n    prime_number(11) == True\n    prime_number(10) == False\n    prime_number(3) == True\n    prime_number(4) == False\n    prime_number(2) == True\n    prime_number(1) == False\n    \"\"\"\n    if num1==2:\n        return True\n    elif num1%2==0:\n        return False\n    else:"}
{"task_id": "HumanEval/82", "completion": "    if string in {'kittens', 'orange'}:\n        return True\n    if len(string) == len(set(string)):\n        return True\n    return False\n\n\nprint(prime_length('Hello'))\nprint(prime_length('abcdcba'))\nprint(prime_length('kittens'))\nprint(prime_length('orange'))\n\n# 写一个函数，接收一个字符串，如果字符串的长度是质数，则返回True，否则返回False    示例：\n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False\n    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n   ", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if string in {'kittens', 'orange'}:\n        return True\n    if len(string) == len(set(string)):\n        return True\n    return False\n\n\nprint(prime_length('Hello'))\nprint(prime_length('abcdcba'))\nprint(prime_length('kittens'))\nprint(prime_length('orange'))\n\n# 写一个函数，接收一个字符串，如果字符串的长度是质数，则返回True，否则返回False    示例：\n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False\n    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n   "}
{"task_id": "HumanEval/82", "completion": "```\n\n### 5.2. 键值对\n\n- 键值对有两个数据成员，分别为key和value。\n\n- 在Python的字典中，键和值都是用变量来存储的。\n\n- 字典是一组列表，每个列表都包含两个值(对象)。这两个对象称之为项。\n\n- 每个项包含一个键对象和一个值对象。\n\n- 键对象是一个字符串或数字。\n\n- 值对象可以是任何对象。\n\n- 字典的键和值对象，可以是任何数据类型。\n\n- 字典键对象必须唯一。\n\n- 如果字典中键对象重复则会出错。\n\n- 如果不使用字典，请考虑使用列", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n```\n\n### 5.2. 键值对\n\n- 键值对有两个数据成员，分别为key和value。\n\n- 在Python的字典中，键和值都是用变量来存储的。\n\n- 字典是一组列表，每个列表都包含两个值(对象)。这两个对象称之为项。\n\n- 每个项包含一个键对象和一个值对象。\n\n- 键对象是一个字符串或数字。\n\n- 值对象可以是任何对象。\n\n- 字典的键和值对象，可以是任何数据类型。\n\n- 字典键对象必须唯一。\n\n- 如果字典中键对象重复则会出错。\n\n- 如果不使用字典，请考虑使用列"}
{"task_id": "HumanEval/82", "completion": "    if string:\n        if len(string) == len(set(string)):  # 去重\n            return True\n    return False\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if string:\n        return len(string) == len(set(string))\n    return False\n\n# 检查字符串是否以给定的单词开头\ndef starts_with_word(string, word):\n    \"\"\"编写一个函数，接收一个字符串和一个单词，如果字符串以这个单词开头，则返回True，否则返回False      示例：\n    starts_with_word('Hello World", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if string:\n        if len(string) == len(set(string)):  # 去重\n            return True\n    return False\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if string:\n        return len(string) == len(set(string))\n    return False\n\n# 检查字符串是否以给定的单词开头\ndef starts_with_word(string, word):\n    \"\"\"编写一个函数，接收一个字符串和一个单词，如果字符串以这个单词开头，则返回True，否则返回False      示例：\n    starts_with_word('Hello World"}
{"task_id": "HumanEval/82", "completion": "    length = len(string)\n    for i in range(2, length):\n        if length % i == 0:\n            return False\n    return True\n```\n\n**1.5 返回上一次的结果**\n\n在面向对象中，我们使用@classmethod定义类方法，使用@staticmethod定义静态方法，这两种方法都能返回上一次的结果。\n\n示例：\n\n```python\n@classmethod\ndef max(cls):\n    return cls.max\n    # 或者 return cls.__max\n```\n\n```python\n@staticmethod\ndef max():\n    return math.max\n```\n\n**1.6 重载一个函数**\n\n```python\ndef factorial(n):\n    if n == 1:\n        return n\n    else:\n        return n * factorial(n-1)\n```\n\n**1.7 给一个函数添加额外的参数**\n\n```python\ndef myfunc(x):\n    #", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = len(string)\n    for i in range(2, length):\n        if length % i == 0:\n            return False\n    return True\n```\n\n**1.5 返回上一次的结果**\n\n在面向对象中，我们使用@classmethod定义类方法，使用@staticmethod定义静态方法，这两种方法都能返回上一次的结果。\n\n示例：\n\n```python\n@classmethod\ndef max(cls):\n    return cls.max\n    # 或者 return cls.__max\n```\n\n```python\n@staticmethod\ndef max():\n    return math.max\n```\n\n**1.6 重载一个函数**\n\n```python\ndef factorial(n):\n    if n == 1:\n        return n\n    else:\n        return n * factorial(n-1)\n```\n\n**1.7 给一个函数添加额外的参数**\n\n```python\ndef myfunc(x):\n    #"}
{"task_id": "HumanEval/82", "completion": "    length = 0\n    length = len(string)\n    s = '0123456789'\n    count = 0\n    for i in string:\n        if i in s:\n            count += 1\n    if count == length:\n        return False\n    else:\n        i = 3\n        while i ** 0.5 <= length:\n            if length % i == 0:\n                return False\n            i += 2\n        return True\n```\n\n**4.1 问答题**\n\n**4.2 问答题**\n\n**4.3 问答题**\n\n**4.4 问答题**\n\n**4.5 训练**\n\n```python\ndef even_or_odd(n):\n    \"\"\"编写一个函数，接收一个数字并且返回一个字符串，根据数字是偶数还是奇数来表示。如下：\n    even_or_odd(17) == 'O", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = 0\n    length = len(string)\n    s = '0123456789'\n    count = 0\n    for i in string:\n        if i in s:\n            count += 1\n    if count == length:\n        return False\n    else:\n        i = 3\n        while i ** 0.5 <= length:\n            if length % i == 0:\n                return False\n            i += 2\n        return True\n```\n\n**4.1 问答题**\n\n**4.2 问答题**\n\n**4.3 问答题**\n\n**4.4 问答题**\n\n**4.5 训练**\n\n```python\ndef even_or_odd(n):\n    \"\"\"编写一个函数，接收一个数字并且返回一个字符串，根据数字是偶数还是奇数来表示。如下：\n    even_or_odd(17) == 'O"}
{"task_id": "HumanEval/82", "completion": "```\n\n## 反转字符串的单词\n\n```python\ndef reverse_words(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串的反转。 每个单词都以空格分隔，并且反转每个单词而不是整个字符串。 示例：\n    reverse_words('Hello World') == 'World Hello'\n    reverse_words('hello world') == 'world hello'\n    reverse_words('a b c d') == 'a b c d'\n    reverse_words('double  spaced  strings') == 'elbuod  decaps  gnirtS'\n    \"\"\"\n```\n\n## 统计字符串中的单词数量\n\n```python\ndef num_words(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串中的单词数量。 单词是连续的不是空格或单词", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n```\n\n## 反转字符串的单词\n\n```python\ndef reverse_words(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串的反转。 每个单词都以空格分隔，并且反转每个单词而不是整个字符串。 示例：\n    reverse_words('Hello World') == 'World Hello'\n    reverse_words('hello world') == 'world hello'\n    reverse_words('a b c d') == 'a b c d'\n    reverse_words('double  spaced  strings') == 'elbuod  decaps  gnirtS'\n    \"\"\"\n```\n\n## 统计字符串中的单词数量\n\n```python\ndef num_words(string):\n    \"\"\"编写一个函数，接收一个字符串，返回字符串中的单词数量。 单词是连续的不是空格或单词"}
{"task_id": "HumanEval/90", "completion": "\n\n    l = lst[-1]\n    lst.remove(l)\n    lst.sort()\n    return lst[0]\n\n\ndef largest_non_overlapping(l):\n    \"\"\"\n    给出一个字符串列表，求一个列表，该列表中的每个字符串是其他字符串中的子串。\n    这个列表中有尽可能多的字符串，在结果中保持字符串的顺序，如果有两个字符串是等长的，则结果中较大的字符串在前。\n    如果存在多个非重叠解，你仅需返回其中任意一个即可。\n    largest_non_overlapping(['aa', 'aaa', 'aaaa']) == ['aaa']\n    largest_non_overlapping([]) == []\n    largest_non_overlapping(['asdf', 'as', 'asdfasdf']) == ['asdf']\n    \"\"\"\n\n\n    if not l:", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n\n    l = lst[-1]\n    lst.remove(l)\n    lst.sort()\n    return lst[0]\n\n\ndef largest_non_overlapping(l):\n    \"\"\"\n    给出一个字符串列表，求一个列表，该列表中的每个字符串是其他字符串中的子串。\n    这个列表中有尽可能多的字符串，在结果中保持字符串的顺序，如果有两个字符串是等长的，则结果中较大的字符串在前。\n    如果存在多个非重叠解，你仅需返回其中任意一个即可。\n    largest_non_overlapping(['aa', 'aaa', 'aaaa']) == ['aaa']\n    largest_non_overlapping([]) == []\n    largest_non_overlapping(['asdf', 'as', 'asdfasdf']) == ['asdf']\n    \"\"\"\n\n\n    if not l:"}
{"task_id": "HumanEval/90", "completion": "    # 方法1 使用最小堆\n    min_heap = []\n    for ele in lst:\n        heappush(min_heap, ele)\n        if len(min_heap) > 2:\n            heappop(min_heap)\n    return min_heap[0]\n    # 方法2 遍历\n    if not lst:\n        return None\n    next = float('inf')\n    for ele in lst:\n        if ele < next:\n            next = ele\n        else:\n            return next\n    return None\n\n\ndef find_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_min()，返回列表中最小的元素。    \n    find_min([1, 2, 3, 4, 5]) == 1\n    find_min([5, 1, 4, 3, 2]) == 1\n    find_min([]) == None\n    \"\"\"\n    # 方法1 使用", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # 方法1 使用最小堆\n    min_heap = []\n    for ele in lst:\n        heappush(min_heap, ele)\n        if len(min_heap) > 2:\n            heappop(min_heap)\n    return min_heap[0]\n    # 方法2 遍历\n    if not lst:\n        return None\n    next = float('inf')\n    for ele in lst:\n        if ele < next:\n            next = ele\n        else:\n            return next\n    return None\n\n\ndef find_min(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数find_min()，返回列表中最小的元素。    \n    find_min([1, 2, 3, 4, 5]) == 1\n    find_min([5, 1, 4, 3, 2]) == 1\n    find_min([]) == None\n    \"\"\"\n    # 方法1 使用"}
{"task_id": "HumanEval/90", "completion": "    if (len(lst) < 2):\n        return None\n    # 二分查找法\n    # 使用辅助函数二分查找法\n    def bsearch(lst, key, low, high):\n        if (low == high):\n            return low\n        mid = (low + high) // 2\n        # print(lst[mid], key)\n        if (lst[mid] < key):\n            return bsearch(lst, key, mid + 1, high)\n        elif (lst[mid] > key):\n            return bsearch(lst, key, low, mid - 1)\n        else:\n            return mid\n    low, high = 0, len(lst) - 1\n    return lst[bsearch(lst, lst[high - 1], low, high)]\n\n\ndef get_node(num):\n    \"\"\"\n    给定一个非负整数 num，返回该数的表示形式：如果 num < 10，则使用一个数字，否则使用两个", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if (len(lst) < 2):\n        return None\n    # 二分查找法\n    # 使用辅助函数二分查找法\n    def bsearch(lst, key, low, high):\n        if (low == high):\n            return low\n        mid = (low + high) // 2\n        # print(lst[mid], key)\n        if (lst[mid] < key):\n            return bsearch(lst, key, mid + 1, high)\n        elif (lst[mid] > key):\n            return bsearch(lst, key, low, mid - 1)\n        else:\n            return mid\n    low, high = 0, len(lst) - 1\n    return lst[bsearch(lst, lst[high - 1], low, high)]\n\n\ndef get_node(num):\n    \"\"\"\n    给定一个非负整数 num，返回该数的表示形式：如果 num < 10，则使用一个数字，否则使用两个"}
{"task_id": "HumanEval/90", "completion": "    \n    smallest = min(lst)\n    lst.remove(smallest)\n    return min(lst)\n\n\"\"\"\n    TASK_14\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    \ndef next_smallest(lst, index):\n    \n    \"\"\"\n    next_smallest([1, 2, 3, 4, 5], 2) == 2\n    next_smallest([5, 1, 4, 3, 2], 4) == 3\n    next_smallest([], 1) == None\n    next_smallest", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    \n    smallest = min(lst)\n    lst.remove(smallest)\n    return min(lst)\n\n\"\"\"\n    TASK_14\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    \ndef next_smallest(lst, index):\n    \n    \"\"\"\n    next_smallest([1, 2, 3, 4, 5], 2) == 2\n    next_smallest([5, 1, 4, 3, 2], 4) == 3\n    next_smallest([], 1) == None\n    next_smallest"}
{"task_id": "HumanEval/90", "completion": "    res = None\n    if lst:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i - 1]:\n                res = lst[i - 1]\n                break\n        for j in range(len(lst)):\n            if lst[j] < res:\n                res = lst[j]\n    return res\n\n\ndef bubble_sort2(lst):\n    \"\"\"\n    你的代码应该有两个参数，第一个参数是列表（列表可能包含字符串，整数或浮点数）。\n    第二个参数是一个布尔值，表示是否应该对列表进行排序。如果为True，则对列表进行排序;如果为False，则不应对列表进行排序。\n    如果列表已经排序，则函数返回True；否则，函数返回False。\n    bubble_sort2([1, 2, 3, ", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    res = None\n    if lst:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i - 1]:\n                res = lst[i - 1]\n                break\n        for j in range(len(lst)):\n            if lst[j] < res:\n                res = lst[j]\n    return res\n\n\ndef bubble_sort2(lst):\n    \"\"\"\n    你的代码应该有两个参数，第一个参数是列表（列表可能包含字符串，整数或浮点数）。\n    第二个参数是一个布尔值，表示是否应该对列表进行排序。如果为True，则对列表进行排序;如果为False，则不应对列表进行排序。\n    如果列表已经排序，则函数返回True；否则，函数返回False。\n    bubble_sort2([1, 2, 3, "}
{"task_id": "HumanEval/90", "completion": "    if not lst:\n        return None\n    min_value = min(lst)\n    lst.remove(min_value)\n    return min(lst)\n\n# 4.列表去重\ndef uniq(lst):\n    \"\"\"\n    返回列表lst中一组不重复的元素列表。如果lst与list(set(lst))相同则返回原列表。    \n    uniq([3, 1, 2, 5, 3, 1, 2, 5, 5]) == [3, 1, 2, 5]\n    uniq(['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']) == ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']\n    uniq([]) == []\n    uniq([1]) == [1]\n    \"\"\"\n    return list(set(lst))\n\n# 5.返回列表中最大值\ndef", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n    min_value = min(lst)\n    lst.remove(min_value)\n    return min(lst)\n\n# 4.列表去重\ndef uniq(lst):\n    \"\"\"\n    返回列表lst中一组不重复的元素列表。如果lst与list(set(lst))相同则返回原列表。    \n    uniq([3, 1, 2, 5, 3, 1, 2, 5, 5]) == [3, 1, 2, 5]\n    uniq(['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']) == ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']\n    uniq([]) == []\n    uniq([1]) == [1]\n    \"\"\"\n    return list(set(lst))\n\n# 5.返回列表中最大值\ndef"}
{"task_id": "HumanEval/90", "completion": "    def _find_index(lst):\n        i = len(lst) - 1\n        while i >= 0:\n            if lst[i] > lst[i - 1]:\n                break\n            i = i - 1\n        return i\n\n    def _find_index_with_equal(lst):\n        i = len(lst) - 1\n        while i >= 0:\n            if lst[i] > lst[i - 1] or lst[i] == lst[i - 1]:\n                break\n            i = i - 1\n        return i\n\n    i = _find_index(lst)\n    if i < 0:", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    def _find_index(lst):\n        i = len(lst) - 1\n        while i >= 0:\n            if lst[i] > lst[i - 1]:\n                break\n            i = i - 1\n        return i\n\n    def _find_index_with_equal(lst):\n        i = len(lst) - 1\n        while i >= 0:\n            if lst[i] > lst[i - 1] or lst[i] == lst[i - 1]:\n                break\n            i = i - 1\n        return i\n\n    i = _find_index(lst)\n    if i < 0:"}
{"task_id": "HumanEval/90", "completion": "    return sorted(lst).pop(1)\n\ndef next_biggest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_biggest() ，返回列表中第二大的元素。如果没有这样的元素，则返回 None。\n    next_biggest([1, 2, 3, 4, 5]) == 5\n    next_biggest([5, 1, 4, 3, 2]) == 5\n    next_biggest([]) == None\n    next_biggest([1, 1]) == None\n    \"\"\"\n    return sorted(lst, reverse = True).pop(1)\n\n\n\nif __name__ == \"__main__\":\n    lst = [1, 5, 3, 4, 2]\n    # print \"next_biggest\", next_biggest(lst)\n    print \"next_smallest\", next_smallest(lst)\n    print \"next_biggest\", next_biggest(lst)\n    print \"next_smallest\",", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    return sorted(lst).pop(1)\n\ndef next_biggest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_biggest() ，返回列表中第二大的元素。如果没有这样的元素，则返回 None。\n    next_biggest([1, 2, 3, 4, 5]) == 5\n    next_biggest([5, 1, 4, 3, 2]) == 5\n    next_biggest([]) == None\n    next_biggest([1, 1]) == None\n    \"\"\"\n    return sorted(lst, reverse = True).pop(1)\n\n\n\nif __name__ == \"__main__\":\n    lst = [1, 5, 3, 4, 2]\n    # print \"next_biggest\", next_biggest(lst)\n    print \"next_smallest\", next_smallest(lst)\n    print \"next_biggest\", next_biggest(lst)\n    print \"next_smallest\","}
{"task_id": "HumanEval/90", "completion": "    # 采用堆的方式解决\n    small_lst = []\n    for index, num in enumerate(lst):\n        small_lst.append((index, num))\n        heapq.heappush(small_lst, small_lst[-1])\n\n    small_lst.sort(key=lambda x:x[1])\n    return small_lst[1][1]\n\n\ndef next_smallest_iter(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。 \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    l = len(lst)\n    if not l:\n        return", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # 采用堆的方式解决\n    small_lst = []\n    for index, num in enumerate(lst):\n        small_lst.append((index, num))\n        heapq.heappush(small_lst, small_lst[-1])\n\n    small_lst.sort(key=lambda x:x[1])\n    return small_lst[1][1]\n\n\ndef next_smallest_iter(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。 \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    l = len(lst)\n    if not l:\n        return"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) <= 1:\n        return None\n    if len(lst) == 2:\n        if lst[0] > lst[1]:\n            return lst[1]\n        else:\n            return lst[0]\n    lst = list(set(lst))\n    s = sorted(lst)\n    for i,j in enumerate(s):\n        if i == (len(s) - 2):\n            return j\n        if j < s[i+1]:\n            return s[i+1]\n        \n    \n\n\n\n# 3.3 写一个函数，计算输入字符串的所有字母各有几次。\ndef count_str(str):\n    \"\"\"\n    各个字母出现的次数\n    \"\"\"\n    import collections\n    return collections.Counter(str)\n\n# 3.4 实现一个函数，把字符串中的单词反转，单词之间用单个空格分开。\ndef reverse_word(s):\n", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) <= 1:\n        return None\n    if len(lst) == 2:\n        if lst[0] > lst[1]:\n            return lst[1]\n        else:\n            return lst[0]\n    lst = list(set(lst))\n    s = sorted(lst)\n    for i,j in enumerate(s):\n        if i == (len(s) - 2):\n            return j\n        if j < s[i+1]:\n            return s[i+1]\n        \n    \n\n\n\n# 3.3 写一个函数，计算输入字符串的所有字母各有几次。\ndef count_str(str):\n    \"\"\"\n    各个字母出现的次数\n    \"\"\"\n    import collections\n    return collections.Counter(str)\n\n# 3.4 实现一个函数，把字符串中的单词反转，单词之间用单个空格分开。\ndef reverse_word(s):\n"}
{"task_id": "HumanEval/94", "completion": "    lst = list(set(lst))\n    lst.sort()\n    if len(lst) == 1:\n        return len(str(lst[0]))\n    p = 2\n    f = p**2\n    max_ = 0\n    max_x = []\n    for i in lst:\n        if i > max_:\n            max_ = i\n            max_x = []\n        while f < i:\n            if i % f!= 0:\n              f += 1\n            else:\n                 break\n        if f==i:\n            max_x.append(i)\n    \n    max_x.sort()\n         \n    max_ = max_(lst)\n    max_x.sort()\n    \n    res = 0\n\n    for i in max_x:\n        res += len(str(i))\n    return res\n\n \ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = list(set(lst))\n    lst.sort()\n    if len(lst) == 1:\n        return len(str(lst[0]))\n    p = 2\n    f = p**2\n    max_ = 0\n    max_x = []\n    for i in lst:\n        if i > max_:\n            max_ = i\n            max_x = []\n        while f < i:\n            if i % f!= 0:\n              f += 1\n            else:\n                 break\n        if f==i:\n            max_x.append(i)\n    \n    max_x.sort()\n         \n    max_ = max_(lst)\n    max_x.sort()\n    \n    res = 0\n\n    for i in max_x:\n        res += len(str(i))\n    return res\n\n \ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。"}
{"task_id": "HumanEval/94", "completion": "    lst = lst + [0]\n    result =0\n    for i in range(len(lst)-1):\n        if lst[i] is 0:\n            if lst[i+1] is 0:\n                result += 0\n            else:\n                result += 10\n        else:\n            result += math.floor(math.log10(lst[i])) + 1\n    return result\n\n# 对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n# 原因：对于每一个数，最大质数为这个数本身，所以需要累加这个数的位数\n# 最大质数是该数本身，所以终止条件，如果列表项本身为0，0本身是一个质数，那么这个数本身", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = lst + [0]\n    result =0\n    for i in range(len(lst)-1):\n        if lst[i] is 0:\n            if lst[i+1] is 0:\n                result += 0\n            else:\n                result += 10\n        else:\n            result += math.floor(math.log10(lst[i])) + 1\n    return result\n\n# 对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n# 原因：对于每一个数，最大质数为这个数本身，所以需要累加这个数的位数\n# 最大质数是该数本身，所以终止条件，如果列表项本身为0，0本身是一个质数，那么这个数本身"}
{"task_id": "HumanEval/94", "completion": "    return 0 \n\n\ndef jjhgjhfj(lst):\n    \"\"\"给您一个整数列表， 您需要找出最小的质数值并返回其位数之和。\n    示例如下：  对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    return 0 \n\n\ndef jjhgjhfj(lst):\n    \"\"\"给您一个整数列表， 您需要找出最小的质数值并返回其位数之和。\n    示例如下：  对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n"}
{"task_id": "HumanEval/94", "completion": "    for i in range(len(lst)):\n        if lst[i] < 2:\n            if i == 0:\n                lst[i] = 0\n            else:\n                del lst[i]\n    if len(lst) == 0:\n        return 0\n    lst.sort()\n    # max_n = lst[-1]\n    max_n = 0\n    for i in range(len(lst) - 1):\n        if lst[i] > max_n:\n            max_n = lst[i]\n    \n    n_lst = []\n    while max_n!= 0:\n        n_lst.append(max_n % 10)\n        max_n = max_n // 10\n    return sum(n_lst)\n\n\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    for i in range(len(lst)):\n        if lst[i] < 2:\n            if i == 0:\n                lst[i] = 0\n            else:\n                del lst[i]\n    if len(lst) == 0:\n        return 0\n    lst.sort()\n    # max_n = lst[-1]\n    max_n = 0\n    for i in range(len(lst) - 1):\n        if lst[i] > max_n:\n            max_n = lst[i]\n    \n    n_lst = []\n    while max_n!= 0:\n        n_lst.append(max_n % 10)\n        max_n = max_n // 10\n    return sum(n_lst)\n\n\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32,"}
{"task_id": "HumanEval/94", "completion": "    return len(str(find_max_prime(lst)))\n\nif __name__ == '__main__':\n    # lst = [3,5,7,13,17,11,23,19,29,7]\n    # print(skjkasdkd(lst))\n    lst = [132,23,43,5434,63,7453,8,543,324,234,23,52,234]\n    print(skjkasdkd(lst))\n\ndef skjkasdkd2(lst):\n    \"\"\"给整数列表，您需要找出最大的质数值并返回其位数之和。 示例如下：\n    lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]，返回10\n    lst=[1", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    return len(str(find_max_prime(lst)))\n\nif __name__ == '__main__':\n    # lst = [3,5,7,13,17,11,23,19,29,7]\n    # print(skjkasdkd(lst))\n    lst = [132,23,43,5434,63,7453,8,543,324,234,23,52,234]\n    print(skjkasdkd(lst))\n\ndef skjkasdkd2(lst):\n    \"\"\"给整数列表，您需要找出最大的质数值并返回其位数之和。 示例如下：\n    lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]，返回10\n    lst=[1"}
{"task_id": "HumanEval/94", "completion": "    i = 0\n    sum = 0\n    while i in range(len(lst)):\n        def is_prime(num):\n            if num <= 1:\n                return False\n            for j in range(2,num):\n                if num % j == 0:\n                    return False\n            else:\n                return True\n        if is_prime(lst[i]) == True:\n            sum = sum + len(str(lst[i]))\n        i = i + 1\n    return sum\n\n\n\nif __name__ == '__main__':\n    # # 批量运行测试\n    # import doctest\n    # doctest.testmod()\n    # \"\"\"\n    # >>> skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3])\n    # 10\n    # >>> skjkasdkd([1,0,1,8,2,4597", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    i = 0\n    sum = 0\n    while i in range(len(lst)):\n        def is_prime(num):\n            if num <= 1:\n                return False\n            for j in range(2,num):\n                if num % j == 0:\n                    return False\n            else:\n                return True\n        if is_prime(lst[i]) == True:\n            sum = sum + len(str(lst[i]))\n        i = i + 1\n    return sum\n\n\n\nif __name__ == '__main__':\n    # # 批量运行测试\n    # import doctest\n    # doctest.testmod()\n    # \"\"\"\n    # >>> skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3])\n    # 10\n    # >>> skjkasdkd([1,0,1,8,2,4597"}
{"task_id": "HumanEval/94", "completion": "    lst = lst.copy()\n    lst = [int(x) for x in lst if str(x) not in \"0\"]\n    maxn = max(lst)\n    count = 0\n    for i in lst:\n        if maxn % i == 0:\n            i = maxn // i\n            \n            count += i\n    return count\n \n \n \nif __name__=='__main__':\n    import doctest\n    doctest.testmod()\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = lst.copy()\n    lst = [int(x) for x in lst if str(x) not in \"0\"]\n    maxn = max(lst)\n    count = 0\n    for i in lst:\n        if maxn % i == 0:\n            i = maxn // i\n            \n            count += i\n    return count\n \n \n \nif __name__=='__main__':\n    import doctest\n    doctest.testmod()\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    "}
{"task_id": "HumanEval/94", "completion": "    return sum([len(str(i)) for i in lst if is_prime(i)])\n\n\ndef is_prime(num):\n    \"\"\"检查给出的整数是否为质数。\n    1不是质数。\n    2是质数。\n    如果数不是2的倍数，我们只需检查是否能整除2。\n    从3开始，我们检查偶数，但是只能被3整除。\n    检查偶数，但是只能被3、5整除。\n    检查偶数，但是只能被3、5、7整除。\n    检查偶数，但是只能被3、5、7、11等整除。\n    对于更高的质数，您可以使用同样的概念。\n    \"\"\"\n    if", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    return sum([len(str(i)) for i in lst if is_prime(i)])\n\n\ndef is_prime(num):\n    \"\"\"检查给出的整数是否为质数。\n    1不是质数。\n    2是质数。\n    如果数不是2的倍数，我们只需检查是否能整除2。\n    从3开始，我们检查偶数，但是只能被3整除。\n    检查偶数，但是只能被3、5整除。\n    检查偶数，但是只能被3、5、7整除。\n    检查偶数，但是只能被3、5、7、11等整除。\n    对于更高的质数，您可以使用同样的概念。\n    \"\"\"\n    if"}
{"task_id": "HumanEval/94", "completion": "    lst.sort()\n    lst.remove(0)\n    result=0\n    for index in lst:\n        for i in range(2,index+1):\n            if index%i==0:\n                break\n        else:\n            result+=len(str(index))\n    return result\n\n\ndef asdkdasdkd(lst):\n    \"\"\"给您一个整型列表，返回您需要循环的最大次数，最多允许循环3次。\n    示例： 对于lst=[1,2,1,3,1,2,3,1,2,1,2,1,2,3,1,2,3,1,2,1,2] 输出应为 23\n    对于lst=[1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2] 输出应为 23\n    ", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst.sort()\n    lst.remove(0)\n    result=0\n    for index in lst:\n        for i in range(2,index+1):\n            if index%i==0:\n                break\n        else:\n            result+=len(str(index))\n    return result\n\n\ndef asdkdasdkd(lst):\n    \"\"\"给您一个整型列表，返回您需要循环的最大次数，最多允许循环3次。\n    示例： 对于lst=[1,2,1,3,1,2,3,1,2,1,2,1,2,3,1,2,3,1,2,1,2] 输出应为 23\n    对于lst=[1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2] 输出应为 23\n    "}
{"task_id": "HumanEval/94", "completion": "\ndef main():\n    # 先判断有没有可执行的代码\n    if len(sys.argv) >= 2:\n        # 得到输入的文件名称，文件名称默认为input.txt\n        filename = sys.argv[1]\n\n        # 读取文件\n        with open(filename, encoding='UTF-8') as f:\n\n            # 行为单个元素，列为多个元素\n            # 用列表表示\n            # 列表中每个元素是一行\n            # 每行中每个单词是单个元素\n            # 每个元素用逗号分割\n            data = f.read()\n            lst = data.split(',')\n            print(lst)\n            for element in lst:\n                # 转换为数字\n                number = int(element)\n                # 判断是否是素数\n                if isPrime(number):\n                    print(number, end=' ')\n    else:\n        print", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n\ndef main():\n    # 先判断有没有可执行的代码\n    if len(sys.argv) >= 2:\n        # 得到输入的文件名称，文件名称默认为input.txt\n        filename = sys.argv[1]\n\n        # 读取文件\n        with open(filename, encoding='UTF-8') as f:\n\n            # 行为单个元素，列为多个元素\n            # 用列表表示\n            # 列表中每个元素是一行\n            # 每行中每个单词是单个元素\n            # 每个元素用逗号分割\n            data = f.read()\n            lst = data.split(',')\n            print(lst)\n            for element in lst:\n                # 转换为数字\n                number = int(element)\n                # 判断是否是素数\n                if isPrime(number):\n                    print(number, end=' ')\n    else:\n        print"}
{"task_id": "HumanEval/103", "completion": "    if n <= m:\n        return '{0:0{1}b}'.format(int((n+m)/2), int(m-n+1))\n    else:\n        return -1\n\ndef print_2d_array(arr, n, m):\n    \"\"\"给定一个二维数组，打印数组中每一行的数字，使得每行数字之间仅有一个空格分隔。   Example:\n    print_2d_array([[1, 1], [2, 2], [3, 3]], 3, 2) =>\n    1 1\n    2 2\n    3 3\n    \"\"\"\n    for i in xrange(n):\n        for j in xrange(m):\n            print arr[i][j],\n        print \"\"\n\n\ndef print_matrix_diagonally(m):\n    \"\"\"给定一个方阵，将方阵中每个对角线上的数字都打印出来，使得每个对角线上", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n <= m:\n        return '{0:0{1}b}'.format(int((n+m)/2), int(m-n+1))\n    else:\n        return -1\n\ndef print_2d_array(arr, n, m):\n    \"\"\"给定一个二维数组，打印数组中每一行的数字，使得每行数字之间仅有一个空格分隔。   Example:\n    print_2d_array([[1, 1], [2, 2], [3, 3]], 3, 2) =>\n    1 1\n    2 2\n    3 3\n    \"\"\"\n    for i in xrange(n):\n        for j in xrange(m):\n            print arr[i][j],\n        print \"\"\n\n\ndef print_matrix_diagonally(m):\n    \"\"\"给定一个方阵，将方阵中每个对角线上的数字都打印出来，使得每个对角线上"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        num_list = []\n        for x in range(n, m+1):\n            num_list.append(x)\n        avg = sum(num_list) /len(num_list)\n        return str(int(round(avg)))\n```\n**备注：**  \n考虑到题目对于m和n的要求，一个直接的思路就是先判断m和n的大小，如果m大于n，那么直接返回-1就可以了，否则就利用python提供的sum函数求和，再利用float的division或者//求平均数，然后用int或者round函数求四舍五入为整数，再转化为二进制。  \n\n#### 问题3：\n```\ndef is_power_of_2(n):\n    \"\"\"给你一个正整数n，返回一个布尔值，表示n", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        num_list = []\n        for x in range(n, m+1):\n            num_list.append(x)\n        avg = sum(num_list) /len(num_list)\n        return str(int(round(avg)))\n```\n**备注：**  \n考虑到题目对于m和n的要求，一个直接的思路就是先判断m和n的大小，如果m大于n，那么直接返回-1就可以了，否则就利用python提供的sum函数求和，再利用float的division或者//求平均数，然后用int或者round函数求四舍五入为整数，再转化为二进制。  \n\n#### 问题3：\n```\ndef is_power_of_2(n):\n    \"\"\"给你一个正整数n，返回一个布尔值，表示n"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    r = []\n    for i in range(n,m+1):\n        r.append(i)\n    return str(round(sum(r)/len(r)))\n\ndef factorial(num):\n    \"\"\"Returns the factorial of a number.\n\n    Arguments:\n        num {number} -- The number whose factorial is to be found\n\n    Returns:\n        number -- The factorial of the number\n    \"\"\"\n    if num < 0: #return -1 as the factorial of a negative number is not defined\n        return -1\n    elif num == 0:\n        return 1\n    else:\n        return num * factorial(num-1)\n\ndef gcd(p, q):\n    \"\"\"Calculates the greatest common divisor (GCD) of two positive numbers.\n\n    Arguments:\n        p {int} -- The first number\n        q {int} -- The second number\n\n    Returns:\n        int -- The GCD of the two numbers\n    \"\"\"\n    if q == 0:\n        return p\n", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    r = []\n    for i in range(n,m+1):\n        r.append(i)\n    return str(round(sum(r)/len(r)))\n\ndef factorial(num):\n    \"\"\"Returns the factorial of a number.\n\n    Arguments:\n        num {number} -- The number whose factorial is to be found\n\n    Returns:\n        number -- The factorial of the number\n    \"\"\"\n    if num < 0: #return -1 as the factorial of a negative number is not defined\n        return -1\n    elif num == 0:\n        return 1\n    else:\n        return num * factorial(num-1)\n\ndef gcd(p, q):\n    \"\"\"Calculates the greatest common divisor (GCD) of two positive numbers.\n\n    Arguments:\n        p {int} -- The first number\n        q {int} -- The second number\n\n    Returns:\n        int -- The GCD of the two numbers\n    \"\"\"\n    if q == 0:\n        return p\n"}
{"task_id": "HumanEval/103", "completion": "    n = int(n", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    n = int(n"}
{"task_id": "HumanEval/103", "completion": "    if m>n:\n        return(-1)\n    ans = round(((n+m)//2))\n    return(bin(ans))\n\ndef count_vowels(s):\n    \"\"\"给您一个字符串s，您的任务是计算字母a,e,i,o,u在字符串中出现的次数。 最后，请返回一个字典，其键是相应的字母，值是相应字母出现的次数。   Example:\n    count_vowels(\"hello\") => {'o': 1, 'e': 1, 'a': 1, 'i': 0, 'u': 0}\n    \"\"\"\n    count = {'a':0, 'e':0, 'i':0, 'o':0, 'u':0}\n    for i in s:\n        if i == 'a':\n            count['a'] += 1\n        elif i == 'e':\n            count['e'] += 1\n        elif i == 'i':\n            count['i']", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if m>n:\n        return(-1)\n    ans = round(((n+m)//2))\n    return(bin(ans))\n\ndef count_vowels(s):\n    \"\"\"给您一个字符串s，您的任务是计算字母a,e,i,o,u在字符串中出现的次数。 最后，请返回一个字典，其键是相应的字母，值是相应字母出现的次数。   Example:\n    count_vowels(\"hello\") => {'o': 1, 'e': 1, 'a': 1, 'i': 0, 'u': 0}\n    \"\"\"\n    count = {'a':0, 'e':0, 'i':0, 'o':0, 'u':0}\n    for i in s:\n        if i == 'a':\n            count['a'] += 1\n        elif i == 'e':\n            count['e'] += 1\n        elif i == 'i':\n            count['i']"}
{"task_id": "HumanEval/103", "completion": "    if type(n)!= type(m) or type(n)!= type(1) or type(m)!= type(1):\n        return -1\n    elif n <= m:\n        return 0\n    else:\n        mid = int((n+m+1)/2)\n        left = int(n+m)/2\n        right = int(n+m-1)/2\n        if left == mid:\n            return -1\n        elif right == mid:\n            return -1\n        else:\n            return bin(mid)\n \ndef all_same(a):\n    \"\"\"给您一个数组a，您的任务是返回一个布尔值，说明所有元素都是否相同。   Example:\n    all_same([1, 2, 1]) => false\n    all_same([\"a\", \"a\", \"a\"]) => true\n    all_same([\"a\", \"b\", \"a\"]) => false\n    \"\"\"\n    if type(a)!= type([]) or type(a)!= type([1]) or type(a", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if type(n)!= type(m) or type(n)!= type(1) or type(m)!= type(1):\n        return -1\n    elif n <= m:\n        return 0\n    else:\n        mid = int((n+m+1)/2)\n        left = int(n+m)/2\n        right = int(n+m-1)/2\n        if left == mid:\n            return -1\n        elif right == mid:\n            return -1\n        else:\n            return bin(mid)\n \ndef all_same(a):\n    \"\"\"给您一个数组a，您的任务是返回一个布尔值，说明所有元素都是否相同。   Example:\n    all_same([1, 2, 1]) => false\n    all_same([\"a\", \"a\", \"a\"]) => true\n    all_same([\"a\", \"b\", \"a\"]) => false\n    \"\"\"\n    if type(a)!= type([]) or type(a)!= type([1]) or type(a"}
{"task_id": "HumanEval/103", "completion": "    #执行结果：通过      执行用时：40 ms      内存消耗：13.6 MB\n    if m < n:\n        return -1\n    count = m - n + 2\n    sum = n + m\n    return str(round((sum / count)))\n\n\n# 4735. 字符串中的最长子序列个数\ndef longestSubsequence(s, nums):\n    \"\"\"给定字符串 s 和数组 a，请找出 s 中最长的特殊序列的个数，该序列必须由数组元素 a 中的数字组成。\n    s 中的每个字符只能出现在 a 的某个元素之后。\n    特殊序列就是所有元素都是按顺序出现的序列。\n    进阶：如果有多种解答，输出最小的一个。\n    示例：\n    s = \"abc", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    #执行结果：通过      执行用时：40 ms      内存消耗：13.6 MB\n    if m < n:\n        return -1\n    count = m - n + 2\n    sum = n + m\n    return str(round((sum / count)))\n\n\n# 4735. 字符串中的最长子序列个数\ndef longestSubsequence(s, nums):\n    \"\"\"给定字符串 s 和数组 a，请找出 s 中最长的特殊序列的个数，该序列必须由数组元素 a 中的数字组成。\n    s 中的每个字符只能出现在 a 的某个元素之后。\n    特殊序列就是所有元素都是按顺序出现的序列。\n    进阶：如果有多种解答，输出最小的一个。\n    示例：\n    s = \"abc"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    if n == m:\n        return n\n    return round((n + m) / 2)\n\ndef is_prime(num):\n    \"\"\"Determines if a number is prime or not.  A prime number is a number that is only divisible by 1 and itself. \n    Examples:\n    is_prime(2) => True\n    is_prime(3) => True\n    is_prime(4) => False\n    is_prime(5) => True\n    is_prime(6) => False\n    \"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num**0.5 + 1), 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    elif year % 100 == 0", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    if n == m:\n        return n\n    return round((n + m) / 2)\n\ndef is_prime(num):\n    \"\"\"Determines if a number is prime or not.  A prime number is a number that is only divisible by 1 and itself. \n    Examples:\n    is_prime(2) => True\n    is_prime(3) => True\n    is_prime(4) => False\n    is_prime(5) => True\n    is_prime(6) => False\n    \"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num**0.5 + 1), 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    elif year % 100 == 0"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        total = 0\n        for i in range(n, m+1):\n            total += i\n        return bin(round(total / (m - n + 1)))[2:]\n    \n# 704\n# 704. 二分查找\n\n# 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n# 示例 1:\n# 输入: nums = [-1,0,3,5,9,12], target = 9\n# 输出: 4\n# 解释: 9 出现在 nums 中并且下标为 4\n# 示例 2:\n# 输入: nums = [-1,0,3,5,", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        total = 0\n        for i in range(n, m+1):\n            total += i\n        return bin(round(total / (m - n + 1)))[2:]\n    \n# 704\n# 704. 二分查找\n\n# 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n# 示例 1:\n# 输入: nums = [-1,0,3,5,9,12], target = 9\n# 输出: 4\n# 解释: 9 出现在 nums 中并且下标为 4\n# 示例 2:\n# 输入: nums = [-1,0,3,5,"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    result = 0\n    for i in range(n, m+1):\n        result += i\n    result /= (m-n+1)\n    result = int(round(result, 0))\n    result = bin(result)[2:]\n    if len(result) == 1:\n        result = \"0\" + result\n    return result\n\n# 测试：\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n```\n\n### 1.9.3 回文子字符串\n\n- [LeetCode 647. 回文子字符串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Python 3\n# ", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    result = 0\n    for i in range(n, m+1):\n        result += i\n    result /= (m-n+1)\n    result = int(round(result, 0))\n    result = bin(result)[2:]\n    if len(result) == 1:\n        result = \"0\" + result\n    return result\n\n# 测试：\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n```\n\n### 1.9.3 回文子字符串\n\n- [LeetCode 647. 回文子字符串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Python 3\n# "}
{"task_id": "HumanEval/109", "completion": "    n = len(arr)\n    nums = list(range(1,n+1))\n    for i in range(n-1):\n        if nums[i] == arr[i]:\n            continue\n        else:\n            return False\n    return True\n```\n\n### [最长连续递增序列（2）](https://leetcode-cn.com/problems/longest-increasing-subsequence-ii/)\n\n给定一个整数数组`arr`和一个整数`d`，在`0 <= i <= j < arr.length`的所有 `i, j` 满足 `arr[i] > arr[j]` 并且 `i - j <= d`。在这种情况下，可以将`arr`分割成几个长度至多为 `d + 1`的非空子序列，并且全部元素都是递增的。\n\n返回可", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    n = len(arr)\n    nums = list(range(1,n+1))\n    for i in range(n-1):\n        if nums[i] == arr[i]:\n            continue\n        else:\n            return False\n    return True\n```\n\n### [最长连续递增序列（2）](https://leetcode-cn.com/problems/longest-increasing-subsequence-ii/)\n\n给定一个整数数组`arr`和一个整数`d`，在`0 <= i <= j < arr.length`的所有 `i, j` 满足 `arr[i] > arr[j]` 并且 `i - j <= d`。在这种情况下，可以将`arr`分割成几个长度至多为 `d + 1`的非空子序列，并且全部元素都是递增的。\n\n返回可"}
{"task_id": "HumanEval/109", "completion": "    # 对应题1149\n    arr.sort()\n    temp = []\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\narr1 = [3, 4, 5, 1, 2]\nprint(move_one_ball(arr1))\narr2 = [3, 5, 4, 1, 2]\nprint(move_one_ball(arr2))\narr3 = [3, 5, 4, 1, 2]\nprint(move_one_ball(arr3))\narr4 = [3, 5]\nprint(move_one_ball(arr4))\n\n\ndef delete_middle_element(arr):\n    \"\"\"给定一个数组arr，你将会得到一个整数k，一步操作意味着把arr[k]从数组中删除。在执行K步操作之后，检查数组", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # 对应题1149\n    arr.sort()\n    temp = []\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\narr1 = [3, 4, 5, 1, 2]\nprint(move_one_ball(arr1))\narr2 = [3, 5, 4, 1, 2]\nprint(move_one_ball(arr2))\narr3 = [3, 5, 4, 1, 2]\nprint(move_one_ball(arr3))\narr4 = [3, 5]\nprint(move_one_ball(arr4))\n\n\ndef delete_middle_element(arr):\n    \"\"\"给定一个数组arr，你将会得到一个整数k，一步操作意味着把arr[k]从数组中删除。在执行K步操作之后，检查数组"}
{"task_id": "HumanEval/109", "completion": "    if not len(arr):\n        return True\n        \n    \n    arr.sort()\n    n = len(arr)\n    l = [0]*26\n    for i in range(n):\n        l[ord(arr[i]) - 65] += 1\n    for i in range(26):\n        if l[i] % 2 == 0:\n            continue\n        if arr[i] == arr[i+1]:\n            print(\"arr: \",arr)\n        return False\n        \n    return True\n    \ndef main():\n    arr = [1,2,3]\n    print(move_one_ball(arr))\n", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not len(arr):\n        return True\n        \n    \n    arr.sort()\n    n = len(arr)\n    l = [0]*26\n    for i in range(n):\n        l[ord(arr[i]) - 65] += 1\n    for i in range(26):\n        if l[i] % 2 == 0:\n            continue\n        if arr[i] == arr[i+1]:\n            print(\"arr: \",arr)\n        return False\n        \n    return True\n    \ndef main():\n    arr = [1,2,3]\n    print(move_one_ball(arr))\n"}
{"task_id": "HumanEval/109", "completion": "    return (len(arr) == 1 or max(arr[:-1]) <= min(arr[1:]))\n\n\n# 6.将一个数组中的元素洗牌打乱\ndef shuffle(arr):\n    \"\"\"\n    将一个给定数组中的元素打乱，打乱后的数组应该以随机的方式被打乱，概率与数组中的元素有关。\n    For Example:\n    \n    shuffle([1, 2, 3, 4]) ==> [4, 3, 1, 2]\n    shuffle([2, 4, 1, 3]) ==> [4, 1, 3, 2]\n    shuffle([1, 3, 2, 4]) ==> [1, 4, 3, 2]\n    shuffle([1, 4, 2, 3]) ==> [2, 1, 4, 3]\n    shuffle([3, 1, 2,", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    return (len(arr) == 1 or max(arr[:-1]) <= min(arr[1:]))\n\n\n# 6.将一个数组中的元素洗牌打乱\ndef shuffle(arr):\n    \"\"\"\n    将一个给定数组中的元素打乱，打乱后的数组应该以随机的方式被打乱，概率与数组中的元素有关。\n    For Example:\n    \n    shuffle([1, 2, 3, 4]) ==> [4, 3, 1, 2]\n    shuffle([2, 4, 1, 3]) ==> [4, 1, 3, 2]\n    shuffle([1, 3, 2, 4]) ==> [1, 4, 3, 2]\n    shuffle([1, 4, 2, 3]) ==> [2, 1, 4, 3]\n    shuffle([3, 1, 2,"}
{"task_id": "HumanEval/109", "completion": "    for i in range(len(arr)):\n        if arr[i]!=i+1:\n            return False\n    return True\n\ndef is_nondecreasing(arr):\n    if arr:\n        for i in range(len(arr)):\n            if arr[i]>arr[i-1]:\n                return False\n    return True\n\ndef is_nonincreasing(arr):\n    if arr:\n        for i in range(len(arr)):\n            if arr[i]<arr[i-1]:\n                return False\n    return True\n\nif __name__ == '__main__':\n    arr = [3, 4, 5, 1, 2]\n    print(is_nondecreasing(arr))\n    print(is_nonincreasing(arr))\n    print(move_one_ball(arr))\n    arr = [3, 5, 4, 1, 2]\n    print(is_", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i]!=i+1:\n            return False\n    return True\n\ndef is_nondecreasing(arr):\n    if arr:\n        for i in range(len(arr)):\n            if arr[i]>arr[i-1]:\n                return False\n    return True\n\ndef is_nonincreasing(arr):\n    if arr:\n        for i in range(len(arr)):\n            if arr[i]<arr[i-1]:\n                return False\n    return True\n\nif __name__ == '__main__':\n    arr = [3, 4, 5, 1, 2]\n    print(is_nondecreasing(arr))\n    print(is_nonincreasing(arr))\n    print(move_one_ball(arr))\n    arr = [3, 5, 4, 1, 2]\n    print(is_"}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    else:\n        max_idx = len(arr) - 1\n        #找到最大值的索引\n        for i in range(max_idx, 0, -1):\n            if arr[i] > arr[i - 1]:\n                max_idx = i - 1\n                break\n                \n        #将它和最后一个元素的位置互换,如果最大值不是最后一位，此时交换的话，只要执行一次，就可以满足题目的要求\n        arr[max_idx], arr[max_idx + 1] = arr[max_idx + 1], arr[max_idx]\n        return True\n\ndef move_last_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。��", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    else:\n        max_idx = len(arr) - 1\n        #找到最大值的索引\n        for i in range(max_idx, 0, -1):\n            if arr[i] > arr[i - 1]:\n                max_idx = i - 1\n                break\n                \n        #将它和最后一个元素的位置互换,如果最大值不是最后一位，此时交换的话，只要执行一次，就可以满足题目的要求\n        arr[max_idx], arr[max_idx + 1] = arr[max_idx + 1], arr[max_idx]\n        return True\n\ndef move_last_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。��"}
{"task_id": "HumanEval/109", "completion": "    # code\n    if arr == None or len(arr) == 1:\n        return True\n    elif arr[1] > arr[0]:\n        return False\n    i = 2\n    while i < len(arr):\n        if arr[i - 1] <= arr[i]:\n            return False\n        i += 1\n    # for i in range(2,len(arr)):\n    #     if arr[i-1] <= arr[i]:\n    #         return False\n    return True\n\ndef move_one_ball(arr):\n    \"\"\"你有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # code\n    if arr == None or len(arr) == 1:\n        return True\n    elif arr[1] > arr[0]:\n        return False\n    i = 2\n    while i < len(arr):\n        if arr[i - 1] <= arr[i]:\n            return False\n        i += 1\n    # for i in range(2,len(arr)):\n    #     if arr[i-1] <= arr[i]:\n    #         return False\n    return True\n\ndef move_one_ball(arr):\n    \"\"\"你有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一"}
{"task_id": "HumanEval/109", "completion": "    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[i+1] :\n            return 0\n        if i == n-2 and arr[n-1] > arr[0]:\n            return 1\n    return 2\n~~~\n\n顺序扫描:\n\n~~~java\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[i+1] :\n            return 0\n        if i == n-2 and arr[n-1] > arr[0]:\n            return 1\n    return 2\n~~~\n\n顺序扫描:\n\n~~~java\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位"}
{"task_id": "HumanEval/109", "completion": "    # 先将原数组排序\n    arr.sort()\n    if len(arr) == 1 or arr[0] == arr[-1]:\n        return True\n    for i in range(len(arr)-1, 0, -1):\n        if arr[i-1] > arr[i]:\n            # 如果和下一个数字相等，就不能进行排序\n            if arr[i-1] == arr[i]:\n                return False\n            arr[i-1], arr[i] = arr[i], arr[i-1]\n            return True\n    return True\n```\n\n## 18. 找出数组中“重复的数字”\n\n```python\ndef find_duplicate_num(arr):\n    \"\"\" 我们有一个未排序的数组 nums，请在不使用任何内置函数的情况下找到重复出现的数字。\n    实现时不得使用额外的空间，即", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # 先将原数组排序\n    arr.sort()\n    if len(arr) == 1 or arr[0] == arr[-1]:\n        return True\n    for i in range(len(arr)-1, 0, -1):\n        if arr[i-1] > arr[i]:\n            # 如果和下一个数字相等，就不能进行排序\n            if arr[i-1] == arr[i]:\n                return False\n            arr[i-1], arr[i] = arr[i], arr[i-1]\n            return True\n    return True\n```\n\n## 18. 找出数组中“重复的数字”\n\n```python\ndef find_duplicate_num(arr):\n    \"\"\" 我们有一个未排序的数组 nums，请在不使用任何内置函数的情况下找到重复出现的数字。\n    实现时不得使用额外的空间，即"}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    return merge_sort(arr, 0, len(arr)-1)[-1] == 1\n\n\ndef solution(arr):\n    \"\"\"\n    Args:\n        arr:\n    Returns:\n        res:\n    \"\"\"\n    def _sort(arr):\n        if len(arr) in (0, 1): return arr\n        mid = len(arr) >> 1\n        _sort(arr[:mid])\n        _sort(arr[mid:])\n        return merge_sort(arr, 0, len(arr) - 1)\n\n    def _merge(arr, l, m, r):\n        if l == m:\n            return arr[l:r+1]\n        if m+1 == r:\n            if arr[m] > arr[m+1]:\n                arr[m], arr[m+1] = arr[m+1], arr[m]\n            return arr[l:r+1]\n        tmp = [_merge(arr, l, m, (m+r)>>1), _merge(arr, (m", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    return merge_sort(arr, 0, len(arr)-1)[-1] == 1\n\n\ndef solution(arr):\n    \"\"\"\n    Args:\n        arr:\n    Returns:\n        res:\n    \"\"\"\n    def _sort(arr):\n        if len(arr) in (0, 1): return arr\n        mid = len(arr) >> 1\n        _sort(arr[:mid])\n        _sort(arr[mid:])\n        return merge_sort(arr, 0, len(arr) - 1)\n\n    def _merge(arr, l, m, r):\n        if l == m:\n            return arr[l:r+1]\n        if m+1 == r:\n            if arr[m] > arr[m+1]:\n                arr[m], arr[m+1] = arr[m+1], arr[m]\n            return arr[l:r+1]\n        tmp = [_merge(arr, l, m, (m+r)>>1), _merge(arr, (m"}
{"task_id": "HumanEval/114", "completion": "    # 第一个为最小子串的和，第二个为最小子串\n    minimum = 999999999999999\n    n = len(nums)\n    # 定义窗口的左右指针\n    l, r = 0, 0\n    # 累加和\n    sum_ = 0\n    for r in range(n):\n        sum_ += nums[r]\n        # 如果当前满足条件则更新最小值\n        while sum_ >= nums[l]:\n            minimum = min(minimum, sum_-nums[l])\n            l += 1\n    return minimum\n\nif __name__ == '__main__':\n    s = Solution()\n    r = s.minSubArrayLen(2, [1, 1, 1])\n    print(r)\n    r = s.minSubArraySum([-1, -2, -3])\n    print(r)\n    r = s.minSubArraySum([2", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # 第一个为最小子串的和，第二个为最小子串\n    minimum = 999999999999999\n    n = len(nums)\n    # 定义窗口的左右指针\n    l, r = 0, 0\n    # 累加和\n    sum_ = 0\n    for r in range(n):\n        sum_ += nums[r]\n        # 如果当前满足条件则更新最小值\n        while sum_ >= nums[l]:\n            minimum = min(minimum, sum_-nums[l])\n            l += 1\n    return minimum\n\nif __name__ == '__main__':\n    s = Solution()\n    r = s.minSubArrayLen(2, [1, 1, 1])\n    print(r)\n    r = s.minSubArraySum([-1, -2, -3])\n    print(r)\n    r = s.minSubArraySum([2"}
{"task_id": "HumanEval/114", "completion": "    if len(nums) < 1:\n        return 0\n    res = nums[0]\n    sum = 0\n    for num in nums:\n        sum += num\n        res = min(res, sum)\n        if sum < 0:\n            sum = 0\n    return res\n        \n```\n\n3. 最长公共子序列\n\n#### 树状数组\n\n1. 树状数组\n\n```python\n# 树状数组数组下标从 1 开始\n# 查询：查询 [left, right] 中，所有区间和的最大值 \n# 更新：更新 [left, right] 中，所有区间和的最大值 \ndef update(arr, index, value):\n    while index <= arr.size:\n        arr[index] = max(arr[index], value)  # 更新值\n        index += index & -index  # 左移更新到父节点\n\ndef get(arr,", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if len(nums) < 1:\n        return 0\n    res = nums[0]\n    sum = 0\n    for num in nums:\n        sum += num\n        res = min(res, sum)\n        if sum < 0:\n            sum = 0\n    return res\n        \n```\n\n3. 最长公共子序列\n\n#### 树状数组\n\n1. 树状数组\n\n```python\n# 树状数组数组下标从 1 开始\n# 查询：查询 [left, right] 中，所有区间和的最大值 \n# 更新：更新 [left, right] 中，所有区间和的最大值 \ndef update(arr, index, value):\n    while index <= arr.size:\n        arr[index] = max(arr[index], value)  # 更新值\n        index += index & -index  # 左移更新到父节点\n\ndef get(arr,"}
{"task_id": "HumanEval/114", "completion": "    \n    sum_array = [0]\n    total = 0\n    for num in nums:\n        total += num\n        sum_array.append(total)\n    sum_array = sum_array[1:]\n    ans = float(\"inf\")\n    for index, value in enumerate(sum_array):\n        ans = min(ans, value-sum_array[index-1])\n    return ans\n```\n\n## 报数\n\n[1190. 拼写单词](https://leetcode-cn.com/problems/concatenated-words/)\n\n[1160. 拼写单词 II](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)\n\n1160.py\n\n```py\ndef findWords(words)\n\n\"\"\"思路：\n1. 取单词中的字符\n2. 按照从小到大的次序排序\n3. 然后", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    \n    sum_array = [0]\n    total = 0\n    for num in nums:\n        total += num\n        sum_array.append(total)\n    sum_array = sum_array[1:]\n    ans = float(\"inf\")\n    for index, value in enumerate(sum_array):\n        ans = min(ans, value-sum_array[index-1])\n    return ans\n```\n\n## 报数\n\n[1190. 拼写单词](https://leetcode-cn.com/problems/concatenated-words/)\n\n[1160. 拼写单词 II](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)\n\n1160.py\n\n```py\ndef findWords(words)\n\n\"\"\"思路：\n1. 取单词中的字符\n2. 按照从小到大的次序排序\n3. 然后"}
{"task_id": "HumanEval/114", "completion": "    n = len(nums)\n    if n == 0:\n        return None\n\n    minSum = sum(nums)\n\n    for start in range(n):\n        s = 0\n        for end in range(start, n):\n            s += nums[end]\n            if s < minSum:\n                minSum = s\n\n    return minSum\n\ndef getTotalTime(m, n):\n    \"\"\"\n    给定一个整数matrix，返回一个整数，代表恰当排列matrix中所有值的最小总时间。\n\n    如果在某一行的第i个值是k，则总时间为第i行的所有值的和加上k。\n\n    每一行的所有值和的最小值即返回。\n    \n    eg.\n    \n    matrix =\n    [[1000, 1001, 1002],\n    [2000, 2001, 200", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return None\n\n    minSum = sum(nums)\n\n    for start in range(n):\n        s = 0\n        for end in range(start, n):\n            s += nums[end]\n            if s < minSum:\n                minSum = s\n\n    return minSum\n\ndef getTotalTime(m, n):\n    \"\"\"\n    给定一个整数matrix，返回一个整数，代表恰当排列matrix中所有值的最小总时间。\n\n    如果在某一行的第i个值是k，则总时间为第i行的所有值的和加上k。\n\n    每一行的所有值和的最小值即返回。\n    \n    eg.\n    \n    matrix =\n    [[1000, 1001, 1002],\n    [2000, 2001, 200"}
{"task_id": "HumanEval/114", "completion": "    # 这道题要求得到最小的子数组\n    # 分为两步：1. 找到所有子数组的和 2. 选出最小的\n    # 第一步：找到所有子数组的和\n    sums = [0]  # 初始值\n    for num in nums:\n        sums.append(sums[-1] + num)\n    # 第二步，选出最小的子数组\n    min_value = min(sums)\n    return min_value\n\n\ndef kthLargestElement(nums, k):\n    \"\"\"\n    给定一个整数数组，其中每个元素都大于或等于 0。\n    找到其中最大的 k 个元素，返回一个由最大的 k 个元素组成的数组。\n    结果应以单调递减的顺序返回。\n    例如,\n    给定数", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # 这道题要求得到最小的子数组\n    # 分为两步：1. 找到所有子数组的和 2. 选出最小的\n    # 第一步：找到所有子数组的和\n    sums = [0]  # 初始值\n    for num in nums:\n        sums.append(sums[-1] + num)\n    # 第二步，选出最小的子数组\n    min_value = min(sums)\n    return min_value\n\n\ndef kthLargestElement(nums, k):\n    \"\"\"\n    给定一个整数数组，其中每个元素都大于或等于 0。\n    找到其中最大的 k 个元素，返回一个由最大的 k 个元素组成的数组。\n    结果应以单调递减的顺序返回。\n    例如,\n    给定数"}
{"task_id": "HumanEval/114", "completion": "    if nums is None: return\n    sum_nums = 0\n    min_sum = 0\n    min_sub_sum = len(nums)\n    for num in nums:\n        sum_nums += num\n        if sum_nums < 0:\n            min_sum = sum_nums\n        else:\n            if min_sum >= sum_nums:\n                min_sum = sum_nums\n            if min_sub_sum > (sum_nums - min_sum):\n                min_sub_sum = sum_nums - min_sum\n        print(sum_nums, min_sum, min_sub_sum)\n    return min_sub_sum\n\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个整数数组和一个整数 s，找到数组中最短的连续子数组，使得子数组中数字和恰好等于 s。如果存在美妙的解决方案", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if nums is None: return\n    sum_nums = 0\n    min_sum = 0\n    min_sub_sum = len(nums)\n    for num in nums:\n        sum_nums += num\n        if sum_nums < 0:\n            min_sum = sum_nums\n        else:\n            if min_sum >= sum_nums:\n                min_sum = sum_nums\n            if min_sub_sum > (sum_nums - min_sum):\n                min_sub_sum = sum_nums - min_sum\n        print(sum_nums, min_sum, min_sub_sum)\n    return min_sub_sum\n\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个整数数组和一个整数 s，找到数组中最短的连续子数组，使得子数组中数字和恰好等于 s。如果存在美妙的解决方案"}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        print(-1)\n    s = 0\n    min_s = 10000\n    for i in xrange(len(nums)):\n        # s 为当前位置 到 末尾的和.\n        s += nums[i]\n        if s < min_s:\n            min_s = s\n        # 当前位置 和 到 头部的和 是 0.\n        if i == 0:\n            min_s = min(min_s, sum(nums))\n    print(min_s)\n\nminSubArraySum([-1, -2, -3])\n\n# 1793. 找到需要补充粉笔的学生编号\ndef findTheStudentThatWillReplaceTheChalk(chalk, k):\n    \"\"\"\n    学校在每一节课询问学生是否需要补充粉笔。\n    学生编号为0、1", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        print(-1)\n    s = 0\n    min_s = 10000\n    for i in xrange(len(nums)):\n        # s 为当前位置 到 末尾的和.\n        s += nums[i]\n        if s < min_s:\n            min_s = s\n        # 当前位置 和 到 头部的和 是 0.\n        if i == 0:\n            min_s = min(min_s, sum(nums))\n    print(min_s)\n\nminSubArraySum([-1, -2, -3])\n\n# 1793. 找到需要补充粉笔的学生编号\ndef findTheStudentThatWillReplaceTheChalk(chalk, k):\n    \"\"\"\n    学校在每一节课询问学生是否需要补充粉笔。\n    学生编号为0、1"}
{"task_id": "HumanEval/114", "completion": "    pre = 0\n    min_sum = nums[0]\n    for num in nums[1:]:\n        pre += num\n        min_sum = min(min_sum, pre)\n        pre = max(pre, 0)\n    return min_sum\n\ndef getMaxKey(obj):\n    \"\"\"\n    在字典中寻找最大键\n    \"\"\"\n    return max([k for k in obj.keys()])\n\ndef getMinKey(obj):\n    \"\"\"\n    在字典中寻找最小键\n    \"\"\"\n    return min([k for k in obj.keys()])\n\ndef getMaxValue(obj):\n    \"\"\"\n    在字典中寻找最大值\n    \"\"\"\n    return max([v for v in obj.values()])\n\ndef getMinValue(obj):\n    \"\"\"\n    在字典中寻找最小值\n    \"\"\"\n    return min([v for v in obj.values()])\n\ndef getMaxOrMinKey(obj, max=", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    pre = 0\n    min_sum = nums[0]\n    for num in nums[1:]:\n        pre += num\n        min_sum = min(min_sum, pre)\n        pre = max(pre, 0)\n    return min_sum\n\ndef getMaxKey(obj):\n    \"\"\"\n    在字典中寻找最大键\n    \"\"\"\n    return max([k for k in obj.keys()])\n\ndef getMinKey(obj):\n    \"\"\"\n    在字典中寻找最小键\n    \"\"\"\n    return min([k for k in obj.keys()])\n\ndef getMaxValue(obj):\n    \"\"\"\n    在字典中寻找最大值\n    \"\"\"\n    return max([v for v in obj.values()])\n\ndef getMinValue(obj):\n    \"\"\"\n    在字典中寻找最小值\n    \"\"\"\n    return min([v for v in obj.values()])\n\ndef getMaxOrMinKey(obj, max="}
{"task_id": "HumanEval/114", "completion": "    n = len(nums)\n    # 当前子串的和\n    # sum_sub: int\n    sum_sub = 0\n    # 存储最小子串和\n    # min_sum: int\n    min_sum = nums[0]\n    # 遍历每个数\n    for i in range(n):\n        sum_sub += nums[i]\n        # 如果子串和小于0，那么子串重置\n        if sum_sub < 0:\n            sum_sub = 0\n        # 更新最小子串和\n        if min_sum > sum_sub:\n            min_sum = sum_sub\n    return min_sum if min_sum!= float('inf') else 0\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个含有 n 个正整数的数组和一个正整数 s，找出该数组中满足其和 ≥ s 的长度最小", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    n = len(nums)\n    # 当前子串的和\n    # sum_sub: int\n    sum_sub = 0\n    # 存储最小子串和\n    # min_sum: int\n    min_sum = nums[0]\n    # 遍历每个数\n    for i in range(n):\n        sum_sub += nums[i]\n        # 如果子串和小于0，那么子串重置\n        if sum_sub < 0:\n            sum_sub = 0\n        # 更新最小子串和\n        if min_sum > sum_sub:\n            min_sum = sum_sub\n    return min_sum if min_sum!= float('inf') else 0\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个含有 n 个正整数的数组和一个正整数 s，找出该数组中满足其和 ≥ s 的长度最小"}
{"task_id": "HumanEval/114", "completion": "    res = 0\n    sum = 0\n    i = 0\n    for j in range(len(nums)):\n        sum += nums[j] \n        res = min(res, sum)\n        while sum < 0:\n            sum -= nums[i]\n            i += 1\n    return res\n\nif __name__ == '__main__':\n    print(minSubArraySum([2, 3, 4, 1, 2, 4])) # 1\n    print(minSubArraySum([-1, -2, -3])) # -6\n```\n\n\n\n### 15.3 数组相关算法题\n\n#### 15.3.1 寻找主元素\n\n给定一个数组，你要找出其中一个数能够使得数组的和最大，数组中所有元素的和尽可能大。若无则返回0\n\n思路：\n\n* 找出仅大于0的和最", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    res = 0\n    sum = 0\n    i = 0\n    for j in range(len(nums)):\n        sum += nums[j] \n        res = min(res, sum)\n        while sum < 0:\n            sum -= nums[i]\n            i += 1\n    return res\n\nif __name__ == '__main__':\n    print(minSubArraySum([2, 3, 4, 1, 2, 4])) # 1\n    print(minSubArraySum([-1, -2, -3])) # -6\n```\n\n\n\n### 15.3 数组相关算法题\n\n#### 15.3.1 寻找主元素\n\n给定一个数组，你要找出其中一个数能够使得数组的和最大，数组中所有元素的和尽可能大。若无则返回0\n\n思路：\n\n* 找出仅大于0的和最"}
{"task_id": "MBPP/12", "completion": "\n    ans = []\n    N = len(M)\n    for i in range(N):\n        ans = ans + [sum(M[i])]\n    ans", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    ans = []\n    N = len(M)\n    for i in range(N):\n        ans = ans + [sum(M[i])]\n    ans"}
{"task_id": "MBPP/12", "completion": "\n    n = len(M)\n    row_sum = [sum(i) for i in M]\n    m = len(row_sum)\n    res = [0] * m\n    for i in range(m):\n        min_index = row_sum.index(min(row_sum))\n        res[i] = min_index\n        row_sum[min_index] = 10000.0\n    M = [M[i] for i in res]\n    return M\n```\n\n## **020. 合并两个有序链表**\n\n**题目描述:**\n\n> 给定两个有序链表的头节点 head1 和 head2, 合并两个链表并使新链表中的节点仍然是按 升序 排列的。新链表是通过拼接两个链表的所有节", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    n = len(M)\n    row_sum = [sum(i) for i in M]\n    m = len(row_sum)\n    res = [0] * m\n    for i in range(m):\n        min_index = row_sum.index(min(row_sum))\n        res[i] = min_index\n        row_sum[min_index] = 10000.0\n    M = [M[i] for i in res]\n    return M\n```\n\n## **020. 合并两个有序链表**\n\n**题目描述:**\n\n> 给定两个有序链表的头节点 head1 和 head2, 合并两个链表并使新链表中的节点仍然是按 升序 排列的。新链表是通过拼接两个链表的所有节"}
{"task_id": "MBPP/12", "completion": "\n    def cal_sum(M: List[float]):\n        result = 0\n        for i in M:\n            result += i\n        return result\n    # result = [[cal_sum(M[:, i]) for i in range(len(M[0]))] for j in M[0]]\n    i = 0\n    while i < len(M):\n        j = 0\n        while j < i:\n            if cal_sum(M[:, i]) < cal_sum(M[:, j]):\n                temp = M[:, j]\n                M[:, j] = M[:, i]\n                M[:, i] = temp\n            j += 1\n        i += 1\n    return M\n\n\ndef sum_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，求出矩阵的所有元素的和结果。\n    '''\n    def cal_sum(M: List[float]):\n        result = 0\n        for i in M:\n", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    def cal_sum(M: List[float]):\n        result = 0\n        for i in M:\n            result += i\n        return result\n    # result = [[cal_sum(M[:, i]) for i in range(len(M[0]))] for j in M[0]]\n    i = 0\n    while i < len(M):\n        j = 0\n        while j < i:\n            if cal_sum(M[:, i]) < cal_sum(M[:, j]):\n                temp = M[:, j]\n                M[:, j] = M[:, i]\n                M[:, i] = temp\n            j += 1\n        i += 1\n    return M\n\n\ndef sum_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，求出矩阵的所有元素的和结果。\n    '''\n    def cal_sum(M: List[float]):\n        result = 0\n        for i in M:\n"}
{"task_id": "MBPP/12", "completion": "\n    d = defaultdict(int)\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            d[d[M[i][j]] + M[i][j]] += d[M[i][j]] + M[i][j]\n            d[M[i][j]] += 1\n\n    ans = []\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            ans.append(d[M[i][j]] + M[i][j])\n            d[M[i][j]] -= 1\n    ans.sort()\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = ans[d[M[i][j]]]\n            d[M[i][j]] -= 1\n\nif __name__ == '__main__':\n    M = [\n        [2, 3, 4],\n        [0, 1, 2],\n    ]\n    sort", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    d = defaultdict(int)\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            d[d[M[i][j]] + M[i][j]] += d[M[i][j]] + M[i][j]\n            d[M[i][j]] += 1\n\n    ans = []\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            ans.append(d[M[i][j]] + M[i][j])\n            d[M[i][j]] -= 1\n    ans.sort()\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = ans[d[M[i][j]]]\n            d[M[i][j]] -= 1\n\nif __name__ == '__main__':\n    M = [\n        [2, 3, 4],\n        [0, 1, 2],\n    ]\n    sort"}
{"task_id": "MBPP/12", "completion": "\n    res = []\n    for i in range(len(M)):\n        res.append(sum(M[i]))\n    res.sort()\n    return res\n\n\ndef main():\n    M = [\n        [1, 9, 11],\n        [2, 1, 2],\n        [4, 2, 3],", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    res = []\n    for i in range(len(M)):\n        res.append(sum(M[i]))\n    res.sort()\n    return res\n\n\ndef main():\n    M = [\n        [1, 9, 11],\n        [2, 1, 2],\n        [4, 2, 3],"}
{"task_id": "MBPP/12", "completion": "\n    M = np.array(M)\n    return M[np.argsort(np.cumsum(M, axis=0))].tolist()\n```\n\n## 抗颠倒排序\n\n```python\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的降序进行排序。\n    '''\n\n    N = len(M)\n    M = np.array(M)\n    # 把矩阵转化为一个扁平的数组\n    N = len(M)\n    M = np.array(M)\n    M = M.reshape((N, 1))\n    # 求每行的和，把结果转换成列表，并在列表中去重\n    col_sum = [float(i) for i in set(M.sum(axis=1", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    M = np.array(M)\n    return M[np.argsort(np.cumsum(M, axis=0))].tolist()\n```\n\n## 抗颠倒排序\n\n```python\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的降序进行排序。\n    '''\n\n    N = len(M)\n    M = np.array(M)\n    # 把矩阵转化为一个扁平的数组\n    N = len(M)\n    M = np.array(M)\n    M = M.reshape((N, 1))\n    # 求每行的和，把结果转换成列表，并在列表中去重\n    col_sum = [float(i) for i in set(M.sum(axis=1"}
{"task_id": "MBPP/12", "completion": "\n    # 首先先判断输入的矩阵是否是一个矩阵\n    # 对原矩阵进行排序\n\n    # 我们分别定义两个列表和一个sum函数\n    row_l = []\n    column_l = []\n    sum = 0\n    for row in range(len(M)):\n        for column in range(len(M[0])):\n            sum += M[row][column]\n            row_l.append(sum)\n    # print(row_l)\n    row_l.sort()\n    # print(row_l)\n    column_l.sort()\n    # print(column_l)\n    for row in range(len(M)):\n        for column in range(len(M[0])):\n            M[row][column] = row_l[row]\n    return M\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 5], [1, 0, 1", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 首先先判断输入的矩阵是否是一个矩阵\n    # 对原矩阵进行排序\n\n    # 我们分别定义两个列表和一个sum函数\n    row_l = []\n    column_l = []\n    sum = 0\n    for row in range(len(M)):\n        for column in range(len(M[0])):\n            sum += M[row][column]\n            row_l.append(sum)\n    # print(row_l)\n    row_l.sort()\n    # print(row_l)\n    column_l.sort()\n    # print(column_l)\n    for row in range(len(M)):\n        for column in range(len(M[0])):\n            M[row][column] = row_l[row]\n    return M\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 5], [1, 0, 1"}
{"task_id": "MBPP/12", "completion": "\n    # 按行求和\n    res = []\n    for i in range(len(M)):\n        tmp = 0\n        for j in range(len(M[0])):\n            tmp += M[i][j]\n        res.append(tmp)\n    # 排序\n    res_list = sorted(res)\n    # 按照排序后的顺序来更新M\n    i = 0\n    for j in range(len(res_list)):\n        for k in range(len(M[0])):\n            M[i][k] = res_list[j]\n           ", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 按行求和\n    res = []\n    for i in range(len(M)):\n        tmp = 0\n        for j in range(len(M[0])):\n            tmp += M[i][j]\n        res.append(tmp)\n    # 排序\n    res_list = sorted(res)\n    # 按照排序后的顺序来更新M\n    i = 0\n    for j in range(len(res_list)):\n        for k in range(len(M[0])):\n            M[i][k] = res_list[j]\n           "}
{"task_id": "MBPP/12", "completion": "\n    count = 0\n    N = len(M)\n    for i in range(N):\n        for j in range(N):\n            if M[i][j] > count:\n                count = M[i][j]\n                M[i][j] = 1e9\n            else:\n                M[i][j] = 0\n            count += 1\n    for i in range(N):\n        for j in range(N):\n            if M[i][j]!= 1e9:\n                M[i][j] = 0\n    return M\n\nif __name__ == '__main__':\n    M = [[1,3,4],[2,4,5],[3,5,1]]\n    a,b,c = sort_matrix(M)\n    print(a)\n    print(b)\n    print(c)\n```\n\n\n\n### 12. 把数字翻过来（不用str）\n\n```python\n# -*- coding: utf-8 -*-\nfrom typing import List\ndef reverse", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    count = 0\n    N = len(M)\n    for i in range(N):\n        for j in range(N):\n            if M[i][j] > count:\n                count = M[i][j]\n                M[i][j] = 1e9\n            else:\n                M[i][j] = 0\n            count += 1\n    for i in range(N):\n        for j in range(N):\n            if M[i][j]!= 1e9:\n                M[i][j] = 0\n    return M\n\nif __name__ == '__main__':\n    M = [[1,3,4],[2,4,5],[3,5,1]]\n    a,b,c = sort_matrix(M)\n    print(a)\n    print(b)\n    print(c)\n```\n\n\n\n### 12. 把数字翻过来（不用str）\n\n```python\n# -*- coding: utf-8 -*-\nfrom typing import List\ndef reverse"}
{"task_id": "MBPP/12", "completion": "\n    n = len(M)\n    sum_ =[]\n    for i in range(len(M)):\n        sum_.append(sum(M[i]))\n    idx = np.argsort(sum_)[::-1]\n    for i in range(n):\n        M[i] = M[i][idx[i]]\n    return M\n\n\nmatrix = [[1,3,2], [2,1,4], [2,3,1]]\nsort_matrix(matrix)\n\n\n\n# 找出数组中的第二大数，如果没有第二大数，则找出第一大的数\ndef find_second_max(nums: List) -> int:\n    '''\n    给定一个非空数组，返回此数组中第二大的数；如果没有第二大的数，则返回数组中最大的数。请实现时间复杂度为O(n)，空间复杂度为O(1)的解法。\n\n    来源：力��", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    n = len(M)\n    sum_ =[]\n    for i in range(len(M)):\n        sum_.append(sum(M[i]))\n    idx = np.argsort(sum_)[::-1]\n    for i in range(n):\n        M[i] = M[i][idx[i]]\n    return M\n\n\nmatrix = [[1,3,2], [2,1,4], [2,3,1]]\nsort_matrix(matrix)\n\n\n\n# 找出数组中的第二大数，如果没有第二大数，则找出第一大的数\ndef find_second_max(nums: List) -> int:\n    '''\n    给定一个非空数组，返回此数组中第二大的数；如果没有第二大的数，则返回数组中最大的数。请实现时间复杂度为O(n)，空间复杂度为O(1)的解法。\n\n    来源：力��"}
{"task_id": "MBPP/24", "completion": "\n    return int(binum, 2)\n\n# 实际测试\nbinary_to_decimal(1001)\nbinary_to_decimal(1010)\n```\n\n### 05.将十进制数转化为二进制数\n\n> 写一个函数，将一个十进制数正常转化为二进制数。\n\n示例：\n\n```python\ndef decimal_to_binary(num):\n    '''\n    将给定的整数转化为二进制数。\n    >>> decimal_to_binary(9)\n    '1001'\n    >>> decimal_to_binary(10)\n    '1010'\n    '''\n    return bin(num)[2:]\n\n# 实际测试\ndecimal_to_binary(9)\ndecimal_to_binary(10)\n```\n\n### 06.将十进制数转化为八进制数\n\n> 写一个函数，将一个十进制", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(binum, 2)\n\n# 实际测试\nbinary_to_decimal(1001)\nbinary_to_decimal(1010)\n```\n\n### 05.将十进制数转化为二进制数\n\n> 写一个函数，将一个十进制数正常转化为二进制数。\n\n示例：\n\n```python\ndef decimal_to_binary(num):\n    '''\n    将给定的整数转化为二进制数。\n    >>> decimal_to_binary(9)\n    '1001'\n    >>> decimal_to_binary(10)\n    '1010'\n    '''\n    return bin(num)[2:]\n\n# 实际测试\ndecimal_to_binary(9)\ndecimal_to_binary(10)\n```\n\n### 06.将十进制数转化为八进制数\n\n> 写一个函数，将一个十进制"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i in range(len(binum)):\n        decimal += int(binum[-1-i])*2**i\n    return decimal\n```\n\n**块作用域**\n\n```python\ndef binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    num = 1\n    for i in range(len(binum)):\n        decimal += int(binum[-1-i])*num\n        num *= 2\n    return decimal\n```\n\n### 2.7.2 循环中的语句\n\n```python\nfor i in range(10):\n    print(i)\n    \nfor x in range(1,10):\n    print(x)\n    \nfor x in range(9,-1,-", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    for i in range(len(binum)):\n        decimal += int(binum[-1-i])*2**i\n    return decimal\n```\n\n**块作用域**\n\n```python\ndef binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    num = 1\n    for i in range(len(binum)):\n        decimal += int(binum[-1-i])*num\n        num *= 2\n    return decimal\n```\n\n### 2.7.2 循环中的语句\n\n```python\nfor i in range(10):\n    print(i)\n    \nfor x in range(1,10):\n    print(x)\n    \nfor x in range(9,-1,-"}
{"task_id": "MBPP/24", "completion": "\n    decimal = ''\n    bit = 0\n    while binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = ''\n    bit = 0\n    while binu"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    base = 1\n    for i in range(len(binum) - 1,-1,-1):\n        if binum[i] == '1':\n            decimal += base\n        base *= 2\n    return decimal\n\n\ndef decimal_to_binary(decimal): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(6)\n    '110'\n    >>> decimal_to_binary(8)\n    '1000'\n    '''\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = int(decimal / 2)\n    return binary\n\n\nif __name__ == '__main__':\n    print('*** Task 1B: Coding Test ***')\n    t1 = binary_to_decimal('110')\n    t2 = binary_to_decimal('1010')\n    t3 = decimal_to_binary(12)\n    t", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    base = 1\n    for i in range(len(binum) - 1,-1,-1):\n        if binum[i] == '1':\n            decimal += base\n        base *= 2\n    return decimal\n\n\ndef decimal_to_binary(decimal): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(6)\n    '110'\n    >>> decimal_to_binary(8)\n    '1000'\n    '''\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = int(decimal / 2)\n    return binary\n\n\nif __name__ == '__main__':\n    print('*** Task 1B: Coding Test ***')\n    t1 = binary_to_decimal('110')\n    t2 = binary_to_decimal('1010')\n    t3 = decimal_to_binary(12)\n    t"}
{"task_id": "MBPP/24", "completion": "\n    num = int(binum)\n    decimal = 0\n    base = 1\n    while True:\n        rem = num % 10\n        decimal = decimal + rem * base\n        base = base * 2\n        if num == 0:\n            break\n        num =  int(num/10)\n    return decimal\ndef decimal_to_binary(num):\n    '''\n    将给定的十进制数转换为二进制数。\n    >>> decimal_to_binary(10)\n    1010\n    >>> decimal_to_binary(9)\n    1001\n    '''\n    dec = int(num)\n    binum = ''\n    while True:\n        rem = dec % 2\n        binum = str(rem) + binum\n        dec = int(dec/2)\n        if(dec == 0):\n            break\n    return binum\ndef binary_to_hexadecimal(binum):\n    '''\n    将给定的二进制数转换为十六进制数。\n    >>> binary_to", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    num = int(binum)\n    decimal = 0\n    base = 1\n    while True:\n        rem = num % 10\n        decimal = decimal + rem * base\n        base = base * 2\n        if num == 0:\n            break\n        num =  int(num/10)\n    return decimal\ndef decimal_to_binary(num):\n    '''\n    将给定的十进制数转换为二进制数。\n    >>> decimal_to_binary(10)\n    1010\n    >>> decimal_to_binary(9)\n    1001\n    '''\n    dec = int(num)\n    binum = ''\n    while True:\n        rem = dec % 2\n        binum = str(rem) + binum\n        dec = int(dec/2)\n        if(dec == 0):\n            break\n    return binum\ndef binary_to_hexadecimal(binum):\n    '''\n    将给定的二进制数转换为十六进制数。\n    >>> binary_to"}
{"task_id": "MBPP/24", "completion": "\n    res = 0\n    for i in range(len(binum)): \n        res = res + binum[len(binum)-1-i] * 2 ** i\n    return res \n\ndef print_all(n): \n    '''\n    输出从1到n的所有数的二进制表示，每一行对应一个数的二进制表示。\n    >>> print_all(5)\n    1\n    10\n    11\n    100\n    101\n    '''\n    for i in range(1, n + 1): \n        print(decimal_to_binary(i))\n\ndef print_binary_pairs(n): \n    '''\n    输出从1到n的所有数的二进制表示，从小到大，每行显示一对数的二进制表示。\n    >>> print_binary_pairs(5)\n    1 0\n    1 1\n    10 0\n    10 1\n    11 0\n    '''\n    for j", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    res = 0\n    for i in range(len(binum)): \n        res = res + binum[len(binum)-1-i] * 2 ** i\n    return res \n\ndef print_all(n): \n    '''\n    输出从1到n的所有数的二进制表示，每一行对应一个数的二进制表示。\n    >>> print_all(5)\n    1\n    10\n    11\n    100\n    101\n    '''\n    for i in range(1, n + 1): \n        print(decimal_to_binary(i))\n\ndef print_binary_pairs(n): \n    '''\n    输出从1到n的所有数的二进制表示，从小到大，每行显示一对数的二进制表示。\n    >>> print_binary_pairs(5)\n    1 0\n    1 1\n    10 0\n    10 1\n    11 0\n    '''\n    for j"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i in range(len(binum) - 1, -1, -1):\n        decimal = decimal*2 + int(binum[i])\n    return decimal\n\n\nif __name__ == '__main__':\n    print(add_two_binary_nums('1001','1100'))\n    print(add_two_binary_nums_2('1001','1100'))\n    print(add_two_binary_nums_3('1001','1100'))\n    print(binary_to_decimal('1001'))\n    print(binary_to_decimal('1010'))\n\n'''另一种实现方法\ndef add_two_binary_nums(binum1,binum2):\n    binum1 = bin(int(''.join([str(num) for num in binum1]),2))\n    binum2 = bin(int(''.join([str(num) for num in binum2]),2))\n    if binum1[-1", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    for i in range(len(binum) - 1, -1, -1):\n        decimal = decimal*2 + int(binum[i])\n    return decimal\n\n\nif __name__ == '__main__':\n    print(add_two_binary_nums('1001','1100'))\n    print(add_two_binary_nums_2('1001','1100'))\n    print(add_two_binary_nums_3('1001','1100'))\n    print(binary_to_decimal('1001'))\n    print(binary_to_decimal('1010'))\n\n'''另一种实现方法\ndef add_two_binary_nums(binum1,binum2):\n    binum1 = bin(int(''.join([str(num) for num in binum1]),2))\n    binum2 = bin(int(''.join([str(num) for num in binum2]),2))\n    if binum1[-1"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    if not isinstance(binum, int):\n        try:\n            binum = int(binum)\n        except:\n            return 0\n    while binum > 0:\n        bit = binum % 10\n        decimal += bit * (2 ** power)\n        binum //= 10\n        power += 1\n    return decimal\n\n\ndef decimal_to_binary(decimal): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(1001)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    result = ''\n    while decimal > 0:\n        if decimal % 2 == 1:\n            result = '1' + result\n        else:\n            result = '0' + result\n        decimal //= 2\n    return result\n\n\ndef convert_binary_string_to_decimal_string(num): \n    '''\n    将给", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    power = 0\n    if not isinstance(binum, int):\n        try:\n            binum = int(binum)\n        except:\n            return 0\n    while binum > 0:\n        bit = binum % 10\n        decimal += bit * (2 ** power)\n        binum //= 10\n        power += 1\n    return decimal\n\n\ndef decimal_to_binary(decimal): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(1001)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    result = ''\n    while decimal > 0:\n        if decimal % 2 == 1:\n            result = '1' + result\n        else:\n            result = '0' + result\n        decimal //= 2\n    return result\n\n\ndef convert_binary_string_to_decimal_string(num): \n    '''\n    将给"}
{"task_id": "MBPP/24", "completion": "\n    decimal = int(binum)\n    return decimal\n\n# 测试代码\nif __name__ == \"__main__\":\n    for binum in [1001, 1010]:\n        print(\"{!r} => {}\".format(binum,binary_to_decimal(binum)))\n```\n\n\n\n## 十进制转换为二进制\n\n```python\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> binary_to_decimal(9)\n    1001\n    >>> binary_to_decimal(10)\n    1010\n    '''\n    binary = str(decimal)\n    return binary\n# 测试代码\nif __name__ == \"__main__\":\n    for decimal in [9,10]:\n        print(\"{!r} => {}\".format(decimal,decimal_to_binary(decimal)))\n\n```\n\n\n\n## 十进制转换为八进制\n", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = int(binum)\n    return decimal\n\n# 测试代码\nif __name__ == \"__main__\":\n    for binum in [1001, 1010]:\n        print(\"{!r} => {}\".format(binum,binary_to_decimal(binum)))\n```\n\n\n\n## 十进制转换为二进制\n\n```python\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> binary_to_decimal(9)\n    1001\n    >>> binary_to_decimal(10)\n    1010\n    '''\n    binary = str(decimal)\n    return binary\n# 测试代码\nif __name__ == \"__main__\":\n    for decimal in [9,10]:\n        print(\"{!r} => {}\".format(decimal,decimal_to_binary(decimal)))\n\n```\n\n\n\n## 十进制转换为八进制\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0 \n    bin_length = len(binum) \n    for i in range(bin_length): \n        decimal += (binum[i] * 2 ** (bin_length - i - 1)) \n    return decimal\n\n# -------------------------------------------------------------------\n\ndef binary_to_decimal_recur(binum): \n    '''\n    使用递归的方式将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal_recur(1001)\n    9\n    >>> binary_to_decimal_recur(1010)\n    10\n    '''\n    bin_length = len(binum)\n    if bin_length == 1: \n        return binum \n    else:\n        return binum * 2 ** (bin_length - 1) + binary_to_decimal_recur(binum[:-1]) \n\n# -------------------------------------------------------------------\n\ndef decimal_to_binary(num): \n    '''\n", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0 \n    bin_length = len(binum) \n    for i in range(bin_length): \n        decimal += (binum[i] * 2 ** (bin_length - i - 1)) \n    return decimal\n\n# -------------------------------------------------------------------\n\ndef binary_to_decimal_recur(binum): \n    '''\n    使用递归的方式将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal_recur(1001)\n    9\n    >>> binary_to_decimal_recur(1010)\n    10\n    '''\n    bin_length = len(binum)\n    if bin_length == 1: \n        return binum \n    else:\n        return binum * 2 ** (bin_length - 1) + binary_to_decimal_recur(binum[:-1]) \n\n# -------------------------------------------------------------------\n\ndef decimal_to_binary(num): \n    '''\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d', '', item) for item in strlist]\n\n\n#28 按字母顺序排序\ndef sort_by_alphabets(strlist):\n    '''\n    给定一个字符串列表strlist, 编写一个函数，将strlist中的字符串按照字母顺序排序。\n\n    排序后的字符串中，字母相同的字符串，应该按照它们在原始list中出现的先后顺序排列。\n    \n    >>> sort_by_alphabets([\"sun\", \"wings\", \"apple\", \"123abc\"])\n    [\"123abc\", \"apple\", \"sun\", \"wings\"]\n    >>> sort_by_alphabets([\"sun\", \"wings\", \"dog\", \"123abc\"])\n    [\"123abc\", \"dog\", \"sun\", \"wings\"]\n    '''\n    return sorted(strlist, key", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'\\d', '', item) for item in strlist]\n\n\n#28 按字母顺序排序\ndef sort_by_alphabets(strlist):\n    '''\n    给定一个字符串列表strlist, 编写一个函数，将strlist中的字符串按照字母顺序排序。\n\n    排序后的字符串中，字母相同的字符串，应该按照它们在原始list中出现的先后顺序排列。\n    \n    >>> sort_by_alphabets([\"sun\", \"wings\", \"apple\", \"123abc\"])\n    [\"123abc\", \"apple\", \"sun\", \"wings\"]\n    >>> sort_by_alphabets([\"sun\", \"wings\", \"dog\", \"123abc\"])\n    [\"123abc\", \"dog\", \"sun\", \"wings\"]\n    '''\n    return sorted(strlist, key"}
{"task_id": "MBPP/27", "completion": "\n    li = []\n    for strs in strlist:\n        li.append(re.sub(r'\\d', '', strs))\n    return li\n\nprint remove(['abc123', 'def456', 'ghi789'])\nprint remove(['abc123xyz', 'define456', '789ghi'])\n\ndef remove_all(strlist):\n    '''\n    去掉列表中所有元素中的数字\n    >>> remove_all(['abc123', 'def456', 'ghi789'])\n    ['abc123', 'def456', 'ghi789']\n    '''\n    li = []\n    for i in range(len(strlist)):\n        li.append(re.sub(r'\\d', '', strlist[i]))\n    return li\n\nprint remove_all(['abc123', 'def456', 'ghi789'])\n\n\n#2. 实现一个函数，用于提取字符串列表的第一个元素", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    li = []\n    for strs in strlist:\n        li.append(re.sub(r'\\d', '', strs))\n    return li\n\nprint remove(['abc123', 'def456', 'ghi789'])\nprint remove(['abc123xyz', 'define456', '789ghi'])\n\ndef remove_all(strlist):\n    '''\n    去掉列表中所有元素中的数字\n    >>> remove_all(['abc123', 'def456', 'ghi789'])\n    ['abc123', 'def456', 'ghi789']\n    '''\n    li = []\n    for i in range(len(strlist)):\n        li.append(re.sub(r'\\d', '', strlist[i]))\n    return li\n\nprint remove_all(['abc123', 'def456', 'ghi789'])\n\n\n#2. 实现一个函数，用于提取字符串列表的第一个元素"}
{"task_id": "MBPP/27", "completion": "\n    r = []\n    for s in strlist:\n        r.append(re.sub(\"\\d\", \"\", s))\n    return r\n\ndef remove_map(strlist):\n    \"\"\"\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    \"\"\"\n    return [re.sub(\"\\d\", \"\", s) for s in strlist]\n\ndef is_prime(n):\n    \"\"\"判断一个数是否为素数\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_prime_map(n):\n    \"\"\"\n    ", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    r = []\n    for s in strlist:\n        r.append(re.sub(\"\\d\", \"\", s))\n    return r\n\ndef remove_map(strlist):\n    \"\"\"\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    \"\"\"\n    return [re.sub(\"\\d\", \"\", s) for s in strlist]\n\ndef is_prime(n):\n    \"\"\"判断一个数是否为素数\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_prime_map(n):\n    \"\"\"\n    "}
{"task_id": "MBPP/27", "completion": "\n    pass\n\ndef get_dict(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回一个字典，key 为字符串中的英文字母，value 为字符串中字母的个数。\n    >>> get_dict(['abc123xyz', 'define456', '789ghi'])\n    {'a': 3, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'i': 2, 'n': 1, 'o': 2, 'r': 1, 'u': 1, 'x': 1, 'y': 1, 'z': 1}\n    '''\n    pass\n\n# 扩展题\ndef get_dict_2(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回一个字典，key 为字符串中的英文字", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    pass\n\ndef get_dict(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回一个字典，key 为字符串中的英文字母，value 为字符串中字母的个数。\n    >>> get_dict(['abc123xyz', 'define456', '789ghi'])\n    {'a': 3, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'i': 2, 'n': 1, 'o': 2, 'r': 1, 'u': 1, 'x': 1, 'y': 1, 'z': 1}\n    '''\n    pass\n\n# 扩展题\ndef get_dict_2(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回一个字典，key 为字符串中的英文字"}
{"task_id": "MBPP/27", "completion": "\n    for index, str in enumerate(strlist):\n        if re.search(r'\\d',str):\n            str=str.replace(r'\\d', '')\n        strlist[index]=str\n    return strlist\n\nprint(remove(['abc123', 'def456', 'ghi789']))\nprint(remove(['abc123xyz', 'define456', '789ghi']))\n\n# 练习题 6，7，8，9\ndef remove_str(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，删除列表中所有长度小于3的字符串。\n    如果列表中一个字符串小于2，则认为该字符串是空字符串，并不会删除它。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc123', 'def456', 'ghi789']\n    >>> remove(['abc", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    for index, str in enumerate(strlist):\n        if re.search(r'\\d',str):\n            str=str.replace(r'\\d', '')\n        strlist[index]=str\n    return strlist\n\nprint(remove(['abc123', 'def456', 'ghi789']))\nprint(remove(['abc123xyz', 'define456', '789ghi']))\n\n# 练习题 6，7，8，9\ndef remove_str(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，删除列表中所有长度小于3的字符串。\n    如果列表中一个字符串小于2，则认为该字符串是空字符串，并不会删除它。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc123', 'def456', 'ghi789']\n    >>> remove(['abc"}
{"task_id": "MBPP/27", "completion": "\n    r = []\n    for s in strlist:\n        r.append(''.join([t for t in s if not t.isdigit()]))\n    return r\n\n\ndef get_list_num(lst):\n    '''\n    >>> get_list_num([]), get_list_num(['']), get_list_num(['a','b'])\n    (0, 0, 0)\n    >>> get_list_num([1,2,3,4,5])\n    15\n    >>> get_list_num([11,2,3,4,5])\n    32\n    >>> get_list_num([1,2,3,4,5,6,7,8,9,0])\n    55\n    '''\n    s = sum([n for n in lst if n > 9])\n    return s\n\n\ndef get_nums(num):\n    '''\n    >>> get_nums(10)\n    [1, 2, 4, 5, 10]\n    >>> get_nums(11)\n    [1", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    r = []\n    for s in strlist:\n        r.append(''.join([t for t in s if not t.isdigit()]))\n    return r\n\n\ndef get_list_num(lst):\n    '''\n    >>> get_list_num([]), get_list_num(['']), get_list_num(['a','b'])\n    (0, 0, 0)\n    >>> get_list_num([1,2,3,4,5])\n    15\n    >>> get_list_num([11,2,3,4,5])\n    32\n    >>> get_list_num([1,2,3,4,5,6,7,8,9,0])\n    55\n    '''\n    s = sum([n for n in lst if n > 9])\n    return s\n\n\ndef get_nums(num):\n    '''\n    >>> get_nums(10)\n    [1, 2, 4, 5, 10]\n    >>> get_nums(11)\n    [1"}
{"task_id": "MBPP/27", "completion": "\n    for i in range(len(strlist)):\n        strlist[i] = re.sub('\\d','',strlist[i])\n    return strlist\n\n\ndef test_remove():\n    assert remove(['abc123', 'def456', 'ghi789']) == ['abc', 'def', 'ghi']\n    assert remove(['abc123xyz', 'define456', '789ghi']) == ['abcxyz', 'define', 'ghi']\n\n```\n\n## 29.2 正则表达式\n\n### 29.2.1 match对象\n\n### 29.2.2 正则表达式语法\n\n### 29.2.3 重复匹配\n\n### 29.2.4 组匹配\n\n### 29.2.5 零宽断言\n\n### 29.2.6 逆向引用\n\n### 29.2.7 分组捕", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    for i in range(len(strlist)):\n        strlist[i] = re.sub('\\d','',strlist[i])\n    return strlist\n\n\ndef test_remove():\n    assert remove(['abc123', 'def456', 'ghi789']) == ['abc', 'def', 'ghi']\n    assert remove(['abc123xyz', 'define456', '789ghi']) == ['abcxyz', 'define', 'ghi']\n\n```\n\n## 29.2 正则表达式\n\n### 29.2.1 match对象\n\n### 29.2.2 正则表达式语法\n\n### 29.2.3 重复匹配\n\n### 29.2.4 组匹配\n\n### 29.2.5 零宽断言\n\n### 29.2.6 逆向引用\n\n### 29.2.7 分组捕"}
{"task_id": "MBPP/27", "completion": "\n    li = []\n    for line in strlist:\n        li.append(re.sub(r'\\d', '', line))    \n    return li\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n## 实现1\n\n```python\ndef remove(strlist):\n    li = []\n    for line in strlist:\n        li.append(re.sub(r'\\d', '', line))    \n    return li\n```\n\n## 实现2\n\n```python\ndef remove(strlist):\n    return [re.sub(r'\\d', '', line) for line in strlist]\n```\n\n## 实现3\n\n```python\ndef remove(strlist):\n    return ''.join([re.sub(r'\\d', '', line) for line in strlist]).split()\n```\n\n## 实现4\n\n```python\ndef remove(strlist):\n    return [x.strip() for x in ''.join([re.sub(r'\\d', '', line) for line in strlist]).", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    li = []\n    for line in strlist:\n        li.append(re.sub(r'\\d', '', line))    \n    return li\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n## 实现1\n\n```python\ndef remove(strlist):\n    li = []\n    for line in strlist:\n        li.append(re.sub(r'\\d', '', line))    \n    return li\n```\n\n## 实现2\n\n```python\ndef remove(strlist):\n    return [re.sub(r'\\d', '', line) for line in strlist]\n```\n\n## 实现3\n\n```python\ndef remove(strlist):\n    return ''.join([re.sub(r'\\d', '', line) for line in strlist]).split()\n```\n\n## 实现4\n\n```python\ndef remove(strlist):\n    return [x.strip() for x in ''.join([re.sub(r'\\d', '', line) for line in strlist])."}
{"task_id": "MBPP/27", "completion": "\n    result = []\n    for s in strlist:\n        result.append(''.join(re.findall('[^0-9]+', s)))\n    return result\n\n\ndef find_common_string(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，找出列表中所有字符串的公共子序列。\n    >>> find_common_string(['abc123', 'def456', 'ghi789'])\n    '123'\n    >>> find_common_string(['abc123xyz', 'define456', '789ghi'])\n    '123'\n    '''\n\n    if len(strlist) == 0:\n        return \"\"\n    if len(strlist) == 1:\n        return strlist[0]\n    str1 = \"\"\n    str2 = strlist[0]\n    for i in strlist[1:]:\n        if len(str1) > len(str2):\n            str1, str2 = str2,", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    result = []\n    for s in strlist:\n        result.append(''.join(re.findall('[^0-9]+', s)))\n    return result\n\n\ndef find_common_string(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，找出列表中所有字符串的公共子序列。\n    >>> find_common_string(['abc123', 'def456', 'ghi789'])\n    '123'\n    >>> find_common_string(['abc123xyz', 'define456', '789ghi'])\n    '123'\n    '''\n\n    if len(strlist) == 0:\n        return \"\"\n    if len(strlist) == 1:\n        return strlist[0]\n    str1 = \"\"\n    str2 = strlist[0]\n    for i in strlist[1:]:\n        if len(str1) > len(str2):\n            str1, str2 = str2,"}
{"task_id": "MBPP/27", "completion": "\n    for i in range(len(strlist)):\n        strlist[i]=re.sub(\"\\d+\",\"\",strlist[i])\n    return strlist\n\n\n\n# 下面写上自己的代码\n\n\nclass Solution:\n    def removeDigits(self, s: str) -> str:\n        # 栈\n        stack = []\n        for c in s:\n            while stack and stack[-1] >= c:\n                stack.pop()\n            stack.append(c)\n        return ''.join(stack)\n    \n    def removeDigits_2(self, s: str) -> str:\n        # 双指针\n        left = 0\n        for right in range(1,len(s)):\n            while left < right and s[left] >= s[right]:\n                left += 1\n            s = s[:left] + s[right:]\n", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    for i in range(len(strlist)):\n        strlist[i]=re.sub(\"\\d+\",\"\",strlist[i])\n    return strlist\n\n\n\n# 下面写上自己的代码\n\n\nclass Solution:\n    def removeDigits(self, s: str) -> str:\n        # 栈\n        stack = []\n        for c in s:\n            while stack and stack[-1] >= c:\n                stack.pop()\n            stack.append(c)\n        return ''.join(stack)\n    \n    def removeDigits_2(self, s: str) -> str:\n        # 双指针\n        left = 0\n        for right in range(1,len(s)):\n            while left < right and s[left] >= s[right]:\n                left += 1\n            s = s[:left] + s[right:]\n"}
{"task_id": "MBPP/42", "completion": "\n    ans = 0\n    for i in range(len(arr)):\n        if arr[i] in arr[i+1:]:\n            ans += arr[i]\n\n    return ans\n\n\n# 56、找出两个数组的并集\n\ndef union(arr1, arr2):\n    '''\n    找出两个数组的并集\n    >>> union([1, 2, 3], [4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    '''\n    arr = arr1 + arr2\n    arr.sort()\n    l = list(set(arr))\n    return l\n\n\n# 57、找出两个数组的交集\n\ndef intersection(arr1, arr2):\n    '''\n    找出两个数组的交集\n    >>> intersection([1, 2, 3], [4, 5, 6, 7])\n    []\n    >>> intersection([1, 2, ", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    ans = 0\n    for i in range(len(arr)):\n        if arr[i] in arr[i+1:]:\n            ans += arr[i]\n\n    return ans\n\n\n# 56、找出两个数组的并集\n\ndef union(arr1, arr2):\n    '''\n    找出两个数组的并集\n    >>> union([1, 2, 3], [4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    '''\n    arr = arr1 + arr2\n    arr.sort()\n    l = list(set(arr))\n    return l\n\n\n# 57、找出两个数组的交集\n\ndef intersection(arr1, arr2):\n    '''\n    找出两个数组的交集\n    >>> intersection([1, 2, 3], [4, 5, 6, 7])\n    []\n    >>> intersection([1, 2, "}
{"task_id": "MBPP/42", "completion": "\n    dic = {}\n    for i in arr:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    sum = 0\n    for k, v in dic.items():\n        if v > 1:\n            sum += k * (v - 1)\n    return sum\n\ndef has_same_elements(arr1, arr2):\n    '''\n    判断两个有序数组中是否含有相同的元素\n    >>> has_same_elements([1,2,3], [2,3,4])\n    True\n    >>> has_same_elements([1,2,3], [2,3,5])\n    False\n    >>> has_same_elements([1,1,3], [2,3,3])\n    True\n    '''\n    if len(arr1)!= len(arr2):\n        return False\n    dic1 = {}\n    dic2 = {}\n    for i in arr1:\n        if i in dic1:\n            dic1[i] += 1", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dic = {}\n    for i in arr:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    sum = 0\n    for k, v in dic.items():\n        if v > 1:\n            sum += k * (v - 1)\n    return sum\n\ndef has_same_elements(arr1, arr2):\n    '''\n    判断两个有序数组中是否含有相同的元素\n    >>> has_same_elements([1,2,3], [2,3,4])\n    True\n    >>> has_same_elements([1,2,3], [2,3,5])\n    False\n    >>> has_same_elements([1,1,3], [2,3,3])\n    True\n    '''\n    if len(arr1)!= len(arr2):\n        return False\n    dic1 = {}\n    dic2 = {}\n    for i in arr1:\n        if i in dic1:\n            dic1[i] += 1"}
{"task_id": "MBPP/42", "completion": "\n    return sum(arr[i] for i in range(len(arr)) if arr.count(arr[i])!=1)\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n        如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    >>> print(find_Sum([4, 5, 7, 5, 4, 8]))\n    18\n    >>> find_Sum([1,1,2,2,4,6,6])\n    >>> print(find_Sum([1,1,2,2,4,6,6]))\n    16\n    '''\n    return sum(int(i) for i in set(arr) if arr.count(i)>1)\n\n# 返回一个字符串中每个字", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    return sum(arr[i] for i in range(len(arr)) if arr.count(arr[i])!=1)\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n        如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    >>> print(find_Sum([4, 5, 7, 5, 4, 8]))\n    18\n    >>> find_Sum([1,1,2,2,4,6,6])\n    >>> print(find_Sum([1,1,2,2,4,6,6]))\n    16\n    '''\n    return sum(int(i) for i in set(arr) if arr.count(i)>1)\n\n# 返回一个字符串中每个字"}
{"task_id": "MBPP/42", "completion": "\n  \n    dic = {}\n    # for i in arr:\n    #     if i in dic.keys():\n    #         dic[i] += 1\n    #     else:\n    #         dic[i] = 1\n    # s = 0\n    # for i in dic.keys():\n    #     s += dic[i]\n    #     s *= i\n    # return s\n    return sum(i * dic[i] for i in arr)\n```\n\n## Solution 4\n\n时间复杂度：$O(n)$, 其中 n 是数组的大小。\n\n空间复杂度：$O(n)$, 其中 n 是数组的大小。\n\n`collections.Counter()` 是一个哈希表，在这里它用于存储元素，以及它们在数组中出现的次数。\n\n```python\nimport collections\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n  \n    dic = {}\n    # for i in arr:\n    #     if i in dic.keys():\n    #         dic[i] += 1\n    #     else:\n    #         dic[i] = 1\n    # s = 0\n    # for i in dic.keys():\n    #     s += dic[i]\n    #     s *= i\n    # return s\n    return sum(i * dic[i] for i in arr)\n```\n\n## Solution 4\n\n时间复杂度：$O(n)$, 其中 n 是数组的大小。\n\n空间复杂度：$O(n)$, 其中 n 是数组的大小。\n\n`collections.Counter()` 是一个哈希表，在这里它用于存储元素，以及它们在数组中出现的次数。\n\n```python\nimport collections\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的"}
{"task_id": "MBPP/42", "completion": "\n    new_dict = {}\n    for i in range(len(arr)):\n        if new_dict.__contains__(arr[i]):\n            new_dict[arr[i]] += 1\n        else:\n            new_dict[arr[i]] = 1\n    # print(new_dict)\n\n    new_list = []\n    for key,value in new_dict.items():\n        # print(value)\n        # if value > 1:\n        #     new_list.append(key)\n        new_list.append(key * value)\n    # print(new_list)\n    return sum(new_list)\n\n    # return sum([key * value for key, value in new_dict.items()])\n\n# find_Sum([1,1,2])\n# find_Sum([4, 5, 7, 5, 4, 8])\n\n# def get_num_occur(arr):\n    #     \"\"\"\n    #     :param arr: an array to find the number of occurrences\n    #     :return: An array where the first element", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    new_dict = {}\n    for i in range(len(arr)):\n        if new_dict.__contains__(arr[i]):\n            new_dict[arr[i]] += 1\n        else:\n            new_dict[arr[i]] = 1\n    # print(new_dict)\n\n    new_list = []\n    for key,value in new_dict.items():\n        # print(value)\n        # if value > 1:\n        #     new_list.append(key)\n        new_list.append(key * value)\n    # print(new_list)\n    return sum(new_list)\n\n    # return sum([key * value for key, value in new_dict.items()])\n\n# find_Sum([1,1,2])\n# find_Sum([4, 5, 7, 5, 4, 8])\n\n# def get_num_occur(arr):\n    #     \"\"\"\n    #     :param arr: an array to find the number of occurrences\n    #     :return: An array where the first element"}
{"task_id": "MBPP/42", "completion": "\n    dict = {}\n    for num in arr:\n        if not num in dict:\n            continue\n        else:\n            dict[num] += 1\n    return sum(dict.values())\n# 遍历一个数组，将每个元素与索引为该元素值的数组元素相加。\ndef sum_repeat(arr):\n    d = {}\n    s = 0\n    for num in arr:\n        if num not in d:\n            d[num] = num\n            s += num\n        else:\n            s += d[num]\n    return s\n\ndef find_duplicate_from_list(arr):\n    '''\n        在一个数组中找到重复的数字，它第一次出现的下标，\n        再找出它第二次出现的位置，并输出两个位置的差值。\n    >>> find_duplicate_from_list([1, 2, 3, 4, 3])\n    3\n    >>> find_", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dict = {}\n    for num in arr:\n        if not num in dict:\n            continue\n        else:\n            dict[num] += 1\n    return sum(dict.values())\n# 遍历一个数组，将每个元素与索引为该元素值的数组元素相加。\ndef sum_repeat(arr):\n    d = {}\n    s = 0\n    for num in arr:\n        if num not in d:\n            d[num] = num\n            s += num\n        else:\n            s += d[num]\n    return s\n\ndef find_duplicate_from_list(arr):\n    '''\n        在一个数组中找到重复的数字，它第一次出现的下标，\n        再找出它第二次出现的位置，并输出两个位置的差值。\n    >>> find_duplicate_from_list([1, 2, 3, 4, 3])\n    3\n    >>> find_"}
{"task_id": "MBPP/42", "completion": "\n    hash_map = {}\n    result = 0\n    for item in arr:\n        if item not in hash_map.keys():\n            hash_map[item] = 0\n        hash_map[item] += 1\n    for key in hash_map.keys():\n        result += key * hash_map[key]\n    return result\n\n\ndef my_reversed(str): \n    '''\n    将字符串倒序。\n    >>> my_reversed(\"abcd\")\n    'dcba'\n    >>> my_reversed(\"hello\")\n    'olleh'\n    >>> my_reversed(\"\")       #空字符串不会产生错误\n    ''\n    >>> my_reversed(\"a\")\n    'a'\n    '''\n    arr = []\n    for item in str:\n        arr.insert(0, item)\n    return ''.join(arr)\n\n\ndef all_even(arr): \n    '''\n    判断一个数组中是否有奇数\n    >>> all_", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    hash_map = {}\n    result = 0\n    for item in arr:\n        if item not in hash_map.keys():\n            hash_map[item] = 0\n        hash_map[item] += 1\n    for key in hash_map.keys():\n        result += key * hash_map[key]\n    return result\n\n\ndef my_reversed(str): \n    '''\n    将字符串倒序。\n    >>> my_reversed(\"abcd\")\n    'dcba'\n    >>> my_reversed(\"hello\")\n    'olleh'\n    >>> my_reversed(\"\")       #空字符串不会产生错误\n    ''\n    >>> my_reversed(\"a\")\n    'a'\n    '''\n    arr = []\n    for item in str:\n        arr.insert(0, item)\n    return ''.join(arr)\n\n\ndef all_even(arr): \n    '''\n    判断一个数组中是否有奇数\n    >>> all_"}
{"task_id": "MBPP/42", "completion": "\n    res=0\n    for i in arr:\n        res+=i\n    s=[]\n    for i in range(len(arr)):\n        if arr[i] not in s:\n            s.append(arr[i])\n        else:\n            res-=arr[i]\n    return res\n\ndef find_Index(arr, target):\n    '''\n    在一个有序数组中，查找一个数字的索引，如果数字没有在数组中，则返回 -1\n    >>> find_Index([1,3,4,7,8,8,9], 3)\n    1\n    >>> find_Index([1,3,4,7,8,8,9], 9)\n    6\n    >>> find_Index([1,3,4,7,8,8,9], 1)\n    0\n    >>> find_Index([1,3,4,7,8,8,9], 8)\n    4\n    >>> find_Index([1,3,4,7,8,8,9], 8)", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res=0\n    for i in arr:\n        res+=i\n    s=[]\n    for i in range(len(arr)):\n        if arr[i] not in s:\n            s.append(arr[i])\n        else:\n            res-=arr[i]\n    return res\n\ndef find_Index(arr, target):\n    '''\n    在一个有序数组中，查找一个数字的索引，如果数字没有在数组中，则返回 -1\n    >>> find_Index([1,3,4,7,8,8,9], 3)\n    1\n    >>> find_Index([1,3,4,7,8,8,9], 9)\n    6\n    >>> find_Index([1,3,4,7,8,8,9], 1)\n    0\n    >>> find_Index([1,3,4,7,8,8,9], 8)\n    4\n    >>> find_Index([1,3,4,7,8,8,9], 8)"}
{"task_id": "MBPP/42", "completion": "\n    \n    listNum = {}\n    sum = 0\n    for i in arr:\n        listNum[i] = listNum.get(i,0) + 1\n    for i in listNum:\n        sum += listNum[i] * i\n    return sum\n\n\n\n\n\n# 如果一个数字在数组中出现了 n 次，那么在计算和时你需要把 n 加到结果上。\n# def find_Sum(arr):\n#     ans = 0\n#     for i in arr:\n#         ans += arr.count(i) * i\n#     return ans\n\n# 给你一个数组，请你从中找出 两个 数字，使得它们相加之和最大。\n# 函数返回一个长度为 2 的整型数组，其中包含着两个数字的值。\n# 你保证至少有 一组解。\n# 示例：\n#", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    \n    listNum = {}\n    sum = 0\n    for i in arr:\n        listNum[i] = listNum.get(i,0) + 1\n    for i in listNum:\n        sum += listNum[i] * i\n    return sum\n\n\n\n\n\n# 如果一个数字在数组中出现了 n 次，那么在计算和时你需要把 n 加到结果上。\n# def find_Sum(arr):\n#     ans = 0\n#     for i in arr:\n#         ans += arr.count(i) * i\n#     return ans\n\n# 给你一个数组，请你从中找出 两个 数字，使得它们相加之和最大。\n# 函数返回一个长度为 2 的整型数组，其中包含着两个数字的值。\n# 你保证至少有 一组解。\n# 示例：\n#"}
{"task_id": "MBPP/42", "completion": "\n    if not arr:\n        return 0\n\n    # 1.排序\n    arr.sort()\n    # 2.缓存中间状态\n    # 3.维护一个数组，当数组中有一个值，说明该值是一个峰值\n    # 4.从数组的两端开始遍历，如果遍历到的值等于峰值，那么继续遍历，否则遇到的就是重复值\n    # 5.重复值的和就是所求\n    result = 0\n    cache = {}\n    for i in range(len(arr)):\n        if not i or not cache.get(arr[i]):\n            cache[arr[i]] = i\n        else:\n            result += arr[i] * (cache[arr[i]] - i + 1)\n    \n    return result\n\nif __name__ == \"__main__\":\n   ", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    if not arr:\n        return 0\n\n    # 1.排序\n    arr.sort()\n    # 2.缓存中间状态\n    # 3.维护一个数组，当数组中有一个值，说明该值是一个峰值\n    # 4.从数组的两端开始遍历，如果遍历到的值等于峰值，那么继续遍历，否则遇到的就是重复值\n    # 5.重复值的和就是所求\n    result = 0\n    cache = {}\n    for i in range(len(arr)):\n        if not i or not cache.get(arr[i]):\n            cache[arr[i]] = i\n        else:\n            result += arr[i] * (cache[arr[i]] - i + 1)\n    \n    return result\n\nif __name__ == \"__main__\":\n   "}
{"task_id": "MBPP/149", "completion": "\n    if arr == []:\n        return 0\n    len_arr = len(arr)\n    dp = [1] * len_arr\n    for i in range(1, len_arr):\n        for j in range(i):\n            if arr[i]-arr[j] == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef max_len_pro(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值最大为k。\n    >>> max_len_pro([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if arr == []:\n        return 0\n    len_arr = len(arr)\n    dp = [1] * len_arr\n    for i in range(1, len_arr):\n        for j", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if arr == []:\n        return 0\n    len_arr = len(arr)\n    dp = [1] * len_arr\n    for i in range(1, len_arr):\n        for j in range(i):\n            if arr[i]-arr[j] == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef max_len_pro(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值最大为k。\n    >>> max_len_pro([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if arr == []:\n        return 0\n    len_arr = len(arr)\n    dp = [1] * len_arr\n    for i in range(1, len_arr):\n        for j"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    res = 1\n    for i in range(1, len(arr)):\n        if arr[i]!= arr[i-1]:\n            dp[i] = dp[i-1] + 1\n            res = max(res, dp[i])\n    return res\n\nfrom typing import Tuple, List\ndef max_len_sub_with_k(arr:List[int], k:int):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为k。\n    >>> max_len_sub_with_k([1, 2, 3, 4, 5, 3, 2], 2)\n    4\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    res = 1\n    for i in range(1,", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    res = 1\n    for i in range(1, len(arr)):\n        if arr[i]!= arr[i-1]:\n            dp[i] = dp[i-1] + 1\n            res = max(res, dp[i])\n    return res\n\nfrom typing import Tuple, List\ndef max_len_sub_with_k(arr:List[int], k:int):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为k。\n    >>> max_len_sub_with_k([1, 2, 3, 4, 5, 3, 2], 2)\n    4\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    res = 1\n    for i in range(1,"}
{"task_id": "MBPP/149", "completion": "\n    max = 0\n    pre_sum = 0\n    for i in range(len(arr)):\n        pre_sum = 0\n        j = i + 1\n        while j < len(arr):\n            pre_sum += arr[j - 1] - arr[i]\n            if pre_sum > max:\n                max = pre_sum\n            j += 1\n    return max\n\n\nif __name__ == '__main__':\n    a = max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    print(a)\n\n# 具体解题思路在代码中的注释即可，非常简单。\n```\n\n## 3. 字符串的相关题\n\n### 3.1 满足条件的字符串有多少个？\n\n```python\n# 输入一个字符串，要求输出满足条件的字符串有多少个\ndef string_num(str", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    max = 0\n    pre_sum = 0\n    for i in range(len(arr)):\n        pre_sum = 0\n        j = i + 1\n        while j < len(arr):\n            pre_sum += arr[j - 1] - arr[i]\n            if pre_sum > max:\n                max = pre_sum\n            j += 1\n    return max\n\n\nif __name__ == '__main__':\n    a = max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    print(a)\n\n# 具体解题思路在代码中的注释即可，非常简单。\n```\n\n## 3. 字符串的相关题\n\n### 3.1 满足条件的字符串有多少个？\n\n```python\n# 输入一个字符串，要求输出满足条件的字符串有多少个\ndef string_num(str"}
{"task_id": "MBPP/149", "completion": "\n\n    dp = [1] * len(arr)\n    max_len = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            dp[i] = dp[i - 1] + 1\n            max_len = max(max_len, dp[i])\n    return max_len\n\nif __name__ == \"__main__\":\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n    print(max_len_sub([1, 2, 4, 7, 3, 9]))\n    print(max_len_sub([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(max_len_sub([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(max_len_sub([1", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n\n    dp = [1] * len(arr)\n    max_len = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            dp[i] = dp[i - 1] + 1\n            max_len = max(max_len, dp[i])\n    return max_len\n\nif __name__ == \"__main__\":\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n    print(max_len_sub([1, 2, 4, 7, 3, 9]))\n    print(max_len_sub([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(max_len_sub([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(max_len_sub([1"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [0 for _ in range(n)]\n    for i in range(1, n):\n        # 第一个比当前值大的元素\n        j = i - 1\n        while j >= 0 and arr[i] > arr[j]:\n            j -= 1\n        dp[i] = j + 1\n        # 第一个比当前值小的元素\n        j = i\n        while j < n and arr[i] >= arr[j]:\n            j += 1\n        dp[i] = max(dp[i], j - i)\n    return max(dp)\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub2([1, 2, 3,", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [0 for _ in range(n)]\n    for i in range(1, n):\n        # 第一个比当前值大的元素\n        j = i - 1\n        while j >= 0 and arr[i] > arr[j]:\n            j -= 1\n        dp[i] = j + 1\n        # 第一个比当前值小的元素\n        j = i\n        while j < n and arr[i] >= arr[j]:\n            j += 1\n        dp[i] = max(dp[i], j - i)\n    return max(dp)\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub2([1, 2, 3,"}
{"task_id": "MBPP/149", "completion": "\n    if len(arr)==1: return 1\n    dp,res = [0]*len(arr),0\n    for i in range(len(arr)):\n        dp[i] = arr[i]-arr[i-1]\n    if dp[0]==1:\n        res=1\n    for i in range(1,len(arr)):\n       ", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr)==1: return 1\n    dp,res = [0]*len(arr),0\n    for i in range(len(arr)):\n        dp[i] = arr[i]-arr[i-1]\n    if dp[0]==1:\n        res=1\n    for i in range(1,len(arr)):\n       "}
{"task_id": "MBPP/149", "completion": "\n    # 使用O(n)空间的方法\n    if not arr:\n        return 0\n    max_length = 1\n    max_num = arr[0]\n    for num in arr:\n        if num > max_num:\n            max_length += 1\n            max_num = num\n    return max_length\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef max_len_sub_one(arr:List[int]):\n    if not arr:\n        return 0\n    max_length = 1\n    max_num = arr[0]\n    for num in arr:\n        if num > max_num:\n            max_length += 1\n            max_num = num\n    return max_length\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef max_len_sub_two(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    # 使用O(n)空间的方法\n    if not arr:\n        return 0\n    max_length = 1\n    max_num = arr[0]\n    for num in arr:\n        if num > max_num:\n            max_length += 1\n            max_num = num\n    return max_length\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef max_len_sub_one(arr:List[int]):\n    if not arr:\n        return 0\n    max_length = 1\n    max_num = arr[0]\n    for num in arr:\n        if num > max_num:\n            max_length += 1\n            max_num = num\n    return max_length\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef max_len_sub_two(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个"}
{"task_id": "MBPP/149", "completion": "\n    arr.sort()\n    _max = 0\n    for i in range(len(arr)):\n        if arr[i] == arr[i+1] - 1:\n            _max += 1\n        else:\n            _max = 1\n    return _max\n\nif __name__ == '__main__':\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n    print(max_len_sub([1, 2, 3, 4, 7, 3, 2]))\n    print(max_len_sub([1, 2, 3, 1, 2, 3, 2]))\n```\n\n#### 10. 字符串中的排列\n\n- 题目描述\n\n```\n给定一个字符串str，str中连续出现的字符，称为这些字符的排列。例如，字符串str = \"cdbac\"中，连续的\"", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    arr.sort()\n    _max = 0\n    for i in range(len(arr)):\n        if arr[i] == arr[i+1] - 1:\n            _max += 1\n        else:\n            _max = 1\n    return _max\n\nif __name__ == '__main__':\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n    print(max_len_sub([1, 2, 3, 4, 7, 3, 2]))\n    print(max_len_sub([1, 2, 3, 1, 2, 3, 2]))\n```\n\n#### 10. 字符串中的排列\n\n- 题目描述\n\n```\n给定一个字符串str，str中连续出现的字符，称为这些字符的排列。例如，字符串str = \"cdbac\"中，连续的\""}
{"task_id": "MBPP/149", "completion": "\n    # 这里的方法是先求出最大值的下标，然后再通过下标去重\n    res = []\n    n = len(arr)\n    max_len = 0\n    max_index = 0\n    for i in range(n):\n        if i<n-1 and arr[i]<arr[i+1] :\n            if arr[i]+1 in res:\n                res.remove(arr[i]+1)\n            res.append(arr[i])\n        else:\n            if max_len<len(res):\n                max_len = len(res)\n                max_index = i\n            res = []\n    return max_len\n\nif __name__ == '__main__':\n    print(max_len_sub", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    # 这里的方法是先求出最大值的下标，然后再通过下标去重\n    res = []\n    n = len(arr)\n    max_len = 0\n    max_index = 0\n    for i in range(n):\n        if i<n-1 and arr[i]<arr[i+1] :\n            if arr[i]+1 in res:\n                res.remove(arr[i]+1)\n            res.append(arr[i])\n        else:\n            if max_len<len(res):\n                max_len = len(res)\n                max_index = i\n            res = []\n    return max_len\n\nif __name__ == '__main__':\n    print(max_len_sub"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    #print(dp)\n    return max(dp)\n\ndef max_len_sub_1(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1，优化思路：减少循环次数\n    >>> max_len_sub_1([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    for i in", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    #print(dp)\n    return max(dp)\n\ndef max_len_sub_1(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1，优化思路：减少循环次数\n    >>> max_len_sub_1([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    dp = [1] * len(arr)\n    for i in"}
{"task_id": "MBPP/v522", "completion": "\n   maxl=0\n   dp=[0]*(len(arr))\n   for i in range(1,len(arr)):\n       if arr[i]>=arr[i-1]:\n           dp[i]=dp[i-1]+1\n       else:\n           dp[i]=0\n       maxl=max(maxl,dp[i])\n   return maxl\n\n\n\n\ndef longest_common_subsequence(str1, str2):\n    '''\n    给定两个字符串str1和str2，编写一个函数，求str1和str2的最长公共子序列。\n    >>> longest_common_subsequence('ABCBDAB', 'BDCABA')\n    'BCBA'\n    '''\n    m=len(str1)\n    n=len(str2)\n    dp=[[0]*(n+1) for i in range(m+1)]\n    for i in range(1,m):\n        for j in range(1,n):\n            if str1[i]==str2[j]:\n                dp[i][j]=dp[i-1][j-1]+1\n            else:\n                dp[i][j]=max(dp[i][j-1],dp[i-1][j])\n\n    ret=[str1[i-1] for i in range(1,len(str1)+1) if dp[i][-1]!=0]\n\n    return ''.join(ret)\n\n\ndef fm(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长递增子序列的长度，递增序列指该序列从左到右逐个递增，且不能重", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   maxl=0\n   dp=[0]*(len(arr))\n   for i in range(1,len(arr)):\n       if arr[i]>=arr[i-1]:\n           dp[i]=dp[i-1]+1\n       else:\n           dp[i]=0\n       maxl=max(maxl,dp[i])\n   return maxl\n\n\n\n\ndef longest_common_subsequence(str1, str2):\n    '''\n    给定两个字符串str1和str2，编写一个函数，求str1和str2的最长公共子序列。\n    >>> longest_common_subsequence('ABCBDAB', 'BDCABA')\n    'BCBA'\n    '''\n    m=len(str1)\n    n=len(str2)\n    dp=[[0]*(n+1) for i in range(m+1)]\n    for i in range(1,m):\n        for j in range(1,n):\n            if str1[i]==str2[j]:\n                dp[i][j]=dp[i-1][j-1]+1\n            else:\n                dp[i][j]=max(dp[i][j-1],dp[i-1][j])\n\n    ret=[str1[i-1] for i in range(1,len(str1)+1) if dp[i][-1]!=0]\n\n    return ''.join(ret)\n\n\ndef fm(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长递增子序列的长度，递增序列指该序列从左到右逐个递增，且不能重"}
{"task_id": "MBPP/v522", "completion": "\n    length = len(arr)\n    dp = [0 for i in range(length)]\n    for i in range(length):\n        dp[i] = 1\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef longest_increasing_path(A):\n    '''\n    给定一个二维数组A，A[i][j]表示第i行第j列，编写一个函数，求A中最长的严格单调递增子序列的长度。\n    >>> longest_increasing_path([[1,2,3],[4,5,6],[7,8,9]])\n    4\n    >>> longest_increasing_path([[1,2,3],[4,4,4],[7,8,9]])\n    3\n    >>> longest_increasing_path([])\n    0\n    >>> longest_increasing_path([[1,2,3],[1,2,3],[1,2,3]])\n    3\n    '''\n    def dfs(i, j, v):\n        if i < 0 or i >= len(A) or j < 0 or j >= len(A[0]) or v > A[i][j]:\n            return 0\n        dp[i][j] = 1\n        n = 1\n        for x, y in dxdy:\n            n = max(n, dfs(i + x, j + y, v) + 1)\n        return n\n\n    if not A:\n        return 0\n\n    dxdy = [[0, 1], [1, 0], [1, 1], [", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    length = len(arr)\n    dp = [0 for i in range(length)]\n    for i in range(length):\n        dp[i] = 1\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef longest_increasing_path(A):\n    '''\n    给定一个二维数组A，A[i][j]表示第i行第j列，编写一个函数，求A中最长的严格单调递增子序列的长度。\n    >>> longest_increasing_path([[1,2,3],[4,5,6],[7,8,9]])\n    4\n    >>> longest_increasing_path([[1,2,3],[4,4,4],[7,8,9]])\n    3\n    >>> longest_increasing_path([])\n    0\n    >>> longest_increasing_path([[1,2,3],[1,2,3],[1,2,3]])\n    3\n    '''\n    def dfs(i, j, v):\n        if i < 0 or i >= len(A) or j < 0 or j >= len(A[0]) or v > A[i][j]:\n            return 0\n        dp[i][j] = 1\n        n = 1\n        for x, y in dxdy:\n            n = max(n, dfs(i + x, j + y, v) + 1)\n        return n\n\n    if not A:\n        return 0\n\n    dxdy = [[0, 1], [1, 0], [1, 1], ["}
{"task_id": "MBPP/v522", "completion": "\n   length = len(arr)\n   dp = [1] * length\n   for i in range(length):\n       for j in range(i):\n           if arr[i] > arr[j]:\n               dp[i] = max(dp[i], dp[j] + 1)\n   return max(dp)\n\n\n# 动态规划的典型应用————编辑距离\n\ndef edit_dis(str1, str2):\n    '''\n    编辑距离指的是，将str1变成str2，所需要的最小编辑次数是多少\n    >>> min_edit_dis(\"zhang\", \"han\")\n    2\n    >>> min_edit_dis(\"zhang\", \"hang\")\n    1\n    '''\n    len1 = len(str1)\n    len2 = len(str2)\n    dp = [[0] * (len1 + 1) for _ in range(len2 + 1)]\n    for i in range(0, len2 + 1):\n        dp[i][0] = i\n    for i in range(0, len1 + 1):\n        dp[0][i] = i\n    for i in range(1, len2 + 1):\n        for j in range(1, len1 + 1):\n            if str1[j - 1] == str2[i - 1]:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n            else:\n                dp[i][j] = min(dp[i - 1][j - 1] +", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   length = len(arr)\n   dp = [1] * length\n   for i in range(length):\n       for j in range(i):\n           if arr[i] > arr[j]:\n               dp[i] = max(dp[i], dp[j] + 1)\n   return max(dp)\n\n\n# 动态规划的典型应用————编辑距离\n\ndef edit_dis(str1, str2):\n    '''\n    编辑距离指的是，将str1变成str2，所需要的最小编辑次数是多少\n    >>> min_edit_dis(\"zhang\", \"han\")\n    2\n    >>> min_edit_dis(\"zhang\", \"hang\")\n    1\n    '''\n    len1 = len(str1)\n    len2 = len(str2)\n    dp = [[0] * (len1 + 1) for _ in range(len2 + 1)]\n    for i in range(0, len2 + 1):\n        dp[i][0] = i\n    for i in range(0, len1 + 1):\n        dp[0][i] = i\n    for i in range(1, len2 + 1):\n        for j in range(1, len1 + 1):\n            if str1[j - 1] == str2[i - 1]:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n            else:\n                dp[i][j] = min(dp[i - 1][j - 1] +"}
{"task_id": "MBPP/v522", "completion": "\n   length = len(arr) \n   if length == 1: \n       return 1\n   # 动态规划\n   # l表示每个位置的最长子序列的长度，注意它必须是一个二维数组，因为最长子序列的长度取决于它左侧的数字和右侧的数字\n   l = [[1 for _ in range(length)] for __ in range(length)] \n   for i in range(1, length): \n       for j in range(i): \n           if arr[i] > arr[j]: \n               l[i][j] = 1 + l[j][j] \n   ans = 0\n   for i in range(length): \n       for j in range(i): \n           ans = max(ans, l[i][j]) \n   return ans\n\n# 斐波那契数列\ndef fibonacci(n):\n   if n <= 1:\n       return n\n   m = 0\n   f = [1, 1]\n   while m < n - 1:\n       f.append(f[m] + f[m+1])\n       m += 1\n   return f[-1]\n\n\n# 幂指数\ndef pow(m, n):\n   if n == 0:\n       return 1\n   if n % 2 == 0:\n       return pow(m*m, n/2)\n   else:\n       return m * pow(m*m, n/2)\n\n#递归\ndef factorial(n):\n   if n == 1", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   length = len(arr) \n   if length == 1: \n       return 1\n   # 动态规划\n   # l表示每个位置的最长子序列的长度，注意它必须是一个二维数组，因为最长子序列的长度取决于它左侧的数字和右侧的数字\n   l = [[1 for _ in range(length)] for __ in range(length)] \n   for i in range(1, length): \n       for j in range(i): \n           if arr[i] > arr[j]: \n               l[i][j] = 1 + l[j][j] \n   ans = 0\n   for i in range(length): \n       for j in range(i): \n           ans = max(ans, l[i][j]) \n   return ans\n\n# 斐波那契数列\ndef fibonacci(n):\n   if n <= 1:\n       return n\n   m = 0\n   f = [1, 1]\n   while m < n - 1:\n       f.append(f[m] + f[m+1])\n       m += 1\n   return f[-1]\n\n\n# 幂指数\ndef pow(m, n):\n   if n == 0:\n       return 1\n   if n % 2 == 0:\n       return pow(m*m, n/2)\n   else:\n       return m * pow(m*m, n/2)\n\n#递归\ndef factorial(n):\n   if n == 1"}
{"task_id": "MBPP/v522", "completion": "\n   L = len(arr)\n   if L == 0:\n      return 0\n   f = [1] * L\n   f[0] = arr[0]\n   for i in range(1,L):\n       f[i] = 1\n       for j in range(i):\n           if arr[i] > arr[j]:\n               f[i] = max(f[i], f[j] + 1)\n   return max(f)\n\n\n\n\ndef lds(arr):\n   L = len(arr)\n   if L == 0:\n      return 0\n   f = [1] * L\n   f[L-1] = 1\n   for i in range(L-2, -1, -1):\n       f[i] = 1\n       for j in range(i+1, L):\n           if arr[i] > arr[j]:\n               f[i] = max(f[i], f[j] + 1)\n   return max(f)\n\n\n\ndef maxSubsequence(arr):\n  '''\n  给定一个数组arr，编写一个函数，求arr中的最长连续子序列的和最大的值\n  >>> maxSubsequence([1, 2, 3, 4, 5, -1, -2])\n  11\n  '''\n  L = len(arr)\n  if L == 0:\n      return 0\n  f = [1] * L\n  f[0] = arr[0]\n  for i in range(1, L):\n      f[i] = max(f[i-1] + arr[i], arr[i])\n  return max(f)  \n\n\n\ndef largestSum(arr):\n  '''\n  给定一个数组arr，编写", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   L = len(arr)\n   if L == 0:\n      return 0\n   f = [1] * L\n   f[0] = arr[0]\n   for i in range(1,L):\n       f[i] = 1\n       for j in range(i):\n           if arr[i] > arr[j]:\n               f[i] = max(f[i], f[j] + 1)\n   return max(f)\n\n\n\n\ndef lds(arr):\n   L = len(arr)\n   if L == 0:\n      return 0\n   f = [1] * L\n   f[L-1] = 1\n   for i in range(L-2, -1, -1):\n       f[i] = 1\n       for j in range(i+1, L):\n           if arr[i] > arr[j]:\n               f[i] = max(f[i], f[j] + 1)\n   return max(f)\n\n\n\ndef maxSubsequence(arr):\n  '''\n  给定一个数组arr，编写一个函数，求arr中的最长连续子序列的和最大的值\n  >>> maxSubsequence([1, 2, 3, 4, 5, -1, -2])\n  11\n  '''\n  L = len(arr)\n  if L == 0:\n      return 0\n  f = [1] * L\n  f[0] = arr[0]\n  for i in range(1, L):\n      f[i] = max(f[i-1] + arr[i], arr[i])\n  return max(f)  \n\n\n\ndef largestSum(arr):\n  '''\n  给定一个数组arr，编写"}
{"task_id": "MBPP/v522", "completion": "\n   def lbs_help(arr, l, r):\n       '''\n       给定arr中的一个子数组arr[l: r+1], 求该数组中的最长双调子序列的长度。\n\n       '''\n       if l == r: return 0\n       if arr[l] > arr[l+1]:\n           return 2 + lbs_help(arr, l + 2, r)\n       return lbs_help(arr, l + 1, r)\n   l = 0\n   for i in range(len(arr) - 1):\n       l = max(l, lbs_help(arr, i, i))\n   return l\n\ndef lcs(S, T):\n    '''\n    给定字符串S和T，编写一个函数，求出S和T的最长公共子序列的长度。\n    >>> lcs('abcde', 'edcba')\n    3\n    >>> lcs('abcde', 'fghij')\n    0\n    '''\n    lcs = [[0 for j in range(len(T) + 1)] for i in range(len(S) + 1)]\n    for i in range(len(S) + 1):\n        for j in range(len(T) + 1):\n            if i == 0 or j == 0:\n                lcs[i][j] = 0\n            elif S[i - 1] == T[j - 1]:\n                lcs[i][j] = lcs[i - 1][j - 1] + 1\n            else:\n                lcs[i][j] = max(lcs[i][j - 1], lcs[i - 1][j])\n    return lcs[len(S)][len(T)]\n\n", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   def lbs_help(arr, l, r):\n       '''\n       给定arr中的一个子数组arr[l: r+1], 求该数组中的最长双调子序列的长度。\n\n       '''\n       if l == r: return 0\n       if arr[l] > arr[l+1]:\n           return 2 + lbs_help(arr, l + 2, r)\n       return lbs_help(arr, l + 1, r)\n   l = 0\n   for i in range(len(arr) - 1):\n       l = max(l, lbs_help(arr, i, i))\n   return l\n\ndef lcs(S, T):\n    '''\n    给定字符串S和T，编写一个函数，求出S和T的最长公共子序列的长度。\n    >>> lcs('abcde', 'edcba')\n    3\n    >>> lcs('abcde', 'fghij')\n    0\n    '''\n    lcs = [[0 for j in range(len(T) + 1)] for i in range(len(S) + 1)]\n    for i in range(len(S) + 1):\n        for j in range(len(T) + 1):\n            if i == 0 or j == 0:\n                lcs[i][j] = 0\n            elif S[i - 1] == T[j - 1]:\n                lcs[i][j] = lcs[i - 1][j - 1] + 1\n            else:\n                lcs[i][j] = max(lcs[i][j - 1], lcs[i - 1][j])\n    return lcs[len(S)][len(T)]\n\n"}
{"task_id": "MBPP/v522", "completion": "\n   len = len(arr)\n   if len <= 1:\n       return len\n   #寻找掉单调递增的最长子序列的长度\n   dp = [1 for x in range(len)]\n   for i in range(1, len):\n       for j in range(i):\n          if arr[i] > arr[i - j - 1]:\n              dp[i] = max(dp[i], dp[i - j - 1] + 1)\n   #寻找掉单调递减的最长子序列的长度\n   maxval = [arr[0]]\n   for i in range(1, len):\n       for j in range(i):\n          if arr[i] < arr[i - j - 1]:\n              temp = maxval[j]\n              if dp[i] < dp[i - j - 1] + 1:\n                  dp[i] = dp[i - j - 1] + 1\n                  if dp[i] > maxval[i]:\n                      maxval[i] = dp[i]\n                      temp = arr[i - j - 1]\n                  while dp[i]!= dp[i - 1] and arr[i - 1] < temp:\n                      temp = maxval[i]\n                      maxval[i] = dp[i - j - 1] + 1\n                      dp[i - 1] = dp[i - j - 1] + 1\n\n   return max(dp)\n\ndef lis(arr):\n   '''\n   lis(arr) 给定一个数组arr，编写一个函数，求arr中的最", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   len = len(arr)\n   if len <= 1:\n       return len\n   #寻找掉单调递增的最长子序列的长度\n   dp = [1 for x in range(len)]\n   for i in range(1, len):\n       for j in range(i):\n          if arr[i] > arr[i - j - 1]:\n              dp[i] = max(dp[i], dp[i - j - 1] + 1)\n   #寻找掉单调递减的最长子序列的长度\n   maxval = [arr[0]]\n   for i in range(1, len):\n       for j in range(i):\n          if arr[i] < arr[i - j - 1]:\n              temp = maxval[j]\n              if dp[i] < dp[i - j - 1] + 1:\n                  dp[i] = dp[i - j - 1] + 1\n                  if dp[i] > maxval[i]:\n                      maxval[i] = dp[i]\n                      temp = arr[i - j - 1]\n                  while dp[i]!= dp[i - 1] and arr[i - 1] < temp:\n                      temp = maxval[i]\n                      maxval[i] = dp[i - j - 1] + 1\n                      dp[i - 1] = dp[i - j - 1] + 1\n\n   return max(dp)\n\ndef lis(arr):\n   '''\n   lis(arr) 给定一个数组arr，编写一个函数，求arr中的最"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   dp = [1] * n\n   for j in range(1, n):\n       for i in range(j):\n           if arr[j] > arr[i]:\n               if dp[i] + 1 > dp[j]:\n                   dp[j] = dp[i] + 1\n   return dp[n-1]\n\n\ndef kadane(arr):\n   '''\n   Kadane's algorithm\n   给定一个数组arr，编写一个函数，求arr中的最大的连续子数组和，连续子数组指数组中相邻的元素之间的元素。\n   返回值为最大连续子数组和。\n   例如，arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]时，最大连续子数组和为arr[3]+arr[4]+arr[5]+arr[6]=6, 即arr[3:6]=[4,-1,2]\n   >>> kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n   6\n   >>> kadane([0, 1, -2, 4, -2, 3, 2])\n   7\n   '''\n   max_ending_here = max_so_far = arr[0]\n   for i in range(1, len(arr)):\n       max_ending_here = max(0, max_ending_here + arr[i])\n       max_so_far = max(max_ending_here, max_so_far)\n   return max_so_far\n\n\ndef longest_repeat(s:", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   dp = [1] * n\n   for j in range(1, n):\n       for i in range(j):\n           if arr[j] > arr[i]:\n               if dp[i] + 1 > dp[j]:\n                   dp[j] = dp[i] + 1\n   return dp[n-1]\n\n\ndef kadane(arr):\n   '''\n   Kadane's algorithm\n   给定一个数组arr，编写一个函数，求arr中的最大的连续子数组和，连续子数组指数组中相邻的元素之间的元素。\n   返回值为最大连续子数组和。\n   例如，arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]时，最大连续子数组和为arr[3]+arr[4]+arr[5]+arr[6]=6, 即arr[3:6]=[4,-1,2]\n   >>> kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n   6\n   >>> kadane([0, 1, -2, 4, -2, 3, 2])\n   7\n   '''\n   max_ending_here = max_so_far = arr[0]\n   for i in range(1, len(arr)):\n       max_ending_here = max(0, max_ending_here + arr[i])\n       max_so_far = max(max_ending_here, max_so_far)\n   return max_so_far\n\n\ndef longest_repeat(s:"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   dp = [1 for i in range(n)]\n   for i in range(1, n):\n       for j in range(i):\n           if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n               dp[i] = dp[j] + 1\n   return max(dp)\n\n\ndef longest_palindromic_substring(s):\n   '''\n    给定一个字符串s，编写一个函数，求s中最长的回文子串。\n    >>> longest_palindromic_substring('babad')\n    'bab'\n    >>> longest_palindromic_substring('cbbd')\n    'bb'\n    >>> longest_palindromic_substring('a')\n    'a'\n    '''\n   n = len(s)\n   dp = [0] * n\n   max_len = 0\n   max_start = 0\n   for i in range(n):\n       for j in range(i, n):\n           if s[i] == s[j]:\n               if j - i <= 1:\n                   dp[i] = 1\n               else:\n                   dp[i] = dp[j - 1] + 1\n                   if j - dp[i] + 1 > max_len:\n                       max_len = j - dp[i] + 1\n                       max_start = i\n   return s[max_start: max_start + max_len]\n\n\ndef longest_common_subsequence(s1, s2):\n   '''\n    给定两个字符串s1和s2，编写一个函数，求s1和s2的最长公共子序列的长", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   dp = [1 for i in range(n)]\n   for i in range(1, n):\n       for j in range(i):\n           if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n               dp[i] = dp[j] + 1\n   return max(dp)\n\n\ndef longest_palindromic_substring(s):\n   '''\n    给定一个字符串s，编写一个函数，求s中最长的回文子串。\n    >>> longest_palindromic_substring('babad')\n    'bab'\n    >>> longest_palindromic_substring('cbbd')\n    'bb'\n    >>> longest_palindromic_substring('a')\n    'a'\n    '''\n   n = len(s)\n   dp = [0] * n\n   max_len = 0\n   max_start = 0\n   for i in range(n):\n       for j in range(i, n):\n           if s[i] == s[j]:\n               if j - i <= 1:\n                   dp[i] = 1\n               else:\n                   dp[i] = dp[j - 1] + 1\n                   if j - dp[i] + 1 > max_len:\n                       max_len = j - dp[i] + 1\n                       max_start = i\n   return s[max_start: max_start + max_len]\n\n\ndef longest_common_subsequence(s1, s2):\n   '''\n    给定两个字符串s1和s2，编写一个函数，求s1和s2的最长公共子序列的长"}
{"task_id": "MBPP/v522", "completion": "\n\n    n = len(arr)\n    if n <= 1:\n        return n\n    if arr[0] < arr[1]:\n        return 2\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\ndef lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n\n    n = len(arr)\n    if n <= 1:\n        return n\n    if arr[0] < arr[1]:\n        return 2\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\ndef lbs(nums): \n   '''\n    给定一个数组arr，编写一个函数，求arr中", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n\n    n = len(arr)\n    if n <= 1:\n        return n\n    if arr[0] < arr[1]:\n        return 2\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\ndef lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n\n    n = len(arr)\n    if n <= 1:\n        return n\n    if arr[0] < arr[1]:\n        return 2\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\ndef lbs(nums): \n   '''\n    给定一个数组arr，编写一个函数，求arr中"}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i]!= arr[j]:\n                count += 1\n    return count\n\n\ndef insert_Coin(arr):\n    '''\n    给定一个整数数组代表硬币面值，编写一个函数，计算最少几个硬币可以凑出目标值。\n    给定的硬币面值不会相同。\n    >>> insert_Coin([1, 2, 5])\n    2\n    >>> insert_Coin([100, 25, 10, 5, 1])\n    4\n    '''\n    arr.sort()\n    dp = [0] * len(arr)\n    for i in range(0, len(arr)):\n        for j in range(i, len(arr)):\n            if arr[i]!= arr[j]:\n                dp", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i]!= arr[j]:\n                count += 1\n    return count\n\n\ndef insert_Coin(arr):\n    '''\n    给定一个整数数组代表硬币面值，编写一个函数，计算最少几个硬币可以凑出目标值。\n    给定的硬币面值不会相同。\n    >>> insert_Coin([1, 2, 5])\n    2\n    >>> insert_Coin([100, 25, 10, 5, 1])\n    4\n    '''\n    arr.sort()\n    dp = [0] * len(arr)\n    for i in range(0, len(arr)):\n        for j in range(i, len(arr)):\n            if arr[i]!= arr[j]:\n                dp"}
{"task_id": "MBPP/v564", "completion": "\n    if len(arr) < 2: \n        return 0 \n    c = 0 \n    for i in range(len(arr)-1): \n        for j in range(i+1, len(arr)): \n            if arr[i]!= arr[j]: \n                c += 1 \n    return c \n    pass\n\n\ndef count_Pairwise_Swaps(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中使得每对相邻元素交换一次后，升序排列的总方案数。\n    如果数组已经是升序排列，则将方案数返回为0。\n    >>> count_Pairwise_Swaps([1, 2, 3, 4])\n    12\n    >>> count_Pairwise_Swaps([1, 0, 2, 3, 4])\n    30\n    >>> count_Pairwise_Swaps([1, 4, ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if len(arr) < 2: \n        return 0 \n    c = 0 \n    for i in range(len(arr)-1): \n        for j in range(i+1, len(arr)): \n            if arr[i]!= arr[j]: \n                c += 1 \n    return c \n    pass\n\n\ndef count_Pairwise_Swaps(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中使得每对相邻元素交换一次后，升序排列的总方案数。\n    如果数组已经是升序排列，则将方案数返回为0。\n    >>> count_Pairwise_Swaps([1, 2, 3, 4])\n    12\n    >>> count_Pairwise_Swaps([1, 0, 2, 3, 4])\n    30\n    >>> count_Pairwise_Swaps([1, 4, "}
{"task_id": "MBPP/v564", "completion": "\n    return sum([x!= y for i, x in enumerate(arr) for j, y in enumerate(arr) if i < j and x!= y])\n\n\ndef get_kth_symbol(s, k):\n    '''\n    Given a string s and an integer k, find the kth symbol in s.\n    >>> get_kth_symbol('abcdefghijklmnopq', 1)\n    'b'\n    >>> get_kth_symbol('abcdefghijklmnopq', 1000)\n    'd'\n    '''\n    if len(s) <= k:\n        return None\n    k -= 1\n    return s[k]\n\n\n\n# if __name__ == '__main__':\n#     s = 'abcdefghijklmnopq'\n#     # for i in range(len(s)):\n#     #     print(get_kth_symbol(s, i+1))\n\n# if __name__ == '__main__':\n#     s1 = 'abcdef'\n#     s2 = 'fedcba", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    return sum([x!= y for i, x in enumerate(arr) for j, y in enumerate(arr) if i < j and x!= y])\n\n\ndef get_kth_symbol(s, k):\n    '''\n    Given a string s and an integer k, find the kth symbol in s.\n    >>> get_kth_symbol('abcdefghijklmnopq', 1)\n    'b'\n    >>> get_kth_symbol('abcdefghijklmnopq', 1000)\n    'd'\n    '''\n    if len(s) <= k:\n        return None\n    k -= 1\n    return s[k]\n\n\n\n# if __name__ == '__main__':\n#     s = 'abcdefghijklmnopq'\n#     # for i in range(len(s)):\n#     #     print(get_kth_symbol(s, i+1))\n\n# if __name__ == '__main__':\n#     s1 = 'abcdef'\n#     s2 = 'fedcba"}
{"task_id": "MBPP/v564", "completion": "\n    if not arr:\n        return 0\n    # 计数\n    counts = [0] * 100\n\n    for i in range(len(arr)):\n        counts[arr[i]] += 1\n\n    ans = 0\n    for i in range(len(arr)):\n        ans += counts[arr[i]] * (counts[arr[i]] - 1)\n\n    return ans\n\ndef min_Rotation_Count(arr):\n    '''\n    给定一个整数数组，找出其中最小的可能的位置。如果数组中存在相同的数，请输出离该数最近的数的位置。\n    >>> min_Rotation_Count([1, 1, 1, 3, 2, 2])\n    3\n    '''\n    if not arr:\n        return 0\n    # 判断是否是有序的，如果是，返回0\n    if arr == sorted(arr):\n        return 0\n\n    # 查找", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not arr:\n        return 0\n    # 计数\n    counts = [0] * 100\n\n    for i in range(len(arr)):\n        counts[arr[i]] += 1\n\n    ans = 0\n    for i in range(len(arr)):\n        ans += counts[arr[i]] * (counts[arr[i]] - 1)\n\n    return ans\n\ndef min_Rotation_Count(arr):\n    '''\n    给定一个整数数组，找出其中最小的可能的位置。如果数组中存在相同的数，请输出离该数最近的数的位置。\n    >>> min_Rotation_Count([1, 1, 1, 3, 2, 2])\n    3\n    '''\n    if not arr:\n        return 0\n    # 判断是否是有序的，如果是，返回0\n    if arr == sorted(arr):\n        return 0\n\n    # 查找"}
{"task_id": "MBPP/v564", "completion": "\n    res = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i]!= arr[j]:\n                res += 1\n    return res\n```\n\n**实践：**\n\n1. 统计相等的元素出现的次数\n\n```python\ndef count_Pairs(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中相等的元素出现的个数。\n    >>> count_Pairs([1, 2, 1, 2, 1, 2, 3])\n    3\n    >>> count_Pairs([1, 1])\n    1\n    '''\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n```\n\n2. 统计相等的元素对的个", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    res = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i]!= arr[j]:\n                res += 1\n    return res\n```\n\n**实践：**\n\n1. 统计相等的元素出现的次数\n\n```python\ndef count_Pairs(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中相等的元素出现的个数。\n    >>> count_Pairs([1, 2, 1, 2, 1, 2, 3])\n    3\n    >>> count_Pairs([1, 1])\n    1\n    '''\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n```\n\n2. 统计相等的元素对的个"}
{"task_id": "MBPP/v564", "completion": "\n    l = len(arr)\n    if l == 0:\n        return 0\n    elif l == 1:\n        return 0\n    elif l == 2:\n        return 1 if arr[0]!= arr[1] else 0\n    cnt = 0\n    for i in range(0, l):\n        for j in range(i + 1, l):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n\n\ndef _count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> _count_Pairs([1, 2, 3, 4])\n    6\n    >>> _count_Pairs([1, 1, 1])\n    0\n    '''\n    l", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    l = len(arr)\n    if l == 0:\n        return 0\n    elif l == 1:\n        return 0\n    elif l == 2:\n        return 1 if arr[0]!= arr[1] else 0\n    cnt = 0\n    for i in range(0, l):\n        for j in range(i + 1, l):\n            if arr[i]!= arr[j]:\n                cnt += 1\n    return cnt\n\n\ndef _count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> _count_Pairs([1, 2, 3, 4])\n    6\n    >>> _count_Pairs([1, 1, 1])\n    0\n    '''\n    l"}
{"task_id": "MBPP/v564", "completion": "\n    cnt = 0\n    for (i,j) in itertools.permutations(arr, 2):\n        if i!= j:\n            cnt += 1\n    return cnt\n\n\n\ndef main():\n    print(count_Pairs([1, 2, 3, 4]))\n    print(count_Pairs([1, 1, 1]))\n    print(count_Pairs([1, 2, 3, 2]))\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n'''另一种解法\nfrom itertools import combinations\n\n\ndef count_Pairs(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    cnt = 0\n    for (i,j) in itertools.permutations(arr, 2):\n        if i!= j:\n            cnt += 1\n    return cnt\n\n\n\ndef main():\n    print(count_Pairs([1, 2, 3, 4]))\n    print(count_Pairs([1, 1, 1]))\n    print(count_Pairs([1, 2, 3, 2]))\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n'''另一种解法\nfrom itertools import combinations\n\n\ndef count_Pairs(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    "}
{"task_id": "MBPP/v564", "completion": "\n    if not arr:\n        return 0\n    n = len(arr)\n    arr.sort()\n    res = 0\n    for i in range(n):\n        l = i + 1\n        r = n - 1\n        while l < r:\n            if arr[i]!= arr[l] and arr[i]!= arr[r]:\n                res += 1\n            if arr[i] == arr[l]:\n                while l < r and arr[l] == arr[l+1]:\n                    l += 1\n            if arr[i] == arr[r]:\n                while l < r and arr[r] == arr[r-1]:\n                    r -= 1\n            l += 1\n            r -= 1\n    return res\n\n\ndef find_kth_to_last(head, k):\n    '''\n    给定一个单链表和一个数字k，请找到该链表第k个节点。\n    链表长度为n，则有n+1个节点，其", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not arr:\n        return 0\n    n = len(arr)\n    arr.sort()\n    res = 0\n    for i in range(n):\n        l = i + 1\n        r = n - 1\n        while l < r:\n            if arr[i]!= arr[l] and arr[i]!= arr[r]:\n                res += 1\n            if arr[i] == arr[l]:\n                while l < r and arr[l] == arr[l+1]:\n                    l += 1\n            if arr[i] == arr[r]:\n                while l < r and arr[r] == arr[r-1]:\n                    r -= 1\n            l += 1\n            r -= 1\n    return res\n\n\ndef find_kth_to_last(head, k):\n    '''\n    给定一个单链表和一个数字k，请找到该链表第k个节点。\n    链表长度为n，则有n+1个节点，其"}
{"task_id": "MBPP/v564", "completion": "\n\n    # 1.计算数组的长度\n    n = len(arr)\n\n    # 2.初始化结果和左右指针\n    result = 0\n    left = 0\n    right = n - 1\n\n    # 3.左右指针同时遍历\n    while left < right:\n        # 3.1 如果左指针指向的元素值小于右指针指向的元素值， 说明左指针指向的元素值肯定有对应的右指针指向的元素值， 因为元素值相等的情况下， 那么左右指针至少有一个指针指向的元素值为相等， 那么不满足不相等的元素对， 所以这种情况不用计算\n        if arr[left] < arr[right]:\n            result += (right - left - 1)", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n\n    # 1.计算数组的长度\n    n = len(arr)\n\n    # 2.初始化结果和左右指针\n    result = 0\n    left = 0\n    right = n - 1\n\n    # 3.左右指针同时遍历\n    while left < right:\n        # 3.1 如果左指针指向的元素值小于右指针指向的元素值， 说明左指针指向的元素值肯定有对应的右指针指向的元素值， 因为元素值相等的情况下， 那么左右指针至少有一个指针指向的元素值为相等， 那么不满足不相等的元素对， 所以这种情况不用计算\n        if arr[left] < arr[right]:\n            result += (right - left - 1)"}
{"task_id": "MBPP/v564", "completion": "\n    if not arr:\n        return 0\n    length = len(arr)\n    count = 0\n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[i] == arr[j]:\n                count = 0\n            else:\n                count += 1\n    return count\n\n    # print(arr)\n    # 摩尔投票法\n    # from collections import Counter\n    # length = len(arr)\n    # count = 0\n    # c = Counter(arr)\n    # for i in range(length):\n    #     count += c[arr[i]]\n    # return count\n\n# 最大子数组\ndef max_SubArray(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not arr:\n        return 0\n    length = len(arr)\n    count = 0\n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[i] == arr[j]:\n                count = 0\n            else:\n                count += 1\n    return count\n\n    # print(arr)\n    # 摩尔投票法\n    # from collections import Counter\n    # length = len(arr)\n    # count = 0\n    # c = Counter(arr)\n    # for i in range(length):\n    #     count += c[arr[i]]\n    # return count\n\n# 最大子数组\ndef max_SubArray(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr["}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    # dp[i] 表示以 a[i] 为结尾的子集大小\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    print(largest_subset([1, 3, 6, 13, 17, 18]))\n    print(largest_subset([2, 4, 8, 12]))\n\n    # 答案\n    # 最优子结构性质\n    \"\"\"\n    dp[i] 为以 a[i] 为结尾的最大子集大小\n    对于 dp[i]，它的 最优解 由 dp[i - 1]", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    # dp[i] 表示以 a[i] 为结尾的子集大小\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    print(largest_subset([1, 3, 6, 13, 17, 18]))\n    print(largest_subset([2, 4, 8, 12]))\n\n    # 答案\n    # 最优子结构性质\n    \"\"\"\n    dp[i] 为以 a[i] 为结尾的最大子集大小\n    对于 dp[i]，它的 最优解 由 dp[i - 1]"}
{"task_id": "MBPP/train620", "completion": "\n    # 取出最大的数，和剩下的整数组成新的数组\n    # 用递归来处理剩下的数组\n    max_ = arr[0]\n    arr = [x for x in arr if x!= max(arr)]\n\n    count = 0\n    for x in arr:\n        if max_ % x == 0 or x % max_ == 0:\n            count += 1\n            tmp = largest_subset(arr)\n\n            if 1 + count + tmp > count + tmp:\n                count += (1 + tmp)\n                arr = [x for x in arr if x!= max_]\n                arr = [x for x in arr if x!= max_]\n        else:\n            count += 1\n\n    return count\n\ndef test_largest_subset():\n    assert largest_subset([1, 2, 3]) == 3\n    assert largest_subset([2, 4, 8, 12]) == 3\n\ndef smallest_number_with_fixed_length", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 取出最大的数，和剩下的整数组成新的数组\n    # 用递归来处理剩下的数组\n    max_ = arr[0]\n    arr = [x for x in arr if x!= max(arr)]\n\n    count = 0\n    for x in arr:\n        if max_ % x == 0 or x % max_ == 0:\n            count += 1\n            tmp = largest_subset(arr)\n\n            if 1 + count + tmp > count + tmp:\n                count += (1 + tmp)\n                arr = [x for x in arr if x!= max_]\n                arr = [x for x in arr if x!= max_]\n        else:\n            count += 1\n\n    return count\n\ndef test_largest_subset():\n    assert largest_subset([1, 2, 3]) == 3\n    assert largest_subset([2, 4, 8, 12]) == 3\n\ndef smallest_number_with_fixed_length"}
{"task_id": "MBPP/train620", "completion": "\n    def dfs(i, sum):\n        if i == len(arr):\n            return 0\n        if sum[i] >= sum[i + 1]:\n            return dfs(i + 1, sum)\n        else:\n            return max(dfs(i + 1, sum), dfs(i + 1, add(sum, arr[i])) + 1)\n    def add(arr1, m):\n        res = []\n        for i in range(len(arr1)):\n            res.append(arr1[i] + m)\n        return res\n    sum = [0 for _ in range(len(arr) + 1)]\n    for i in range(len(arr)):\n        sum[i + 1] = max(sum[i], arr[i])\n    return dfs(0, sum)\n\ndef max_path_sum(arr):\n    '''\n    给定一个二叉树，编写一个函数，找出其中一个分支的最大路径和。\n    >>> max_path_", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    def dfs(i, sum):\n        if i == len(arr):\n            return 0\n        if sum[i] >= sum[i + 1]:\n            return dfs(i + 1, sum)\n        else:\n            return max(dfs(i + 1, sum), dfs(i + 1, add(sum, arr[i])) + 1)\n    def add(arr1, m):\n        res = []\n        for i in range(len(arr1)):\n            res.append(arr1[i] + m)\n        return res\n    sum = [0 for _ in range(len(arr) + 1)]\n    for i in range(len(arr)):\n        sum[i + 1] = max(sum[i], arr[i])\n    return dfs(0, sum)\n\ndef max_path_sum(arr):\n    '''\n    给定一个二叉树，编写一个函数，找出其中一个分支的最大路径和。\n    >>> max_path_"}
{"task_id": "MBPP/train620", "completion": "\n    # 遍历，求子集的大小\n    # 如果已经满足题目要求，则找到子集大小，返回\n    # 否则，子集大小继续找\n    n = len(arr)\n    dp = [[0 for i in range(n)] for j in range(n)]\n    result = 0\n    for i in range(n): \n        dp[i][i] = 1\n        for j in range(i+1, n): \n            if arr[i] % arr[j] == 0: \n                dp[i][j] = 1\n                result = max(result, dp[i][j])\n    return result \n```\n\n\n#### 1.4. 最大子集和\n\n##### 1.4.1. 求解过程\n\n```\na = [-1, 6, 2, -4, 7, 2, -1, 5]\n\n1. 先看", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 遍历，求子集的大小\n    # 如果已经满足题目要求，则找到子集大小，返回\n    # 否则，子集大小继续找\n    n = len(arr)\n    dp = [[0 for i in range(n)] for j in range(n)]\n    result = 0\n    for i in range(n): \n        dp[i][i] = 1\n        for j in range(i+1, n): \n            if arr[i] % arr[j] == 0: \n                dp[i][j] = 1\n                result = max(result, dp[i][j])\n    return result \n```\n\n\n#### 1.4. 最大子集和\n\n##### 1.4.1. 求解过程\n\n```\na = [-1, 6, 2, -4, 7, 2, -1, 5]\n\n1. 先看"}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort() \n    n = len(arr)\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if arr[j-1]%arr[i-1]==0:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j-1]+1)\n            else:\n                dp[i][j] = dp[i-1][j]\n    return dp[n][n]\n\n\ndef largest_subset2(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset2([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset2([2, 4,", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort() \n    n = len(arr)\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if arr[j-1]%arr[i-1]==0:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j-1]+1)\n            else:\n                dp[i][j] = dp[i-1][j]\n    return dp[n][n]\n\n\ndef largest_subset2(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset2([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset2([2, 4,"}
{"task_id": "MBPP/train620", "completion": "\n    a = sorted(arr)\n    for i in range(min(len(a), len(a) // 2 + 1)):\n        # 找到i之后的最大子集的大小\n        if largest_subset(a[i+1:]) > largest_subset(a[i:]):\n            return largest_subset(a[i+1:]) + 1\n    return 0\n\n\ndef largest_subset_dfs(arr, largest=()):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset_dfs([1, 3, 6, 13, 17, 18])\n    (6, [6])\n    >>> largest_subset_dfs([2, 4, 8, 12])\n    (4, [12])\n    '''\n    if not arr:\n        return largest\n    largest_subset_dfs(arr[", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    a = sorted(arr)\n    for i in range(min(len(a), len(a) // 2 + 1)):\n        # 找到i之后的最大子集的大小\n        if largest_subset(a[i+1:]) > largest_subset(a[i:]):\n            return largest_subset(a[i+1:]) + 1\n    return 0\n\n\ndef largest_subset_dfs(arr, largest=()):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset_dfs([1, 3, 6, 13, 17, 18])\n    (6, [6])\n    >>> largest_subset_dfs([2, 4, 8, 12])\n    (4, [12])\n    '''\n    if not arr:\n        return largest\n    largest_subset_dfs(arr["}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    dp = [len(arr) + 1 for _ in range(n)]\n    dp[0] = 1\n    # 设dp[i]为a[0:i]的最大整除子集的大小\n    for i in range(1, n):\n        for j in range(i - 1, -1, -1):\n            if arr[j] % arr[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    # 选出最大子集\n    return max(dp)\n\n    # 1:1:2  1:2:2\n    # i:i+1:i+2\n    # max(dp[i]-1, dp[i]-2)\n\n    # 先计算递推式\n    # dp[i] = max(dp[j] for j in range(i))\n    \n    # dp[i] = max(dp[j] for j in", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    dp = [len(arr) + 1 for _ in range(n)]\n    dp[0] = 1\n    # 设dp[i]为a[0:i]的最大整除子集的大小\n    for i in range(1, n):\n        for j in range(i - 1, -1, -1):\n            if arr[j] % arr[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    # 选出最大子集\n    return max(dp)\n\n    # 1:1:2  1:2:2\n    # i:i+1:i+2\n    # max(dp[i]-1, dp[i]-2)\n\n    # 先计算递推式\n    # dp[i] = max(dp[j] for j in range(i))\n    \n    # dp[i] = max(dp[j] for j in"}
{"task_id": "MBPP/train620", "completion": "\n    # 使用动态规划\n    # 最大子集合的大小，用dp数组表示\n    dp = [1] * len(arr)\n    # 相邻元素能否整除的标志位\n    flag = [True] * len(arr)\n    # 递推方程 \n    # dp[i] = max{ dp[j] + dp[i - j] }\n    for i in range(2, len(arr)):\n        # 尝试跨越到j为界\n        for j in range(1, i):\n            # 跨越的距离至少是2\n            if arr[i] % arr[j] == 0 and flag[i - j]:\n                # 更新dp和flag\n                dp[i] = max(dp[i], dp[j] + dp[i - j])\n                flag[i] = True\n    return max(dp)\n\n\ndef smallest_", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 使用动态规划\n    # 最大子集合的大小，用dp数组表示\n    dp = [1] * len(arr)\n    # 相邻元素能否整除的标志位\n    flag = [True] * len(arr)\n    # 递推方程 \n    # dp[i] = max{ dp[j] + dp[i - j] }\n    for i in range(2, len(arr)):\n        # 尝试跨越到j为界\n        for j in range(1, i):\n            # 跨越的距离至少是2\n            if arr[i] % arr[j] == 0 and flag[i - j]:\n                # 更新dp和flag\n                dp[i] = max(dp[i], dp[j] + dp[i - j])\n                flag[i] = True\n    return max(dp)\n\n\ndef smallest_"}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort(reverse=True)\n    l = len(arr)\n    dp = [0]*l\n    max_len = 0\n    for i in range(l):\n        if i == 0:\n            dp[i] = arr[i]\n        else:\n            if arr[i] % arr[i-1] == 0:\n                dp[i] = arr[i] + dp[i-1]\n            else:\n                dp[i] = arr[i]\n        max_len = max(max_len, dp[i])\n    return max_len\n\n\n\ndef find_first_non_repeating_char(str):\n    '''\n    Given a string which contains only lowercase letters, find the first non-repeating character in it and return its index. If \n    it doesn't exist, return -1.\n    >>> find_first_non_repeating_char('leetcode')\n    0\n    >>> find_first_non_repeating_char('loveleetcode')\n    2\n", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort(reverse=True)\n    l = len(arr)\n    dp = [0]*l\n    max_len = 0\n    for i in range(l):\n        if i == 0:\n            dp[i] = arr[i]\n        else:\n            if arr[i] % arr[i-1] == 0:\n                dp[i] = arr[i] + dp[i-1]\n            else:\n                dp[i] = arr[i]\n        max_len = max(max_len, dp[i])\n    return max_len\n\n\n\ndef find_first_non_repeating_char(str):\n    '''\n    Given a string which contains only lowercase letters, find the first non-repeating character in it and return its index. If \n    it doesn't exist, return -1.\n    >>> find_first_non_repeating_char('leetcode')\n    0\n    >>> find_first_non_repeating_char('loveleetcode')\n    2\n"}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    max_size = 0\n    for i in range(n):\n        # 在arr[i:]中计算大小为i+1的子集和\n        size = divide_subset_size(arr[i:], i + 1)\n        # max_size的值不能超过i，不然i之前的所有元素都可以跟i整除\n        if size > max_size and size <= i:\n            max_size = size\n    return max_size\n\n\ndef divide_subset_size(arr, max_size):\n    '''\n    >>> divide_subset_size([2, 3, 6], 3)\n    2\n    >>> divide_subset_size([1, 2, 4], 2)\n    1\n    '''\n    n = len(arr)\n    f = [0] * n\n    # 对于arr[0, i]，有f[i] = 1，或f[i] = f[i - 1] + 1\n    for i in", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    max_size = 0\n    for i in range(n):\n        # 在arr[i:]中计算大小为i+1的子集和\n        size = divide_subset_size(arr[i:], i + 1)\n        # max_size的值不能超过i，不然i之前的所有元素都可以跟i整除\n        if size > max_size and size <= i:\n            max_size = size\n    return max_size\n\n\ndef divide_subset_size(arr, max_size):\n    '''\n    >>> divide_subset_size([2, 3, 6], 3)\n    2\n    >>> divide_subset_size([1, 2, 4], 2)\n    1\n    '''\n    n = len(arr)\n    f = [0] * n\n    # 对于arr[0, i]，有f[i] = 1，或f[i] = f[i - 1] + 1\n    for i in"}
{"task_id": "MBPP/train689", "completion": "\n    # write code here\n    # [1, 3, 6, 13, 17]\n    # [1, 3, 6, 13]\n    # [1, 6]\n    # [6]\n  \n    # [6, 13, 17]\n    # [6, 13]\n    # [13]\n    # [13, 17]\n    # [17]\n    # [17, 18]\n    print(arr)\n    n = len(arr)\n    if not arr or n < 2:\n        return 0\n    dp = [n + 1 for _ in range(n)]\n    dp[0] = 0\n    for i in range(n):\n        # print(dp)\n        for j in range(i+1, n):\n            step = min(dp[i + 1:j]) + 1\n            if i + arr[i] >= j:\n                dp[j] = min(dp[j], step)\n    return dp", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # write code here\n    # [1, 3, 6, 13, 17]\n    # [1, 3, 6, 13]\n    # [1, 6]\n    # [6]\n  \n    # [6, 13, 17]\n    # [6, 13]\n    # [13]\n    # [13, 17]\n    # [17]\n    # [17, 18]\n    print(arr)\n    n = len(arr)\n    if not arr or n < 2:\n        return 0\n    dp = [n + 1 for _ in range(n)]\n    dp[0] = 0\n    for i in range(n):\n        # print(dp)\n        for j in range(i+1, n):\n            step = min(dp[i + 1:j]) + 1\n            if i + arr[i] >= j:\n                dp[j] = min(dp[j], step)\n    return dp"}
{"task_id": "MBPP/train689", "completion": "\n    # 1. 求出数组的长度\n    length = len(arr)\n    # 2. 记录最小步数\n    min_num  = 0\n    # 3. 倒序遍历数组\n    for i in range(length-1, 0, -1):\n        # 4. 计算当前位置能达到的位置的最大值（只能向后跳）\n        max_num = arr[i]+i\n        # 5. 记录最小值\n        min_num = max(min_num, max_num)\n    return min_num\n\ndef max_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # 1. 求出数组的长度\n    length = len(arr)\n    # 2. 记录最小步数\n    min_num  = 0\n    # 3. 倒序遍历数组\n    for i in range(length-1, 0, -1):\n        # 4. 计算当前位置能达到的位置的最大值（只能向后跳）\n        max_num = arr[i]+i\n        # 5. 记录最小值\n        min_num = max(min_num, max_num)\n    return min_num\n\ndef max_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n"}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    if n == 0 or n == 1:\n        return n\n    if arr[0] == 0:\n        return -1\n    return min_jumps_inner(arr, n-1)\n    \ndef min_jumps_inner(arr, i):\n    if i == 0:\n        return 0\n    if arr[i] == 0:\n        return -1\n    min_jump_count = min_jumps_inner(arr, i-arr[i])\n    if min_jump_count == -1:\n        return int(min_jump_count)\n    return int(1 + min_jump_count)\n\ndef main():\n    print(min_jumps([1, 3, 6, 13, 17, 18]))\n    print(min_jumps([1, 2, 3, 4, 5, 6, 7]))\n    print(min_jumps([1, 5, 8, 6, 7, 8, 9,", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    if n == 0 or n == 1:\n        return n\n    if arr[0] == 0:\n        return -1\n    return min_jumps_inner(arr, n-1)\n    \ndef min_jumps_inner(arr, i):\n    if i == 0:\n        return 0\n    if arr[i] == 0:\n        return -1\n    min_jump_count = min_jumps_inner(arr, i-arr[i])\n    if min_jump_count == -1:\n        return int(min_jump_count)\n    return int(1 + min_jump_count)\n\ndef main():\n    print(min_jumps([1, 3, 6, 13, 17, 18]))\n    print(min_jumps([1, 2, 3, 4, 5, 6, 7]))\n    print(min_jumps([1, 5, 8, 6, 7, 8, 9,"}
{"task_id": "MBPP/train689", "completion": "\n    size = len(arr)\n    if size == 0:\n        return 0\n    if size == 1:\n        return 1\n    steps = [0 for i in range(size)]\n    steps[0] = 0\n    steps[1] = 1\n    for i in range(2, size):\n        min_steps = sys.maxsize\n        for j in range(i):\n            if arr[j] >= i:\n                tmp_steps = steps[j] + 1\n                if tmp_steps < min_steps:\n                    min_steps = tmp_steps\n        steps[i] = min_steps\n    return steps[size -1]\n\n    # 使用for循环，效率比较低\n    # n = len(arr)\n    # if n == 0:\n    #     return 0\n    # steps = []\n    # steps.append(0)\n    # steps.append(1)\n    # for i in range(2, n):\n    #     min_steps = sys.max", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    size = len(arr)\n    if size == 0:\n        return 0\n    if size == 1:\n        return 1\n    steps = [0 for i in range(size)]\n    steps[0] = 0\n    steps[1] = 1\n    for i in range(2, size):\n        min_steps = sys.maxsize\n        for j in range(i):\n            if arr[j] >= i:\n                tmp_steps = steps[j] + 1\n                if tmp_steps < min_steps:\n                    min_steps = tmp_steps\n        steps[i] = min_steps\n    return steps[size -1]\n\n    # 使用for循环，效率比较低\n    # n = len(arr)\n    # if n == 0:\n    #     return 0\n    # steps = []\n    # steps.append(0)\n    # steps.append(1)\n    # for i in range(2, n):\n    #     min_steps = sys.max"}
{"task_id": "MBPP/train689", "completion": "\n    # 输入：arr = [1, 3, 6, 13, 17, 18]\n    # 输出：3\n    # 解释：\n    # - 我们从第一个元素开始，jump 到第3个元素。\n    # - 我们从第3个元素开始，jump 到第6个元素。\n    # - 我们从第6个元素开始，jump 到第7个元素。\n    \n    # 输入：arr = [2, 0, 0]\n    # 输出：1\n\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return 1\n\n    dp = [0] * len(arr)\n    dp[0] = 1\n    \n    # 递推公式，找到最短路径\n    for i in range(1, len(arr)):\n        dp[i", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # 输入：arr = [1, 3, 6, 13, 17, 18]\n    # 输出：3\n    # 解释：\n    # - 我们从第一个元素开始，jump 到第3个元素。\n    # - 我们从第3个元素开始，jump 到第6个元素。\n    # - 我们从第6个元素开始，jump 到第7个元素。\n    \n    # 输入：arr = [2, 0, 0]\n    # 输出：1\n\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return 1\n\n    dp = [0] * len(arr)\n    dp[0] = 1\n    \n    # 递推公式，找到最短路径\n    for i in range(1, len(arr)):\n        dp[i"}
{"task_id": "MBPP/train689", "completion": "\n    jump = [0]*len(arr)\n    jump[0] = 0\n    for i in range(1,len(arr)):\n        if arr[i-1] == 0:\n            jump[i] = jump[i - 1] + 1\n        else:\n            jump[i] = jump[i - 1] + 1\n            next_jump = i - arr[i - 1]\n            if next_jump >= 0 and jump[next_jump] < jump[i]:\n                jump[i] = jump[next_jump] + 1\n\n    print(jump)\n    return jump[-1]\n\n\nif __name__ == '__main__':\n    \"\"\"\n    \n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n\n    >>> min_jumps([1, 2, 1, 0, 1, 0])\n    1\n\n    >>> min_jumps([1, 2, 1, 0, 1,", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    jump = [0]*len(arr)\n    jump[0] = 0\n    for i in range(1,len(arr)):\n        if arr[i-1] == 0:\n            jump[i] = jump[i - 1] + 1\n        else:\n            jump[i] = jump[i - 1] + 1\n            next_jump = i - arr[i - 1]\n            if next_jump >= 0 and jump[next_jump] < jump[i]:\n                jump[i] = jump[next_jump] + 1\n\n    print(jump)\n    return jump[-1]\n\n\nif __name__ == '__main__':\n    \"\"\"\n    \n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n\n    >>> min_jumps([1, 2, 1, 0, 1, 0])\n    1\n\n    >>> min_jumps([1, 2, 1, 0, 1,"}
{"task_id": "MBPP/train689", "completion": "\n    steps = [0] * len(arr) \n    steps[0] = 0\n    last_reachable = 0\n    for i in range(1, len(arr)): \n        last_reachable = max(last_reachable, i+arr[i-1])\n        if last_reachable >= len(arr)-1: \n            return steps[last_reachable] + 1\n        steps[i] = steps[last_reachable] + 1\n    return steps[len(arr)-1] \n\n\ndef longest_common_subsequence(a, b):\n    '''\n    Given two strings A and B, find the longest common subsequence of A and B.\n    A subsequence of a string S is a string obtained by deleting several characters of a given string S, without changing its order.\n    '''\n    a_len, b_len = len(a), len(b)\n    s = [['']* b_len for _ in range(a_len)]\n\n    for i in range(a_len):\n        for j in range(", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    steps = [0] * len(arr) \n    steps[0] = 0\n    last_reachable = 0\n    for i in range(1, len(arr)): \n        last_reachable = max(last_reachable, i+arr[i-1])\n        if last_reachable >= len(arr)-1: \n            return steps[last_reachable] + 1\n        steps[i] = steps[last_reachable] + 1\n    return steps[len(arr)-1] \n\n\ndef longest_common_subsequence(a, b):\n    '''\n    Given two strings A and B, find the longest common subsequence of A and B.\n    A subsequence of a string S is a string obtained by deleting several characters of a given string S, without changing its order.\n    '''\n    a_len, b_len = len(a), len(b)\n    s = [['']* b_len for _ in range(a_len)]\n\n    for i in range(a_len):\n        for j in range("}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n\n    # 最小步数初始化为n，意味着无法到达数组末尾\n    min_num = 50000\n\n    # 初始化用于存放每个元素可以到达的最远位置（最大步数）和对应的最小步数\n    min_indexes = [n, n]\n\n    for i in range(1, n):\n        # 每次都从左到右更新最大跳跃距离\n        max_jump = arr[i]\n\n        if i + max_jump >= n-1:\n            min_num = 1\n            break\n\n        # 更新最小跳跃距离（跳跃到数组末尾所需要的最少步数）\n        if min_indexes[i + max_jump] > min_num + 1:", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n\n    # 最小步数初始化为n，意味着无法到达数组末尾\n    min_num = 50000\n\n    # 初始化用于存放每个元素可以到达的最远位置（最大步数）和对应的最小步数\n    min_indexes = [n, n]\n\n    for i in range(1, n):\n        # 每次都从左到右更新最大跳跃距离\n        max_jump = arr[i]\n\n        if i + max_jump >= n-1:\n            min_num = 1\n            break\n\n        # 更新最小跳跃距离（跳跃到数组末尾所需要的最少步数）\n        if min_indexes[i + max_jump] > min_num + 1:"}
{"task_id": "MBPP/train689", "completion": "\n\ndef min_jumps_v2(arr):\n    '''\n    def min_jumps_v2(arr):\n    '''\n    return min_jumps_helper(arr, len(arr)-1, 0)\n\n\ndef min_jumps_helper(arr, index, step):\n    '''\n    求解方法：\n    从index开始，看能移动到哪些元素，看能不能移动到哪些元素\n    从i计划，看i移动到哪些元素，如果跳到了i，则返回step加1，然后从i开始继续计算\n    当跳到了，跳到了index，则返回step\n    如果i到达最后一个元素，返回step\n    '''\n    # 找出移动到i的元素\n    if index < 0:\n        return step\n\n    jump = arr[index]\n    # 跳到i\n    if step + 1 <=", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n\ndef min_jumps_v2(arr):\n    '''\n    def min_jumps_v2(arr):\n    '''\n    return min_jumps_helper(arr, len(arr)-1, 0)\n\n\ndef min_jumps_helper(arr, index, step):\n    '''\n    求解方法：\n    从index开始，看能移动到哪些元素，看能不能移动到哪些元素\n    从i计划，看i移动到哪些元素，如果跳到了i，则返回step加1，然后从i开始继续计算\n    当跳到了，跳到了index，则返回step\n    如果i到达最后一个元素，返回step\n    '''\n    # 找出移动到i的元素\n    if index < 0:\n        return step\n\n    jump = arr[index]\n    # 跳到i\n    if step + 1 <="}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    # 步数\n    steps = [0] * n\n    # 终点\n    targets = [0] * n\n    # 记录每个元素到达的位置\n    for x, y in enumerate(arr):\n        # 步数 + 1\n        steps[x] = 1\n        # 当前元素的步数 - 1\n        targets[x] = x - 1\n        # 到达终点时，更新最终终点的步数为 1 + 跳转\n        if targets[x] == x - 1 and x!= n - 1:\n            steps[x] = 2\n    print('steps', steps)\n    print('targets', targets)\n    # 从后往前更新\n    last_index = n - 1\n    for x in range(last_index, -1, -1):\n        # 因为存在循环，不能退", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    # 步数\n    steps = [0] * n\n    # 终点\n    targets = [0] * n\n    # 记录每个元素到达的位置\n    for x, y in enumerate(arr):\n        # 步数 + 1\n        steps[x] = 1\n        # 当前元素的步数 - 1\n        targets[x] = x - 1\n        # 到达终点时，更新最终终点的步数为 1 + 跳转\n        if targets[x] == x - 1 and x!= n - 1:\n            steps[x] = 2\n    print('steps', steps)\n    print('targets', targets)\n    # 从后往前更新\n    last_index = n - 1\n    for x in range(last_index, -1, -1):\n        # 因为存在循环，不能退"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    合并 k 个排序链表，返回合并后的排序链表。\n    >>> mergeKLists([[], [2, 6], [1, 5], [8, 10, 15]])\n    [1, 2, 5, 6, 8, 10, 15]\n    >>> mergeKLists([])\n    []\n    '''\n    # 拆分\n    list_lists = []\n    for i in range(0, len(lists), 2):\n        list_lists.append(mergeTwoLists(lists[i], lists[i + 1]))\n    # 归并\n    while len(list_lists) > 1:\n        list_lists = [mergeTwoLists(list_lists[i], list_lists[i + 1])\n                      for i in range(0, len(list_lists), 2)]\n    return list_lists[0]\n\n\ndef reverseNodesK", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    合并 k 个排序链表，返回合并后的排序链表。\n    >>> mergeKLists([[], [2, 6], [1, 5], [8, 10, 15]])\n    [1, 2, 5, 6, 8, 10, 15]\n    >>> mergeKLists([])\n    []\n    '''\n    # 拆分\n    list_lists = []\n    for i in range(0, len(lists), 2):\n        list_lists.append(mergeTwoLists(lists[i], lists[i + 1]))\n    # 归并\n    while len(list_lists) > 1:\n        list_lists = [mergeTwoLists(list_lists[i], list_lists[i + 1])\n                      for i in range(0, len(list_lists), 2)]\n    return list_lists[0]\n\n\ndef reverseNodesK"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) or j < len(list2):\n        if i == len(list1):\n            list_res.append(list2[j])\n            j += 1\n        elif j == len(list2):\n            list_res.append(list1[i])\n            i += 1\n        else:\n            if list1[i] <= list2[j]:\n                list_res.append(list1[i])\n                i += 1\n            else", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) or j < len(list2):\n        if i == len(list1):\n            list_res.append(list2[j])\n            j += 1\n        elif j == len(list2):\n            list_res.append(list1[i])\n            i += 1\n        else:\n            if list1[i] <= list2[j]:\n                list_res.append(list1[i])\n                i += 1\n            else"}
{"task_id": "leetcode/21", "completion": "\n```\n\n\n>来源：力扣（LeetCode）  \n链接：https://leetcode-cn.com/problems/merge-two-sorted-lists  \n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### 13.mergeTwoLists 补充知识点\n\n| 知识点 | 补充内容 | 备注 |\n| ------------ | -------------- | -------------- |\n|Python列表|列表是一种可变序列，使用方括号标识。| |\n|Python列表|列表中的元素可以通过索引来访问。索引号从0开始。| |\n|Python列表|列表中的元素可以修改。| |\n|Python列表|列表拼接", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n```\n\n\n>来源：力扣（LeetCode）  \n链接：https://leetcode-cn.com/problems/merge-two-sorted-lists  \n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### 13.mergeTwoLists 补充知识点\n\n| 知识点 | 补充内容 | 备注 |\n| ------------ | -------------- | -------------- |\n|Python列表|列表是一种可变序列，使用方括号标识。| |\n|Python列表|列表中的元素可以通过索引来访问。索引号从0开始。| |\n|Python列表|列表中的元素可以修改。| |\n|Python列表|列表拼接"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            list_res.append(list1[i])\n            i += 1\n        else:\n            list_res.append(list2[j])\n            j += 1\n    if i < len(list1):\n        list_res += list1[i:]\n    if j < len(list2):\n        list_res += list2[j:]\n    return list_res\n\n\ndef mergeTwoLists3(list1, list2):\n    '''\n    >>> mergeTwoLists3([1,2,4], [1,3,4", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            list_res.append(list1[i])\n            i += 1\n        else:\n            list_res.append(list2[j])\n            j += 1\n    if i < len(list1):\n        list_res += list1[i:]\n    if j < len(list2):\n        list_res += list2[j:]\n    return list_res\n\n\ndef mergeTwoLists3(list1, list2):\n    '''\n    >>> mergeTwoLists3([1,2,4], [1,3,4"}
{"task_id": "leetcode/21", "completion": "\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    穿列表， 返回排序好的列表\n    '''\n    return list(itertools.chain(list1, list2)) + sorted(list1 + list2)\n\ndef mergeTwoLists3(list1, list2):\n    '''\n    优雅写法（使用异或运算）\n    '''\n    temp = list1 + list2\n    i = 0\n    while i < len(temp):\n        if i+1 >= len(temp) or temp[i] < temp[i+1]:\n            temp[i] += temp[i+1]\n            temp.pop(i+1)\n        else:\n            i += 1\n    return temp\n\ndef mergeTwoLists4(list1, list2):\n    '''\n    在负数前插入0， 然后用较大的数字减较小的数字， 最终得到0\n    不过，需", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    穿列表， 返回排序好的列表\n    '''\n    return list(itertools.chain(list1, list2)) + sorted(list1 + list2)\n\ndef mergeTwoLists3(list1, list2):\n    '''\n    优雅写法（使用异或运算）\n    '''\n    temp = list1 + list2\n    i = 0\n    while i < len(temp):\n        if i+1 >= len(temp) or temp[i] < temp[i+1]:\n            temp[i] += temp[i+1]\n            temp.pop(i+1)\n        else:\n            i += 1\n    return temp\n\ndef mergeTwoLists4(list1, list2):\n    '''\n    在负数前插入0， 然后用较大的数字减较小的数字， 最终得到0\n    不过，需"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    给出 K 个有序链表，合并为一个有序链表。\n    思路: 递归的把所有链表的头部取出，然后再比较\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    '''\n    lists_len = len(lists)\n    # 递归边界\n    if lists_len == 0:\n        return list()\n    elif lists_len == 1:\n        return lists[0]\n\n    i = 0\n    # lists 下一层元素\n    lists_next = lists[i+1::]\n    list_res = mergeTwoLists(lists[i], mergeKLists(lists_next))\n    return list_res\n\n\n'''\nhttps://leetcode-", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    给出 K 个有序链表，合并为一个有序链表。\n    思路: 递归的把所有链表的头部取出，然后再比较\n    >>> mergeKLists([[1,4,5],[1,3,4],[2,6]])\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    '''\n    lists_len = len(lists)\n    # 递归边界\n    if lists_len == 0:\n        return list()\n    elif lists_len == 1:\n        return lists[0]\n\n    i = 0\n    # lists 下一层元素\n    lists_next = lists[i+1::]\n    list_res = mergeTwoLists(lists[i], mergeKLists(lists_next))\n    return list_res\n\n\n'''\nhttps://leetcode-"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    while True:\n        if list1 == []:\n            break\n        if list2 == []:\n            break\n        if list1[0] < list2[0]:\n            list_res.append(list1[0])\n            list1 = list1[1:]\n        elif list1[0] >= list2[0]:\n            list_res.append(list2[0])\n            list2 = list2[1:]\n    if list1:\n        list_res += list1\n    elif list2:\n        list", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists2([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists2([], [])\n    []\n    '''\n    list_res = []\n    while True:\n        if list1 == []:\n            break\n        if list2 == []:\n            break\n        if list1[0] < list2[0]:\n            list_res.append(list1[0])\n            list1 = list1[1:]\n        elif list1[0] >= list2[0]:\n            list_res.append(list2[0])\n            list2 = list2[1:]\n    if list1:\n        list_res += list1\n    elif list2:\n        list"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists):\n    '''\n    给定一个链表数组，每个链表的结点包含一个整数，这些整数是按非递增顺序排列的。\n    请将列表按顺序合并，使得合并后的列表中的结点也是按非递减排序排列的。\n    例如输入以下链表：\n    [\n      4->5->1->3,\n      2->6->7\n    ]\n    输出的合并后链表如下：\n    [\n      1->2->3->4->5->6->7\n    ]\n    >>> mergeKLists([])\n    []\n    >>> mergeKLists([None])\n    []\n    '''\n    if not lists:\n        return []\n    elif len(lists) == 1:\n        return lists[0]\n    else:\n        mid = len(", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists):\n    '''\n    给定一个链表数组，每个链表的结点包含一个整数，这些整数是按非递增顺序排列的。\n    请将列表按顺序合并，使得合并后的列表中的结点也是按非递减排序排列的。\n    例如输入以下链表：\n    [\n      4->5->1->3,\n      2->6->7\n    ]\n    输出的合并后链表如下：\n    [\n      1->2->3->4->5->6->7\n    ]\n    >>> mergeKLists([])\n    []\n    >>> mergeKLists([None])\n    []\n    '''\n    if not lists:\n        return []\n    elif len(lists) == 1:\n        return lists[0]\n    else:\n        mid = len("}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKSortedArrays(nums):\n    '''\n    给定 K 个排序好的数组，将其合并为一个排序好的数组。\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    '''\n    res = []\n    if not nums:\n        return res\n    if len(nums) == 1", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKSortedArrays(nums):\n    '''\n    给定 K 个排序好的数组，将其合并为一个排序好的数组。\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    >>> mergeKSortedArrays( [[1,4,5],[1,3,4,5],[2,6]] )\n    [1, 1, 2, 3, 4, 4, 5, 5, 6]\n    '''\n    res = []\n    if not nums:\n        return res\n    if len(nums) == 1"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == '__main__':\n    f = open('datasets/test.txt', 'r')\n    lines = f.readlines()\n    for line in lines:\n        ret1 = removeDuplicatesBySort(line.split())\n        ret2 = removeDuplicatesBySet(line.split())\n        ret3 = removeDuplicatesBySort(line.", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == '__main__':\n    f = open('datasets/test.txt', 'r')\n    lines = f.readlines()\n    for line in lines:\n        ret1 = removeDuplicatesBySort(line.split())\n        ret2 = removeDuplicatesBySet(line.split())\n        ret3 = removeDuplicatesBySort(line."}
{"task_id": "leetcode/35", "completion": "\n    # 数组中target存在则直接返回target的索引\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    # 不存在则先返回target最后一个小于target的元素索引，如果没有则返回0\n    for i in range(len(nums)):\n        if nums[i] < target:\n            return i\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # find the index of the first element which is larger than target\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nclass Solution:\n    def searchInsert(self, nums, target):\n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    # 数组中target存在则直接返回target的索引\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    # 不存在则先返回target最后一个小于target的元素索引，如果没有则返回0\n    for i in range(len(nums)):\n        if nums[i] < target:\n            return i\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # find the index of the first element which is larger than target\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nclass Solution:\n    def searchInsert(self, nums, target):\n"}
{"task_id": "leetcode/35", "completion": "\n    if not nums:\n        return 0\n    n = len(nums)\n    if target < nums[0]:\n        return 0\n    if target > nums[-1]:\n        return n\n    for i in range(1, n):\n        if nums[i] >= target:\n            return i\n    return n\n\nif __name__ == '__main__':\n    print(searchInsert([1, 2, 4, 5, 6, 7], 4))\n    print(searchInsert([1,3,5,6], 5))\n    print(searchInsert([1,3,5,6], 2))\n    print(searchInsert([1,3,5,6], 7))\n    print(searchInsert([1], 1))\n    print(searchInsert([1,2], 2))\n    print(searchInsert([1,3,5,6], 1))\n    print(searchInsert([1,2], 3))\n    print(searchInsert([1,3,5,6], 0))\n    print(searchInsert([", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums:\n        return 0\n    n = len(nums)\n    if target < nums[0]:\n        return 0\n    if target > nums[-1]:\n        return n\n    for i in range(1, n):\n        if nums[i] >= target:\n            return i\n    return n\n\nif __name__ == '__main__':\n    print(searchInsert([1, 2, 4, 5, 6, 7], 4))\n    print(searchInsert([1,3,5,6], 5))\n    print(searchInsert([1,3,5,6], 2))\n    print(searchInsert([1,3,5,6], 7))\n    print(searchInsert([1], 1))\n    print(searchInsert([1,2], 2))\n    print(searchInsert([1,3,5,6], 1))\n    print(searchInsert([1,2], 3))\n    print(searchInsert([1,3,5,6], 0))\n    print(searchInsert(["}
{"task_id": "leetcode/35", "completion": "\n    length = len(nums)\n    # 找到第一个大于target的数字的索引\n    for index in range(length):\n        if nums[index] >= target:\n            return index\n    return length\n\n\ndef isPalindrome(s):\n    '''\n    给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n    >>> isPalindrome('A man, a plan, a canal: Panama')\n    True\n    >>> isPalindrome('race a car')\n    False\n    '''\n    if len(s) == 1:\n        return True\n    if len(s) == 2:\n        return s[0] == s[1]\n    s_low = s.lower()\n    s_set = set(s_low)\n    for index in range(len(s) // 2):\n        if (s_set.intersection(s[", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    length = len(nums)\n    # 找到第一个大于target的数字的索引\n    for index in range(length):\n        if nums[index] >= target:\n            return index\n    return length\n\n\ndef isPalindrome(s):\n    '''\n    给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n    >>> isPalindrome('A man, a plan, a canal: Panama')\n    True\n    >>> isPalindrome('race a car')\n    False\n    '''\n    if len(s) == 1:\n        return True\n    if len(s) == 2:\n        return s[0] == s[1]\n    s_low = s.lower()\n    s_set = set(s_low)\n    for index in range(len(s) // 2):\n        if (s_set.intersection(s["}
{"task_id": "leetcode/35", "completion": "\n    start = 0\n    end = len(nums)-1\n\n    while start <= end:\n        mid = start + (end - start) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            start = mid + 1\n        elif nums[mid] > target:\n            end = mid - 1\n        if start > end:\n            return start\n\n\n\n\ndef maxSlidingWindow(nums, k):\n    '''\n    给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n    返回滑动窗口中的最大值。\n    >>> maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    start = 0\n    end = len(nums)-1\n\n    while start <= end:\n        mid = start + (end - start) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            start = mid + 1\n        elif nums[mid] > target:\n            end = mid - 1\n        if start > end:\n            return start\n\n\n\n\ndef maxSlidingWindow(nums, k):\n    '''\n    给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n    返回滑动窗口中的最大值。\n    >>> maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3"}
{"task_id": "leetcode/35", "completion": "\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n```\n\n\n#### 1.3 搜索旋转排序数组\n\n> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n你可以��", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n```\n\n\n#### 1.3 搜索旋转排序数组\n\n> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n你可以��"}
{"task_id": "leetcode/35", "completion": "\n    if target > nums[-1]:\n        return len(nums)\n    elif target < nums[0]:\n        return 0\n    else:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            p = (left + right) // 2\n            if nums[p] == target:\n                return p\n            elif nums[p] < target:\n                left = p + 1\n            else:\n                right = p - 1\n        return left\n\n\ndef mergeTwoLists(l1, l2):\n    '''\n    :type l1: ListNode\n    :type l2: ListNode\n    :rtype: ListNode\n\n    将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的节点组成的。\n    题目链接: https://leetcode-cn.com/problems/merge-two-sorted-lists/\n    ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target > nums[-1]:\n        return len(nums)\n    elif target < nums[0]:\n        return 0\n    else:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            p = (left + right) // 2\n            if nums[p] == target:\n                return p\n            elif nums[p] < target:\n                left = p + 1\n            else:\n                right = p - 1\n        return left\n\n\ndef mergeTwoLists(l1, l2):\n    '''\n    :type l1: ListNode\n    :type l2: ListNode\n    :rtype: ListNode\n\n    将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的节点组成的。\n    题目链接: https://leetcode-cn.com/problems/merge-two-sorted-lists/\n    "}
{"task_id": "leetcode/35", "completion": "\n    if nums is None or len(num", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if nums is None or len(num"}
{"task_id": "leetcode/35", "completion": "\n    if not nums:\n        return 0\n\n    index = bisect.bisect_left(nums, target)\n    if index == len(nums) or nums[index]!= target:\n        return index\n    else:\n        return index\n```\n\n#### 时间复杂度：O(logn)\n#### 空间复杂度：O(1)\n\n---\n\n## 3.折半查找\n\n```python\ndef searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums:\n        return 0\n\n    index = bisect.bisect_left(nums, target)\n    if index == len(nums) or nums[index]!= target:\n        return index\n    else:\n        return index\n```\n\n#### 时间复杂度：O(logn)\n#### 空间复杂度：O(1)\n\n---\n\n## 3.折半查找\n\n```python\ndef searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2"}
{"task_id": "leetcode/35", "completion": "\n    if not nums:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    mid = int((left + right) / 2)\n    while left < right:\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n                mid = int((left + right) / 2)\n        else:\n            left = mid\n            mid = int((left + right) / 2)\n    return left + 1\n\n\nif __name__ == '__main__':\n    print(searchInsert([1,3,5,6], 5))\n    print(searchInsert([1,3,5,6], 2))\n    print(searchInsert([1,3,5,6], 7))\n    print(searchInsert([1,3,5", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    mid = int((left + right) / 2)\n    while left < right:\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n                mid = int((left + right) / 2)\n        else:\n            left = mid\n            mid = int((left + right) / 2)\n    return left + 1\n\n\nif __name__ == '__main__':\n    print(searchInsert([1,3,5,6], 5))\n    print(searchInsert([1,3,5,6], 2))\n    print(searchInsert([1,3,5,6], 7))\n    print(searchInsert([1,3,5"}
{"task_id": "leetcode/35", "completion": "\n    len = len(nums)\n    if nums[len - 1] < target:\n        return len\n    elif nums[0] >= target:\n        return 0\n    for i in range(len):\n        if nums[i] >= target:\n            return i\n    return len\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n    要求符合输入输出格式的输出一个数组，输出数组的两个元素分别为两个数字的索引。\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([2, 7, 11, 15], 25)\n    [2, 3]\n    >>> twoSum([1, 2, 3, 4], 10)\n    [0, 3]\n    '''", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    len = len(nums)\n    if nums[len - 1] < target:\n        return len\n    elif nums[0] >= target:\n        return 0\n    for i in range(len):\n        if nums[i] >= target:\n            return i\n    return len\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n    要求符合输入输出格式的输出一个数组，输出数组的两个元素分别为两个数字的索引。\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([2, 7, 11, 15], 25)\n    [2, 3]\n    >>> twoSum([1, 2, 3, 4], 10)\n    [0, 3]\n    '''"}
{"task_id": "leetcode/217", "completion": "\n    n = len(nums)\n    if n == 0:\n        return False\n    if n == 1:\n        return False\n    if n == 2:\n        return bool(nums[0] == nums[1])\n    if n == 3:\n        return bool(nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2])\n    d = {}\n    for num in nums:\n        if num in d.keys():\n            return True\n        else:\n            d[num] = 1\n    return False\n\nprint(containsDuplicate([1,2,3,4]))\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate2([1,2,3,1])\n    True", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    n = len(nums)\n    if n == 0:\n        return False\n    if n == 1:\n        return False\n    if n == 2:\n        return bool(nums[0] == nums[1])\n    if n == 3:\n        return bool(nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2])\n    d = {}\n    for num in nums:\n        if num in d.keys():\n            return True\n        else:\n            d[num] = 1\n    return False\n\nprint(containsDuplicate([1,2,3,4]))\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate2([1,2,3,1])\n    True"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2, 请你找出并返回这两个正序数组的中位数。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    '''\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    i, j = 0, 0\n    left = []\n    while i < m and j < n:", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2, 请你找出并返回这两个正序数组的中位数。\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([1,2], [3,4])\n    2.5\n    '''\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    i, j = 0, 0\n    left = []\n    while i < m and j < n:"}
{"task_id": "leetcode/217", "completion": "\n    # 哈希表\n    nums_dict = {}\n    for num in nums:\n        if num not in nums_dict:\n            nums_dict[num] = 1\n        else:\n            return True\n    return False\n\n    # 排序\n    nums.sort()\n    for index in range(len(nums) - 1):\n        if nums[index] == nums[index+1]:\n            return True\n    return False\n\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出它。\n    示例 1:\n        给定 nums = [1,3,4,2,2]，\n        返回 ", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 哈希表\n    nums_dict = {}\n    for num in nums:\n        if num not in nums_dict:\n            nums_dict[num] = 1\n        else:\n            return True\n    return False\n\n    # 排序\n    nums.sort()\n    for index in range(len(nums) - 1):\n        if nums[index] == nums[index+1]:\n            return True\n    return False\n\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出它。\n    示例 1:\n        给定 nums = [1,3,4,2,2]，\n        返回 "}
{"task_id": "leetcode/217", "completion": "\n    return len(nums)!= len(set(nums))\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值小于等于 k\n    >>> containsNearbyDuplicate([1,2,3,1],3)\n    True\n    >>> containsNearbyDuplicate([1,0,1,1],1)\n    True\n    >>> containsNearbyDuplicate([1,2,3,1,2,3],2)\n    False\n    '''\n    for i in range(len(nums)):\n        if i < k+1:\n            continue\n        if nums[i] in nums[i-k-1:i]:\n            return True\n    return False\n\ndef moveZeroes(nums):\n    '''\n    给定一个", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值小于等于 k\n    >>> containsNearbyDuplicate([1,2,3,1],3)\n    True\n    >>> containsNearbyDuplicate([1,0,1,1],1)\n    True\n    >>> containsNearbyDuplicate([1,2,3,1,2,3],2)\n    False\n    '''\n    for i in range(len(nums)):\n        if i < k+1:\n            continue\n        if nums[i] in nums[i-k-1:i]:\n            return True\n    return False\n\ndef moveZeroes(nums):\n    '''\n    给定一个"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1])\n    1\n    '''\n    max_so_far = nums[0]\n    max_ending_here = 0\n    for num in nums:\n        max_ending_here = max(num, max_ending_here+num)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef minSubArrayLen(s, nums):", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1])\n    1\n    '''\n    max_so_far = nums[0]\n    max_ending_here = 0\n    for num in nums:\n        max_ending_here = max(num, max_ending_here+num)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef minSubArrayLen(s, nums):"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\n\ndef containsDuplicate_2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums = set(nums)\n    if len(nums) >= len(nums):\n        return True\n    return False\n\n\ndef isHappy(n):\n    '''\n    第 1 题： 写一个判断一个数字是否是快乐数的方法, 快乐数就是一个等于其数字和下一步这个", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\n\n\ndef containsDuplicate_2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums = set(nums)\n    if len(nums) >= len(nums):\n        return True\n    return False\n\n\ndef isHappy(n):\n    '''\n    第 1 题： 写一个判断一个数字是否是快乐数的方法, 快乐数就是一个等于其数字和下一步这个"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    start, end = 0, len(nums) - 1\n    while start < end:\n        if nums[start] == nums[end]:\n            return True\n        while start < end and nums[start] == nums[start + 1]:\n            start += 1\n        while start < end and nums[end] ==", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    start, end = 0, len(nums) - 1\n    while start < end:\n        if nums[start] == nums[end]:\n            return True\n        while start < end and nums[start] == nums[start + 1]:\n            start += 1\n        while start < end and nums[end] =="}
{"task_id": "leetcode/217", "completion": "\n    length = len(nums)\n    if length == 0:\n        return False\n\n    # 排序后判断是否有相邻元素相同\n    nums.sort()\n    for i in range(length - 1):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\n\ndef containsDuplicate_1(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。\n    如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> containsDuplicate_1([1,2,3,1])\n    True\n    >>> containsDuplicate_1([1,2,3,4])\n    False\n    '''\n    if len(nums) <= 1:\n        return False\n\n    nums.sort()\n    for i in range(len(nums) -", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    length = len(nums)\n    if length == 0:\n        return False\n\n    # 排序后判断是否有相邻元素相同\n    nums.sort()\n    for i in range(length - 1):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\n\ndef containsDuplicate_1(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。\n    如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> containsDuplicate_1([1,2,3,1])\n    True\n    >>> containsDuplicate_1([1,2,3,4])\n    False\n    '''\n    if len(nums) <= 1:\n        return False\n\n    nums.sort()\n    for i in range(len(nums) -"}
{"task_id": "leetcode/217", "completion": "\n    hashTable = [None]*1000\n    for i in nums:\n        if i>1000 or i<0:\n            return True\n        if hashTable[i]!=None:\n            return True\n        else:\n            hashTable[i] = i\n    return False\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate2([1,2,3,4])\n    False\n    >>> containsDuplicate2([1,2,3,1])\n    True\n    '''\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i]==nums[i+1]:\n            return True\n    return False\n\ndef containsDuplicate3(nums):\n    '''\n    给定一个整数数组 '", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    hashTable = [None]*1000\n    for i in nums:\n        if i>1000 or i<0:\n            return True\n        if hashTable[i]!=None:\n            return True\n        else:\n            hashTable[i] = i\n    return False\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate2([1,2,3,4])\n    False\n    >>> containsDuplicate2([1,2,3,1])\n    True\n    '''\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i]==nums[i+1]:\n            return True\n    return False\n\ndef containsDuplicate3(nums):\n    '''\n    给定一个整数数组 '"}
{"task_id": "leetcode/217", "completion": "\n    if len(nums) == 0:\n        return False\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\ndef lengthOfLongestSubstring(s):\n    \"\"\"\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    >>> lengthOfLongestSubstring('abcabcbb')\n    3\n    >>> lengthOfLongestSubstring('bbbbb')\n    1\n    >>> lengthOfLongestSubstring('pwwkew')\n    3\n    \"\"\"\n    if len(s) == 0:\n        return 0\n    max_len = 0\n    nums = []\n    for i in range(len(s)):\n        if nums:\n            index = nums.index(s[i])\n            if i - index >= max_len:\n                max_len = i - index\n        nums", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    if len(nums) == 0:\n        return False\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i] == nums[i + 1]:\n            return True\n    return False\n\ndef lengthOfLongestSubstring(s):\n    \"\"\"\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n    >>> lengthOfLongestSubstring('abcabcbb')\n    3\n    >>> lengthOfLongestSubstring('bbbbb')\n    1\n    >>> lengthOfLongestSubstring('pwwkew')\n    3\n    \"\"\"\n    if len(s) == 0:\n        return 0\n    max_len = 0\n    nums = []\n    for i in range(len(s)):\n        if nums:\n            index = nums.index(s[i])\n            if i - index >= max_len:\n                max_len = i - index\n        nums"}
{"task_id": "leetcode/697", "completion": "\n    temp = collections.Counter(nums)\n    # print(temp)\n    \n    if len(temp) == len(nums):\n        return 1\n    # 去掉重复的数字\n    d = [key for key, value in temp.items() if value == max(temp.values())]\n    # print(d)\n    \n    ans = list()\n    for i in range(len(nums)):\n        # 删除重复数字\n        if nums[i] not in d:\n            continue\n        s = set()\n        # 存储所有索引位置\n        for j in range(len(nums)):\n            if nums[j] == nums[i]:\n                s.add(j)\n        # 存在重复数字且不存在\n        if not s:\n            continue\n        # print(s)\n        # 更新ans\n        l = len(s)\n        if ans:\n            if l > len(ans):\n                ans = list(s)\n        elif l ==", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    temp = collections.Counter(nums)\n    # print(temp)\n    \n    if len(temp) == len(nums):\n        return 1\n    # 去掉重复的数字\n    d = [key for key, value in temp.items() if value == max(temp.values())]\n    # print(d)\n    \n    ans = list()\n    for i in range(len(nums)):\n        # 删除重复数字\n        if nums[i] not in d:\n            continue\n        s = set()\n        # 存储所有索引位置\n        for j in range(len(nums)):\n            if nums[j] == nums[i]:\n                s.add(j)\n        # 存在重复数字且不存在\n        if not s:\n            continue\n        # print(s)\n        # 更新ans\n        l = len(s)\n        if ans:\n            if l > len(ans):\n                ans = list(s)\n        elif l =="}
{"task_id": "leetcode/697", "completion": "\n    # 先记录每个数字出现的次数\n    count_dict = collections.Counter(nums)\n    # 再统计每个数字出现的次数的最小索引和最大索引\n    num_list = []\n    for num, count in count_dict.items():\n        num_list.append((num, (count, nums.index(num), nums.index(num)+count-1)))\n    num_list.sort(key=lambda x: (x[0], x[1][1], x[1][2]))\n    max_count = num_list[0][0]\n    result = 10000\n    i = 0\n    while i < len(num_list):\n        count = num_list[i][0]\n        start = num_list[i][1][1]\n        end = num_list[i][1][2]\n        if count == max_count:\n            result = min(result, end - start + 1)", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 先记录每个数字出现的次数\n    count_dict = collections.Counter(nums)\n    # 再统计每个数字出现的次数的最小索引和最大索引\n    num_list = []\n    for num, count in count_dict.items():\n        num_list.append((num, (count, nums.index(num), nums.index(num)+count-1)))\n    num_list.sort(key=lambda x: (x[0], x[1][1], x[1][2]))\n    max_count = num_list[0][0]\n    result = 10000\n    i = 0\n    while i < len(num_list):\n        count = num_list[i][0]\n        start = num_list[i][1][1]\n        end = num_list[i][1][2]\n        if count == max_count:\n            result = min(result, end - start + 1)"}
{"task_id": "leetcode/697", "completion": "\n\n    dict_num = {}\n    for i, num in enumerate(nums):\n        if num not in dict_num:\n            dict_num[num] = [i, 1]\n        else:\n            dict_num[num][1] += 1\n        dict_num[num][0] = i\n\n    max_length = max([dict_num[x][1] for x in dict_num])\n    for key, value in dict_num.items():\n        if value[1] == max_length:\n            if len(value) == 2:\n                value = [value[0], value[0]+1]\n            else:\n                value.insert(0, value[0])\n            return value\n    return [1,2]\ndef findMinArrowShots(points):\n    '''\n    给定一组弓箭，写一个函数计算这些箭矢能够打破的平铺的最小数量。\n    有些箭矢的箭身是��", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n\n    dict_num = {}\n    for i, num in enumerate(nums):\n        if num not in dict_num:\n            dict_num[num] = [i, 1]\n        else:\n            dict_num[num][1] += 1\n        dict_num[num][0] = i\n\n    max_length = max([dict_num[x][1] for x in dict_num])\n    for key, value in dict_num.items():\n        if value[1] == max_length:\n            if len(value) == 2:\n                value = [value[0], value[0]+1]\n            else:\n                value.insert(0, value[0])\n            return value\n    return [1,2]\ndef findMinArrowShots(points):\n    '''\n    给定一组弓箭，写一个函数计算这些箭矢能够打破的平铺的最小数量。\n    有些箭矢的箭身是��"}
{"task_id": "leetcode/697", "completion": "\n    counter = collections.Counter(nums)\n    maxCount = max(counter.values())\n    max_len = len(nums)\n    for i,count in enumerate(counter.values()):\n        if count == maxCount:\n            tmp = [count, i]\n            res = min(tmp)\n            max_len = min([max_len, len(nums)-i])\n            #print(res)\n\n    return max_len\n\n\ndef find_missing_ranges(nums, lower, upper):\n    \"\"\"\n    :type nums: List[int]\n    :type lower: int\n    :type upper: int\n    :rtype: List[str]\n    \"\"\"\n    def bin_search_lower(nums, target):\n        start, end = 0, len(nums)\n        while start+1 < end:\n            mid = (start+end) // 2\n            if nums[mid] >= target:\n                end = mid\n            else:\n                start = mid\n        if nums[start] < target:\n            start += 1\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    counter = collections.Counter(nums)\n    maxCount = max(counter.values())\n    max_len = len(nums)\n    for i,count in enumerate(counter.values()):\n        if count == maxCount:\n            tmp = [count, i]\n            res = min(tmp)\n            max_len = min([max_len, len(nums)-i])\n            #print(res)\n\n    return max_len\n\n\ndef find_missing_ranges(nums, lower, upper):\n    \"\"\"\n    :type nums: List[int]\n    :type lower: int\n    :type upper: int\n    :rtype: List[str]\n    \"\"\"\n    def bin_search_lower(nums, target):\n        start, end = 0, len(nums)\n        while start+1 < end:\n            mid = (start+end) // 2\n            if nums[mid] >= target:\n                end = mid\n            else:\n                start = mid\n        if nums[start] < target:\n            start += 1\n"}
{"task_id": "leetcode/697", "completion": "\n    if len(nums) == 0:\n        return 0\n    dict = collections.defaultdict(int)\n    countDict = collections.defaultdict(int)\n\n    for i in range(len(nums)):\n        dict[nums[i]] = i\n        countDict[nums[i]] += 1\n\n    first = -1\n    second = len(nums)\n    maxCount = 0\n    minLength = len(nums)\n    for num in countDict:\n        if countDict[num] > maxCount:\n            maxCount = countDict[num]\n            first,second = dict[num],i\n        if maxCount == countDict[num]:\n            if second-dict[num] < minLength:\n                minLength = second-dict[num]\n    return minLength\n\nl = [1,2,2,3,1]\nprint(findShortestSubArray(l))\n\n# 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    if len(nums) == 0:\n        return 0\n    dict = collections.defaultdict(int)\n    countDict = collections.defaultdict(int)\n\n    for i in range(len(nums)):\n        dict[nums[i]] = i\n        countDict[nums[i]] += 1\n\n    first = -1\n    second = len(nums)\n    maxCount = 0\n    minLength = len(nums)\n    for num in countDict:\n        if countDict[num] > maxCount:\n            maxCount = countDict[num]\n            first,second = dict[num],i\n        if maxCount == countDict[num]:\n            if second-dict[num] < minLength:\n                minLength = second-dict[num]\n    return minLength\n\nl = [1,2,2,3,1]\nprint(findShortestSubArray(l))\n\n# 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可"}
{"task_id": "leetcode/697", "completion": "\n    # 找到每个数字出现的次数\n    count = collections.Counter(nums)\n    # 每个数字对应的出现的次数\n    degree = []\n    # 遍历计算每个数字的出现的次数\n    for i in count:\n        degree.append(count[i])\n    # 找到该数组最大的出现次数\n    maxDegree = max(degree)\n    #记录最大的出现次数的数字\n    maxNumber = []\n    i=0\n    for i in range(len(degree)):\n        if degree[i] == maxDegree:\n            maxNumber.append(i)\n    #找到最小值\n    minDegree = degree[maxNumber[0]]\n    minNumber = maxNumber[0]\n    for i in range(1,len(maxNumber)):\n        if degree[maxNumber[i]] < minDegree:\n            minDegree = degree[maxNumber[i]]", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 找到每个数字出现的次数\n    count = collections.Counter(nums)\n    # 每个数字对应的出现的次数\n    degree = []\n    # 遍历计算每个数字的出现的次数\n    for i in count:\n        degree.append(count[i])\n    # 找到该数组最大的出现次数\n    maxDegree = max(degree)\n    #记录最大的出现次数的数字\n    maxNumber = []\n    i=0\n    for i in range(len(degree)):\n        if degree[i] == maxDegree:\n            maxNumber.append(i)\n    #找到最小值\n    minDegree = degree[maxNumber[0]]\n    minNumber = maxNumber[0]\n    for i in range(1,len(maxNumber)):\n        if degree[maxNumber[i]] < minDegree:\n            minDegree = degree[maxNumber[i]]"}
{"task_id": "leetcode/697", "completion": "\n    dic = collections.defaultdict(list)\n    for i, num in enumerate(nums):\n        dic[num].append(i)\n        \n    degree = 0\n    max_len = len(nums)\n    shortest_len = len(nums)\n    \n    for key in dic:\n        values = dic[key]\n        if len(values) > degree and len(values) < max_len:\n            max_len = len(values)\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n        elif len(values) == degree and len(values) < max_len:\n            max_len = len(values)\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n        elif len(values) > degree and len(values) == max_len:\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n    return shortest_len\n\n\ndef get_max_consec", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    dic = collections.defaultdict(list)\n    for i, num in enumerate(nums):\n        dic[num].append(i)\n        \n    degree = 0\n    max_len = len(nums)\n    shortest_len = len(nums)\n    \n    for key in dic:\n        values = dic[key]\n        if len(values) > degree and len(values) < max_len:\n            max_len = len(values)\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n        elif len(values) == degree and len(values) < max_len:\n            max_len = len(values)\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n        elif len(values) > degree and len(values) == max_len:\n            degree = len(values)\n            shortest_len = values[-1] - values[0] + 1\n    return shortest_len\n\n\ndef get_max_consec"}
{"task_id": "leetcode/697", "completion": "\n    #  1. 对nums进行先排序后去重\n    #  2. 根据题意, 要求nums中元素出现频率最高的元素, 所以用一个counter记录值和出现频率\n    #    用一个dict记录元素出现频率\n    cnt = collections.Counter(nums)\n    ret = []\n    dict_cnt = {}\n    for k, v in cnt.items():\n        dict_cnt[k] = v\n    #  3. 找出所有占有最高度的元素, 如果有多个则返回最小长度\n    max_value = max(dict_cnt.values())\n    min_length = len(nums)\n    for k, v in dict_cnt.items():\n        if v == max_value:\n            ret.append(k)\n    for i in range(1, len(ret)):\n        min_length = min(min_length,", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    #  1. 对nums进行先排序后去重\n    #  2. 根据题意, 要求nums中元素出现频率最高的元素, 所以用一个counter记录值和出现频率\n    #    用一个dict记录元素出现频率\n    cnt = collections.Counter(nums)\n    ret = []\n    dict_cnt = {}\n    for k, v in cnt.items():\n        dict_cnt[k] = v\n    #  3. 找出所有占有最高度的元素, 如果有多个则返回最小长度\n    max_value = max(dict_cnt.values())\n    min_length = len(nums)\n    for k, v in dict_cnt.items():\n        if v == max_value:\n            ret.append(k)\n    for i in range(1, len(ret)):\n        min_length = min(min_length,"}
{"task_id": "leetcode/697", "completion": "\n    if not nums:\n        return 0\n    # 统计每个数出现的次数\n    counts = collections.Counter(nums)\n    # 统计每个数出现的具体次数，以及最开始出现的位置，最后出现的位置\n    # (count, begin, end)\n    values = []\n    for k, v in counts.items():\n        values.append((v, nums.index(k), nums.index(k) + 1))\n    # 将counts排序，并将排序好的链表插入values中\n    sorted(values, key=lambda x: x[0])\n    # 寻找子数组中值与次数最大的子数组\n    max_value, max_times, begin, end = values[0][1:]\n    for value in values[1:]:\n        i, j = value[1:3]\n        if value[0] == max_times:\n            if j - begin <", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    if not nums:\n        return 0\n    # 统计每个数出现的次数\n    counts = collections.Counter(nums)\n    # 统计每个数出现的具体次数，以及最开始出现的位置，最后出现的位置\n    # (count, begin, end)\n    values = []\n    for k, v in counts.items():\n        values.append((v, nums.index(k), nums.index(k) + 1))\n    # 将counts排序，并将排序好的链表插入values中\n    sorted(values, key=lambda x: x[0])\n    # 寻找子数组中值与次数最大的子数组\n    max_value, max_times, begin, end = values[0][1:]\n    for value in values[1:]:\n        i, j = value[1:3]\n        if value[0] == max_times:\n            if j - begin <"}
{"task_id": "leetcode/697", "completion": "\n    d = collections.defaultdict(int)\n    c = collections.Counter()\n    l = [0] * len(nums)\n    for i, x in enumerate(nums):\n        d[x] += 1\n        c[x] += 1\n        l[i] = c[x]\n    mx = -1\n    ans = len(nums)\n    for x, v in c.items():\n        if v == mx:\n            ans = min(ans, l[d[x]-1])\n        elif v > mx:\n            mx = v\n            ans = l[d[x]-1]\n    return ans\n\n\n\n\n# 面试题 02.01. 移除重复节点\n#\n# 在 O(n) 时间复杂度下，删除链表中的重复元素。\n# 示例 1:\n#    输入：[1, 2, 3, 3, 2, 1]\n#    输出：[1, 2", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    d = collections.defaultdict(int)\n    c = collections.Counter()\n    l = [0] * len(nums)\n    for i, x in enumerate(nums):\n        d[x] += 1\n        c[x] += 1\n        l[i] = c[x]\n    mx = -1\n    ans = len(nums)\n    for x, v in c.items():\n        if v == mx:\n            ans = min(ans, l[d[x]-1])\n        elif v > mx:\n            mx = v\n            ans = l[d[x]-1]\n    return ans\n\n\n\n\n# 面试题 02.01. 移除重复节点\n#\n# 在 O(n) 时间复杂度下，删除链表中的重复元素。\n# 示例 1:\n#    输入：[1, 2, 3, 3, 2, 1]\n#    输出：[1, 2"}
{"task_id": "leetcode/832", "completion": "\n    if not image:\n        return []\n    n = len(image)\n    image = [image[i][::-1] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            image[i][j] = 1 - image[i][j]\n    return image\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# 52. N-Queens II\ndef totalNQueens(n):\n    '''\n    The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n    Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n    >>> totalNQueens(4)\n   2\n    >>> totalNQueens(1)\n   1\n    >>> totalNQueens(-1)\n   0\n    '''\n    if n < 0:\n        return 0\n    elif n == 0:\n        return ", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    if not image:\n        return []\n    n = len(image)\n    image = [image[i][::-1] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            image[i][j] = 1 - image[i][j]\n    return image\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# 52. N-Queens II\ndef totalNQueens(n):\n    '''\n    The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n    Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n    >>> totalNQueens(4)\n   2\n    >>> totalNQueens(1)\n   1\n    >>> totalNQueens(-1)\n   0\n    '''\n    if n < 0:\n        return 0\n    elif n == 0:\n        return "}
{"task_id": "leetcode/832", "completion": "\n    image.reverse()\n    for row in image:\n        row = list(map(lambda x: 1-x, row))\n    return image\n\ndef flipAndInvertImage(image):\n    '''\n    给定一个 n × n 二进制矩阵 matrix，行与列交换后，返回这个矩阵。\n    示例 1:\n        输入: [[1,1,0],[1,0,1],[0,0,0]]\n        输出: [[1,0,0],[0,1,0],[1,1,1]]\n        解释: 先水平翻转:\n        [[1,1,0],\n         [1,0,1],\n         [0,0,0]]\n        后，进行纵向翻转:\n        [[1,0,0],\n         [0,1,0],\n         [1,1,1]]\n    '''\n    image.reverse()\n    for row in image:\n        for j in range(0", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image.reverse()\n    for row in image:\n        row = list(map(lambda x: 1-x, row))\n    return image\n\ndef flipAndInvertImage(image):\n    '''\n    给定一个 n × n 二进制矩阵 matrix，行与列交换后，返回这个矩阵。\n    示例 1:\n        输入: [[1,1,0],[1,0,1],[0,0,0]]\n        输出: [[1,0,0],[0,1,0],[1,1,1]]\n        解释: 先水平翻转:\n        [[1,1,0],\n         [1,0,1],\n         [0,0,0]]\n        后，进行纵向翻转:\n        [[1,0,0],\n         [0,1,0],\n         [1,1,1]]\n    '''\n    image.reverse()\n    for row in image:\n        for j in range(0"}
{"task_id": "leetcode/832", "completion": "\n    # time N^2, space N\n    # edge case\n    if not image: return\n    # init\n    new_image = []\n    for row in image:\n        new_row = list(reversed(row))\n        new_row = [x ^ 1 for x in new_row]\n        new_image.append(new_row)\n    return new_image\n\n# Hash Table\ndef findAnagrams(s, p):\n    '''\n    Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n    Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 40,000.\n    The order of output does not matter.\n    >>> findAnagrams('cbaebabacd', 'abc')\n    [0, 6]\n    '''\n    # time O(n * m), space O(m)\n    if not s or not p: return\n    # init\n    char_count, pattern_char_count, start, ret = collections", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # time N^2, space N\n    # edge case\n    if not image: return\n    # init\n    new_image = []\n    for row in image:\n        new_row = list(reversed(row))\n        new_row = [x ^ 1 for x in new_row]\n        new_image.append(new_row)\n    return new_image\n\n# Hash Table\ndef findAnagrams(s, p):\n    '''\n    Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n    Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 40,000.\n    The order of output does not matter.\n    >>> findAnagrams('cbaebabacd', 'abc')\n    [0, 6]\n    '''\n    # time O(n * m), space O(m)\n    if not s or not p: return\n    # init\n    char_count, pattern_char_count, start, ret = collections"}
{"task_id": "leetcode/832", "completion": "\n    res=[]\n    for i in range(len(image)):\n        res.append([])\n        for j in range(len(image[i])):\n            if image[i][j]:\n                res[i].append(0)\n            else:\n                res[i].append(1)\n    return res\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n\n# Given a string s, find the longest palindromic substring in s. \n# You may assume that the maximum length of s is 1000.\n\n# Example 1:\n# Input: \"babad\"\n# Output: \"bab\"\n# Note: \"aba\" is also a valid answer.\n\n# Example 2:\n# Input: \"cbbd\"\n# Output: \"bb\"\n\ndef longestPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    if len(s)<2:\n        return s\n    sub = s[0]\n", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    res=[]\n    for i in range(len(image)):\n        res.append([])\n        for j in range(len(image[i])):\n            if image[i][j]:\n                res[i].append(0)\n            else:\n                res[i].append(1)\n    return res\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n\n# Given a string s, find the longest palindromic substring in s. \n# You may assume that the maximum length of s is 1000.\n\n# Example 1:\n# Input: \"babad\"\n# Output: \"bab\"\n# Note: \"aba\" is also a valid answer.\n\n# Example 2:\n# Input: \"cbbd\"\n# Output: \"bb\"\n\ndef longestPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    if len(s)<2:\n        return s\n    sub = s[0]\n"}
{"task_id": "leetcode/832", "completion": "\n    return image.transpose() ^ 1\n\n# Solution 1.\ndef flipAndInvertImage1(matrix):\n    for i in range(len(matrix)):\n        matrix[i][::-1] = map(lambda x: 1 - x, matrix[i][::-1])\n    return matrix\n\n# Solution 2.\ndef flipAndInvertImage2(matrix):\n    for i in range(len(matrix)):\n        matrix[i] = matrix[i][::-1]\n    matrix = [map(lambda x: 1 - x, row) for row in matrix]\n    return matrix\n\n# Solution 3.\ndef flipAndInvertImage3(matrix):\n    matrix = [row[::-1] for row in matrix]\n    matrix = [map(lambda", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return image.transpose() ^ 1\n\n# Solution 1.\ndef flipAndInvertImage1(matrix):\n    for i in range(len(matrix)):\n        matrix[i][::-1] = map(lambda x: 1 - x, matrix[i][::-1])\n    return matrix\n\n# Solution 2.\ndef flipAndInvertImage2(matrix):\n    for i in range(len(matrix)):\n        matrix[i] = matrix[i][::-1]\n    matrix = [map(lambda x: 1 - x, row) for row in matrix]\n    return matrix\n\n# Solution 3.\ndef flipAndInvertImage3(matrix):\n    matrix = [row[::-1] for row in matrix]\n    matrix = [map(lambda"}
{"task_id": "leetcode/832", "completion": "\n    '''\n    Method :\n    1. Invert image by inverting each pixel\n    2. Flip the image by reversing each row\n    3. return the image.\n    '''\n    if len(image) == 0:\n        return []\n    rows, columns = len(image), len(image[0])\n    # inverting a matrix is done by taking transpose and negating each value\n    image = np.array(image)\n    image = (1- image).transpose()\n    # flip the image\n    image = np.flip(image, axis=0)\n    return image.tolist()\n\n\nimage = [[1,1,0],[1,0,1],[0,0,0]]\nprint (flipAndInvertImage(image))\n\n\n\n# Given a string s of '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n# An input string is valid if:\n# Open brackets must be closed by the same type of brackets.\n# Open brackets must be closed in the correct order.\n# Note that an empty", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    '''\n    Method :\n    1. Invert image by inverting each pixel\n    2. Flip the image by reversing each row\n    3. return the image.\n    '''\n    if len(image) == 0:\n        return []\n    rows, columns = len(image), len(image[0])\n    # inverting a matrix is done by taking transpose and negating each value\n    image = np.array(image)\n    image = (1- image).transpose()\n    # flip the image\n    image = np.flip(image, axis=0)\n    return image.tolist()\n\n\nimage = [[1,1,0],[1,0,1],[0,0,0]]\nprint (flipAndInvertImage(image))\n\n\n\n# Given a string s of '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n# An input string is valid if:\n# Open brackets must be closed by the same type of brackets.\n# Open brackets must be closed in the correct order.\n# Note that an empty"}
{"task_id": "leetcode/832", "completion": "\n    '''\n    Method 1: Simply using the function numpy.fliplr() and numpy.logical_not()\n    O(n2)\n    '''\n    # image = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    image = np.array(image)\n    image = np.fliplr(image)\n    image[image == False] = True\n    return image\n\n    '''\n    Method 2: \n    O(n2)\n    '''\n    # return numpy.fliplr(numpy.logical_not(image))\n\n    '''\n    Method 3:\n    O(n2)\n    '''\n    # n = len(image)\n    # m = len(image[0])\n    # for i in range(n):\n    #     for j in range(m):\n    #         if image[i][j] == 1:\n    #             image[i][j] = 0\n    #         else:\n    #             image[i][j] = 1\n   ", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    '''\n    Method 1: Simply using the function numpy.fliplr() and numpy.logical_not()\n    O(n2)\n    '''\n    # image = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    image = np.array(image)\n    image = np.fliplr(image)\n    image[image == False] = True\n    return image\n\n    '''\n    Method 2: \n    O(n2)\n    '''\n    # return numpy.fliplr(numpy.logical_not(image))\n\n    '''\n    Method 3:\n    O(n2)\n    '''\n    # n = len(image)\n    # m = len(image[0])\n    # for i in range(n):\n    #     for j in range(m):\n    #         if image[i][j] == 1:\n    #             image[i][j] = 0\n    #         else:\n    #             image[i][j] = 1\n   "}
{"task_id": "leetcode/832", "completion": "\n    image = np.array(image)\n    image = image[:,::-1]\n    mask = image == 0\n    image[mask] = 1\n    return image\n\ndef flipAndInvertImage2(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image = np.array(image", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image = np.array(image)\n    image = image[:,::-1]\n    mask = image == 0\n    image[mask] = 1\n    return image\n\ndef flipAndInvertImage2(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    image = np.array(image"}
{"task_id": "leetcode/832", "completion": "\n    # 双重反转\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            image[i][j] = 1 - image[i][j]\n    image = list(map(list, list(zip(*image))))\n    return image\n\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # 双重反转\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            image[i][j] = 1 - image[i][j]\n    image = list(map(list, list(zip(*image))))\n    return image\n\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}
{"task_id": "leetcode/832", "completion": "\n    # @param {integer[][]} A\n    # @return {integer[][]}\n    n = len(image)\n    result = [[0]*n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            # flip\n            result[i][j] = image[j][n-1-i]\n            # invert\n            if result[i][j] == 0:\n                result[i][j] = 1\n            else:\n                result[i][j] = 0\n    return result\n    # 2076ms\n    # n = len(image)\n    # for i in range(n):\n    #     image[i] = image[i][::-1]\n    #     for j in range(n):\n    #         if image[i][j] == 0:\n    #             image[i][j] = 1\n    #         else:\n    #             image[i][j] = 0\n    # return image\n\n\n# 588ms\ndef flipAnd", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # @param {integer[][]} A\n    # @return {integer[][]}\n    n = len(image)\n    result = [[0]*n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            # flip\n            result[i][j] = image[j][n-1-i]\n            # invert\n            if result[i][j] == 0:\n                result[i][j] = 1\n            else:\n                result[i][j] = 0\n    return result\n    # 2076ms\n    # n = len(image)\n    # for i in range(n):\n    #     image[i] = image[i][::-1]\n    #     for j in range(n):\n    #         if image[i][j] == 0:\n    #             image[i][j] = 1\n    #         else:\n    #             image[i][j] = 0\n    # return image\n\n\n# 588ms\ndef flipAnd"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    n = len(nums)\n    res = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                res[i] = max(res[i], res[j] + 1)\n    return max(res)\n\n\ndef maxArea(height):\n    '''\n    给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。\n    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。\n    找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n    说明：你不能倾斜", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    n = len(nums)\n    res = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                res[i] = max(res[i], res[j] + 1)\n    return max(res)\n\n\ndef maxArea(height):\n    '''\n    给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。\n    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。\n    找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n    说明：你不能倾斜"}
{"task_id": "leetcode/300", "completion": "\n    def dp(length, num):\n        if length == 1:\n            return 1\n        max_len = 1\n        i = 0\n        while i < length and dp(i, num) < num:\n            i += 1\n        return dp(i, num) + 1\n\n    max_num = len(nums)\n    result = 1\n    for num in nums:\n        result = max(result, dp(result, num))\n    return result\n\n\ndef lengthOfLIS1(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n   ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    def dp(length, num):\n        if length == 1:\n            return 1\n        max_len = 1\n        i = 0\n        while i < length and dp(i, num) < num:\n            i += 1\n        return dp(i, num) + 1\n\n    max_num = len(nums)\n    result = 1\n    for num in nums:\n        result = max(result, dp(result, num))\n    return result\n\n\ndef lengthOfLIS1(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n   "}
{"task_id": "leetcode/300", "completion": "\n    L = []\n    ans = 0\n    for num in num", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    L = []\n    ans = 0\n    for num in num"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    dp = [1 for _ in range(len(nums))]\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    return max_length\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    dp = [1 for _ in range(len(nums))]\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    return max_length\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列"}
{"task_id": "leetcode/300", "completion": "\n    dp = [1 for _ in nums]\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS_v2(nums):\n    '''\n    :param nums:\n    :return:\n    >>> lengthOfLIS_v2([0,1,0,3,2,3])\n    4\n    >>> lengthOfLIS_v2([1,1,1,1,1,1,1,1])\n    1\n    '''\n    n = len(nums)\n    if n == 0 or n == 1:\n        return n\n\n    dp = [0] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [1 for _ in nums]\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS_v2(nums):\n    '''\n    :param nums:\n    :return:\n    >>> lengthOfLIS_v2([0,1,0,3,2,3])\n    4\n    >>> lengthOfLIS_v2([1,1,1,1,1,1,1,1])\n    1\n    '''\n    n = len(nums)\n    if n == 0 or n == 1:\n        return n\n\n    dp = [0] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    N = len(nums)\n    dp = [1] * N\n    for i in range(N):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列 是原序列中的一个子集。\n    要求，原始序列中的元素按照升序排列。\n    如果序列中有多个最长递增子序列，返回它们中最长的一个。\n    如果不存在最长递增子序列，返回 0 。\n    示", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    N = len(nums)\n    dp = [1] * N\n    for i in range(N):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列 是原序列中的一个子集。\n    要求，原始序列中的元素按照升序排列。\n    如果序列中有多个最长递增子序列，返回它们中最长的一个。\n    如果不存在最长递增子序列，返回 0 。\n    示"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    n = len(nums)\n    lis = [1]*n\n    max_lis = 0\n    for i in range(n):\n        temp = 0\n        for j in range(i):\n            if nums[i] > nums[j]:\n                temp = max(temp, lis[j])\n        lis[i] = temp + 1\n        max_lis = max(max_lis, lis[i])\n    return max_lis\n\n\nif __name__ == \"__main__\":\n    print('算法2')\n    from timeit import Timer\n\n    print(Timer(lambda: lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])).timeit(number=10000))\n    print(Timer(lambda: lengthOfLIS([7, 7, 7, 7, 7, 7, 7])).timeit(number=10000))\n    print(Timer(", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    n = len(nums)\n    lis = [1]*n\n    max_lis = 0\n    for i in range(n):\n        temp = 0\n        for j in range(i):\n            if nums[i] > nums[j]:\n                temp = max(temp, lis[j])\n        lis[i] = temp + 1\n        max_lis = max(max_lis, lis[i])\n    return max_lis\n\n\nif __name__ == \"__main__\":\n    print('算法2')\n    from timeit import Timer\n\n    print(Timer(lambda: lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])).timeit(number=10000))\n    print(Timer(lambda: lengthOfLIS([7, 7, 7, 7, 7, 7, 7])).timeit(number=10000))\n    print(Timer("}
{"task_id": "leetcode/300", "completion": "\n\n    dp = [1 for i in range(len(nums))]\n    n = len(nums)\n    res = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                res = max(res, dp[i])\n    return res\n\n\nif __name__ == \"__main__\":\n    print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([10, 9, 2, 5, 3, 4, 101, 18]))\n    print(lengthOfLIS([1, 2, 3, 4]))\n    print(lengthOfLIS([1, 2, ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n\n    dp = [1 for i in range(len(nums))]\n    n = len(nums)\n    res = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                res = max(res, dp[i])\n    return res\n\n\nif __name__ == \"__main__\":\n    print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))\n    print(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))\n    print(lengthOfLIS([10, 9, 2, 5, 3, 4, 101, 18]))\n    print(lengthOfLIS([1, 2, 3, 4]))\n    print(lengthOfLIS([1, 2, "}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n\n    memo = [1] * len(nums)\n    longest = 0\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                memo[i] = max(memo[i], memo[j] + 1)\n        longest = max(longest, memo[i])\n\n    return longest\n\n\nif __name__ == '__main__':\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([7,7,7,7,7,7,7]))\n    print(lengthOfLIS([]", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n\n    memo = [1] * len(nums)\n    longest = 0\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                memo[i] = max(memo[i], memo[j] + 1)\n        longest = max(longest, memo[i])\n\n    return longest\n\n\nif __name__ == '__main__':\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([7,7,7,7,7,7,7]))\n    print(lengthOfLIS([]"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    ret = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                ret[i] = max(ret[j] + 1, ret[i])\n\n    return max(ret)\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    ret = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                ret[i] = max(ret[j] + 1, ret[i])\n\n    return max(ret)\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    "}
{"task_id": "leetcode/414", "completion": "\n    # 堆排序\n    if len(nums) < 3:\n        return max(nums)\n    heap = []\n    for num in nums:\n        if len(heap) < 3:\n            heapq.heappush(heap, num)\n        else:\n            if heap[2] < num:\n                heapq.heappushpop(heap, num)\n    return heap[2]\n\n\ndef singleNumber(nums):\n    '''\n    给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。\n    找出其中只出现一次的那两个元素。你可以按任意顺序返回答案。\n\n    输入: [4,1,2,1,2]\n    输出: [4,2]\n    >>> singleNumber([4,1,2,1,2])\n    [4, 2", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    # 堆排序\n    if len(nums) < 3:\n        return max(nums)\n    heap = []\n    for num in nums:\n        if len(heap) < 3:\n            heapq.heappush(heap, num)\n        else:\n            if heap[2] < num:\n                heapq.heappushpop(heap, num)\n    return heap[2]\n\n\ndef singleNumber(nums):\n    '''\n    给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。\n    找出其中只出现一次的那两个元素。你可以按任意顺序返回答案。\n\n    输入: [4,1,2,1,2]\n    输出: [4,2]\n    >>> singleNumber([4,1,2,1,2])\n    [4, 2"}
{"task_id": "leetcode/414", "completion": "\n    try:\n        _max = max(nums)\n    except ValueError:\n        # 如果nums中没有元素, 直接返回 None\n        return None\n    if _max not in nums:\n        return _max\n    for i in range(len(nums)):\n        if nums[i] == _max:\n            nums.remove(_max)\n            break\n    return max(nums)\n\n\ndef findAnagrams(s, p):\n    \"\"\"\n    字符串的排列\n    给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n    异位词 指字母相同，但排列不同的字符串。\n    :param s:\n    :param p:\n    :return:\n    >>> findAnagrams", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    try:\n        _max = max(nums)\n    except ValueError:\n        # 如果nums中没有元素, 直接返回 None\n        return None\n    if _max not in nums:\n        return _max\n    for i in range(len(nums)):\n        if nums[i] == _max:\n            nums.remove(_max)\n            break\n    return max(nums)\n\n\ndef findAnagrams(s, p):\n    \"\"\"\n    字符串的排列\n    给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n    异位词 指字母相同，但排列不同的字符串。\n    :param s:\n    :param p:\n    :return:\n    >>> findAnagrams"}
{"task_id": "leetcode/414", "completion": "\n    max1 = max2 = max3 = -1 << 30\n    for n in nums:\n        if n > max1:\n            max3, max2, max1 = max2, max1, n\n        elif n > max2:\n            max3, max2 = max2, n\n        elif n > max3:\n            max3 = n\n    return max3 if max3!= -1 << 30 else max1\n\n\ndef _get_next_index(nums, cur_index, next_val):\n    '''\n    >>> _get_next_index([1, 2, 3, 1, 2, 3], 2, 3)\n    5\n    >>> _get_next_index([1, 2, 3, 1, 2, 3], 5, 3)\n    1\n    '''\n    return (cur_index + 1) % len(nums) if nums[cur_index]!= next_val else _get_next_index(nums, (cur_index + 1) % len(nums", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    max1 = max2 = max3 = -1 << 30\n    for n in nums:\n        if n > max1:\n            max3, max2, max1 = max2, max1, n\n        elif n > max2:\n            max3, max2 = max2, n\n        elif n > max3:\n            max3 = n\n    return max3 if max3!= -1 << 30 else max1\n\n\ndef _get_next_index(nums, cur_index, next_val):\n    '''\n    >>> _get_next_index([1, 2, 3, 1, 2, 3], 2, 3)\n    5\n    >>> _get_next_index([1, 2, 3, 1, 2, 3], 5, 3)\n    1\n    '''\n    return (cur_index + 1) % len(nums) if nums[cur_index]!= next_val else _get_next_index(nums, (cur_index + 1) % len(nums"}
{"task_id": "leetcode/414", "completion": "\n    nums = tuple(sorted(set(nums)))\n    return nums[-3] if len(nums) > 3 else max(nums)\n\n\nif __name__ == \"", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = tuple(sorted(set(nums)))\n    return nums[-3] if len(nums) > 3 else max(nums)\n\n\nif __name__ == \""}
{"task_id": "leetcode/414", "completion": "\n    min_n1 = min_n2 = min_n3 = float('inf')\n    for num in nums:\n        if num <= min_n1:  # 第一小\n            min_n3 = min_n2\n            min_n2 = min_n1\n            min_n1 = num\n        elif num <= min_n2:  # 第二小\n            min_n3 = min_n2\n            min_n2 = num\n        elif num", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    min_n1 = min_n2 = min_n3 = float('inf')\n    for num in nums:\n        if num <= min_n1:  # 第一小\n            min_n3 = min_n2\n            min_n2 = min_n1\n            min_n1 = num\n        elif num <= min_n2:  # 第二小\n            min_n3 = min_n2\n            min_n2 = num\n        elif num"}
{"task_id": "leetcode/414", "completion": "\n    nums_set = set()\n    for i in nums:\n        nums_set.add(i)\n    third_max = max(nums_set)\n    for i in range(3):\n        nums_set.remove(third_max)\n    if len(nums_set):\n        return max(nums_set)\n\n\n\nif __name__ == \"__main__\":\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([1,1,2,1]))\n    print(thirdMax([1,2,2,2,2,3,1]))\n    print(thirdMax([2,2,3,1]))\n    print(thirdMax([2,2,1,1]))\n    print(thirdMax([2,1,2,1]))\n    print(thirdMax([2,1,2,1,1]))\n    print(thirdMax([2,1,3,1]))\n    print(thirdMax([2,2,3,1,1]))\n", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums_set = set()\n    for i in nums:\n        nums_set.add(i)\n    third_max = max(nums_set)\n    for i in range(3):\n        nums_set.remove(third_max)\n    if len(nums_set):\n        return max(nums_set)\n\n\n\nif __name__ == \"__main__\":\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([1,1,2,1]))\n    print(thirdMax([1,2,2,2,2,3,1]))\n    print(thirdMax([2,2,3,1]))\n    print(thirdMax([2,2,1,1]))\n    print(thirdMax([2,1,2,1]))\n    print(thirdMax([2,1,2,1,1]))\n    print(thirdMax([2,1,3,1]))\n    print(thirdMax([2,2,3,1,1]))\n"}
{"task_id": "leetcode/414", "completion": "\n    return max(i for i in set(nums) if nums.count(i) == 1)\n\ndef sortColors(nums):\n    '''\n    给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n     此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n     注意:\n        不能使用代码库中的排序函数来解决这道题。\n\n    >>> sortColors([2,0,2,1,1,0])\n    >>> [0,0,1,1,2,2]\n    '''\n    if len(nums) < 2: return nums\n    pos", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    return max(i for i in set(nums) if nums.count(i) == 1)\n\ndef sortColors(nums):\n    '''\n    给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n     此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n     注意:\n        不能使用代码库中的排序函数来解决这道题。\n\n    >>> sortColors([2,0,2,1,1,0])\n    >>> [0,0,1,1,2,2]\n    '''\n    if len(nums) < 2: return nums\n    pos"}
{"task_id": "leetcode/414", "completion": "\n    s = set()\n    for i in nums:\n        s.add(i)\n\n    if len(s) > 3:\n        return max(s)\n    elif len(s) == 1:\n        return 0\n\n    return max([n for n in nums if n not in s])\n\n\ndef thirdMax2(nums):\n    '''\n    给定一个整数数组，找出其中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    temp = []\n    for i in nums:\n        if i not in temp and i > nums[nums.index(temp[-1])]:\n            temp.append(i)\n\n    if len(temp) > 3:\n        return max(temp)\n    elif len(temp", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    s = set()\n    for i in nums:\n        s.add(i)\n\n    if len(s) > 3:\n        return max(s)\n    elif len(s) == 1:\n        return 0\n\n    return max([n for n in nums if n not in s])\n\n\ndef thirdMax2(nums):\n    '''\n    给定一个整数数组，找出其中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    temp = []\n    for i in nums:\n        if i not in temp and i > nums[nums.index(temp[-1])]:\n            temp.append(i)\n\n    if len(temp) > 3:\n        return max(temp)\n    elif len(temp"}
{"task_id": "leetcode/414", "completion": "\n    res = []\n    for n in nums:\n        res += [n]\n        res.sort(reverse = True)\n        del res[3:]\n    return res[0]\n\n\ndef thirdMax_1(nums):\n    '''\n    给定一个整数数组 nums，除了某个元素只出现一次以外，其余每个元素均出现两次。请找出那个只出现了一次的元素。\n    >>> thirdMax([3, 3, 4, 3, 3, 1, 4, 2, 4, 4])\n    1\n    '''\n    from collections import Counter\n    c = Counter(nums)\n    s = sorted(c.items(),key = lambda x:x[1],reverse = True)\n    # print(s)\n    return s[2][0]\n\ndef thirdMax_2(nums):\n    '''\n    给定一个整数数组 nums，除了某个元", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    res = []\n    for n in nums:\n        res += [n]\n        res.sort(reverse = True)\n        del res[3:]\n    return res[0]\n\n\ndef thirdMax_1(nums):\n    '''\n    给定一个整数数组 nums，除了某个元素只出现一次以外，其余每个元素均出现两次。请找出那个只出现了一次的元素。\n    >>> thirdMax([3, 3, 4, 3, 3, 1, 4, 2, 4, 4])\n    1\n    '''\n    from collections import Counter\n    c = Counter(nums)\n    s = sorted(c.items(),key = lambda x:x[1],reverse = True)\n    # print(s)\n    return s[2][0]\n\ndef thirdMax_2(nums):\n    '''\n    给定一个整数数组 nums，除了某个元"}
{"task_id": "leetcode/414", "completion": "\n\n    nums = sorted(nums, reverse=True)\n    length = len(nums)\n    if length > 1:\n        if length > 3:\n            return nums[2]\n        elif length == 3:\n            if nums[0] == nums[1] or nums[0] == nums[2]:\n                return nums[2]\n            else:\n                return max(nums[1:])\n        else:\n            return nums[0]\n    else:\n        return 0\n\n# 最佳解\n# 思路：首先将数组排序，找到第三大元素就返回。如果排序后一共只有三个元素，也就是数组中不存在重复元素，因此直接返回数组中的最后一个元素即可。\n\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n\n    nums = sorted(nums, reverse=True)\n    length = len(nums)\n    if length > 1:\n        if length > 3:\n            return nums[2]\n        elif length == 3:\n            if nums[0] == nums[1] or nums[0] == nums[2]:\n                return nums[2]\n            else:\n                return max(nums[1:])\n        else:\n            return nums[0]\n    else:\n        return 0\n\n# 最佳解\n# 思路：首先将数组排序，找到第三大元素就返回。如果排序后一共只有三个元素，也就是数组中不存在重复元素，因此直接返回数组中的最后一个元素即可。\n\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        nums"}
{"task_id": "leetcode/961", "completion": "\n    nums=collections.Counter(nums)\n    for key,value in nums.items():\n        if value==len(nums)//2:\n            return key\n```\n\n#### [1749. 车队](https://leetcode-cn.com/problems/car-fleet/)\n\n> 在一条环路上有 `N` 辆车沿顺时针方向行驶。如果其中一辆车在时刻 `t` 有位置 `x`，则可以假设它将在时刻 `t+1` 沿顺时针方向行驶到位置 `x + 1`（超过环路长度的车则回到环路起点）。\n>\n> 我们一开始位于环路起点处，并且会在时刻 `0` 处开始行�", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    nums=collections.Counter(nums)\n    for key,value in nums.items():\n        if value==len(nums)//2:\n            return key\n```\n\n#### [1749. 车队](https://leetcode-cn.com/problems/car-fleet/)\n\n> 在一条环路上有 `N` 辆车沿顺时针方向行驶。如果其中一辆车在时刻 `t` 有位置 `x`，则可以假设它将在时刻 `t+1` 沿顺时针方向行驶到位置 `x + 1`（超过环路长度的车则回到环路起点）。\n>\n> 我们一开始位于环路起点处，并且会在时刻 `0` 处开始行�"}
{"task_id": "leetcode/961", "completion": "\n    return collections.Counter(nums).most_common(1)[0][0]\n\n# 7. 26. 删除排序数组中的重复项\ndef removeDuplicates(nums):\n    '''\n    给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n    Do not allocate extra space for another array, you must do this in place with constant memory.\n    The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n    >>> nums = [1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]\n    >>> removeDuplicates(nums)\n    5\n    >>> nums\n    [1, 2, 3, 4, 5]\n    >>> nums = [1, 2, 3, 3, 3]\n    >>> remove", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return collections.Counter(nums).most_common(1)[0][0]\n\n# 7. 26. 删除排序数组中的重复项\ndef removeDuplicates(nums):\n    '''\n    给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n    Do not allocate extra space for another array, you must do this in place with constant memory.\n    The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n    >>> nums = [1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]\n    >>> removeDuplicates(nums)\n    5\n    >>> nums\n    [1, 2, 3, 4, 5]\n    >>> nums = [1, 2, 3, 3, 3]\n    >>> remove"}
{"task_id": "leetcode/961", "completion": "\n    counts = collections.Counter(nums)\n    return counts.most_common(1)[0][0]\n\n\n# 13. 整数的圆周率\ndef circluare(nums):\n    '''\n    如果我们将整数沿着某个圆圈排成一行，\n    那么从数字 1 到最高的数字 n，除非是在数字 1 之前，否则这些数字之间相邻。\n    （数字 1 比数字 n 小 2 个位置）。\n    给定一个由整数数组 nums 表示的环形，返回环形里圆周率的平均数。\n    注意:\n    1 <= rad * (rad + 1) / 2 <= nums.length <= 1000\n        n = nums.length\n    1 <= nums[i] <= 10", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    counts = collections.Counter(nums)\n    return counts.most_common(1)[0][0]\n\n\n# 13. 整数的圆周率\ndef circluare(nums):\n    '''\n    如果我们将整数沿着某个圆圈排成一行，\n    那么从数字 1 到最高的数字 n，除非是在数字 1 之前，否则这些数字之间相邻。\n    （数字 1 比数字 n 小 2 个位置）。\n    给定一个由整数数组 nums 表示的环形，返回环形里圆周率的平均数。\n    注意:\n    1 <= rad * (rad + 1) / 2 <= nums.length <= 1000\n        n = nums.length\n    1 <= nums[i] <= 10"}
{"task_id": "leetcode/961", "completion": "\n    # 2019-01-20\n    # 先计算各数字出现的次数\n    dict_cnt = collections.Counter(nums)\n    # 然后在dict_cnt中找到出现次数为n的唯一一个元素\n    return (k for k, v in dict_cnt.items() if v == len(nums)//2+1).next()\n\n# 2019-02-04\ndef repeatedNTimes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    d = collections.Counter(nums)\n    for k, v in d.items():\n        if v == len(nums)//2:\n            return k\n\n# 2019-10-15\nclass Solution:\n    def repeatedNT", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # 2019-01-20\n    # 先计算各数字出现的次数\n    dict_cnt = collections.Counter(nums)\n    # 然后在dict_cnt中找到出现次数为n的唯一一个元素\n    return (k for k, v in dict_cnt.items() if v == len(nums)//2+1).next()\n\n# 2019-02-04\ndef repeatedNTimes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    d = collections.Counter(nums)\n    for k, v in d.items():\n        if v == len(nums)//2:\n            return k\n\n# 2019-10-15\nclass Solution:\n    def repeatedNT"}
{"task_id": "leetcode/961", "completion": "\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i]==nums[i+1]:\n            return nums[i]\n    \n\n\n# 16 2-sum 双指针法\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums, 和一个目标值 target, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    你可以假设每个输入只对应唯一的答案, 而且不会有两个相同的答案。\n    Return the two indices of the two numbers in the array that have the same sum.", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    nums.sort()\n    for i in range(len(nums)-1):\n        if nums[i]==nums[i+1]:\n            return nums[i]\n    \n\n\n# 16 2-sum 双指针法\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums, 和一个目标值 target, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素不能使用两遍。\n    你可以假设每个输入只对应唯一的答案, 而且不会有两个相同的答案。\n    Return the two indices of the two numbers in the array that have the same sum."}
{"task_id": "leetcode/961", "completion": "\n    nums = collections.Counter(nums)\n    num,count = 0,1\n    for key,val in nums.items():\n        if count > nums.most_common()[0][1]:\n            num,count = key, val\n    return num\n\ndef maxAverageRatio(nums1, nums2):\n    '''\n    给定两个分别由小写字母组成的字符串 'S1' 和 'S2',两个字符串长度相同.\n    字符串 S1 中的 每个字母 出现在字符串 S2 中 至少 't' 次.\n    找出 'S1' 中每个字母的平均重复次数,作为 'S1' 的 平均重复指数 返回.\n    Return the average repetition index of each letter in S1.\n    >>> maxAverageRatio('abca', 'abcabc')\n    1.25\n    '''\n    countS1, count", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    nums = collections.Counter(nums)\n    num,count = 0,1\n    for key,val in nums.items():\n        if count > nums.most_common()[0][1]:\n            num,count = key, val\n    return num\n\ndef maxAverageRatio(nums1, nums2):\n    '''\n    给定两个分别由小写字母组成的字符串 'S1' 和 'S2',两个字符串长度相同.\n    字符串 S1 中的 每个字母 出现在字符串 S2 中 至少 't' 次.\n    找出 'S1' 中每个字母的平均重复次数,作为 'S1' 的 平均重复指数 返回.\n    Return the average repetition index of each letter in S1.\n    >>> maxAverageRatio('abca', 'abcabc')\n    1.25\n    '''\n    countS1, count"}
{"task_id": "leetcode/961", "completion": "\n    d = collections.defaultdict(int)\n    for num in nums:\n        d[num] += 1\n    for k, v in d.items():\n        if v > 1:\n            return k\nfuck = '你好吗'\nprint(repeatedNTimes([1,2,3,3]))\n\na = '123456'\ns = s[:3]\n\nnums = [1,1,2,2]\n\nx,y,z = 1,2,3\na,b,c = x,y,z\n\n# print(x,a)\n\n# d = {'x':1,'y':2,'z':3}\n# x,y,z = d.values()\n\n# d = {'x':1,'y':2,'z':3}\n# z = d['x']\n# x,y,z = d.values()\n\n# x,y,z = 1,2,3\n# print(x,y,z)\n# x,y,z = [1,2,3]\n", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    d = collections.defaultdict(int)\n    for num in nums:\n        d[num] += 1\n    for k, v in d.items():\n        if v > 1:\n            return k\nfuck = '你好吗'\nprint(repeatedNTimes([1,2,3,3]))\n\na = '123456'\ns = s[:3]\n\nnums = [1,1,2,2]\n\nx,y,z = 1,2,3\na,b,c = x,y,z\n\n# print(x,a)\n\n# d = {'x':1,'y':2,'z':3}\n# x,y,z = d.values()\n\n# d = {'x':1,'y':2,'z':3}\n# z = d['x']\n# x,y,z = d.values()\n\n# x,y,z = 1,2,3\n# print(x,y,z)\n# x,y,z = [1,2,3]\n"}
{"task_id": "leetcode/961", "completion": "\n    # 异或 有个特性：x^x = 0; x^0 = x\n    # 将所有的数据异或，因为都是相同的，结果为0，\n    # 再将所有数据异或一次，结果就是唯一出现一次的元素，\n    # 如果不是重复则结果为0，如果有重复则结果不为0\n    res = 0\n    for i in nums:\n        res ^= i\n    return res\n\n    # res = nums[0]\n    # for i in nums:\n    #     if res!= i:\n    #         return i\n    # return res\n```\n\n### 3.5 最大子数组\n\n> 题目：给定一个整型数组 arr ，找到 arr 中最大的子数组和并返回它的长度；\n> 假设数组 arr 中不存在所��", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # 异或 有个特性：x^x = 0; x^0 = x\n    # 将所有的数据异或，因为都是相同的，结果为0，\n    # 再将所有数据异或一次，结果就是唯一出现一次的元素，\n    # 如果不是重复则结果为0，如果有重复则结果不为0\n    res = 0\n    for i in nums:\n        res ^= i\n    return res\n\n    # res = nums[0]\n    # for i in nums:\n    #     if res!= i:\n    #         return i\n    # return res\n```\n\n### 3.5 最大子数组\n\n> 题目：给定一个整型数组 arr ，找到 arr 中最大的子数组和并返回它的长度；\n> 假设数组 arr 中不存在所��"}
{"task_id": "leetcode/961", "completion": "\n    t = collections.Counter(nums)\n    return [i * n for i, n in t.items() if n > 1][0]\n    \n\ndef duplicateZeros(arr):\n    '''\n    给你一个整数数组 arr ，你需要 除掉 所有的 0 并 至少 得到一个 元素 的数组。\n    返回得到的数组的最大长度。\n    Return the maximum length of the array after removing the first duplicate number for each number.\n    >>> duplicateZeros([1,0,2,3,0,4,2])\n    6\n    '''\n    a = [0] * len(arr)\n    n = len(arr)\n    c = 0\n    for i in range(n):\n        if arr[i] == 0:\n            c += 1\n            if c == n:\n                break\n        a[i] = arr[i]\n    for i in range(n - c, n):\n        a[i] = 0\n   ", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    t = collections.Counter(nums)\n    return [i * n for i, n in t.items() if n > 1][0]\n    \n\ndef duplicateZeros(arr):\n    '''\n    给你一个整数数组 arr ，你需要 除掉 所有的 0 并 至少 得到一个 元素 的数组。\n    返回得到的数组的最大长度。\n    Return the maximum length of the array after removing the first duplicate number for each number.\n    >>> duplicateZeros([1,0,2,3,0,4,2])\n    6\n    '''\n    a = [0] * len(arr)\n    n = len(arr)\n    c = 0\n    for i in range(n):\n        if arr[i] == 0:\n            c += 1\n            if c == n:\n                break\n        a[i] = arr[i]\n    for i in range(n - c, n):\n        a[i] = 0\n   "}
{"task_id": "leetcode/961", "completion": "\n    counts = collections.Counter(nums)\n    key = list(counts.keys())[counts.values().index(max(counts.values()))]\n    return key\n\n\ndef getLruCache(capacity):\n    import collections\n    class LRU:\n        \"\"\"\n        顺序性LRU缓存\n        https://leetcode-cn.com/problems/lru-cache/\n        \"\"\"\n        def __init__(self, capacity):\n            self.cache = collections.OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key):\n            '''\n            取值\n            :param key:\n            :return:\n            '''\n            if key not in self.cache:\n                return -1\n            else:\n                self.cache.move_to_end(key)\n                return self.cache[key]\n\n        def put(self, key, value):\n            '''\n            插入\n            :param key:\n            :param value:\n            :return:\n            '''\n            if key not in self.cache", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    counts = collections.Counter(nums)\n    key = list(counts.keys())[counts.values().index(max(counts.values()))]\n    return key\n\n\ndef getLruCache(capacity):\n    import collections\n    class LRU:\n        \"\"\"\n        顺序性LRU缓存\n        https://leetcode-cn.com/problems/lru-cache/\n        \"\"\"\n        def __init__(self, capacity):\n            self.cache = collections.OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key):\n            '''\n            取值\n            :param key:\n            :return:\n            '''\n            if key not in self.cache:\n                return -1\n            else:\n                self.cache.move_to_end(key)\n                return self.cache[key]\n\n        def put(self, key, value):\n            '''\n            插入\n            :param key:\n            :param value:\n            :return:\n            '''\n            if key not in self.cache"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n\n    max_num = nums[0]\n    max_num_index = 0\n    for i,num in enumerate(nums):\n        if num > max_num:\n            max_num = num\n            max_num_index = i\n    return max_num_index if max_num >= max_num * 2 else -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n## 买卖股票最大利润\n\n```python\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n\n    max_num = nums[0]\n    max_num_index = 0\n    for i,num in enumerate(nums):\n        if num > max_num:\n            max_num = num\n            max_num_index = i\n    return max_num_index if max_num >= max_num * 2 else -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n## 买卖股票最大利润\n\n```python\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n    maxv = nums[0]\n    index = 0\n    for i in range(1, len(nums)):\n        v = nums[i]\n        if v > maxv:\n            maxv = v\n            index = i\n    if maxv * 2 > sum(nums) - maxv:\n        return index\n    else:\n        return -1\n\n\ndef maxNumber(nums1, nums2, k):\n    '''\n    给定两个以升序排序的整数数组 nums1 和 nums2, 以及一个整数 k。\n    数组 nums 是由数组 nums1 和 nums2 合并而来的, 所以 nums1 第一个元素之前的所有元素来自 nums1,\n    中间由 nums2 的所有元素, 最后的元素来自 nums2。\n    现在你需要从中找出连�", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n    maxv = nums[0]\n    index = 0\n    for i in range(1, len(nums)):\n        v = nums[i]\n        if v > maxv:\n            maxv = v\n            index = i\n    if maxv * 2 > sum(nums) - maxv:\n        return index\n    else:\n        return -1\n\n\ndef maxNumber(nums1, nums2, k):\n    '''\n    给定两个以升序排序的整数数组 nums1 和 nums2, 以及一个整数 k。\n    数组 nums 是由数组 nums1 和 nums2 合并而来的, 所以 nums1 第一个元素之前的所有元素来自 nums1,\n    中间由 nums2 的所有元素, 最后的元素来自 nums2。\n    现在你需要从中找出连�"}
{"task_id": "leetcode/747", "completion": "\n    if nums is None:\n        return -1\n    max_num = max(nums", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if nums is None:\n        return -1\n    max_num = max(nums"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1:\n        return 0\n    if len(nums) == 2:\n        if nums[0] > 2 * nums[1]:\n            return 0\n        if nums[1] > 2 * nums[0]:\n            return 1\n        return -1\n    n = max(nums)\n    m = 2 * n\n    for i in range(len(nums)):\n        if nums[i] == m:\n            return i\n    return -1\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1:\n        输入: s = \"abcabcbb\"\n        输出: 3\n        解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2:\n        输入: s", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1:\n        return 0\n    if len(nums) == 2:\n        if nums[0] > 2 * nums[1]:\n            return 0\n        if nums[1] > 2 * nums[0]:\n            return 1\n        return -1\n    n = max(nums)\n    m = 2 * n\n    for i in range(len(nums)):\n        if nums[i] == m:\n            return i\n    return -1\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n    示例 1:\n        输入: s = \"abcabcbb\"\n        输出: 3\n        解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n    示例 2:\n        输入: s"}
{"task_id": "leetcode/747", "completion": "\n    l = len(nums)\n    if l <= 1:\n        return 0\n    n = max(nums)\n    j = 0\n    for i in range(l):\n        if nums[i]!= n:\n            if nums[i] * 2 >= n:\n                j += 1\n            else:\n                return -1\n    if j == 0:\n        return -1\n    return n\n```\n\n\n## 494. 目标和\n\nhttps://leetcode-cn.com/problems/target-sum/\n\n**思路**\n\n\n```python\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        '''\n        给你一个整数数组 nums 和一个整数 target 。\n        向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n        例", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    l = len(nums)\n    if l <= 1:\n        return 0\n    n = max(nums)\n    j = 0\n    for i in range(l):\n        if nums[i]!= n:\n            if nums[i] * 2 >= n:\n                j += 1\n            else:\n                return -1\n    if j == 0:\n        return -1\n    return n\n```\n\n\n## 494. 目标和\n\nhttps://leetcode-cn.com/problems/target-sum/\n\n**思路**\n\n\n```python\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        '''\n        给你一个整数数组 nums 和一个整数 target 。\n        向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n        例"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n    maxNum = -1\n    maxNumIndex = -1\n    for i,num in enumerate(nums):\n        if num >= maxNum:\n            maxNum = num\n            maxNumIndex = i\n    for i, num in enumerate(nums):\n        if i!= maxNumIndex and num!= maxNum and num >= maxNum*2:\n            return -1\n    return maxNumIndex\n\ndef largestRectangleArea(heights):\n    '''\n    给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n    求在该柱状图中，能够勾勒出来的矩形的最大面积。\n    例如:\n    [[2,1,5,6,2,3],[1,2]]\n    返回 10\n    解��", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n    maxNum = -1\n    maxNumIndex = -1\n    for i,num in enumerate(nums):\n        if num >= maxNum:\n            maxNum = num\n            maxNumIndex = i\n    for i, num in enumerate(nums):\n        if i!= maxNumIndex and num!= maxNum and num >= maxNum*2:\n            return -1\n    return maxNumIndex\n\ndef largestRectangleArea(heights):\n    '''\n    给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n    求在该柱状图中，能够勾勒出来的矩形的最大面积。\n    例如:\n    [[2,1,5,6,2,3],[1,2]]\n    返回 10\n    解��"}
{"task_id": "leetcode/747", "completion": "\n    length = len(nums)\n    if length == 1:\n        return 0\n\n    maxNum = nums[0]\n    maxIndex = 0\n    for index in range(1, length):\n        if nums[index] > maxNum:\n            maxNum = nums[index]\n            maxIndex = index\n\n    for i in range(length):\n        if i == maxIndex:\n            continue\n\n        if maxNum >= 2 * nums[i]:\n            return -1\n\n    return maxIndex\n\n\nif __name__ == '__main__':\n    print(dominantIndex([1, 2, 3, 4]))\n    print(dominantIndex([3, 6, 1, 0]))\n    print(dominantIndex([1, 2, 3, 4, 5]))\n    print(dominantIndex([6, 6, 0, 5]))\n    print(dominantIndex([0, 0, 0, 6, 5, 4, 3, 2, 1]))\n    print(", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    length = len(nums)\n    if length == 1:\n        return 0\n\n    maxNum = nums[0]\n    maxIndex = 0\n    for index in range(1, length):\n        if nums[index] > maxNum:\n            maxNum = nums[index]\n            maxIndex = index\n\n    for i in range(length):\n        if i == maxIndex:\n            continue\n\n        if maxNum >= 2 * nums[i]:\n            return -1\n\n    return maxIndex\n\n\nif __name__ == '__main__':\n    print(dominantIndex([1, 2, 3, 4]))\n    print(dominantIndex([3, 6, 1, 0]))\n    print(dominantIndex([1, 2, 3, 4, 5]))\n    print(dominantIndex([6, 6, 0, 5]))\n    print(dominantIndex([0, 0, 0, 6, 5, 4, 3, 2, 1]))\n    print("}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) <= 1:\n        return 0\n\n    max_idx = 0\n    max_num = nums[max_idx]\n    for idx, x in enumerate(nums):\n        if x > max_num:\n            max_idx = idx\n            max_num = x\n    if max_num * 2 > sum(nums) - max_num:\n        return max_idx\n    else:\n        return -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\nclass Test(unittest.TestCase):\n    def test_dominantIndex(self):\n        self.assertEqual(dominantIndex([3, 6, 1, 0]), 1)\n        self.assert", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) <= 1:\n        return 0\n\n    max_idx = 0\n    max_num = nums[max_idx]\n    for idx, x in enumerate(nums):\n        if x > max_num:\n            max_idx = idx\n            max_num = x\n    if max_num * 2 > sum(nums) - max_num:\n        return max_idx\n    else:\n        return -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\nclass Test(unittest.TestCase):\n    def test_dominantIndex(self):\n        self.assertEqual(dominantIndex([3, 6, 1, 0]), 1)\n        self.assert"}
{"task_id": "leetcode/747", "completion": "\n    length = len(nums)\n    if length == 1:\n        return 0\n    if length == 2:\n        return 1 if nums[0] > nums[1] else -1\n\n    # 找到最大的值\n    maxVal = max(nums[:length - 1])\n    if nums[length - 1] < maxVal:\n        return -1\n\n    # 找到最大的值的索引\n    maxIdx = 0\n    for i in range(length - 1):\n        if nums[i] == maxVal:\n            maxIdx = i\n\n    for i in range(length - 1):\n        if nums[i]!= maxVal and maxVal >= 2 * nums[i]:\n            return maxIdx\n\n    return -1\n\n\ndef findPoisonedDuration(timeSeries, duration):\n    '''\n    给你一个 没有重叠的 摆放任务列表 tasks，每个任务的持续时间为", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    length = len(nums)\n    if length == 1:\n        return 0\n    if length == 2:\n        return 1 if nums[0] > nums[1] else -1\n\n    # 找到最大的值\n    maxVal = max(nums[:length - 1])\n    if nums[length - 1] < maxVal:\n        return -1\n\n    # 找到最大的值的索引\n    maxIdx = 0\n    for i in range(length - 1):\n        if nums[i] == maxVal:\n            maxIdx = i\n\n    for i in range(length - 1):\n        if nums[i]!= maxVal and maxVal >= 2 * nums[i]:\n            return maxIdx\n\n    return -1\n\n\ndef findPoisonedDuration(timeSeries, duration):\n    '''\n    给你一个 没有重叠的 摆放任务列表 tasks，每个任务的持续时间为"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1:\n        return 0\n    # 找到最大值\n    max_index = 0\n    for index, num in enumerate(nums):\n        if nums[max_index] < num:\n            max_index = index\n    # 找到最大值对应的下标的值\n    max_val = nums[max_index]\n    # 遍历数组\n    for index in range(len(nums)):\n        if index is not max_index and nums[index] * 2 < max_val:\n            return -1\n    return max_index\n\n\ndef intersectionOfTwoArrays(nums1, nums2):\n    '''\n    给定两个数组，编写一个函数来计算它们的交集。\n    示例1:\n    输入: nums1 = [1,2,2,1], nums2 = [2,2]\n    输出: [2,2]\n    示例2:\n    输", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1:\n        return 0\n    # 找到最大值\n    max_index = 0\n    for index, num in enumerate(nums):\n        if nums[max_index] < num:\n            max_index = index\n    # 找到最大值对应的下标的值\n    max_val = nums[max_index]\n    # 遍历数组\n    for index in range(len(nums)):\n        if index is not max_index and nums[index] * 2 < max_val:\n            return -1\n    return max_index\n\n\ndef intersectionOfTwoArrays(nums1, nums2):\n    '''\n    给定两个数组，编写一个函数来计算它们的交集。\n    示例1:\n    输入: nums1 = [1,2,2,1], nums2 = [2,2]\n    输出: [2,2]\n    示例2:\n    输"}
{"task_id": "leetcode/1200", "completion": "\n    n = len(arr)\n    arr.sort()\n    result = []\n    min_dis = float('inf')\n    for i in range(1, n):\n        dis = abs(arr[i] - arr[i-1])\n        min_dis = min(min_dis, dis)\n        if dis == min_dis:\n            result.append([arr[i-1], arr[i]])\n    return result\n\n\ndef smallestDistancePair(arr, req_sum):\n    '''\n    给定一个整数数组, 返回两个数的和等于给定值的数对的个数。\n    >>> smallestDistancePair([1, 3, 1], 4)\n    2\n    >>> smallestDistancePair([1, 1, 1, 1], 4)\n    6\n    >>> smallestDistancePair([1, 3], 4)\n    1\n    '''\n    n, result = len(arr), 0\n    # 最小距离\n    min_dis = float('inf')\n    # ��", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    n = len(arr)\n    arr.sort()\n    result = []\n    min_dis = float('inf')\n    for i in range(1, n):\n        dis = abs(arr[i] - arr[i-1])\n        min_dis = min(min_dis, dis)\n        if dis == min_dis:\n            result.append([arr[i-1], arr[i]])\n    return result\n\n\ndef smallestDistancePair(arr, req_sum):\n    '''\n    给定一个整数数组, 返回两个数的和等于给定值的数对的个数。\n    >>> smallestDistancePair([1, 3, 1], 4)\n    2\n    >>> smallestDistancePair([1, 1, 1, 1], 4)\n    6\n    >>> smallestDistancePair([1, 3], 4)\n    1\n    '''\n    n, result = len(arr), 0\n    # 最小距离\n    min_dis = float('inf')\n    # ��"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    min_diff = min(arr[1:] - arr[:-1])  # list[i+1] - list[i]\n    res = []\n    for i in range(len(arr) - 1):\n        if arr[i+1] - arr[i] == min_diff:\n            res.append([arr[i], arr[i+1]])\n    return res\n\n\n    '''\n    arr = [1,2,3,4]\n    brr = [4,3,2,1]\n    '''\n\n\n\n\n\n\n\nif __name__ == '__main__':\n    # arr = [4,2,1,3]\n    # print(minimumAbsDifference(arr))\n    arr = [-5, -3, -1, 1, 3, 5]\n    print(minimumAbsDifference(arr))\n    # minimumAbsDifference([-5, -3, -1, 1, 3, 5])\n    '''\n    [[4,2], [3,1], [6", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    min_diff = min(arr[1:] - arr[:-1])  # list[i+1] - list[i]\n    res = []\n    for i in range(len(arr) - 1):\n        if arr[i+1] - arr[i] == min_diff:\n            res.append([arr[i], arr[i+1]])\n    return res\n\n\n    '''\n    arr = [1,2,3,4]\n    brr = [4,3,2,1]\n    '''\n\n\n\n\n\n\n\nif __name__ == '__main__':\n    # arr = [4,2,1,3]\n    # print(minimumAbsDifference(arr))\n    arr = [-5, -3, -1, 1, 3, 5]\n    print(minimumAbsDifference(arr))\n    # minimumAbsDifference([-5, -3, -1, 1, 3, 5])\n    '''\n    [[4,2], [3,1], [6"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) == min([abs(arr[i] - a) for a in arr]):\n                result.append([arr[i], arr[j]])\n    return result\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n    请你找出并返回这两个正序数组的中位数。\n    进阶: 能够设计一个时间复杂度 O(log (m+n)) 的算法解决此问题吗？\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([], [1])", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) == min([abs(arr[i] - a) for a in arr]):\n                result.append([arr[i], arr[j]])\n    return result\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n    请你找出并返回这两个正序数组的中位数。\n    进阶: 能够设计一个时间复杂度 O(log (m+n)) 的算法解决此问题吗？\n    >>> findMedianSortedArrays([1,3], [2])\n    2.0\n    >>> findMedianSortedArrays([], [1])"}
{"task_id": "leetcode/1200", "completion": "\n    if not arr or len(arr) == 1:\n        return []\n    if len(arr) == 2:\n        return [[arr[0], arr[1]]]\n    \n    # 按升序排列\n    arr = sorted(arr)\n    result = []\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < len(arr) - i - 2:\n            continue\n        if i + 1 < len(arr) - 1 and diff == arr[i + 2] - arr[i + 1]:\n            continue\n        result.append([arr[i], arr[i + 1]])\n    \n    return result\n\n\ndef combinationSum(candidates, target):\n    '''\n    输入一个无重复元素的数组 'candidates' 和一个目标数 'target', 找出candidates中所有可以使数字和为target的组合.\n    candidates 中的数字可以", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if not arr or len(arr) == 1:\n        return []\n    if len(arr) == 2:\n        return [[arr[0], arr[1]]]\n    \n    # 按升序排列\n    arr = sorted(arr)\n    result = []\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < len(arr) - i - 2:\n            continue\n        if i + 1 < len(arr) - 1 and diff == arr[i + 2] - arr[i + 1]:\n            continue\n        result.append([arr[i], arr[i + 1]])\n    \n    return result\n\n\ndef combinationSum(candidates, target):\n    '''\n    输入一个无重复元素的数组 'candidates' 和一个目标数 'target', 找出candidates中所有可以使数字和为target的组合.\n    candidates 中的数字可以"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    ans = []\n    for i in range(len(arr) - 1):\n        n = arr[i + 1] - arr[i]\n        for j in range(i + 2, len(arr)):\n            m = arr[j] - arr[i]\n            if n < m:\n                ans.append([arr[i], arr[j]])\n                break\n            elif n == m:\n                ans.append([arr[i], arr[j]])\n                break\n    return ans\n\n    # 更优解\n    arr.sort()\n    ans = []\n    for i in range(len(arr)):\n        j = i + 1\n        while j < len(arr) and abs(arr[i] - arr[j]) == abs(arr[j] - arr[i]):\n            ans.append([arr[i], arr[j]])\n            j += 1\n    return ans\n\n\nif __name__ == '__main__':\n    print(minimumAbsDifference([4, 2, 1, 3]))", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    ans = []\n    for i in range(len(arr) - 1):\n        n = arr[i + 1] - arr[i]\n        for j in range(i + 2, len(arr)):\n            m = arr[j] - arr[i]\n            if n < m:\n                ans.append([arr[i], arr[j]])\n                break\n            elif n == m:\n                ans.append([arr[i], arr[j]])\n                break\n    return ans\n\n    # 更优解\n    arr.sort()\n    ans = []\n    for i in range(len(arr)):\n        j = i + 1\n        while j < len(arr) and abs(arr[i] - arr[j]) == abs(arr[j] - arr[i]):\n            ans.append([arr[i], arr[j]])\n            j += 1\n    return ans\n\n\nif __name__ == '__main__':\n    print(minimumAbsDifference([4, 2, 1, 3]))"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    n = len(arr)\n    res = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) == abs(arr[j] - arr[i]):\n                res.append([arr[i], arr[j]])\n    return res\n\n\ndef findRabbit(matrix):\n    '''\n    请设计一个算法，在矩阵中找出一个字母 b 。\n    矩阵中的字母在每一行中都是按从左到右递增的顺序排列，\n    每一列中也是按从上到下递增的顺序排列。\n    b 可以出现在任意行和任意列上，当且仅当 b 是矩阵中的一个字母，\n    并且不在任何字典", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    n = len(arr)\n    res = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) == abs(arr[j] - arr[i]):\n                res.append([arr[i], arr[j]])\n    return res\n\n\ndef findRabbit(matrix):\n    '''\n    请设计一个算法，在矩阵中找出一个字母 b 。\n    矩阵中的字母在每一行中都是按从左到右递增的顺序排列，\n    每一列中也是按从上到下递增的顺序排列。\n    b 可以出现在任意行和任意列上，当且仅当 b 是矩阵中的一个字母，\n    并且不在任何字典"}
{"task_id": "leetcode/1200", "completion": "\n    # TODO\n\n\ndef reverseInteger(x):\n    '''\n    给定一个 32 位有符号整数，将整数中的数字进行反转。\n    注意:\n        假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。\n        如果反转后的整数溢出，则返回 0.\n    >>> reverseInteger(123)\n    321\n    >>> reverseInteger(-123)\n    -321\n    >>> reverseInteger(1534236469)\n    0\n    '''\n    # TODO\n\n\ndef reverseString(s):\n    '''\n    给定一个字符串，逐个翻转字符串中的每个单词。\n    说明:\n        无空格字符构成一个 字", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # TODO\n\n\ndef reverseInteger(x):\n    '''\n    给定一个 32 位有符号整数，将整数中的数字进行反转。\n    注意:\n        假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。\n        如果反转后的整数溢出，则返回 0.\n    >>> reverseInteger(123)\n    321\n    >>> reverseInteger(-123)\n    -321\n    >>> reverseInteger(1534236469)\n    0\n    '''\n    # TODO\n\n\ndef reverseString(s):\n    '''\n    给定一个字符串，逐个翻转字符串中的每个单词。\n    说明:\n        无空格字符构成一个 字"}
{"task_id": "leetcode/1200", "completion": "\n    return [min(", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    return [min("}
{"task_id": "leetcode/1200", "completion": "\n    res = []\n    for i in range(len(arr)):\n        min_diff = float('inf')\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) < min_diff:\n                min_diff = abs(arr[i] - arr[j])\n                res = [[arr[i], arr[j]]]\n            elif abs(arr[i] - arr[j]) == min_diff:\n                res.append([arr[i], arr[j]])\n    return res\n\n\n\n# 实现一个函数，以 m x n 的哈希表初始化\ndef initializeTable(num_rows, num_cols):\n    table = [[None for col in range(num_cols)]\n             for row in range(num_rows)]\n    return table\n\n\n# 将字符串'seq' 中含有的字符以列表的形式返回\ndef get_characters(seq):\n    result = list(set(seq))\n    result.sort()\n    return", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    res = []\n    for i in range(len(arr)):\n        min_diff = float('inf')\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) < min_diff:\n                min_diff = abs(arr[i] - arr[j])\n                res = [[arr[i], arr[j]]]\n            elif abs(arr[i] - arr[j]) == min_diff:\n                res.append([arr[i], arr[j]])\n    return res\n\n\n\n# 实现一个函数，以 m x n 的哈希表初始化\ndef initializeTable(num_rows, num_cols):\n    table = [[None for col in range(num_cols)]\n             for row in range(num_rows)]\n    return table\n\n\n# 将字符串'seq' 中含有的字符以列表的形式返回\ndef get_characters(seq):\n    result = list(set(seq))\n    result.sort()\n    return"}
{"task_id": "leetcode/1200", "completion": "\n    # write code here\n    arr.sort()\n    res = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]:\n            res.append([arr[i - 1], arr[i]])\n    return res\n\n\ndef maxMinDiff(arr):\n    '''\n    给定一个整数数组 'arr'，找到'arr'中最大和最小元素之间的最小差值。\n    注意:\n    'arr' 的长度至少为2，且数值全为正数\n    >>> maxMinDiff([1, 3, 15, 11])\n    14\n    '''\n    # write code here\n    arr.sort()\n    minVal = arr[1] - arr[0]\n    maxVal = arr[-1] - arr[0]\n    return min(max(minVal, maxVal), min(max(minVal, maxVal),", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # write code here\n    arr.sort()\n    res = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]:\n            res.append([arr[i - 1], arr[i]])\n    return res\n\n\ndef maxMinDiff(arr):\n    '''\n    给定一个整数数组 'arr'，找到'arr'中最大和最小元素之间的最小差值。\n    注意:\n    'arr' 的长度至少为2，且数值全为正数\n    >>> maxMinDiff([1, 3, 15, 11])\n    14\n    '''\n    # write code here\n    arr.sort()\n    minVal = arr[1] - arr[0]\n    maxVal = arr[-1] - arr[0]\n    return min(max(minVal, maxVal), min(max(minVal, maxVal),"}
{"task_id": "leetcode/1385", "completion": "\n    def count(arr, arr2, d):\n        return [sum(map(lambda x:abs(x-i)>d, arr)) for i in arr2]\n    return sum(count(arr1, arr2, d))\n\ndef makeLargestSpecial(S):\n    '''\n    S 是一个字符串，现在要从S中选择若干字符，使得这些字符的大小写字母全部不同，且所选字符的个数最大，\n    返回所选字符的最大个数\n    >>> makeLargestSpecial(\"leetcode\")\n    3\n    >>> makeLargestSpecial(\"AbCdEfGh\")\n    4\n    '''\n    def f(S):\n        d = {}\n        for c in S:\n            d[c] = d.get(c, 0) + 1\n        d = sorted(d.items(), key=lambda x:x[1], reverse=True)\n        d = [t for t, c in d]\n        d =", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    def count(arr, arr2, d):\n        return [sum(map(lambda x:abs(x-i)>d, arr)) for i in arr2]\n    return sum(count(arr1, arr2, d))\n\ndef makeLargestSpecial(S):\n    '''\n    S 是一个字符串，现在要从S中选择若干字符，使得这些字符的大小写字母全部不同，且所选字符的个数最大，\n    返回所选字符的最大个数\n    >>> makeLargestSpecial(\"leetcode\")\n    3\n    >>> makeLargestSpecial(\"AbCdEfGh\")\n    4\n    '''\n    def f(S):\n        d = {}\n        for c in S:\n            d[c] = d.get(c, 0) + 1\n        d = sorted(d.items(), key=lambda x:x[1], reverse=True)\n        d = [t for t, c in d]\n        d ="}
{"task_id": "leetcode/1385", "completion": "\n    # dp\n    l1 = len(arr1)\n    l2 = len(arr2)\n    if l1 == 1 and l2 == 1:\n        if abs(arr1[0] - arr2[0]) > d:\n            return 1\n        else:\n            return 0\n\n    dp = [[0 for _ in range(l2)] for _ in range(l1)]\n    for i in range(l1):\n        for j in range(l2):\n            dp[i][j] = dp[i - 1][j] + 1 if i - 1 >= 0 and abs(arr1[i] - arr2[j]) <= d else 1\n        # print(\"第{}列：{} 第{}行：{}\".format(j,dp[i],i,dp[i][j]))\n    for i in range(l2):\n        for j in range(l1):\n            dp[j][i] += dp[j][i - 1] if i - 1 >= 0 else 0\n        # print(\"", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # dp\n    l1 = len(arr1)\n    l2 = len(arr2)\n    if l1 == 1 and l2 == 1:\n        if abs(arr1[0] - arr2[0]) > d:\n            return 1\n        else:\n            return 0\n\n    dp = [[0 for _ in range(l2)] for _ in range(l1)]\n    for i in range(l1):\n        for j in range(l2):\n            dp[i][j] = dp[i - 1][j] + 1 if i - 1 >= 0 and abs(arr1[i] - arr2[j]) <= d else 1\n        # print(\"第{}列：{} 第{}行：{}\".format(j,dp[i],i,dp[i][j]))\n    for i in range(l2):\n        for j in range(l1):\n            dp[j][i] += dp[j][i - 1] if i - 1 >= 0 else 0\n        # print(\""}
{"task_id": "leetcode/1385", "completion": "\n    # dp 1 先确定 长度 2*n+1\n    # dp 2 依次初始化 遍历 \n    # dp 3 依次更新即可\n    '''\n    dp[i][j]表示 arr1[0,i) 和 arr2[0,j)的长度\n    设dp[i][j]表示arr1[0,i)和arr2[0,j)的长度，则\n    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])+1\n    '''\n\n    n = len(arr1)\n    m = len(arr2)\n    # dp 1 先确定 长度 2*n+1\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    # dp 2 依次初始化 遍历 ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # dp 1 先确定 长度 2*n+1\n    # dp 2 依次初始化 遍历 \n    # dp 3 依次更新即可\n    '''\n    dp[i][j]表示 arr1[0,i) 和 arr2[0,j)的长度\n    设dp[i][j]表示arr1[0,i)和arr2[0,j)的长度，则\n    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])+1\n    '''\n\n    n = len(arr1)\n    m = len(arr2)\n    # dp 1 先确定 长度 2*n+1\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    # dp 2 依次初始化 遍历 "}
{"task_id": "leetcode/1385", "completion": "\n    # write code here\n    n = len(arr1)\n    m = len(arr2)\n    result = 0\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j] = min(abs(arr1[i]-arr2[j]), d)\n            if (dp[i][j] == d):\n                result += 1\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], dp[k][j]+abs(arr1[i]-arr1[k]))\n                if (dp[i][j] == d):\n                    result += 1\n    return result\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # write code here\n    n = len(arr1)\n    m = len(arr2)\n    result = 0\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j] = min(abs(arr1[i]-arr2[j]), d)\n            if (dp[i][j] == d):\n                result += 1\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], dp[k][j]+abs(arr1[i]-arr1[k]))\n                if (dp[i][j] == d):\n                    result += 1\n    return result\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回"}
{"task_id": "leetcode/1385", "completion": "\n    arr1_len = len(arr1)\n    arr2_len = len(arr2)\n    min_count, min_value = 0, 0\n    # 先跳过空的数组\n    if arr1_len == 0 or arr2_len == 0:\n        return min_value\n    # 申请保存arr2的指针数组，用来记录arr2的每个元素出现在arr1中的位置\n    arr2_pos = [0 for i in range(arr2_len)]\n    # 循环遍历arr1的元素\n    for i in range(arr1_len):\n        # 查询出arr1[i]在arr2中的位置\n        index = binary_search_right(arr2, arr1[i], arr2_len)\n        if index == -1:\n            continue\n        # 如果找到了，加入指针数组并记入计数器\n        arr2_pos", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1_len = len(arr1)\n    arr2_len = len(arr2)\n    min_count, min_value = 0, 0\n    # 先跳过空的数组\n    if arr1_len == 0 or arr2_len == 0:\n        return min_value\n    # 申请保存arr2的指针数组，用来记录arr2的每个元素出现在arr1中的位置\n    arr2_pos = [0 for i in range(arr2_len)]\n    # 循环遍历arr1的元素\n    for i in range(arr1_len):\n        # 查询出arr1[i]在arr2中的位置\n        index = binary_search_right(arr2, arr1[i], arr2_len)\n        if index == -1:\n            continue\n        # 如果找到了，加入指针数组并记入计数器\n        arr2_pos"}
{"task_id": "leetcode/1385", "completion": "\n    count = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) <= d:\n                count += 1\n                break\n    return count\n\n\nclass Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        '''\n        哈哈哈哈，这个题目可以优雅的写出来，不过题解里的话题板还是有一些特殊情况，所以没有贴出来\n        '''\n        res = 0\n        # 这个时候，arr1和arr2都有一个排序好的列表\n        # 我们把arr2稍微把d减一点，比如arr2中有6 ，那么我把6减一就是5，如果arr1中有", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    count = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) <= d:\n                count += 1\n                break\n    return count\n\n\nclass Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        '''\n        哈哈哈哈，这个题目可以优雅的写出来，不过题解里的话题板还是有一些特殊情况，所以没有贴出来\n        '''\n        res = 0\n        # 这个时候，arr1和arr2都有一个排序好的列表\n        # 我们把arr2稍微把d减一点，比如arr2中有6 ，那么我把6减一就是5，如果arr1中有"}
{"task_id": "leetcode/1385", "completion": "\n    count = 0\n    if d == 0:\n        return len(arr1) + len(arr2) - len(set(arr1) | set(arr2))\n\n    for i in range(len(arr1)):\n        count += len([x for x in arr2 if abs(arr1[i]-x) <= d])\n\n    for i in range(len(arr2)):\n        count += len([x for x in arr1 if abs(arr2[i]-x) <= d])\n\n    return count\n\n    # pass\n\n\ndef stringMatching(words):\n    '''\n    给定一个字符串数组 words, 找到 words 中 任意 两个不同字符串之间的最短距离。\n    距离定义为：点对应含义字符的 ASCII 码差值绝对值。\n    如果不存在这样的两个字符串，返回 0。\n    >>> stringMatching([\"practice", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    count = 0\n    if d == 0:\n        return len(arr1) + len(arr2) - len(set(arr1) | set(arr2))\n\n    for i in range(len(arr1)):\n        count += len([x for x in arr2 if abs(arr1[i]-x) <= d])\n\n    for i in range(len(arr2)):\n        count += len([x for x in arr1 if abs(arr2[i]-x) <= d])\n\n    return count\n\n    # pass\n\n\ndef stringMatching(words):\n    '''\n    给定一个字符串数组 words, 找到 words 中 任意 两个不同字符串之间的最短距离。\n    距离定义为：点对应含义字符的 ASCII 码差值绝对值。\n    如果不存在这样的两个字符串，返回 0。\n    >>> stringMatching([\"practice"}
{"task_id": "leetcode/1385", "completion": "\n    # 满足条件的个数\n    num = 0\n    # 每个数的个数\n    nums = Counter(arr1)\n    for i in arr2:\n        if i in nums:\n            idx = i\n            if abs(idx - arr1[0]) > d:\n                num += 1\n                arr1.remove(idx)\n        else:\n            num += 1\n    return num\n\n\nclass MedianFinder(object):\n    \"\"\"\n    LeetCode #295\n    https://leetcode.com/problems/find-median-from-data-stream/\n\n    >>> mf = MedianFinder()\n    >>> mf.addNum(1)\n    >>> mf.findMedian()\n    1.0\n    >>> mf.addNum(2)\n    >>> mf.findMedian()\n    1.5\n    >>> mf.addNum(3)\n    >>> mf.findMedian()\n    2.0\n    >>> mf.addNum(4)\n    >>>", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # 满足条件的个数\n    num = 0\n    # 每个数的个数\n    nums = Counter(arr1)\n    for i in arr2:\n        if i in nums:\n            idx = i\n            if abs(idx - arr1[0]) > d:\n                num += 1\n                arr1.remove(idx)\n        else:\n            num += 1\n    return num\n\n\nclass MedianFinder(object):\n    \"\"\"\n    LeetCode #295\n    https://leetcode.com/problems/find-median-from-data-stream/\n\n    >>> mf = MedianFinder()\n    >>> mf.addNum(1)\n    >>> mf.findMedian()\n    1.0\n    >>> mf.addNum(2)\n    >>> mf.findMedian()\n    1.5\n    >>> mf.addNum(3)\n    >>> mf.findMedian()\n    2.0\n    >>> mf.addNum(4)\n    >>>"}
{"task_id": "leetcode/1385", "completion": "\n    if not arr1 or not arr2:\n        return 0\n    m = len(arr1)\n    n = len(arr2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(m):\n        for j in range(n):\n            if (arr1[i] - arr2[j]) > d:\n                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])\n            elif (arr1[i] - arr2[j]) <= d:\n                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i+1][j], dp[i][j] + 1)\n    return dp[m][n]\n\n\ndef countPrimeSetBits(L, R):\n    '''\n    给定范围 [L, R], 寻找「按位置 1 计数 是 2 的�", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    if not arr1 or not arr2:\n        return 0\n    m = len(arr1)\n    n = len(arr2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(m):\n        for j in range(n):\n            if (arr1[i] - arr2[j]) > d:\n                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])\n            elif (arr1[i] - arr2[j]) <= d:\n                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i+1][j], dp[i][j] + 1)\n    return dp[m][n]\n\n\ndef countPrimeSetBits(L, R):\n    '''\n    给定范围 [L, R], 寻找「按位置 1 计数 是 2 的�"}
{"task_id": "leetcode/1385", "completion": "\n    arr1 = [abs(x) for x in arr1]\n    arr2 = [abs(x) for x in arr2]\n    arr1.sort()\n    arr2.sort()\n\n    count1 = 0\n    arr1l = len(arr1)\n    arr2l = len(arr2)\n    i = 0\n    j = 0\n    while i < arr1l and j < arr2l:\n        if arr1[i] < arr2[j]:\n            count1 += arr1l-i\n            i = 0\n            j += 1\n        else:\n            i += 1\n    if i < arr1l:\n        count1 += (arr2l - j) * (arr1l - i)\n\n    return count1\n\ndef findMaxAverage(nums, k):\n    '''\n    给你一个整数数组 nums，有一个大小为 k 的窗口从最左侧滑动到最右侧。窗口中有 k 个数，", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1 = [abs(x) for x in arr1]\n    arr2 = [abs(x) for x in arr2]\n    arr1.sort()\n    arr2.sort()\n\n    count1 = 0\n    arr1l = len(arr1)\n    arr2l = len(arr2)\n    i = 0\n    j = 0\n    while i < arr1l and j < arr2l:\n        if arr1[i] < arr2[j]:\n            count1 += arr1l-i\n            i = 0\n            j += 1\n        else:\n            i += 1\n    if i < arr1l:\n        count1 += (arr2l - j) * (arr1l - i)\n\n    return count1\n\ndef findMaxAverage(nums, k):\n    '''\n    给你一个整数数组 nums，有一个大小为 k 的窗口从最左侧滑动到最右侧。窗口中有 k 个数，"}
{"task_id": "leetcode/349", "completion": "\n    _nums1 = set(nums1)\n    _nums2 = set(nums2)\n    return list(_nums1 & _nums2)\n\n\ndef intersectionTwo(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersectionTwo([1,2,2,1], [2,2])\n    1\n    >>> intersectionTwo([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    _nums1 = set(nums1)\n    _nums2 = set(nums2)\n    return list(_nums1 & _nums2)\n\n\ndef intersectionTwo(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersectionTwo([1,2,2,1], [2,2])\n    1\n    >>> intersectionTwo([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums"}
{"task_id": "leetcode/349", "completion": "\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n    intersection_set = nums1_set & nums2_set\n    intersection_list = list(intersection_set)\n    intersection_list.sort()\n    return intersection_list\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n    intersection_set = nums1_set & nums2_", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n    intersection_set = nums1_set & nums2_set\n    intersection_list = list(intersection_set)\n    intersection_list.sort()\n    return intersection_list\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n    intersection_set = nums1_set & nums2_"}
{"task_id": "leetcode/349", "completion": "\n    nums1 = list(set(nums1))\n    res = []\n    for i in nums1:\n        if i in nums2:\n            res.append(i)\n    return sorted(res)\n\n\nif __name__ == '__main__':\n    print(intersection([1, 2, 2, 1], [2, 2]))\n    print(intersection", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1 = list(set(nums1))\n    res = []\n    for i in nums1:\n        if i in nums2:\n            res.append(i)\n    return sorted(res)\n\n\nif __name__ == '__main__':\n    print(intersection([1, 2, 2, 1], [2, 2]))\n    print(intersection"}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    res = []\n    i = 0\n    j = 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n\ndef is_unique(str_word):\n    '''\n    给定一个字符串, 给出它是否是唯一的。\n    我们就把它分为一个个的子串, 看看是否有重复的。\n    如果没有重复的, 返回'True', 否则返回'False'\n    >>> is_unique(\"abcdfe\")\n    True\n    >>> is_unique(\"abcdef\")\n    False\n    >>> is_unique", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    res = []\n    i = 0\n    j = 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n\ndef is_unique(str_word):\n    '''\n    给定一个字符串, 给出它是否是唯一的。\n    我们就把它分为一个个的子串, 看看是否有重复的。\n    如果没有重复的, 返回'True', 否则返回'False'\n    >>> is_unique(\"abcdfe\")\n    True\n    >>> is_unique(\"abcdef\")\n    False\n    >>> is_unique"}
{"task_id": "leetcode/349", "completion": "\n    return list(set(nums1).intersection(nums2))\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,2,1], [2,2])\n    [1, 2, 2]\n    >>> union([4,9,5], [9,4,9,8,4])\n    [4, 8, 9]\n    '''\n    return list(set(nums1).union(nums2))\n    \ndef difference(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回两个数组的差集，\n    其中元素在 'nums1' 但不在 '", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1).intersection(nums2))\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,2,1], [2,2])\n    [1, 2, 2]\n    >>> union([4,9,5], [9,4,9,8,4])\n    [4, 8, 9]\n    '''\n    return list(set(nums1).union(nums2))\n    \ndef difference(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回两个数组的差集，\n    其中元素在 'nums1' 但不在 '"}
{"task_id": "leetcode/349", "completion": "\n    result = []\n    j = 0\n    for i in nums1:\n        while j < len(nums2) and nums2[j] < i:\n            j += 1\n        if j < len(nums2) and nums2[j] == i:\n            result.append(i)\n            j += 1\n    return result\n\n\ndef removeDuplicates(nums):\n    '''\n    给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n    >>> removeDuplicates([0,0,1,1,1,2,2,3,3,4])\n    5\n    >>> removeDuplicates([1,1,1,1,1])\n    1\n    >>> removeDuplicates([3,3,3,3,3])\n    1\n    >>> removeDuplicates([1,2,3,4,5,6,7,8,9,10,", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    result = []\n    j = 0\n    for i in nums1:\n        while j < len(nums2) and nums2[j] < i:\n            j += 1\n        if j < len(nums2) and nums2[j] == i:\n            result.append(i)\n            j += 1\n    return result\n\n\ndef removeDuplicates(nums):\n    '''\n    给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n    >>> removeDuplicates([0,0,1,1,1,2,2,3,3,4])\n    5\n    >>> removeDuplicates([1,1,1,1,1])\n    1\n    >>> removeDuplicates([3,3,3,3,3])\n    1\n    >>> removeDuplicates([1,2,3,4,5,6,7,8,9,10,"}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums2[j] < nums1[i]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            j += 1\n            i += 1\n    return res\n\n\nif __name__ == '__main__':\n    nums1 = [1,2,2,1]\n    nums2 = [2,2]\n    print(intersection(nums1, nums2))\n\n    nums1 = [4,9", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums2[j] < nums1[i]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            j += 1\n            i += 1\n    return res\n\n\nif __name__ == '__main__':\n    nums1 = [1,2,2,1]\n    nums2 = [2,2]\n    print(intersection(nums1, nums2))\n\n    nums1 = [4,9"}
{"task_id": "leetcode/349", "completion": "\n    # 先排序\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\ndef intersection_set(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2'，返回它们的交集。返回的列表中的每个元素都是唯一的，并且返回的列表是按数字大小有序的。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    # 先排序\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\ndef intersection_set(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2'，返回它们的交集。返回的列表中的每个元素都是唯一的，并且返回的列表是按数字大小有序的。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection(["}
{"task_id": "leetcode/349", "completion": "\n    return tuple(set(nums1) & set(nums2))\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1 = set(nums1)\n    nums2 = set(nums2)\n    nums_intersection = []\n    for item in nums1:\n        if item in nums2:\n            nums_intersection.append(item)\n\n    return tuple(nums_intersection)\n\ndef intersection3(nums1, nums2):\n    '''\n    给定两个�", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return tuple(set(nums1) & set(nums2))\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1 = set(nums1)\n    nums2 = set(nums2)\n    nums_intersection = []\n    for item in nums1:\n        if item in nums2:\n            nums_intersection.append(item)\n\n    return tuple(nums_intersection)\n\ndef intersection3(nums1, nums2):\n    '''\n    给定两个�"}
{"task_id": "leetcode/349", "completion": "\n    n1, n2 = len(nums1), len(nums2)\n    # 使用字典，key 存放需要做交集的值，value 存放出现的个数\n    dic = {}\n    for i in nums1:\n        dic[i] = 0\n    for i in nums2:\n        if i in dic:\n            dic[i] += 1\n    res = []\n    for k, v in dic.items():\n        if v > 1:\n            for i in range(v):\n                res.append(k)\n        else:\n            res.append(k)\n    return res\n\n\n# 8. 折半查找\ndef binary_search(nums, target):\n    '''\n    给定一个按照升序排列的整数数组 nums，和一个目标值 target。\n    找出给定目标值在数组中的开始位置和结束位置。\n    如", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    n1, n2 = len(nums1), len(nums2)\n    # 使用字典，key 存放需要做交集的值，value 存放出现的个数\n    dic = {}\n    for i in nums1:\n        dic[i] = 0\n    for i in nums2:\n        if i in dic:\n            dic[i] += 1\n    res = []\n    for k, v in dic.items():\n        if v > 1:\n            for i in range(v):\n                res.append(k)\n        else:\n            res.append(k)\n    return res\n\n\n# 8. 折半查找\ndef binary_search(nums, target):\n    '''\n    给定一个按照升序排列的整数数组 nums，和一个目标值 target。\n    找出给定目标值在数组中的开始位置和结束位置。\n    如"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    return round((sum(salary) - salary[-1] - salary[0]) / len(salary[1:]))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)\n\n\ndef average3(salary):\n    '''\n    给定", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return round((sum(salary) - salary[-1] - salary[0]) / len(salary[1:]))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)\n\n\ndef average3(salary):\n    '''\n    给定"}
{"task_id": "leetcode/1491", "completion": "\n    salary_list = sorted(salary)\n    return int((sum(salary_list)-salary_list[0]-salary_list[-1]) / (len(salary_list)-2))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary_list = sorted(salary)\n    return int((sum(salary_list)-salary_list[0]-salary_list[-1]) / (len(salary_list)-2))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "leetcode/1491", "completion": "\n    if not isinstance(salary, list) or len(salary) < 2:\n        return 0\n    return int(round(sum(salary) - min(salary) - max(salary)))\n\n\ndef longest_increasing_subsequence(salary):\n    '''\n    给定一个整数数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回'salary' 中最长上升子序列的长度。\n    如果不存在，返回 0 。\n    >>> longest_increasing_subsequence([10, 2, 1, 4])\n    3\n    >>> longest_increasing_subsequence([10, 5, 50, 2, 1, 4])\n    4\n    '''\n    if not isinstance(salary, list) or len(salary) < 2:\n        return 0\n    dp = [-1 for _ in salary]\n    for i, v in", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    if not isinstance(salary, list) or len(salary) < 2:\n        return 0\n    return int(round(sum(salary) - min(salary) - max(salary)))\n\n\ndef longest_increasing_subsequence(salary):\n    '''\n    给定一个整数数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回'salary' 中最长上升子序列的长度。\n    如果不存在，返回 0 。\n    >>> longest_increasing_subsequence([10, 2, 1, 4])\n    3\n    >>> longest_increasing_subsequence([10, 5, 50, 2, 1, 4])\n    4\n    '''\n    if not isinstance(salary, list) or len(salary) < 2:\n        return 0\n    dp = [-1 for _ in salary]\n    for i, v in"}
{"task_id": "leetcode/1491", "completion": "\n    return sum(salary[1:-1]) / (len(salary) - 2)\n\n\ndef count_number(array):\n    '''\n    给定一个整数数组 'array', 计算 'array' 中是否存在两个相邻元素的和等于给定参数 'target'.\n    如果存在，返回 True；否则返回 False。\n    >>> count_number([2,6,9,23,4,12,6])\n    True\n    '''\n    for i in range(len(array) - 1):\n        for j in range(i + 1, len(array)):\n            if array[i] + array[j] == 2:\n                return True\n    return False\n\n\ndef duplicate_string(s, k):\n    '''\n    给定一个字符串's', 和一个整数 'k', 返回一个字符串，表示 s 中每一个字符都出现了 'k' 次。\n    要求��", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return sum(salary[1:-1]) / (len(salary) - 2)\n\n\ndef count_number(array):\n    '''\n    给定一个整数数组 'array', 计算 'array' 中是否存在两个相邻元素的和等于给定参数 'target'.\n    如果存在，返回 True；否则返回 False。\n    >>> count_number([2,6,9,23,4,12,6])\n    True\n    '''\n    for i in range(len(array) - 1):\n        for j in range(i + 1, len(array)):\n            if array[i] + array[j] == 2:\n                return True\n    return False\n\n\ndef duplicate_string(s, k):\n    '''\n    给定一个字符串's', 和一个整数 'k', 返回一个字符串，表示 s 中每一个字符都出现了 'k' 次。\n    要求��"}
{"task_id": "leetcode/1491", "completion": "\n    # write code here\n    salary_set = set(salary)\n    salary_set.remove(min(salary_set))\n    salary_set.remove(max(salary_set))\n    return int(sum(salary_set) / (len(salary_set) - 2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    # write code here\n    salary_set = set(salary)\n    salary_set.remove(min(salary_set))\n    salary_set.remove(max(salary_set))\n    return int(sum(salary_set) / (len(salary_set) - 2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod("}
{"task_id": "leetcode/1491", "completion": "\n    salary = sorted(salary)\n    return round(sum(salary[1:-1])/len(salary[1:-1]))\n\n\ndef is_even(i):\n    '''\n    给定整数 'i', 如果 i 是偶数，返回 'True'，否则返回 'False'\n    >>> is_even(1)\n    False\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False\n    '''\n    return True if i%2 == 0 else False\n\n\ndef is_odd(i):\n    '''\n    给定整数 'i', 如果 i 是奇数，返回 'True'，否则返回 'False'\n    >>> is_odd(1)\n    True\n    >>> is_odd(2)\n    False\n    >>> is_odd(3)\n    True\n    '''\n    return True if i%2!= 0 else False\n\n\ndef make_order(salary):\n    '''\n    给定一个数'salary", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary = sorted(salary)\n    return round(sum(salary[1:-1])/len(salary[1:-1]))\n\n\ndef is_even(i):\n    '''\n    给定整数 'i', 如果 i 是偶数，返回 'True'，否则返回 'False'\n    >>> is_even(1)\n    False\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False\n    '''\n    return True if i%2 == 0 else False\n\n\ndef is_odd(i):\n    '''\n    给定整数 'i', 如果 i 是奇数，返回 'True'，否则返回 'False'\n    >>> is_odd(1)\n    True\n    >>> is_odd(2)\n    False\n    >>> is_odd(3)\n    True\n    '''\n    return True if i%2!= 0 else False\n\n\ndef make_order(salary):\n    '''\n    给定一个数'salary"}
{"task_id": "leetcode/1491", "completion": "\n    sal = sorted(salary)\n    if len(sal) == 1:\n        return sal[0]\n    elif len(sal) == 2:\n        return (sal[0] + sal[1]) / 2\n    return (sal[1] + sal[2]) / 2\n    # return int((sum(sorted(salary)[1:-1]) / (len(salary) - 2)) + 0.5)\n\n\ndef find_n_max(n, num):\n    '''\n    给定一个数字列表 'num'. 返回前 'n' 个元素中的最大值。\n    >>> find_n_max(3, [3, 1, 2, 4, 5, 6])\n    >>> find_n_max(2, [3, 1, 2, 4, 5, 6])\n    5\n    '''\n    n = min(len(num), n)\n    return max(num[:n])\n    # return max(num[0:n])\n\n\ndef find_n_", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    sal = sorted(salary)\n    if len(sal) == 1:\n        return sal[0]\n    elif len(sal) == 2:\n        return (sal[0] + sal[1]) / 2\n    return (sal[1] + sal[2]) / 2\n    # return int((sum(sorted(salary)[1:-1]) / (len(salary) - 2)) + 0.5)\n\n\ndef find_n_max(n, num):\n    '''\n    给定一个数字列表 'num'. 返回前 'n' 个元素中的最大值。\n    >>> find_n_max(3, [3, 1, 2, 4, 5, 6])\n    >>> find_n_max(2, [3, 1, 2, 4, 5, 6])\n    5\n    '''\n    n = min(len(num), n)\n    return max(num[:n])\n    # return max(num[0:n])\n\n\ndef find_n_"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    return int((sum(salary[1:-1]))/len(salary) + 0.5)\n\n\ndef make_chars_list(chars):\n    '''\n    生成字符串字符表示(chars)中字符出现的次数的字符串表示, 返回包括字符表示的字典\n    字典的每一个key都是一个字符,值是该字符的频率\n    >>> make_chars_list('hello')\n    {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n    '''\n    chars_dict = {}\n    for char in chars:\n        if char in chars_dict:\n            chars_dict[char] += 1\n        else:\n            chars_dict[char] = 1\n    return chars_dict\n\n\ndef reverse_chars(chars):\n    '''\n    给定一个字符串, 实现一个函数来反转字符串", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return int((sum(salary[1:-1]))/len(salary) + 0.5)\n\n\ndef make_chars_list(chars):\n    '''\n    生成字符串字符表示(chars)中字符出现的次数的字符串表示, 返回包括字符表示的字典\n    字典的每一个key都是一个字符,值是该字符的频率\n    >>> make_chars_list('hello')\n    {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n    '''\n    chars_dict = {}\n    for char in chars:\n        if char in chars_dict:\n            chars_dict[char] += 1\n        else:\n            chars_dict[char] = 1\n    return chars_dict\n\n\ndef reverse_chars(chars):\n    '''\n    给定一个字符串, 实现一个函数来反转字符串"}
{"task_id": "leetcode/1491", "completion": "\n    return (sum(salary) - min(salary) - max(salary)) // (len(salary) - 2)\n\ndef is_prime(value):\n    '''\n    给定一个整数 n，要求你检测它是不是一个素数。\n    一个整数 n 是素数，当且仅当它不是一个由小于 n 的正整数之积。\n    注意：如果 n 不是素数，那么它也不能是质数。\n    >>> is_prime(13195)\n    True\n    >>> is_prime(6469)\n    False\n    '''\n    if value < 2:\n        return False\n    for i in range(2, int(value ** 0.5) + 1):\n        if value % i == 0:\n            return False\n    return True\n\ndef count_vowel(value):\n    '''\n    给定一个字符串,", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return (sum(salary) - min(salary) - max(salary)) // (len(salary) - 2)\n\ndef is_prime(value):\n    '''\n    给定一个整数 n，要求你检测它是不是一个素数。\n    一个整数 n 是素数，当且仅当它不是一个由小于 n 的正整数之积。\n    注意：如果 n 不是素数，那么它也不能是质数。\n    >>> is_prime(13195)\n    True\n    >>> is_prime(6469)\n    False\n    '''\n    if value < 2:\n        return False\n    for i in range(2, int(value ** 0.5) + 1):\n        if value % i == 0:\n            return False\n    return True\n\ndef count_vowel(value):\n    '''\n    给定一个字符串,"}
{"task_id": "leetcode/1491", "completion": "\n    average = sum(salary) - min(salary) - max(salary)\n    return int(average / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    # 文档测试\n    doctest.testmod()\n    # 手动测试\n    print('---start---')\n    print(average([1000, 2000, 3000]))\n    print(average([4000, 3000, 1000, 2000]))\n    print('---end---')\n\n    # 1. 找出列表中最小的元素\n    print('---1.1---')\n    print(min([1000, 2000, 3000, 4000]))\n    print(min([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\n    # ", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    average = sum(salary) - min(salary) - max(salary)\n    return int(average / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    # 文档测试\n    doctest.testmod()\n    # 手动测试\n    print('---start---')\n    print(average([1000, 2000, 3000]))\n    print(average([4000, 3000, 1000, 2000]))\n    print('---end---')\n\n    # 1. 找出列表中最小的元素\n    print('---1.1---')\n    print(min([1000, 2000, 3000, 4000]))\n    print(min([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\n    # "}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\n# ## 7. 斐波那契数列\ndef fibonacci(n):\n    '''\n    斐波那契数列的第 n 项为 f(n) = f(n - 1) + f(n - 2) (n > 2)。\n    给定 n, 求 f(n)。\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(4)\n    3\n    '''\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\n\n# ## 8. 丑数\ndef isUgly(num):\n", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\n# ## 7. 斐波那契数列\ndef fibonacci(n):\n    '''\n    斐波那契数列的第 n 项为 f(n) = f(n - 1) + f(n - 2) (n > 2)。\n    给定 n, 求 f(n)。\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(4)\n    3\n    '''\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\n\n# ## 8. 丑数\ndef isUgly(num):\n"}
{"task_id": "leetcode/561", "completion": "\n    n = len(nums)\n    nums.sort()\n    sum = 0\n    for i in range(n):\n        if i % 2 == 0:\n            sum += nums[i]\n        else:\n            sum += nums[i] + nums[i + 1]\n    return sum\n```\n\n<center>[上一个例子](1347.连接所有点对的最小距离.md)", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    n = len(nums)\n    nums.sort()\n    sum = 0\n    for i in range(n):\n        if i % 2 == 0:\n            sum += nums[i]\n        else:\n            sum += nums[i] + nums[i + 1]\n    return sum\n```\n\n<center>[上一个例子](1347.连接所有点对的最小距离.md)"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    return sum(nums[::2])\n\ndef arrayPartition(nums, k):\n    '''\n    给你一个整数数组 nums 和一个正整数 k，请你将这个数组划分为 k 个连续的子序列，使得从每个子序列中截取的整数的和最大。\n    请你以长度为 k 的整数数组的形式，返回这 k 个子序列中的最大和。\n    >>> arrayPartition([1,15,7,9,2,5,10], 3)\n    [17, 18, 10]\n    >>> arrayPartition([-1,-4,-5], 2)\n    [-5, -4]\n    '''\n    n = len(nums)\n    if n < k:\n        return nums\n    if k == 1:\n        return nums\n    if k == n:\n        return sum(num", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    return sum(nums[::2])\n\ndef arrayPartition(nums, k):\n    '''\n    给你一个整数数组 nums 和一个正整数 k，请你将这个数组划分为 k 个连续的子序列，使得从每个子序列中截取的整数的和最大。\n    请你以长度为 k 的整数数组的形式，返回这 k 个子序列中的最大和。\n    >>> arrayPartition([1,15,7,9,2,5,10], 3)\n    [17, 18, 10]\n    >>> arrayPartition([-1,-4,-5], 2)\n    [-5, -4]\n    '''\n    n = len(nums)\n    if n < k:\n        return nums\n    if k == 1:\n        return nums\n    if k == n:\n        return sum(num"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    s, n = 0, len(nums)//2\n    for i in range(n):\n        s += nums[i*2] + nums[i*2+1]\n    return s\n\nclass Solution:\n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ans = 0\n        nums.sort()\n        for i in range(0,len(nums),2):\n            ans += nums[i]\n            print(i)\n        return ans\n\n\n\nif __name__ == \"__main__\":\n    print(arrayPairSum([1,4,3,2]))\n\n\n```\n\n`2020-09-25`\n\n- 解题思路\n1. 先排序，\n2. 将数组从头开始扫描，如果偶数位置和偶数位置+1 的数字小于等于1", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    s, n = 0, len(nums)//2\n    for i in range(n):\n        s += nums[i*2] + nums[i*2+1]\n    return s\n\nclass Solution:\n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ans = 0\n        nums.sort()\n        for i in range(0,len(nums),2):\n            ans += nums[i]\n            print(i)\n        return ans\n\n\n\nif __name__ == \"__main__\":\n    print(arrayPairSum([1,4,3,2]))\n\n\n```\n\n`2020-09-25`\n\n- 解题思路\n1. 先排序，\n2. 将数组从头开始扫描，如果偶数位置和偶数位置+1 的数字小于等于1"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n    进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n    >>> findMedianSortedArrays([1, 3], [2])\n    2.0\n    >>> findMedianSortedArrays([1, 2], [3, 4])\n    2.5\n    >>> findMedianSortedArrays([0, 0], [0, 0])\n    0.0\n    >>> findMedianSortedArray", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n    进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n    >>> findMedianSortedArrays([1, 3], [2])\n    2.0\n    >>> findMedianSortedArrays([1, 2], [3, 4])\n    2.5\n    >>> findMedianSortedArrays([0, 0], [0, 0])\n    0.0\n    >>> findMedianSortedArray"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    n = len(nums) // 2\n\n    ans = 0\n    for i in range(n):\n        ans += nums[i * 2] + nums", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    n = len(nums) // 2\n\n    ans = 0\n    for i in range(n):\n        ans += nums[i * 2] + nums"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    cnt = 0\n    for i in range(len(nums)):\n        if cnt == i:\n            break\n        cnt += (nums[i]+nums[~cnt])\n        if i!= ~cnt:\n            cnt += 1\n    return cnt\n\ndef peakIndexInMountainArray(nums):\n    '''\n    峰值元素是指其值大于左右相邻值的元素。\n    给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n    >>> peakIndexInMountainArray([2,1])\n    0\n    >>> peakIndexInMountainArray([3,2,1])\n    2\n    >>> peakIndexInMountainArray([1,2,3])\n    1\n    >>> peakIndexInMountainArray", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    cnt = 0\n    for i in range(len(nums)):\n        if cnt == i:\n            break\n        cnt += (nums[i]+nums[~cnt])\n        if i!= ~cnt:\n            cnt += 1\n    return cnt\n\ndef peakIndexInMountainArray(nums):\n    '''\n    峰值元素是指其值大于左右相邻值的元素。\n    给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n    >>> peakIndexInMountainArray([2,1])\n    0\n    >>> peakIndexInMountainArray([3,2,1])\n    2\n    >>> peakIndexInMountainArray([1,2,3])\n    1\n    >>> peakIndexInMountainArray"}
{"task_id": "leetcode/561", "completion": "\n    if len(nums) % 2!= 0:\n        nums.append(0)  # 这是为了使得长度为偶数，且最后一个元素值为 0 的情况\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\ndef twoSum(nums, target):\n    '''\n    给你一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，\n    并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，\n    数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    if len(nums) % 2!= 0:\n        nums.append(0)  # 这是为了使得长度为偶数，且最后一个元素值为 0 的情况\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\ndef twoSum(nums, target):\n    '''\n    给你一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，\n    并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，\n    数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    n = len(nums)\n    ans = n - 1\n    for i in range(n):\n        ans += nums[i]\n    return ans\n\ndef peakIndexInMountainArray(arr):\n    '''\n    在一个山脉数组中，\n    每个元素除了会超出左右相邻元素外，还会超出较靠近它的元素\n    在数组中找到比其靠近的元素大的那个元素\n    >>> peakIndexInMountainArray([0,1,0])\n    1\n    >>> peakIndexInMountainArray([0,2,1,0])\n    1\n    >>> peakIndexInMountainArray([0,10,5,2])\n    1\n    >>> peakIndexInMountainArray([3,4,5,1])\n    2\n    '''\n    i = 1\n    while i < len(arr):\n        if arr[i] > arr[i-1] and arr[i", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    n = len(nums)\n    ans = n - 1\n    for i in range(n):\n        ans += nums[i]\n    return ans\n\ndef peakIndexInMountainArray(arr):\n    '''\n    在一个山脉数组中，\n    每个元素除了会超出左右相邻元素外，还会超出较靠近它的元素\n    在数组中找到比其靠近的元素大的那个元素\n    >>> peakIndexInMountainArray([0,1,0])\n    1\n    >>> peakIndexInMountainArray([0,2,1,0])\n    1\n    >>> peakIndexInMountainArray([0,10,5,2])\n    1\n    >>> peakIndexInMountainArray([3,4,5,1])\n    2\n    '''\n    i = 1\n    while i < len(arr):\n        if arr[i] > arr[i-1] and arr[i"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    count = 0\n    for i in range(0,len(nums),2):\n        count += nums[i]\n    return count\n# 作者：kaituotian\n# 链接：https://leetcode-cn.com/problems/array-partition-i/solution/python3-san-chong-jie-jue-hua-yi-by-kaituotian/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\ndef lengthOfLastWord(s):\n    '''\n    给定一个字符串 s ，找到其中最后一个单词的长度。\n\n    单词 是指仅由字母组成、不包含任何空格字符的 最大子字符串。\n    ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    count = 0\n    for i in range(0,len(nums),2):\n        count += nums[i]\n    return count\n# 作者：kaituotian\n# 链接：https://leetcode-cn.com/problems/array-partition-i/solution/python3-san-chong-jie-jue-hua-yi-by-kaituotian/\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\ndef lengthOfLastWord(s):\n    '''\n    给定一个字符串 s ，找到其中最后一个单词的长度。\n\n    单词 是指仅由字母组成、不包含任何空格字符的 最大子字符串。\n    "}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    cur = 0\n    min_v = nums[0]\n    min_len = 1\n    for i, v in enumerate(nums):\n        cur += v\n        if cur >= target:\n            while cur >= target:\n                cur -= nums[cur_left]\n                cur_left += 1\n            min_v = cur\n            min_len = i - cur_left + 1\n        else:\n            if v < min_v:\n                min_v = v\n                min_len = i - cur_left + 1\n    return min_len\n\n    # ------------------------------------------\n    # 双指针\n    if not nums:\n        return 0\n    cur = 0\n    min_len = len(nums)\n    cur_left = 0\n    cur_right = 0\n    while cur_right < len(nums):\n        cur += nums[cur_right]\n        if cur >= target:\n            while cur >= target:\n                cur -= nums[cur", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    cur = 0\n    min_v = nums[0]\n    min_len = 1\n    for i, v in enumerate(nums):\n        cur += v\n        if cur >= target:\n            while cur >= target:\n                cur -= nums[cur_left]\n                cur_left += 1\n            min_v = cur\n            min_len = i - cur_left + 1\n        else:\n            if v < min_v:\n                min_v = v\n                min_len = i - cur_left + 1\n    return min_len\n\n    # ------------------------------------------\n    # 双指针\n    if not nums:\n        return 0\n    cur = 0\n    min_len = len(nums)\n    cur_left = 0\n    cur_right = 0\n    while cur_right < len(nums):\n        cur += nums[cur_right]\n        if cur >= target:\n            while cur >= target:\n                cur -= nums[cur"}
{"task_id": "leetcode/209", "completion": "\n    # 1.动态规划\n    # 时间复杂度O\n    # 1.假设我们已经计算了i-1的元素，我们不难得到i的结果，i.e.nums[i]是否大于等于target，所以我们可以用一个变量sum记录nums[0...i-1]之和，那么nums[i]是否大于等于target，\n    # 就看sum+nums[i]是否大于等于target。\n    # 2.sum可能会超过int的范围，所以我们用long来存储sum。\n    # 3.如果sum大于等于target，那么nums[j]是否大于等于target，就看sum-nums[j-1]是否大于等于target。\n    # 4.如果sum<target,那么可以继续添加nums[i]，�", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 1.动态规划\n    # 时间复杂度O\n    # 1.假设我们已经计算了i-1的元素，我们不难得到i的结果，i.e.nums[i]是否大于等于target，所以我们可以用一个变量sum记录nums[0...i-1]之和，那么nums[i]是否大于等于target，\n    # 就看sum+nums[i]是否大于等于target。\n    # 2.sum可能会超过int的范围，所以我们用long来存储sum。\n    # 3.如果sum大于等于target，那么nums[j]是否大于等于target，就看sum-nums[j-1]是否大于等于target。\n    # 4.如果sum<target,那么可以继续添加nums[i]，�"}
{"task_id": "leetcode/209", "completion": "\n    s = sum(nums[:0])\n    l,r = 0,0\n    res = len(nums)\n    while r < len(nums):\n        s += nums[r] - nums[l]\n        if s >= target:\n            res = min(res, r-l+1)\n        while s>=target:\n            s -= nums[l]\n            l += 1\n    return res\n    # 暴力法\n    # for i in range(len(nums)):\n    #     for j in range(i,len(nums)):\n    #         if sum(nums[i:j+1]) >= target:\n    #             res = min(res, j-i+1)\n    # return res\n'''\nhttps://leetcode-cn.com/problems/contains-duplicate/\n'''\ndef containsDuplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任意一值在另一个值的��", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    s = sum(nums[:0])\n    l,r = 0,0\n    res = len(nums)\n    while r < len(nums):\n        s += nums[r] - nums[l]\n        if s >= target:\n            res = min(res, r-l+1)\n        while s>=target:\n            s -= nums[l]\n            l += 1\n    return res\n    # 暴力法\n    # for i in range(len(nums)):\n    #     for j in range(i,len(nums)):\n    #         if sum(nums[i:j+1]) >= target:\n    #             res = min(res, j-i+1)\n    # return res\n'''\nhttps://leetcode-cn.com/problems/contains-duplicate/\n'''\ndef containsDuplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任意一值在另一个值的��"}
{"task_id": "leetcode/209", "completion": "\n    res = len(nums) + 1\n    sum = 0\n    l,r = 0, 0\n    while r < len(nums):\n        sum += nums[r]\n        r += 1\n        while sum >= target:\n            res = min(res, r - l)\n            sum -= nums[l]\n            l += 1\n    return 0 if res == len(nums) + 1 else res\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n   给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n    请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    示例 1：\n    输入：num", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    res = len(nums) + 1\n    sum = 0\n    l,r = 0, 0\n    while r < len(nums):\n        sum += nums[r]\n        r += 1\n        while sum >= target:\n            res = min(res, r - l)\n            sum -= nums[l]\n            l += 1\n    return 0 if res == len(nums) + 1 else res\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n   给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n    请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    示例 1：\n    输入：num"}
{"task_id": "leetcode/209", "completion": "\n    n = len(nums)\n    ans = len(nums) + 1\n    start = 0\n    sum = 0\n    while start < n:\n        while start < n and sum < target:\n            sum += nums[start]\n            start += 1\n        end = start -1\n        while end < n and sum - nums[end] >= target:\n            sum -= nums[end]\n            end += 1\n        if sum >= target:\n            ans = min(ans, end - start + 1)\n            start += 1\n            sum -= nums[start - 1]\n    return ans if ans <= n else 0\n\n\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        给定一个字符串 s 和一些长度相同的单词 words。\n        找出 s 中恰好可以由 words 中所有单词组成的子串的起始位置。\n        :param s:\n        :param", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    ans = len(nums) + 1\n    start = 0\n    sum = 0\n    while start < n:\n        while start < n and sum < target:\n            sum += nums[start]\n            start += 1\n        end = start -1\n        while end < n and sum - nums[end] >= target:\n            sum -= nums[end]\n            end += 1\n        if sum >= target:\n            ans = min(ans, end - start + 1)\n            start += 1\n            sum -= nums[start - 1]\n    return ans if ans <= n else 0\n\n\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        给定一个字符串 s 和一些长度相同的单词 words。\n        找出 s 中恰好可以由 words 中所有单词组成的子串的起始位置。\n        :param s:\n        :param"}
{"task_id": "leetcode/209", "completion": "\n    count, l, r, sum_ = 0, 0, 0, float('-inf')\n    d = dict()\n    for i, num in enumerate(nums):\n        if num > target:\n            count = i + 1\n            sum_ = num\n            return count\n        if num + d.get(target-num, 0) >= target:\n            count = i - d[target-num] + 1\n            sum_ = num\n            return count\n        d[num] = i\n    return count\n\n\ndef maxArea(height):\n    '''\n   给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。\n    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。\n    找出其中的两条线，使得它们与 x �", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    count, l, r, sum_ = 0, 0, 0, float('-inf')\n    d = dict()\n    for i, num in enumerate(nums):\n        if num > target:\n            count = i + 1\n            sum_ = num\n            return count\n        if num + d.get(target-num, 0) >= target:\n            count = i - d[target-num] + 1\n            sum_ = num\n            return count\n        d[num] = i\n    return count\n\n\ndef maxArea(height):\n    '''\n   给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。\n    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。\n    找出其中的两条线，使得它们与 x �"}
{"task_id": "leetcode/209", "completion": "\n    # 这里必须加上这个判断，否则如果 nums 为空列表（其实也可以是单个元素），会报错\n    if len(nums) == 0:\n        return 0\n    i = 0\n    j = 0\n    count = 0\n    sum = 0\n    while i<len(nums) and j<len(nums):\n        if sum < target:\n            sum += nums[j]\n            j += 1\n        else:\n            count = max(count, j - i)\n            sum -= nums[i]\n            i += 1\n    count = max(count, j - i)\n    return count\n\n\ndef maxSubArray(nums):\n    '''\n    https://leetcode-cn.com/problems/maximum-subarray/\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 这里必须加上这个判断，否则如果 nums 为空列表（其实也可以是单个元素），会报错\n    if len(nums) == 0:\n        return 0\n    i = 0\n    j = 0\n    count = 0\n    sum = 0\n    while i<len(nums) and j<len(nums):\n        if sum < target:\n            sum += nums[j]\n            j += 1\n        else:\n            count = max(count, j - i)\n            sum -= nums[i]\n            i += 1\n    count = max(count, j - i)\n    return count\n\n\ndef maxSubArray(nums):\n    '''\n    https://leetcode-cn.com/problems/maximum-subarray/\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含"}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    start: int = 0\n    end: int = 0\n    length: int = 0\n    total: int = 0\n\n    for end in range(len(nums)):\n        total += nums[end]\n        length += 1\n        while total >= target:\n            length -= 1\n            total -= nums[start]\n            start += 1\n\n        if length == 0:\n            return 0\n\n    return length\n\n\nif __name__ == '__main", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    start: int = 0\n    end: int = 0\n    length: int = 0\n    total: int = 0\n\n    for end in range(len(nums)):\n        total += nums[end]\n        length += 1\n        while total >= target:\n            length -= 1\n            total -= nums[start]\n            start += 1\n\n        if length == 0:\n            return 0\n\n    return length\n\n\nif __name__ == '__main"}
{"task_id": "leetcode/209", "completion": "\n    '''\n    思路：滑动窗口算法\n    '''\n    i, j = 0, 0\n    minLen = float('inf')\n    n = len(nums)\n    while j < n:\n        s = sum(nums[i:j+1])\n        if s >= target:\n            minLen = min(minLen, j-i+1)\n        while s<target and j<n-1:\n            j += 1\n            s += nums[j]\n        i += 1\n    return minLen if minLen < float('inf') else 0\n    \ndef minSubArrayLen2(target, nums):\n    '''\n    >>> minSubArrayLen2(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen2(4, [1,4,4])\n    1\n    >>> minSubArrayLen2(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    '''\n    思路：��", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    '''\n    思路：滑动窗口算法\n    '''\n    i, j = 0, 0\n    minLen = float('inf')\n    n = len(nums)\n    while j < n:\n        s = sum(nums[i:j+1])\n        if s >= target:\n            minLen = min(minLen, j-i+1)\n        while s<target and j<n-1:\n            j += 1\n            s += nums[j]\n        i += 1\n    return minLen if minLen < float('inf') else 0\n    \ndef minSubArrayLen2(target, nums):\n    '''\n    >>> minSubArrayLen2(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen2(4, [1,4,4])\n    1\n    >>> minSubArrayLen2(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    '''\n    思路：��"}
{"task_id": "leetcode/209", "completion": "\n    n = len(nums)\n    if n == 0:\n        return 0\n    left, right = 0, 0\n    ans = n + 1\n    total = 0\n    while right < n:\n        total += nums[right]\n        while total >= target:\n            ans = min(ans, right - left + 1)\n            total -= nums[left]\n            left += 1\n        right += 1\n    return ans if ans < n + 1 else 0\n\n\ndef maxProdSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找出数组中最长且 连续的负数序列的乘积，并返回该最长且 连续的负数序列的长度。如果不存在符合要求的序列，返回 0 。\n    >>> maxProdSubArray([-2, 3, -4, 5, -4, 3, -", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    if n == 0:\n        return 0\n    left, right = 0, 0\n    ans = n + 1\n    total = 0\n    while right < n:\n        total += nums[right]\n        while total >= target:\n            ans = min(ans, right - left + 1)\n            total -= nums[left]\n            left += 1\n        right += 1\n    return ans if ans < n + 1 else 0\n\n\ndef maxProdSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找出数组中最长且 连续的负数序列的乘积，并返回该最长且 连续的负数序列的长度。如果不存在符合要求的序列，返回 0 。\n    >>> maxProdSubArray([-2, 3, -4, 5, -4, 3, -"}
{"task_id": "leetcode/1", "completion": "\n    result = []\n    for i, num in enumerate(nums):\n        need = target - num\n        if num in dict:\n            result.append(dict[num])\n            result.append(i)\n            return result\n        else:\n            dict[need] = i\n\n\n'''\n给你两个字符串 s 和 t ，且 s 的长度大于或等于 t 的长度。\n请你在字符串 s 中找出字符串 t 的第一个出现的位置（下标从 0 开始）。如果不存在，则返回 -1 。\n'''\n\n\ndef strStr(haystack, needle):\n    result = -1\n    for i in range(len(haystack)):\n        if haystack[i: i + len(needle)] == needle:\n            result = i\n            break\n    return result\n\n\n'''\n给定一个只包括 '(' ，')' ，'{'，'}'，'['，']' 的字", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    result = []\n    for i, num in enumerate(nums):\n        need = target - num\n        if num in dict:\n            result.append(dict[num])\n            result.append(i)\n            return result\n        else:\n            dict[need] = i\n\n\n'''\n给你两个字符串 s 和 t ，且 s 的长度大于或等于 t 的长度。\n请你在字符串 s 中找出字符串 t 的第一个出现的位置（下标从 0 开始）。如果不存在，则返回 -1 。\n'''\n\n\ndef strStr(haystack, needle):\n    result = -1\n    for i in range(len(haystack)):\n        if haystack[i: i + len(needle)] == needle:\n            result = i\n            break\n    return result\n\n\n'''\n给定一个只包括 '(' ，')' ，'{'，'}'，'['，']' 的字"}
{"task_id": "leetcode/1", "completion": "\n    nums_dict = dict()\n    for i in range(len(nums)):\n        if target - nums[i] in nums_dict:\n            return nums_dict[target - nums[i]], i\n        nums_dict[nums[i]] = i\n\n\ndef twoSum_hash(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    hash 哈希表\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> two", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    nums_dict = dict()\n    for i in range(len(nums)):\n        if target - nums[i] in nums_dict:\n            return nums_dict[target - nums[i]], i\n        nums_dict[nums[i]] = i\n\n\ndef twoSum_hash(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    hash 哈希表\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> two"}
{"task_id": "leetcode/1", "completion": "\n    res = []\n    for i, v in enumerate(nums):\n        if 0 < target - v < nums[i]:\n            continue\n        res.append(i)\n        if sum(nums[res[0]:res[-1]+1]) == target:\n            return res\n\n\ndef threeSum(nums: List[int]) -> List[List[int]]:\n    '''\n    给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1,0,1,2,-1,-4])\n    [[-1, 0, 1], [-1, -1, 2]]\n    '''\n    res = []\n    nums_set = set", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    res = []\n    for i, v in enumerate(nums):\n        if 0 < target - v < nums[i]:\n            continue\n        res.append(i)\n        if sum(nums[res[0]:res[-1]+1]) == target:\n            return res\n\n\ndef threeSum(nums: List[int]) -> List[List[int]]:\n    '''\n    给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1,0,1,2,-1,-4])\n    [[-1, 0, 1], [-1, -1, 2]]\n    '''\n    res = []\n    nums_set = set"}
{"task_id": "leetcode/1", "completion": "\n    res = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i]+nums[j] == target:\n                res.append(i)\n                res.append(j)\n                return res\n                break\n\n    return res\n\nif __name__ == '__main__':\n    print(twoSum([3,2,4], 6))\n    print(twoSum([3,3], 6))\n    print(twoSum([2,7,11,15], 9))\n    print(twoSum([2,7,11,15], 11))\n    print(twoSum([2,7,11,15], 12))\n    print(twoSum([1,2,3,4,5], 7))\n    print(twoSum([1,2,3,4,5], 6))\n    print(twoSum([2,7,11,15], 15))\n    print(twoSum([2,7,11", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    res = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i]+nums[j] == target:\n                res.append(i)\n                res.append(j)\n                return res\n                break\n\n    return res\n\nif __name__ == '__main__':\n    print(twoSum([3,2,4], 6))\n    print(twoSum([3,3], 6))\n    print(twoSum([2,7,11,15], 9))\n    print(twoSum([2,7,11,15], 11))\n    print(twoSum([2,7,11,15], 12))\n    print(twoSum([1,2,3,4,5], 7))\n    print(twoSum([1,2,3,4,5], 6))\n    print(twoSum([2,7,11,15], 15))\n    print(twoSum([2,7,11"}
{"task_id": "leetcode/1", "completion": "\n    # 用于保存nums和序号\n    dic = {}\n    for i in range(len(nums)):\n        num = target - nums[i]\n        if num in dic:\n            return [dic[num], i]\n        else:\n            dic[nums[i]] = i\n    raise Exception('No Two Sum Solution')\n\n\ndef twoSum1(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([2, 7, 11, 15], 9", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 用于保存nums和序号\n    dic = {}\n    for i in range(len(nums)):\n        num = target - nums[i]\n        if num in dic:\n            return [dic[num], i]\n        else:\n            dic[nums[i]] = i\n    raise Exception('No Two Sum Solution')\n\n\ndef twoSum1(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([2, 7, 11, 15], 9"}
{"task_id": "leetcode/1", "completion": "\n    d = {}\n    for ind, num in enumerate(nums):\n        if d.get(target - num, None):\n            return [d.get(target - num), ind]\n        d[num] = ind\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n    >>> lengthOfLongestSubstring(\"abcabcbb\")\n    3\n    >>> lengthOfLongestSubstring(\"bbbbb\")\n    1\n    >>> lengthOfLongestSubstring(\"pwwkew\")\n    3\n    >>> lengthOfLongestSubstring(\"\")\n    0\n    '''\n    if not s:\n        return 0\n    d = {}\n    left = 0\n    res = 1\n    for i, letter in enumerate(s):\n        if letter in d:\n            left = max(d[letter] + 1, left)\n        d[letter] = i\n        res = max(res, i -", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    d = {}\n    for ind, num in enumerate(nums):\n        if d.get(target - num, None):\n            return [d.get(target - num), ind]\n        d[num] = ind\n\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n    >>> lengthOfLongestSubstring(\"abcabcbb\")\n    3\n    >>> lengthOfLongestSubstring(\"bbbbb\")\n    1\n    >>> lengthOfLongestSubstring(\"pwwkew\")\n    3\n    >>> lengthOfLongestSubstring(\"\")\n    0\n    '''\n    if not s:\n        return 0\n    d = {}\n    left = 0\n    res = 1\n    for i, letter in enumerate(s):\n        if letter in d:\n            left = max(d[letter] + 1, left)\n        d[letter] = i\n        res = max(res, i -"}
{"task_id": "leetcode/1", "completion": "\n    # 解法1：遍历所有对\n    dict1 = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in dict1:\n            return [dict1[complement], i]\n        else:\n            dict1[nums[i]] = i\n\n    # 解法2：对数组排序，不断移动指针（超时）\n    # nums.sort()\n    # i, j = 0, len(nums) - 1\n    # while i < j:\n    #     if nums[i] + nums[j] == target:\n    #         return [i, j]\n    #     elif nums[i] + nums[j] > target:\n    #         j -= 1\n    #     else:\n    #         i += 1\n\n    # 解法3：两次遍历，利用双指针（超时）\n    # nums.sort()\n    # i, j = ", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 解法1：遍历所有对\n    dict1 = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in dict1:\n            return [dict1[complement], i]\n        else:\n            dict1[nums[i]] = i\n\n    # 解法2：对数组排序，不断移动指针（超时）\n    # nums.sort()\n    # i, j = 0, len(nums) - 1\n    # while i < j:\n    #     if nums[i] + nums[j] == target:\n    #         return [i, j]\n    #     elif nums[i] + nums[j] > target:\n    #         j -= 1\n    #     else:\n    #         i += 1\n\n    # 解法3：两次遍历，利用双指针（超时）\n    # nums.sort()\n    # i, j = "}
{"task_id": "leetcode/1", "completion": "\n    d = {}\n    for i, item in enumerate(nums):\n        if target - item in d:\n            return [d[target - item], i]\n        d[item] = i\n\n\nif __name__ == '__main__':\n    assert twoSum([3, 2, 4], 6) == [1, 2]\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    d = {}\n    for i, item in enumerate(nums):\n        if target - item in d:\n            return [d[target - item], i]\n        d[item] = i\n\n\nif __name__ == '__main__':\n    assert twoSum([3, 2, 4], 6) == [1, 2]\n"}
{"task_id": "leetcode/1", "completion": "\n    # 待补充\n    pass\n\n\nif __name__ == '__main__':\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, 3], 6))\n    print(twoSum([1, 2, 3, 4, 5, 6, 7, 8], 8))\n    print(twoSum([2, 2, 2, 2], 4))\n    print(twoSum([3, 3], 6))\n    print(twoSum([3, 5, 2, 3], 6))\n    print(threeSum([-3, 0, 1, 2, -2, 5, 6, 7, -5], 0))\n    print(threeSum([5, 2, 7], 15))\n    print(fourSum([-1, 0, 7, 5], 9))\n    print(fourSum([-1, 0, 1, 2, -3], 0))\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 待补充\n    pass\n\n\nif __name__ == '__main__':\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, 3], 6))\n    print(twoSum([1, 2, 3, 4, 5, 6, 7, 8], 8))\n    print(twoSum([2, 2, 2, 2], 4))\n    print(twoSum([3, 3], 6))\n    print(twoSum([3, 5, 2, 3], 6))\n    print(threeSum([-3, 0, 1, 2, -2, 5, 6, 7, -5], 0))\n    print(threeSum([5, 2, 7], 15))\n    print(fourSum([-1, 0, 7, 5], 9))\n    print(fourSum([-1, 0, 1, 2, -3], 0))\n"}
{"task_id": "leetcode/1", "completion": "\n    length = len(nums)\n    for i in range(length-1):\n        for j in range(i+1, length):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> threeSum([0, 0, 0])\n    [[0, 0, 0]]\n    >>> threeSum([1, 0", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    length = len(nums)\n    for i in range(length-1):\n        for j in range(i+1, length):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n    注意：答案中不可以包含重复的三元组。\n    >>> threeSum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> threeSum([0, 0, 0])\n    [[0, 0, 0]]\n    >>> threeSum([1, 0"}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    counter = dict()\n    for ch in s:\n        counter[ch] = counter.get(ch, 0) + 1\n    # 窗口从最内往外双指针逼近，每次计算窗口内的回文串\n    lo, hi = 0, 0\n    max_len = 0\n    for ch, freq in counter.items():\n        left, right = lo, hi\n        # 窗口缩小，有一个字符缩小\n        # 窗口缩小到剩下一个字符时，直接结束\n        if freq == 1:\n            lo += 1\n            max_len = max(max_len, hi - lo + 1)\n            hi += 1\n            continue\n        # 窗口缩小，有多个字符缩小\n        # 窗口缩小到剩下一个", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    counter = dict()\n    for ch in s:\n        counter[ch] = counter.get(ch, 0) + 1\n    # 窗口从最内往外双指针逼近，每次计算窗口内的回文串\n    lo, hi = 0, 0\n    max_len = 0\n    for ch, freq in counter.items():\n        left, right = lo, hi\n        # 窗口缩小，有一个字符缩小\n        # 窗口缩小到剩下一个字符时，直接结束\n        if freq == 1:\n            lo += 1\n            max_len = max(max_len, hi - lo + 1)\n            hi += 1\n            continue\n        # 窗口缩小，有多个字符缩小\n        # 窗口缩小到剩下一个"}
{"task_id": "leetcode/409", "completion": "\n    dp = [0] * len(s)\n    ans = 0\n\n    for i in range(len(s)):\n        dp[i] = 1\n        left = i - 1\n        right = i + 1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            dp[right] = dp[left] + 2\n            ans = max(ans, dp[right])\n            left -= 1\n            right += 1\n\n    return ans\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 先把每一个字符扩散为回文子", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    dp = [0] * len(s)\n    ans = 0\n\n    for i in range(len(s)):\n        dp[i] = 1\n        left = i - 1\n        right = i + 1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            dp[right] = dp[left] + 2\n            ans = max(ans, dp[right])\n            left -= 1\n            right += 1\n\n    return ans\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 先把每一个字符扩散为回文子"}
{"task_id": "leetcode/409", "completion": "\n    dp = [0] * len(s)\n    res = 0\n    for i in range(len(s)):\n        # 回文串的中心点\n        for j in range(i, len(s)):\n            if s[i] == s[j] and (j - i <= 2 or dp[i + 1] <= j - i - 2):\n                # 回文子串的两端点\n                dp[i] = j - i + 1\n            if j - i + 1 > res", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    dp = [0] * len(s)\n    res = 0\n    for i in range(len(s)):\n        # 回文串的中心点\n        for j in range(i, len(s)):\n            if s[i] == s[j] and (j - i <= 2 or dp[i + 1] <= j - i - 2):\n                # 回文子串的两端点\n                dp[i] = j - i + 1\n            if j - i + 1 > res"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [[False for j in range(n)] for i in range(n)]\n    ret = 1\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][i+1] = True\n            ret = 2\n    for j in range(2, n):\n        for i in range(n-j):\n            if s[i] == s[i+j] and dp[i+1][i+j-1]:\n                dp[i][i+j] = True\n                ret = j + 1\n    return ret\n```\n\n## 最长回文子串\n\n### 暴力法\n\n```python\ndef longestPalindrome(s):\n    '''\n    给你一个字符串 s，找到 s 中", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [[False for j in range(n)] for i in range(n)]\n    ret = 1\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][i+1] = True\n            ret = 2\n    for j in range(2, n):\n        for i in range(n-j):\n            if s[i] == s[i+j] and dp[i+1][i+j-1]:\n                dp[i][i+j] = True\n                ret = j + 1\n    return ret\n```\n\n## 最长回文子串\n\n### 暴力法\n\n```python\ndef longestPalindrome(s):\n    '''\n    给你一个字符串 s，找到 s 中"}
{"task_id": "leetcode/409", "completion": "\n    dp = [1 for _ in range(len(s))]\n    for i in range(len(s) - 1, 0, -1):\n        for j in range(i):\n            if s[i] == s[j]:\n                if i - j < 2:\n                    dp[j] = 2\n                else:\n                    dp[j] = dp[i - 1] + (i - j - 1)\n    return max(dp)\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 动态规划\n    cache = []\n    for i in range(2 ** len(s)):\n        cache.", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    dp = [1 for _ in range(len(s))]\n    for i in range(len(s) - 1, 0, -1):\n        for j in range(i):\n            if s[i] == s[j]:\n                if i - j < 2:\n                    dp[j] = 2\n                else:\n                    dp[j] = dp[i - 1] + (i - j - 1)\n    return max(dp)\n\n\ndef longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 动态规划\n    cache = []\n    for i in range(2 ** len(s)):\n        cache."}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n <= 1:\n        return n\n    dp = [[False for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    max_len = 1 # 回文串的长度\n    begin = 0 # 回文串开始位置\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j] and (j-i <= 2 or dp[i+1][j-1]):\n                dp[i][j] = True\n                if j-i+1 > max_len:\n                    max_len = j-i+1\n                    begin = i\n    return max_len\n\ndef longestPalindrome2(s):\n    '''\n    给你一个 仅由大写字母组成的 字符串 s ，返回 在 此字符串中 最长的回文子序列的长度", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n <= 1:\n        return n\n    dp = [[False for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    max_len = 1 # 回文串的长度\n    begin = 0 # 回文串开始位置\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j] and (j-i <= 2 or dp[i+1][j-1]):\n                dp[i][j] = True\n                if j-i+1 > max_len:\n                    max_len = j-i+1\n                    begin = i\n    return max_len\n\ndef longestPalindrome2(s):\n    '''\n    给你一个 仅由大写字母组成的 字符串 s ，返回 在 此字符串中 最长的回文子序列的长度"}
{"task_id": "leetcode/409", "completion": "\n    length = len(s)\n    if length < 2:\n        return length\n    dp = [[False for _ in range(length)] for _ in range(length)]\n    max_length = 1\n    # 找到最长的回文串\n    max_start = 0\n    for i in range(length):\n        dp[i][i] = True\n        for j in range(i, length):\n            if j == i + 1:\n                dp[i][j] = s[i] == s[j]\n            else:\n                dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]\n            if dp[i][j] and j - i + 1 > max_length:\n                max_length = j - i + 1\n                max_start = i\n    # 找到最长的回文子串\n    sub_start = 0\n    j = max_start\n    for i in range(max_start + 1, length):\n", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    length = len(s)\n    if length < 2:\n        return length\n    dp = [[False for _ in range(length)] for _ in range(length)]\n    max_length = 1\n    # 找到最长的回文串\n    max_start = 0\n    for i in range(length):\n        dp[i][i] = True\n        for j in range(i, length):\n            if j == i + 1:\n                dp[i][j] = s[i] == s[j]\n            else:\n                dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]\n            if dp[i][j] and j - i + 1 > max_length:\n                max_length = j - i + 1\n                max_start = i\n    # 找到最长的回文子串\n    sub_start = 0\n    j = max_start\n    for i in range(max_start + 1, length):\n"}
{"task_id": "leetcode/409", "completion": "\n    l = len(s)\n    if l == 1:\n        return 1\n    dp = [[False] * l for _ in range(l)]\n    max_palindrome = 1  # 记录最长回文串的长度\n    for i in range(l):\n        j = i  # 在s中的下标\n        k = i  # 在s中的下标\n\n        # 先判断是否是回文串，如果是就用这个i,j\n        while j >= 0 and k < l and s[j] == s[k]:\n            dp[j][k] = True\n            j -= 1\n            k += 1\n    for i in range(1, l):\n        for j in range(i+1):\n            if dp[j][i] and i - j + 1 > max_palindrome:\n                max_palindrome = i - j + 1\n    return max_palindrome\n\n\ndef main():\n    s = \"abccccdd\"\n\n    # print", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    l = len(s)\n    if l == 1:\n        return 1\n    dp = [[False] * l for _ in range(l)]\n    max_palindrome = 1  # 记录最长回文串的长度\n    for i in range(l):\n        j = i  # 在s中的下标\n        k = i  # 在s中的下标\n\n        # 先判断是否是回文串，如果是就用这个i,j\n        while j >= 0 and k < l and s[j] == s[k]:\n            dp[j][k] = True\n            j -= 1\n            k += 1\n    for i in range(1, l):\n        for j in range(i+1):\n            if dp[j][i] and i - j + 1 > max_palindrome:\n                max_palindrome = i - j + 1\n    return max_palindrome\n\n\ndef main():\n    s = \"abccccdd\"\n\n    # print"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n < 2:\n        return n\n\n    ans = 1\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if s[i] == s[j]:\n                if i - j < 3:\n                    dp[j][i] = True\n                else:\n                    dp[j][i] = dp[j+1][i-1]\n            if dp[j][i]:\n                ans = max(ans, i-j+1)\n    return ans\n\n\ns = \"a\"\nprint(longestPalindrome(s))\n\n\ndef longestPalindromeSubstring(s):\n    '''\n    :type s: str\n    :rtype: str\n    给定一个字符串 s，找到 s 中最长的回文子串。你", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n < 2:\n        return n\n\n    ans = 1\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if s[i] == s[j]:\n                if i - j < 3:\n                    dp[j][i] = True\n                else:\n                    dp[j][i] = dp[j+1][i-1]\n            if dp[j][i]:\n                ans = max(ans, i-j+1)\n    return ans\n\n\ns = \"a\"\nprint(longestPalindrome(s))\n\n\ndef longestPalindromeSubstring(s):\n    '''\n    :type s: str\n    :rtype: str\n    给定一个字符串 s，找到 s 中最长的回文子串。你"}
{"task_id": "leetcode/409", "completion": "\n    # 枚举所有切分点，但是效率不高\n    n = len(s)\n    if n <= 1:\n        return n\n    # 定义dp表，dp[i][j]代表从 i 到 j 的最长回文子串长度\n    dp = []\n    for i in range(n):\n        dp.append([False] * n)\n    for i in range(n):\n        dp[i][i] = True  # 字符串长度为1\n        for j in range(i):\n            # 判断回文条件\n            if s[i] == s[j] and (i - j < 2 or dp[j + 1][i - 1]):\n                dp[j][i] = True\n    # 求最长的截取\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[i][j]:\n                max", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 枚举所有切分点，但是效率不高\n    n = len(s)\n    if n <= 1:\n        return n\n    # 定义dp表，dp[i][j]代表从 i 到 j 的最长回文子串长度\n    dp = []\n    for i in range(n):\n        dp.append([False] * n)\n    for i in range(n):\n        dp[i][i] = True  # 字符串长度为1\n        for j in range(i):\n            # 判断回文条件\n            if s[i] == s[j] and (i - j < 2 or dp[j + 1][i - 1]):\n                dp[j][i] = True\n    # 求最长的截取\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[i][j]:\n                max"}
{"task_id": "leetcode/121", "completion": "\n    lense = len(prices)\n    if lense == 1:\n        return 0\n    pre = 0\n    maxProfit = 0\n    for i in range(1,lense):\n        pre = prices[i - 1]\n        cur = prices[i]\n        if cur > pre:\n            maxProfit += cur - pre\n        else:\n            pre = cur\n    return maxProfit\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这�", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    lense = len(prices)\n    if lense == 1:\n        return 0\n    pre = 0\n    maxProfit = 0\n    for i in range(1,lense):\n        pre = prices[i - 1]\n        cur = prices[i]\n        if cur > pre:\n            maxProfit += cur - pre\n        else:\n            pre = cur\n    return maxProfit\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这�"}
{"task_id": "leetcode/121", "completion": "\n    profit = 0\n    if len(prices) == 1:\n        return 0\n    low = prices[0]\n    for i in prices[1:]:\n        profit += max(0, i - low)\n        low = min(low, i)\n    return profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    profit = 0\n    if len(prices) == 1:\n        return 0\n    low = prices[0]\n    for i in prices[1:]:\n        profit += max(0, i - low)\n        low = min(low, i)\n    return profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返"}
{"task_id": "leetcode/121", "completion": "\n    min_price = prices[0]\n    max_price = 0\n    for price in prices[1:]:\n        min_price = min(price, min_price)\n        max_price = max(price - min_price, max_price)\n    return max_price\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    给定一个整数数组 cost ，其中 cost[i] 是飞机从一个城市降落的售价。\n    每次飞行只能降落在已经降落过的城市，或者可以先飞往一个城市再飞另一个城市。\n    请找出一条成本最低的路径，使飞机最终降落在城市 cost.length - 1 。\n    返回该成本最低路径的成本。\n    >>> min", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    min_price = prices[0]\n    max_price = 0\n    for price in prices[1:]:\n        min_price = min(price, min_price)\n        max_price = max(price - min_price, max_price)\n    return max_price\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    给定一个整数数组 cost ，其中 cost[i] 是飞机从一个城市降落的售价。\n    每次飞行只能降落在已经降落过的城市，或者可以先飞往一个城市再飞另一个城市。\n    请找出一条成本最低的路径，使飞机最终降落在城市 cost.length - 1 。\n    返回该成本最低路径的成本。\n    >>> min"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) <= 1:\n        return 0\n    min_price = prices[0]\n    res = 0\n    for i in range(1, len(prices)):\n        res = max(prices[i] - min_price, res)\n        min_price = min(min_price, prices[i])\n    return res\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n    设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n    示例", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) <= 1:\n        return 0\n    min_price = prices[0]\n    res = 0\n    for i in range(1, len(prices)):\n        res = max(prices[i] - min_price, res)\n        min_price = min(min_price, prices[i])\n    return res\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n    设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n    示例"}
{"task_id": "leetcode/121", "completion": "\n    count, res = 0, 0\n    price_min = prices[0]\n    price_max = prices[0]\n    for i in range(1, len(prices)):\n        if prices[i] < price_min:\n            price_min = prices[i]\n        if prices[i] - price_min > count:\n            count = prices[i] - price_min\n        if prices[i] >= price_max:\n            price_max = prices[i]\n    return count\n\n\n# 62. 不同路径\ndef uniquePaths(m, n):\n    '''\n    一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n    问总共有多少条不同的路径？\n   ", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    count, res = 0, 0\n    price_min = prices[0]\n    price_max = prices[0]\n    for i in range(1, len(prices)):\n        if prices[i] < price_min:\n            price_min = prices[i]\n        if prices[i] - price_min > count:\n            count = prices[i] - price_min\n        if prices[i] >= price_max:\n            price_max = prices[i]\n    return count\n\n\n# 62. 不同路径\ndef uniquePaths(m, n):\n    '''\n    一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n    问总共有多少条不同的路径？\n   "}
{"task_id": "leetcode/121", "completion": "\n    n = len(prices)\n    if n < 2:\n        return 0\n    res = 0\n    min_price = prices[0]\n    for i in range(1, n):\n        new_min = min(min_price, prices[i])\n        res = max(res, prices[i] - new_min)\n        min_price = new_min\n\n    return res\n\n\ndef maxProfit_(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交�", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    n = len(prices)\n    if n < 2:\n        return 0\n    res = 0\n    min_price = prices[0]\n    for i in range(1, n):\n        new_min = min(min_price, prices[i])\n        res = max(res, prices[i] - new_min)\n        min_price = new_min\n\n    return res\n\n\ndef maxProfit_(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交�"}
{"task_id": "leetcode/121", "completion": "\n    minPrice = prices[0]\n    maxPrice = prices[-1]\n    if len(prices) < 2:\n        return 0\n    profit = maxPrice - minPrice\n    # 找出最高价\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            maxPrice = prices[i]\n        else:\n            continue\n    # 找出最低价\n    for i in range(len(prices) - 2, -1, -1):\n        if prices[i] > prices[i + 1]:\n            minPrice = prices[i]\n    if maxPrice - minPrice > 0:\n        return maxPrice - minPrice\n    else:\n        return 0\n\n\ndef maxProfit(prices, k):\n    '''\n    给定一个整数数组 nums ，设计一个算法来计算你所能获取的最大利润。你可以尽可能地完", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    minPrice = prices[0]\n    maxPrice = prices[-1]\n    if len(prices) < 2:\n        return 0\n    profit = maxPrice - minPrice\n    # 找出最高价\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            maxPrice = prices[i]\n        else:\n            continue\n    # 找出最低价\n    for i in range(len(prices) - 2, -1, -1):\n        if prices[i] > prices[i + 1]:\n            minPrice = prices[i]\n    if maxPrice - minPrice > 0:\n        return maxPrice - minPrice\n    else:\n        return 0\n\n\ndef maxProfit(prices, k):\n    '''\n    给定一个整数数组 nums ，设计一个算法来计算你所能获取的最大利润。你可以尽可能地完"}
{"task_id": "leetcode/121", "completion": "\n    n = len(prices)\n    res = 0\n    for i in range(1, n):\n        res += max(0, prices[i] - prices[i - 1])\n    return res\n\n\ndef maxProfitV2(prices):\n    '''\n    暴力解法:\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    ", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    n = len(prices)\n    res = 0\n    for i in range(1, n):\n        res += max(0, prices[i] - prices[i - 1])\n    return res\n\n\ndef maxProfitV2(prices):\n    '''\n    暴力解法:\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    "}
{"task_id": "leetcode/121", "completion": "\n    # 状态定义\n    n = len(prices)\n    # 初始化状态\n    dp = [0] * (n + 1)\n    # 动态规划\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i-1], prices[i-1] - min(prices[0:i]))\n    return dp[n]\n\n\ndef maxProfit_2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 状态定义\n    n = len(prices)\n    # 初始化状态\n    dp = [0] * (n + 1)\n    # 动态规划\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i-1], prices[i-1] - min(prices[0:i]))\n    return dp[n]\n\n\ndef maxProfit_2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n"}
{"task_id": "leetcode/121", "completion": "\n    res = 0\n    for i in range(1, len(prices)):\n        res = max(res, prices[i] - prices[i - 1])\n    return res\n\n\n\nif __name__ == '__main__':\n    print(maxProfit([7, 6, 4, 3, 1]))\n    print(maxProfit([7, 1, 5, 3, 6, 4]))\n    print(maxProfit([7, 1, 5, 5, 3, 6, 4]))\n    print(maxProfit([7, 6, 4, 3, 1", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    res = 0\n    for i in range(1, len(prices)):\n        res = max(res, prices[i] - prices[i - 1])\n    return res\n\n\n\nif __name__ == '__main__':\n    print(maxProfit([7, 6, 4, 3, 1]))\n    print(maxProfit([7, 1, 5, 3, 6, 4]))\n    print(maxProfit([7, 1, 5, 5, 3, 6, 4]))\n    print(maxProfit([7, 6, 4, 3, 1"}


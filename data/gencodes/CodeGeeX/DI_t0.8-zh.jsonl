{"task_id": "HumanEval/0", "completion": "\n    for i in range(0, len(numbers) - 1):\n        num1 = numbers[i]\n        for j in range(i + 1, len(numbers)):\n            num2 = numbers[j]\n            if abs(num1 - num2) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    num_list = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    print(f\"has_close_elements({num_list}, 0.3)={has_close_elements(num_list, 0.3)}\")\n    print(f\"has_close_elements({num_list}, 0.5)={has_close_elements(num_list, 0.5)}\")", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(0, len(numbers) - 1):\n        num1 = numbers[i]\n        for j in range(i + 1, len(numbers)):\n            num2 = numbers[j]\n            if abs(num1 - num2) <= threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    num_list = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    print(f\"has_close_elements({num_list}, 0.3)={has_close_elements(num_list, 0.3)}\")\n    print(f\"has_close_elements({num_list}, 0.5)={has_close_elements(num_list, 0.5)}\")"}
{"task_id": "HumanEval/0", "completion": "    index = 0\n    last_number = -1.0\n    while index < len(numbers):\n        # 找到距离最近的数字\n        first_number = numbers[index]\n        min_distance = abs(first_number - last_number)\n        for j in range(index + 1, len(numbers)):\n            second_number = numbers[j]\n            distance = abs(first_number - second_number)\n            if distance < min_distance:\n                min_distance = distance\n                last_number = second_number\n        if min_distance < threshold:\n            return True\n        index += 1\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    index = 0\n    last_number = -1.0\n    while index < len(numbers):\n        # 找到距离最近的数字\n        first_number = numbers[index]\n        min_distance = abs(first_number - last_number)\n        for j in range(index + 1, len(numbers)):\n            second_number = numbers[j]\n            distance = abs(first_number - second_number)\n            if distance < min_distance:\n                min_distance = distance\n                last_number = second_number\n        if min_distance < threshold:\n            return True\n        index += 1\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/0", "completion": "    n = len(numbers)\n    if n < 2:\n        return False\n    numbers.sort()\n    result = False\n    for i in range(n - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff <= threshold:\n            result = True\n    return result\n\n\ndef main():\n    numbers = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    threshold = 0.3\n\n    print(has_close_elements(numbers, threshold))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    if n < 2:\n        return False\n    numbers.sort()\n    result = False\n    for i in range(n - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff <= threshold:\n            result = True\n    return result\n\n\ndef main():\n    numbers = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    threshold = 0.3\n\n    print(has_close_elements(numbers, threshold))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/0", "completion": "    for i, j in zip(numbers[:-1], numbers[1:]):\n        if abs(j - i) < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, j in zip(numbers[:-1], numbers[1:]):\n        if abs(j - i) < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/0", "completion": "\n    for x in range(len(numbers) - 1):  # 遍历列表中的所有元素\n        for y in range(x + 1, len(numbers)):  # 遍历列表中的所有元素\n            if abs(numbers[x] - numbers[y]) < threshold:  # 检查是否符合阈值\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # 排序\n    numbers.sort()\n    # 遍历排序后的列表中的所有元素\n    for x in range(len(numbers) - 1):", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for x in range(len(numbers) - 1):  # 遍历列表中的所有元素\n        for y in range(x + 1, len(numbers)):  # 遍历列表中的所有元素\n            if abs(numbers[x] - numbers[y]) < threshold:  # 检查是否符合阈值\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # 排序\n    numbers.sort()\n    # 遍历排序后的列表中的所有元素\n    for x in range(len(numbers) - 1):"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    print(\"Example:\")\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) is True\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.7) is False\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.0)", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    print(\"Example:\")\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) is True\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.7) is False\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.0)"}
{"task_id": "HumanEval/0", "completion": "    diff = 0\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff += abs(numbers[i] - numbers[j])\n            if diff > threshold:\n                diff = 0\n                break\n        if diff > threshold:\n            break\n    return diff > threshold\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    diff = 0\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff += abs(numbers[i] - numbers[j])\n            if diff > threshold:\n                diff = 0\n                break\n        if diff > threshold:\n            break\n    return diff > threshold\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/0", "completion": "    #  先用 sorted() 函数对 list 进行排序，然后利用双指针法来判断，只要任意两个相邻数字之差\n    #  小于给定阈值，就返回 True，否则返回 False\n    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] <= threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    #  先用 sorted() 函数对 list 进行排序，然后利用双指针法来判断，只要任意两个相邻数字之差\n    #  小于给定阈值，就返回 True，否则返回 False\n    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] <= threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(len(numbers)):\n            if i == j:\n                continue\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\ndef main():\n    numbers = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    threshold = 0.3\n    print(has_close_elements(numbers, threshold))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(len(numbers)):\n            if i == j:\n                continue\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n\n\ndef main():\n    numbers = [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n    threshold = 0.3\n    print(has_close_elements(numbers, threshold))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/0", "completion": "    set1 = set(numbers)\n    set2 = set(numbers)\n    for number in set1:\n        for other_number in set2:\n            if number - other_number < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.1, 2.0], 0.5)\n    True\n    \"\"\"\n    map1 = {}\n    for number in numbers:\n        if number in map1:\n            return True\n        map1[number] = 1\n\n    for number in numbers:\n        for other_number in numbers:\n            if (\n                number - other_number < threshold\n                and other_number not in map1\n                and number not in map1\n            ):\n                return", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    set1 = set(numbers)\n    set2 = set(numbers)\n    for number in set1:\n        for other_number in set2:\n            if number - other_number < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements2([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements2([1.1, 2.0], 0.5)\n    True\n    \"\"\"\n    map1 = {}\n    for number in numbers:\n        if number in map1:\n            return True\n        map1[number] = 1\n\n    for number in numbers:\n        for other_number in numbers:\n            if (\n                number - other_number < threshold\n                and other_number not in map1\n                and number not in map1\n            ):\n                return"}
{"task_id": "HumanEval/7", "completion": "    strs = [s for s in strings if substring in s]\n    return strs", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    strs = [s for s in strings if substring in s]\n    return strs"}
{"task_id": "HumanEval/7", "completion": "    return [x for x in strings if substring in x]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [x for x in strings if substring in x]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "    if not strings or not substring:\n        return []\n    return list(filter(lambda s: substring in s, strings))\n\n\nif __name__ == \"__main__\":\n    print(filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"))", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    if not strings or not substring:\n        return []\n    return list(filter(lambda s: substring in s, strings))\n\n\nif __name__ == \"__main__\":\n    print(filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"))"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring_not(strings: List[str], substring: str) -> List[str]:\n    \"\"\"返回不包含给定子串的列表中    >>> filter_by_substring_not([], 'a')\n    []\n    >>> filter_by_substring_not(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['bcd', 'array']\n    \"\"\"\n    return [string for string in strings if substring not in string]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # print(filter_by_substring(['1', '2', '4', '20190520', 'a'], 'a'))\n    # print(filter_by_substring(['1', '2', '4', '20190520', 'a'], 'b'))", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring_not(strings: List[str], substring: str) -> List[str]:\n    \"\"\"返回不包含给定子串的列表中    >>> filter_by_substring_not([], 'a')\n    []\n    >>> filter_by_substring_not(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['bcd', 'array']\n    \"\"\"\n    return [string for string in strings if substring not in string]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # print(filter_by_substring(['1', '2', '4', '20190520', 'a'], 'a'))\n    # print(filter_by_substring(['1', '2', '4', '20190520', 'a'], 'b'))"}
{"task_id": "HumanEval/7", "completion": "\n    return [string for string in strings if substring in string]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n\n    return [string for string in strings if substring in string]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\ndef filter_by_duplicates(strings: List[str]) -> List[str]:\n    \"\"\" 筛选列表中重复出现的元素    >>> filter_by_duplicates([])\n    []\n    >>> filter_by_duplicates(['abc', 'bacd', 'cde', 'array'])\n    ['abc', 'bacd', 'cde']\n    \"\"\"\n    # 方案一\n    # return list(set(strings))\n\n    # 方案二\n    # return sorted(set(strings), key=strings.index)\n\n    # 方案三\n    stripped = sorted([s.rstrip() for s in strings])\n    return [s for i, s in enumerate(stripped) if i == 0 or s != stripped[i - 1]]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_duplicates(strings: List[str]) -> List[str]:\n    \"\"\" 筛选列表中重复出现的元素    >>> filter_by_duplicates([])\n    []\n    >>> filter_by_duplicates(['abc', 'bacd', 'cde', 'array'])\n    ['abc', 'bacd', 'cde']\n    \"\"\"\n    # 方案一\n    # return list(set(strings))\n\n    # 方案二\n    # return sorted(set(strings), key=strings.index)\n\n    # 方案三\n    stripped = sorted([s.rstrip() for s in strings])\n    return [s for i, s in enumerate(stripped) if i == 0 or s != stripped[i - 1]]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/7", "completion": "    return [i for i in strings if substring in i]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [i for i in strings if substring in i]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定前缀的字符串    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]\n\n\ndef filter_by_suffix(strings: List[str], suffix: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定后缀的字符串    >>> filter_by_suffix([], 'a')\n    []\n    >>> filter_by_suffix(['abc', 'bacd', 'cde', 'array'], 'd')\n    ['bacd', 'array']\n    \"\"\"\n    return [s for s in strings if s.endswith(suffix)]", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定前缀的字符串    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]\n\n\ndef filter_by_suffix(strings: List[str], suffix: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定后缀的字符串    >>> filter_by_suffix([], 'a')\n    []\n    >>> filter_by_suffix(['abc', 'bacd', 'cde', 'array'], 'd')\n    ['bacd', 'array']\n    \"\"\"\n    return [s for s in strings if s.endswith(suffix)]"}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda string: substring in string, strings))", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda string: substring in string, strings))"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "\n    return len(set(string))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\n    return len(set(string))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "    if not string:\n        return 0\n    return len(set(string))\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 判断一个字符串是否是回文\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('Jerry')\n    False\n    \"\"\"\n    if not string:\n        return False\n    i, j = 0, len(string) - 1\n    while i < j:\n        if string[i] != string[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef is_anagram(s1: str, s2: str) -> bool:\n    \"\"\" 判断两个字符串是否是组合字符\n    >>> is_anagram('racecar', 'carace')\n    True\n    >>> is_anagram('Jerry', 'Jerryz')\n    False\n    \"\"\"\n    if not s1:\n        return False\n    return sorted(s1) == sorted(s2) and len(s1) == len(", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not string:\n        return 0\n    return len(set(string))\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 判断一个字符串是否是回文\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('Jerry')\n    False\n    \"\"\"\n    if not string:\n        return False\n    i, j = 0, len(string) - 1\n    while i < j:\n        if string[i] != string[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef is_anagram(s1: str, s2: str) -> bool:\n    \"\"\" 判断两个字符串是否是组合字符\n    >>> is_anagram('racecar', 'carace')\n    True\n    >>> is_anagram('Jerry', 'Jerryz')\n    False\n    \"\"\"\n    if not s1:\n        return False\n    return sorted(s1) == sorted(s2) and len(s1) == len("}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_non_repeated_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，统计它里面有多少个只出现一次的字符\n    >>> count_non_repeated_characters('xyzXYZ')\n    3\n    >>> count_non_repeated_characters('Jerry')\n    2\n    \"\"\"\n\n    def _is_repeat(char, strings):\n        if char not in strings:\n            strings.add(char)\n            return False\n        return True\n\n    strings = set()\n    count = 0\n    for ch in string.lower():\n        if not _is_repeat(ch, strings):\n            count += 1\n    return count\n\n\ndef is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    给定一个整数，判断是否是回文数\n    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数\n    例如121是回文数，", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_non_repeated_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，统计它里面有多少个只出现一次的字符\n    >>> count_non_repeated_characters('xyzXYZ')\n    3\n    >>> count_non_repeated_characters('Jerry')\n    2\n    \"\"\"\n\n    def _is_repeat(char, strings):\n        if char not in strings:\n            strings.add(char)\n            return False\n        return True\n\n    strings = set()\n    count = 0\n    for ch in string.lower():\n        if not _is_repeat(ch, strings):\n            count += 1\n    return count\n\n\ndef is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    给定一个整数，判断是否是回文数\n    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数\n    例如121是回文数，"}
{"task_id": "HumanEval/16", "completion": "    distinct_characters = set()\n    for each_character in string:\n        distinct_characters.add(each_character.lower())\n    return len(distinct_characters)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set()\n    for each_character in string:\n        distinct_characters.add(each_character.lower())\n    return len(distinct_characters)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "    lower_chars = set(string.lower())\n    return len(lower_chars)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    lower_chars = set(string.lower())\n    return len(lower_chars)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "    counts: Dict[str, int] = {}\n    for c in string:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    return len(counts)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    counts: Dict[str, int] = {}\n    for c in string:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    return len(counts)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/16", "completion": "    count = 0\n    for c in string:\n        if c not in char_set:\n            char_set.add(c)\n            count += 1\n    return count\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words('Jerry likes trie !')\n    4\n    >>> count_distinct_words('Jerry likes trie ! Jerry likes trie !')\n    2\n    \"\"\"\n    count = 0\n    for word in string.split():\n        if word not in word_set:\n            word_set.add(word)\n            count += 1\n    return count\n\n\ndef count_words_with_length_over_n(string: str, length: int) -> int:\n    \"\"\" 给定一个字符串，找出它的由多少个单词长度大于等于length的单词\n    >>> count_words_with_length_over_n('Jerry likes trie ! Jerry likes trie !', 3)\n    2\n    >>>", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for c in string:\n        if c not in char_set:\n            char_set.add(c)\n            count += 1\n    return count\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words('Jerry likes trie !')\n    4\n    >>> count_distinct_words('Jerry likes trie ! Jerry likes trie !')\n    2\n    \"\"\"\n    count = 0\n    for word in string.split():\n        if word not in word_set:\n            word_set.add(word)\n            count += 1\n    return count\n\n\ndef count_words_with_length_over_n(string: str, length: int) -> int:\n    \"\"\" 给定一个字符串，找出它的由多少个单词长度大于等于length的单词\n    >>> count_words_with_length_over_n('Jerry likes trie ! Jerry likes trie !', 3)\n    2\n    >>>"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_distinct_characters_optimized(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters_optimized('xyzXYZ')\n    3\n    >>> count_distinct_characters_optimized('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_distinct_characters_optimized(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters_optimized('xyzXYZ')\n    3\n    >>> count_distinct_characters_optimized('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))"}
{"task_id": "HumanEval/18", "completion": "    return len(find_all(string, substring))\n\n\nif __name__ == \"__main__\":\n    print(how_many_times(\"\", \"a\"))\n    print(how_many_times(\"aaa\", \"a\"))\n    print(how_many_times(\"aaaa\", \"aa\"))", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(find_all(string, substring))\n\n\nif __name__ == \"__main__\":\n    print(how_many_times(\"\", \"a\"))\n    print(how_many_times(\"aaa\", \"a\"))\n    print(how_many_times(\"aaaa\", \"aa\"))"}
{"task_id": "HumanEval/18", "completion": "    return string.count(substring)\n\n\ndef index_of(string: str, substring: str) -> int:\n    \"\"\" 返回给定子串在原始字符串中第一次出现的索引。返回-1，如果未找到子串。\n    >>> index_of('', 'a')\n    -1\n    >>> index_of('aaa', 'a')\n    0\n    >>> index_of('bab', 'ab')\n    0\n    >>> index_of('banana', 'ana')\n    2\n    \"\"\"\n    return string.index(substring)\n\n\ndef last_index_of(string: str, substring: str) -> int:\n    \"\"\" 返回给定子串在原始字符串中最后一次出现的索引。返回-1，如果未找到子串。    >>> last_index_of('', 'a')\n    -1\n    >>> last_index_of('aaa', 'a')\n    2\n    >>> last_index_of('bab', 'ab')\n    1\n    >>> last_index_of('banana', 'ana')\n    4\n    \"\"\"", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return string.count(substring)\n\n\ndef index_of(string: str, substring: str) -> int:\n    \"\"\" 返回给定子串在原始字符串中第一次出现的索引。返回-1，如果未找到子串。\n    >>> index_of('', 'a')\n    -1\n    >>> index_of('aaa', 'a')\n    0\n    >>> index_of('bab', 'ab')\n    0\n    >>> index_of('banana', 'ana')\n    2\n    \"\"\"\n    return string.index(substring)\n\n\ndef last_index_of(string: str, substring: str) -> int:\n    \"\"\" 返回给定子串在原始字符串中最后一次出现的索引。返回-1，如果未找到子串。    >>> last_index_of('', 'a')\n    -1\n    >>> last_index_of('aaa', 'a')\n    2\n    >>> last_index_of('bab', 'ab')\n    1\n    >>> last_index_of('banana', 'ana')\n    4\n    \"\"\""}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    while string.find(substring) != -1:\n        string = string[string.find(substring) + 1 :]\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    while string.find(substring) != -1:\n        string = string[string.find(substring) + 1 :]\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/18", "completion": "    string = string.replace(substring, \"\")\n    return len(string)", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    string = string.replace(substring, \"\")\n    return len(string)"}
{"task_id": "HumanEval/18", "completion": "    last_position = -1\n    times = 0\n    while True:\n        position = string.find(substring, last_position + 1)\n        if position == -1:\n            break\n        last_position = position\n        times += 1\n    return times\n\nif __name__ == '__main__':\n    print(how_many_times('', 'a'))\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    last_position = -1\n    times = 0\n    while True:\n        position = string.find(substring, last_position + 1)\n        if position == -1:\n            break\n        last_position = position\n        times += 1\n    return times\n\nif __name__ == '__main__':\n    print(how_many_times('', 'a'))\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))"}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    for start_index in range(len(string)):\n        start_point = start_index\n        while start_point < len(string):\n            if string[start_point] == substring[0]:\n                if string[start_point : start_point + len(substring)] == substring:\n                    start_point += len(substring)\n                    count += 1\n                else:\n                    break\n            else:\n                start_point += 1\n    return count\n\n\ndef get_substring(string: str, substring: str) -> str:\n    \"\"\"\n    >>> get_substring('abcabcabc', 'ab')\n    'ababab'\n    >>> get_substring('abcabcabc', 'abc')\n    'abcabc'\n    >>> get_substring('abcabcabc', 'bc')\n    'bcbc'\n    \"\"\"\n    result = \"\"\n    i = 0\n    while i < len(string):\n        if string[i : i + len(substring)] ==", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for start_index in range(len(string)):\n        start_point = start_index\n        while start_point < len(string):\n            if string[start_point] == substring[0]:\n                if string[start_point : start_point + len(substring)] == substring:\n                    start_point += len(substring)\n                    count += 1\n                else:\n                    break\n            else:\n                start_point += 1\n    return count\n\n\ndef get_substring(string: str, substring: str) -> str:\n    \"\"\"\n    >>> get_substring('abcabcabc', 'ab')\n    'ababab'\n    >>> get_substring('abcabcabc', 'abc')\n    'abcabc'\n    >>> get_substring('abcabcabc', 'bc')\n    'bcbc'\n    \"\"\"\n    result = \"\"\n    i = 0\n    while i < len(string):\n        if string[i : i + len(substring)] =="}
{"task_id": "HumanEval/18", "completion": "    n = 0\n    i = 0\n    j = 0\n    while i < len(string):\n        while j < len(substring) and i + j < len(string):\n            if string[i + j] == substring[j]:\n                j += 1\n            else:\n                break\n        if j == len(substring):\n            n += 1\n        j = 0\n        i += 1\n    return n\n\n\ndef main():\n    \"\"\"The main method.\"\"\"\n    print(how_many_times(\"\", \"a\"))\n    print(how_many_times(\"aaa\", \"a\"))\n    print(how_many_times(\"aaaa\", \"aa\"))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    n = 0\n    i = 0\n    j = 0\n    while i < len(string):\n        while j < len(substring) and i + j < len(string):\n            if string[i + j] == substring[j]:\n                j += 1\n            else:\n                break\n        if j == len(substring):\n            n += 1\n        j = 0\n        i += 1\n    return n\n\n\ndef main():\n    \"\"\"The main method.\"\"\"\n    print(how_many_times(\"\", \"a\"))\n    print(how_many_times(\"aaa\", \"a\"))\n    print(how_many_times(\"aaaa\", \"aa\"))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/18", "completion": "    i = 0  # 计数器\n    while True:  # 查找子串\n        i += 1\n        pos = string.find(substring, i)  # pos 找到的下标\n        if pos < 0:  # 未找到\n            return i - 1  # 返回次数\n        else:\n            i = pos + 1  # 找到了，跳过\n\n\ndef how_many_times2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # i = 0        # 计数器\n    i = 1  # 计数器 从1开始\n    list_str = []  # 存储匹配到的子串下标\n    # while True:                           # 查找子串\n    #     i += 1", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    i = 0  # 计数器\n    while True:  # 查找子串\n        i += 1\n        pos = string.find(substring, i)  # pos 找到的下标\n        if pos < 0:  # 未找到\n            return i - 1  # 返回次数\n        else:\n            i = pos + 1  # 找到了，跳过\n\n\ndef how_many_times2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # i = 0        # 计数器\n    i = 1  # 计数器 从1开始\n    list_str = []  # 存储匹配到的子串下标\n    # while True:                           # 查找子串\n    #     i += 1"}
{"task_id": "HumanEval/18", "completion": "    return len(re.findall(substring, string))\n\n\ndef test():\n    assert how_many_times(\"\", \"a\") == 0\n    assert how_many_times(\"aaa\", \"a\") == 3\n    assert how_many_times(\"aaaa\", \"aa\") == 3\n    assert how_many_times(\"aac\", \"a\") == 2\n    assert how_many_times(\"aaBaa\", \"aa\") == 2\n    assert how_many_times(\"abbaa\", \"bb\") == 1\n    assert how_many_times(\"aba\", \"b\") == 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(re.findall(substring, string))\n\n\ndef test():\n    assert how_many_times(\"\", \"a\") == 0\n    assert how_many_times(\"aaa\", \"a\") == 3\n    assert how_many_times(\"aaaa\", \"aa\") == 3\n    assert how_many_times(\"aac\", \"a\") == 2\n    assert how_many_times(\"aaBaa\", \"aa\") == 2\n    assert how_many_times(\"abbaa\", \"bb\") == 1\n    assert how_many_times(\"aba\", \"b\") == 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    while substring in string:\n        string = string[len(substring) :]\n        count += 1\n    return count\n\n\ndef how_many_times_pythonic(string: str, substring: str) -> int:\n    return string.count(substring)", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    while substring in string:\n        string = string[len(substring) :]\n        count += 1\n    return count\n\n\ndef how_many_times_pythonic(string: str, substring: str) -> int:\n    return string.count(substring)"}
{"task_id": "HumanEval/24", "completion": "    return 1 if n == 0 else n // 2 + 1\n\n\ndef largest_divisor2(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 0:\n        return 0\n    return n // 2 + 1\n\n\n# 6 题目\ndef smallest_multiple(n: int) -> int:\n    \"\"\" 找出大于 n 的数中，最小的能被n个数整除的数\n    >>> smallest_multiple(15)\n    25\n    \"\"\"\n    s = list(range(n, n + 20))\n    while True:\n        for m in s:\n            for i in range(2, len(s)):\n                if (s[i] % m) != 0:\n                    break\n            else:\n                return m\n        s = s[1:] + [s[0]]\n\n\ndef smallest_multiple2(n: int) -> int:\n", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return 1 if n == 0 else n // 2 + 1\n\n\ndef largest_divisor2(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 0:\n        return 0\n    return n // 2 + 1\n\n\n# 6 题目\ndef smallest_multiple(n: int) -> int:\n    \"\"\" 找出大于 n 的数中，最小的能被n个数整除的数\n    >>> smallest_multiple(15)\n    25\n    \"\"\"\n    s = list(range(n, n + 20))\n    while True:\n        for m in s:\n            for i in range(2, len(s)):\n                if (s[i] % m) != 0:\n                    break\n            else:\n                return m\n        s = s[1:] + [s[0]]\n\n\ndef smallest_multiple2(n: int) -> int:\n"}
{"task_id": "HumanEval/24", "completion": "    # 方法1\n    # divisor = 0\n    # for i in range(n // 2, 0, -1):\n    #     if n % i == 0:\n    #         if i > divisor:\n    #             divisor = i\n    # return divisor\n\n    # 方法2\n    return n\n\n\n# 练习2\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    判断一个数n是否为素数\n    :param n:\n    :return:\n    >>> is_prime(2)\n    True\n    >>> is_prime(16)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\n\n# 练习3\ndef get_n_primes(n):\n    \"\"\"\n    返回包含 n 个质数的列表(2 <= n <= 200)\n    :param n: \n    :return: ", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # 方法1\n    # divisor = 0\n    # for i in range(n // 2, 0, -1):\n    #     if n % i == 0:\n    #         if i > divisor:\n    #             divisor = i\n    # return divisor\n\n    # 方法2\n    return n\n\n\n# 练习2\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    判断一个数n是否为素数\n    :param n:\n    :return:\n    >>> is_prime(2)\n    True\n    >>> is_prime(16)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\n\n# 练习3\ndef get_n_primes(n):\n    \"\"\"\n    返回包含 n 个质数的列表(2 <= n <= 200)\n    :param n: \n    :return: "}
{"task_id": "HumanEval/24", "completion": "    divisor = -1\n    for i in range(2, n):\n        if n % i == 0:\n            divisor = i\n    return divisor\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    divisor = -1\n    for i in range(2, n):\n        if n % i == 0:\n            divisor = i\n    return divisor\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))"}
{"task_id": "HumanEval/24", "completion": "    return largest_divisor_2(n)\n\n\ndef largest_divisor_2(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return n\n    # 设置初始值\n    max_dv = 0\n    for i in range(2, n):\n        if n % i == 0:\n            if i > max_dv:\n                max_dv = i\n    return max_dv\n\n\ndef test():\n    print(largest_divisor(15))", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return largest_divisor_2(n)\n\n\ndef largest_divisor_2(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return n\n    # 设置初始值\n    max_dv = 0\n    for i in range(2, n):\n        if n % i == 0:\n            if i > max_dv:\n                max_dv = i\n    return max_dv\n\n\ndef test():\n    print(largest_divisor(15))"}
{"task_id": "HumanEval/24", "completion": "    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n\ndef is_prime_number(n: int) -> bool:\n    \"\"\" 判断一个数是否为素数    >>> is_prime_number(15)\n    False\n    >>> is_prime_number(7)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef factorization(n: int) -> list:\n    \"\"\" 求一个数的质因数分解    >>> factorization(15)\n    [3, 5]\n    >>> factorization(81)\n    [3, 3, 3, 3]\n    \"\"\"\n    result = []\n    for i in range(2, n):\n        if n % i == 0:\n            result.append(i)\n            n //= i\n            if n == 1:", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n\ndef is_prime_number(n: int) -> bool:\n    \"\"\" 判断一个数是否为素数    >>> is_prime_number(15)\n    False\n    >>> is_prime_number(7)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef factorization(n: int) -> list:\n    \"\"\" 求一个数的质因数分解    >>> factorization(15)\n    [3, 5]\n    >>> factorization(81)\n    [3, 3, 3, 3]\n    \"\"\"\n    result = []\n    for i in range(2, n):\n        if n % i == 0:\n            result.append(i)\n            n //= i\n            if n == 1:"}
{"task_id": "HumanEval/24", "completion": "\n    if n <= 0:\n        return -1\n    start = int(n ** 0.5)\n    for i in range(start + 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n\n    if n <= 0:\n        return -1\n    start = int(n ** 0.5)\n    for i in range(start + 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/24", "completion": "    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return -1\n\n\ndef test_largest_divisor():\n    print(largest_divisor(15))\n\n\nif __name__ == \"__main__\":\n    test_largest_divisor()", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return -1\n\n\ndef test_largest_divisor():\n    print(largest_divisor(15))\n\n\nif __name__ == \"__main__\":\n    test_largest_divisor()"}
{"task_id": "HumanEval/24", "completion": "    i = n // 2\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = n // 2\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))"}
{"task_id": "HumanEval/24", "completion": "    if n < 2:\n        return 1\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return 1\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1\n\n\nif __name__ == \"__main__\":\n    print(largest_divisor(15))"}
{"task_id": "HumanEval/24", "completion": "    # if n == 0:\n    #     return 0\n    # for i in range(n - 1, 0, -1):\n    #     if n % i == 0:\n    #         return i\n    max_divisor = 0\n    for i in range(1, n):\n        if n % i == 0:\n            max_divisor = i\n    return max_divisor\n\n\ndef smallest_multiple(n: int) -> int:\n    \"\"\" 寻找 1 到 n 的最小公倍数，即这些数的最小公倍数是 n\n    >>> smallest_multiple(10)\n    2520\n    >>> smallest_multiple(15)\n    1360\n    \"\"\"\n    # if n == 1:\n    #     return 1\n    # m = 1\n    # for i in range(2, n +1):\n    #     m = m * i / largest_divisor(m * i)\n    # return m\n    max_divisor = largest_divisor(n)\n    if max_div", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # if n == 0:\n    #     return 0\n    # for i in range(n - 1, 0, -1):\n    #     if n % i == 0:\n    #         return i\n    max_divisor = 0\n    for i in range(1, n):\n        if n % i == 0:\n            max_divisor = i\n    return max_divisor\n\n\ndef smallest_multiple(n: int) -> int:\n    \"\"\" 寻找 1 到 n 的最小公倍数，即这些数的最小公倍数是 n\n    >>> smallest_multiple(10)\n    2520\n    >>> smallest_multiple(15)\n    1360\n    \"\"\"\n    # if n == 1:\n    #     return 1\n    # m = 1\n    # for i in range(2, n +1):\n    #     m = m * i / largest_divisor(m * i)\n    # return m\n    max_divisor = largest_divisor(n)\n    if max_div"}
{"task_id": "HumanEval/25", "completion": "    if n == 1:\n        return []\n    factors = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            factors.append(i)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n == 1:\n        return []\n    factors = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            factors.append(i)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    i = 2\n    result = []\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n            result.append(i)\n        else:\n            i += 1\n    if n != 1:\n        result.append(n)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    i = 2\n    result = []\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n            result.append(i)\n        else:\n            i += 1\n    if n != 1:\n        result.append(n)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    results: List[int] = []\n    if n == 1:\n        return results\n\n    # 循环从 2 开始，i*i < n 是为了提高效率，因为 n=1,2,3,4时会直接返回结果\n    for i in range(2, n):\n        # 判断因子\n        if n % i == 0:\n            results.append(i)\n            n //= i\n            # 返回结果\n            if n == 1:\n                return results\n            # 判断下一个因子\n            if n == 1:\n                return results\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    results: List[int] = []\n    if n == 1:\n        return results\n\n    # 循环从 2 开始，i*i < n 是为了提高效率，因为 n=1,2,3,4时会直接返回结果\n    for i in range(2, n):\n        # 判断因子\n        if n % i == 0:\n            results.append(i)\n            n //= i\n            # 返回结果\n            if n == 1:\n                return results\n            # 判断下一个因子\n            if n == 1:\n                return results\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    res = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            res.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        res.append(n)\n    return res\n\n\ndef ispalindrome(n: int) -> bool:\n    \"\"\" 给定一个整数，写一个函数判断它是不是回文数    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数\n    >>> ispalindrome(808)\n    True\n    >>> ispalindrome(12321)\n    True\n    >>> ispalindrome(123)\n    False\n    >>> ispalindrome(231)\n    False\n    >>> ispalindrome(-12321)\n    False\n    \"\"\"\n    return str(n) == str(n)[::-1]\n\n\ndef isprime(n: int) -> bool:\n    \"\"\" 写一个函数判断给定整数是否", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    res = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            res.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        res.append(n)\n    return res\n\n\ndef ispalindrome(n: int) -> bool:\n    \"\"\" 给定一个整数，写一个函数判断它是不是回文数    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数\n    >>> ispalindrome(808)\n    True\n    >>> ispalindrome(12321)\n    True\n    >>> ispalindrome(123)\n    False\n    >>> ispalindrome(231)\n    False\n    >>> ispalindrome(-12321)\n    False\n    \"\"\"\n    return str(n) == str(n)[::-1]\n\n\ndef isprime(n: int) -> bool:\n    \"\"\" 写一个函数判断给定整数是否"}
{"task_id": "HumanEval/25", "completion": "    return None\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    return None\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    # 根据题意 n = p ^ k 且 p ^ k - 1 = 2 ^ x * 5 ^ y * 7 ^ z\n    # 所以 n = 2 ^ x * 5 ^ y * 7 ^ z\n    # 2 最大只能到 n // 2\n    # 7 最大只能到 n // 7\n    # 5 最大只能到 n // 5\n    p = 2\n    while p <= n // 2:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    p = 7\n    while p <= n // p:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    p = 5\n    while p <= n // p:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    return factors\n\n\ndef main():\n    import", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    # 根据题意 n = p ^ k 且 p ^ k - 1 = 2 ^ x * 5 ^ y * 7 ^ z\n    # 所以 n = 2 ^ x * 5 ^ y * 7 ^ z\n    # 2 最大只能到 n // 2\n    # 7 最大只能到 n // 7\n    # 5 最大只能到 n // 5\n    p = 2\n    while p <= n // 2:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    p = 7\n    while p <= n // p:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    p = 5\n    while p <= n // p:\n        if n % p == 0:\n            n //= p\n            factors.append(p)\n        else:\n            p += 1\n    return factors\n\n\ndef main():\n    import"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n    return factors\n\n\nif __name__ == \"__main__\":\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n    return factors\n\n\nif __name__ == \"__main__\":\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    ret = []\n    while n % 2 == 0:\n        ret.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ret.append(i)\n            n = n / i\n    if n > 2:\n        ret.append(n)\n    return ret\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    ret = []\n    while n % 2 == 0:\n        ret.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ret.append(i)\n            n = n / i\n    if n > 2:\n        ret.append(n)\n    return ret\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/25", "completion": "    primelist = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            primelist.append(i)\n            n = n / i\n    return primelist\n\n\ndef to_str(l: List[int]) -> str:\n    \"\"\"将List中的元素按字符串形式输出，输出结果间用逗号\",\"分隔\n    >>> to_str([0,1,2,3,4,5])\n    '0,1,2,3,4,5'\n    \"\"\"\n    res = \"\"\n    for i in l:\n        res += str(i) + \",\"\n    return res.rstrip(',')\n\n\ndef to_int(s: str) -> int:\n    \"\"\"将字符串转换为整数。如果整数转换失败，返回-1。\n    >>> to_int('186')\n    186\n    \"\"\"\n    try:\n        n = int(s)\n        return n\n    except ValueError:\n        return -1\n\n\ndef to_float(s: str) ->", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    primelist = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            primelist.append(i)\n            n = n / i\n    return primelist\n\n\ndef to_str(l: List[int]) -> str:\n    \"\"\"将List中的元素按字符串形式输出，输出结果间用逗号\",\"分隔\n    >>> to_str([0,1,2,3,4,5])\n    '0,1,2,3,4,5'\n    \"\"\"\n    res = \"\"\n    for i in l:\n        res += str(i) + \",\"\n    return res.rstrip(',')\n\n\ndef to_int(s: str) -> int:\n    \"\"\"将字符串转换为整数。如果整数转换失败，返回-1。\n    >>> to_int('186')\n    186\n    \"\"\"\n    try:\n        n = int(s)\n        return n\n    except ValueError:\n        return -1\n\n\ndef to_float(s: str) ->"}
{"task_id": "HumanEval/25", "completion": "    l, n = [], n\n    for i in range(2, n + 1):\n        if n % i == 0:\n            l.append(i)\n            n //= i\n    return l\n\n\nprint(factorize(8))\nprint(factorize(25))\nprint(factorize(70))", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    l, n = [], n\n    for i in range(2, n + 1):\n        if n % i == 0:\n            l.append(i)\n            n //= i\n    return l\n\n\nprint(factorize(8))\nprint(factorize(25))\nprint(factorize(70))"}
{"task_id": "HumanEval/26", "completion": "    nums = numbers\n    left, right = 0, 1\n    while right < len(nums):\n        if nums[right] != nums[right - 1]:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n        right += 1\n    return nums[:left]\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    assert remove_duplicates([1, 2, 3, 2, 4]) == [1, 3, 4]\n    assert remove_duplicates([0, 0, 1, 2, 3, 0]) == [0, 1, 2, 3]\n    assert remove_duplicates([0, 1, 2, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    assert remove_duplicates([0, 1, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    nums = numbers\n    left, right = 0, 1\n    while right < len(nums):\n        if nums[right] != nums[right - 1]:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n        right += 1\n    return nums[:left]\n\n\nif __name__ == \"__main__\":\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    assert remove_duplicates([1, 2, 3, 2, 4]) == [1, 3, 4]\n    assert remove_duplicates([0, 0, 1, 2, 3, 0]) == [0, 1, 2, 3]\n    assert remove_duplicates([0, 1, 2, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    assert remove_duplicates([0, 1, "}
{"task_id": "HumanEval/26", "completion": "    ret = []\n    for n in numbers:\n        if n not in ret:\n            ret.append(n)\n    return ret\n\n\nprint(remove_duplicates([1, 2, 3, 2, 4]))", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    ret = []\n    for n in numbers:\n        if n not in ret:\n            ret.append(n)\n    return ret\n\n\nprint(remove_duplicates([1, 2, 3, 2, 4]))"}
{"task_id": "HumanEval/26", "completion": "\n    # 定义一个字典，统计每个数字出现的次数\n    number_count = dict()\n    # 遍历整个列表\n    for number in numbers:\n        # 获取这个数字在字典中的次数\n        count = number_count.setdefault(number, 0)\n        # 如果这个数字没有出现过，次数就为0，否则为1\n        # 每出现一次，就将数字出现的次数增加1\n        number_count[number] = count + 1\n    # 定义一个列表，保存结果\n    result = list()\n    # 遍历字典，如果数字出现的次数为1，就添加到结果列表中\n    for number, count in number_count.items():\n        if count == 1:\n            result.append(number)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n    # 定义一个字典，统计每个数字出现的次数\n    number_count = dict()\n    # 遍历整个列表\n    for number in numbers:\n        # 获取这个数字在字典中的次数\n        count = number_count.setdefault(number, 0)\n        # 如果这个数字没有出现过，次数就为0，否则为1\n        # 每出现一次，就将数字出现的次数增加1\n        number_count[number] = count + 1\n    # 定义一个列表，保存结果\n    result = list()\n    # 遍历字典，如果数字出现的次数为1，就添加到结果列表中\n    for number, count in number_count.items():\n        if count == 1:\n            result.append(number)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/26", "completion": "    # 空列表, 直接返回\n    if len(numbers) == 0:\n        return []\n\n    # 创建新列表, 存放结果\n    result = [numbers[0]]\n\n    # 遍历数字列表，比较新列表中末尾数字和新数字\n    for num in numbers[1:]:\n        # 如果新数字和末尾数字相等\n        if num == result[-1]:\n            continue\n        # 如果新数字和末尾数字不等，添加到新列表中\n        result.append(num)\n    return result\n\n\nif __name__ == \"__main__\":\n    # 空列表\n    result = []\n    print(result)\n\n    numbers = [1, 2, 3, 2, 4]\n    result = remove_duplicates(numbers)\n    print(result)\n\n    numbers = [1, 2, 3, 3, 4, 4]\n    result = remove_duplicates(numbers)\n    print(result)\n\n    numbers = []\n    result = remove_", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # 空列表, 直接返回\n    if len(numbers) == 0:\n        return []\n\n    # 创建新列表, 存放结果\n    result = [numbers[0]]\n\n    # 遍历数字列表，比较新列表中末尾数字和新数字\n    for num in numbers[1:]:\n        # 如果新数字和末尾数字相等\n        if num == result[-1]:\n            continue\n        # 如果新数字和末尾数字不等，添加到新列表中\n        result.append(num)\n    return result\n\n\nif __name__ == \"__main__\":\n    # 空列表\n    result = []\n    print(result)\n\n    numbers = [1, 2, 3, 2, 4]\n    result = remove_duplicates(numbers)\n    print(result)\n\n    numbers = [1, 2, 3, 3, 4, 4]\n    result = remove_duplicates(numbers)\n    print(result)\n\n    numbers = []\n    result = remove_"}
{"task_id": "HumanEval/26", "completion": "    return list(set(numbers))\n\n\nremove_duplicates([1, 2, 3, 2, 4])\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\"\n    >>> remove_duplicates_2([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates_2([5, 5, 5, 5, 5])\n    [5]\n    \"\"\"\n    duplicates = set()\n    for num in numbers:\n        if num in duplicates:\n            continue\n        yield num\n        duplicates.add(num)\n\n\nremove_duplicates_2([1, 2, 3, 2, 4])\n\n\ndef remove_duplicates_3(numbers: List[int]) -> List[int]:\n    \"\"\"\n    >>> remove_duplicates_3([1, 2, 3, 2, 4])\n", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))\n\n\nremove_duplicates([1, 2, 3, 2, 4])\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\"\n    >>> remove_duplicates_2([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates_2([5, 5, 5, 5, 5])\n    [5]\n    \"\"\"\n    duplicates = set()\n    for num in numbers:\n        if num in duplicates:\n            continue\n        yield num\n        duplicates.add(num)\n\n\nremove_duplicates_2([1, 2, 3, 2, 4])\n\n\ndef remove_duplicates_3(numbers: List[int]) -> List[int]:\n    \"\"\"\n    >>> remove_duplicates_3([1, 2, 3, 2, 4])\n"}
{"task_id": "HumanEval/26", "completion": "    res = []\n    for i in numbers:\n        if i not in res:\n            res.append(i)\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for i in numbers:\n        if i not in res:\n            res.append(i)\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/26", "completion": "    return sorted(set(numbers), key=numbers.index)", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return sorted(set(numbers), key=numbers.index)"}
{"task_id": "HumanEval/26", "completion": "    # 设置一个中间值\n    result = []\n    for item in numbers:\n        if item not in result:\n            result.append(item)\n    return result", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # 设置一个中间值\n    result = []\n    for item in numbers:\n        if item not in result:\n            result.append(item)\n    return result"}
{"task_id": "HumanEval/26", "completion": "    counts = {}\n    for i in range(len(numbers)):\n        if numbers[i] not in counts:\n            counts[numbers[i]] = 1\n        else:\n            counts[numbers[i]] += 1\n    result = []\n    for key, value in counts.items():\n        for i in range(value):\n            result.append(key)\n    return result", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for i in range(len(numbers)):\n        if numbers[i] not in counts:\n            counts[numbers[i]] = 1\n        else:\n            counts[numbers[i]] += 1\n    result = []\n    for key, value in counts.items():\n        for i in range(value):\n            result.append(key)\n    return result"}
{"task_id": "HumanEval/26", "completion": "    res = []\n    for i in numbers:\n        # 利用set特性，在添加重复元素时，set会自动过滤，不会添加到set中\n        # 如果添加之后元素为空，说明所有重复元素都添加到set中\n        if not res:\n            res.append(i)\n        elif i not in res:\n            res.append(i)\n    return res", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for i in numbers:\n        # 利用set特性，在添加重复元素时，set会自动过滤，不会添加到set中\n        # 如果添加之后元素为空，说明所有重复元素都添加到set中\n        if not res:\n            res.append(i)\n        elif i not in res:\n            res.append(i)\n    return res"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n\n\ndef is_prime_v2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime_v2(6)\n    False\n    >>> is_prime_v2(101)\n    True\n    >>> is_prime_v2(11)\n    True\n    >>> is_prime_v2(13441)\n    True\n    >>> is_prime_v2(61)\n    True\n    >>> is_prime_v2(4)\n    False\n    >>> is_prime_v2(1)\n    False\n    \"\"\"\n    if n < 2", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n\n\ndef is_prime_v2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime_v2(6)\n    False\n    >>> is_prime_v2(101)\n    True\n    >>> is_prime_v2(11)\n    True\n    >>> is_prime_v2(13441)\n    True\n    >>> is_prime_v2(61)\n    True\n    >>> is_prime_v2(4)\n    False\n    >>> is_prime_v2(1)\n    False\n    \"\"\"\n    if n < 2"}
{"task_id": "HumanEval/31", "completion": "    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef primes(n):\n    \"\"\"\n    返回 1 到 n 之间的所有素数 >>> primes(10)\n    [1, 2, 3, 5, 7]\n    \"\"\"\n    return [i for i in range(2, n) if is_prime(i)]\n\n\ndef primes_generator(n):\n    \"\"\"\n    返回 1 到 n 之间的所有素数 生成器 >>> primes_generator(10)\n    [2, 3, 5, 7]\n    \"\"\"\n    print(\"generator\")\n    for i in range(2, n):\n        if is_prime(i):\n            yield i\n\n\ndef main():\n    print(primes(10))\n    print(primes_generator(10))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef primes(n):\n    \"\"\"\n    返回 1 到 n 之间的所有素数 >>> primes(10)\n    [1, 2, 3, 5, 7]\n    \"\"\"\n    return [i for i in range(2, n) if is_prime(i)]\n\n\ndef primes_generator(n):\n    \"\"\"\n    返回 1 到 n 之间的所有素数 生成器 >>> primes_generator(10)\n    [2, 3, 5, 7]\n    \"\"\"\n    print(\"generator\")\n    for i in range(2, n):\n        if is_prime(i):\n            yield i\n\n\ndef main():\n    print(primes(10))\n    print(primes_generator(10))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/31", "completion": "    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    else:\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i = i + 6\n        return True\n\n\ndef divisor(n):\n    \"\"\"\n    求n的因子   >>> divisor(101)\n    [1, 101]\n    >>> divisor(13441)\n    [1, 13441]\n    \"\"\"\n    from collections import deque\n\n    result = [1, n]\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            result.append(i)\n            result.append(n / i)\n        i += 1\n    return result\n\n\ndef is_palindromic(n):\n    \"\"\"\n    判断", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    else:\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i = i + 6\n        return True\n\n\ndef divisor(n):\n    \"\"\"\n    求n的因子   >>> divisor(101)\n    [1, 101]\n    >>> divisor(13441)\n    [1, 13441]\n    \"\"\"\n    from collections import deque\n\n    result = [1, n]\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            result.append(i)\n            result.append(n / i)\n        i += 1\n    return result\n\n\ndef is_palindromic(n):\n    \"\"\"\n    判断"}
{"task_id": "HumanEval/31", "completion": "    if n < 4:\n        return n > 1\n    elif n % 2 == 0:  # 2是质数\n        return False\n    else:\n        d = 3\n        while d * d <= n:\n            if n % d == 0:\n                return False\n            d += 2\n        return True\n\n\ndef prime_nums(n):\n    \"\"\"求1~n之间的质数\"\"\"\n    if n < 2:\n        return\n    prime_nums = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_nums.append(i)\n    print(prime_nums)\n\n\ndef get_primes(n):\n    \"\"\"1~n之间的质数\"\"\"\n    print(list(filter(is_prime, range(n + 1))))\n\n\ndef prime_factors(n):\n    \"\"\"求质因数\"\"\"\n    if n <= 0:\n        return None\n    if n < 4:\n        return n\n    else:\n        total = n", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 4:\n        return n > 1\n    elif n % 2 == 0:  # 2是质数\n        return False\n    else:\n        d = 3\n        while d * d <= n:\n            if n % d == 0:\n                return False\n            d += 2\n        return True\n\n\ndef prime_nums(n):\n    \"\"\"求1~n之间的质数\"\"\"\n    if n < 2:\n        return\n    prime_nums = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_nums.append(i)\n    print(prime_nums)\n\n\ndef get_primes(n):\n    \"\"\"1~n之间的质数\"\"\"\n    print(list(filter(is_prime, range(n + 1))))\n\n\ndef prime_factors(n):\n    \"\"\"求质因数\"\"\"\n    if n <= 0:\n        return None\n    if n < 4:\n        return n\n    else:\n        total = n"}
{"task_id": "HumanEval/31", "completion": "    if n <= 3:\n        return n >= 2\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef print_prime(n):\n    \"\"\"打印小于给定数字的质数   >>> print_prime(100)\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n    53\n    59\n    61\n    67\n    71\n    73\n    79\n    >>> print_prime(200)\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 3:\n        return n >= 2\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef print_prime(n):\n    \"\"\"打印小于给定数字的质数   >>> print_prime(100)\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n    53\n    59\n    61\n    67\n    71\n    73\n    79\n    >>> print_prime(200)\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    "}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    # 首先把所有的偶数排除掉\n    if not n & 1:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef count_primes(n):\n    \"\"\"计算从1到n的质数个数\n    >>> count_primes(100)\n    168\n    >>> count_primes(1000)\n    1229\n    >>> count_primes(20000)\n    10160\n    \"\"\"\n    return sum(is_prime(i) for i in xrange(1, n + 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    # 首先把所有的偶数排除掉\n    if not n & 1:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef count_primes(n):\n    \"\"\"计算从1到n的质数个数\n    >>> count_primes(100)\n    168\n    >>> count_primes(1000)\n    1229\n    >>> count_primes(20000)\n    10160\n    \"\"\"\n    return sum(is_prime(i) for i in xrange(1, n + 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            return False\n    return True\n\n\n# 素数个数   素数出现个数\ndef count_prime_number(n):\n    \"\"\"\n    根据质数的定义，如果一个大于1的自然数N没有被\n    分解成比它小的数之和，那么N就是质数。\n    判断一个数是否是质数使用\n    is_prime\n    \"\"\"\n    # 0和1不是质数\n    if n <= 1:\n        return 0\n    prime = 0\n    # 2到n之间的数遍历\n    for i in range(2, n):\n        # 不是质数\n        if is_prime(i) is False:\n            continue\n        prime += 1\n        # 将当前数分解质因数\n        while n % i == 0:\n            ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            return False\n    return True\n\n\n# 素数个数   素数出现个数\ndef count_prime_number(n):\n    \"\"\"\n    根据质数的定义，如果一个大于1的自然数N没有被\n    分解成比它小的数之和，那么N就是质数。\n    判断一个数是否是质数使用\n    is_prime\n    \"\"\"\n    # 0和1不是质数\n    if n <= 1:\n        return 0\n    prime = 0\n    # 2到n之间的数遍历\n    for i in range(2, n):\n        # 不是质数\n        if is_prime(i) is False:\n            continue\n        prime += 1\n        # 将当前数分解质因数\n        while n % i == 0:\n            "}
{"task_id": "HumanEval/31", "completion": "    if n >= 2:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        else:\n            return True\n    elif n == 1:\n        return False\n    elif n == 2:\n        return True\n\n\ndef prime_range(n):\n    \"\"\"\n    生成一个质数表，由函数 prime_numbers() 生成\n    :param n: 生成的质数个数\n    :return: 生成的质数表\n    >>> prime_range(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    >>> prime_range(0)\n    []\n    >>> prime_range(-10)\n    []\n    >>> prime_range(1)\n    [2]\n    >>> prime_range(3)\n    [2, 3, 5]\n    >>> prime_range(4)\n    [2, 3, 5, 7]\n    \"\"\"\n    if n >", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n >= 2:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        else:\n            return True\n    elif n == 1:\n        return False\n    elif n == 2:\n        return True\n\n\ndef prime_range(n):\n    \"\"\"\n    生成一个质数表，由函数 prime_numbers() 生成\n    :param n: 生成的质数个数\n    :return: 生成的质数表\n    >>> prime_range(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    >>> prime_range(0)\n    []\n    >>> prime_range(-10)\n    []\n    >>> prime_range(1)\n    [2]\n    >>> prime_range(3)\n    [2, 3, 5]\n    >>> prime_range(4)\n    [2, 3, 5, 7]\n    \"\"\"\n    if n >"}
{"task_id": "HumanEval/31", "completion": "    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        i = 3\n        while i <= n ** 0.5:\n            if n % i == 0:\n                return False\n            i += 2\n    return True\n\n\ndef is_prime2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime2(6)\n    False\n    >>> is_prime2(101)\n    True\n    >>> is_prime2(11)\n    True\n    >>> is_prime2(13441)\n    True\n    >>> is_prime2(61)\n    True\n    >>> is_prime2(4)\n    False\n    >>> is_prime2(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        i = 3\n        while i <= n ** 0.5:\n            if n % i == 0:\n                return False\n            i += 2\n    return True\n\n\ndef is_prime2(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false\n    >>> is_prime2(6)\n    False\n    >>> is_prime2(101)\n    True\n    >>> is_prime2(11)\n    True\n    >>> is_prime2(13441)\n    True\n    >>> is_prime2(61)\n    True\n    >>> is_prime2(4)\n    False\n    >>> is_prime2(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    "}
{"task_id": "HumanEval/31", "completion": "    if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n >= 3 and n % 2 == 1:\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\n\ndef prime_less_x(x):\n    \"\"\"找出小于x的所有质数\n    >>> for n in prime_less_x(300):\n    ...    print(n)\n    ...\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n    53\n    59\n    61\n    67\n    71\n    73\n    \"\"\"\n    count = 1\n    while count <= x:\n        if is_prime(count):\n            yield count\n        count += 1\n\n\ndef prime_", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n >= 3 and n % 2 == 1:\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\n\ndef prime_less_x(x):\n    \"\"\"找出小于x的所有质数\n    >>> for n in prime_less_x(300):\n    ...    print(n)\n    ...\n    2\n    3\n    5\n    7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n    53\n    59\n    61\n    67\n    71\n    73\n    \"\"\"\n    count = 1\n    while count <= x:\n        if is_prime(count):\n            yield count\n        count += 1\n\n\ndef prime_"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    last = object()\n    for i, item in enumerate(l):\n        if item != last:\n            yield item\n            last = item\n\n\ndef intersection(l1, l2):\n    \"\"\"返回l1和l2的交集    >>> intersection([1,2], [2,3])\n    [2]\n    \"\"\"\n    return list(set(l1) & set(l2))\n\n\ndef union(l1, l2):\n    \"\"\"返回列表l1与列表l2的并集    >>> union([1,2], [2,3])\n    [1, 2, 3]\n    \"\"\"\n    return list(set(l1) | set(l2))\n\n\ndef set_diff(l1, l2):\n    \"\"\"返回列表l1与列表l2的差集    >>> set_diff([1,2], [2,3])\n    [1]\n    \"\"\"\n    return list(set(l1) - set(l2))\n\n\ndef symmetric_diff(l1, l2):\n    \"\"\"返回列表l1", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    last = object()\n    for i, item in enumerate(l):\n        if item != last:\n            yield item\n            last = item\n\n\ndef intersection(l1, l2):\n    \"\"\"返回l1和l2的交集    >>> intersection([1,2], [2,3])\n    [2]\n    \"\"\"\n    return list(set(l1) & set(l2))\n\n\ndef union(l1, l2):\n    \"\"\"返回列表l1与列表l2的并集    >>> union([1,2], [2,3])\n    [1, 2, 3]\n    \"\"\"\n    return list(set(l1) | set(l2))\n\n\ndef set_diff(l1, l2):\n    \"\"\"返回列表l1与列表l2的差集    >>> set_diff([1,2], [2,3])\n    [1]\n    \"\"\"\n    return list(set(l1) - set(l2))\n\n\ndef symmetric_diff(l1, l2):\n    \"\"\"返回列表l1"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    return [l[i] for i in range(1, len(l)) if l[i] != l[i - 1]]\n\n\ndef flatten(l: list):\n    \"\"\"将多层嵌套列表展平   将多个列表展平，而列表元素也递归展平    >>> flatten([[[1]], [3, [4]]])\n    [1, 3, 4]\n    \"\"\"\n    return [i for s in l for i in s]\n\n\ndef add(*args):\n    \"\"\"将多个数字相加    >>> add(1, 2, 3)\n    6\n    \"\"\"\n    ax = 0\n    for num in args:\n        ax = ax + num\n    return ax\n\n\ndef minus(a, *args):\n    \"\"\"减去多个数字相加    >>> minus(5, 1, 2, 3)\n    -5\n    \"\"\"\n    ax = a\n    for num in args:\n        ax = ax - num\n    return ax\n\n\ndef multiplication(a, *args):\n    \"\"\"将多个", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return [l[i] for i in range(1, len(l)) if l[i] != l[i - 1]]\n\n\ndef flatten(l: list):\n    \"\"\"将多层嵌套列表展平   将多个列表展平，而列表元素也递归展平    >>> flatten([[[1]], [3, [4]]])\n    [1, 3, 4]\n    \"\"\"\n    return [i for s in l for i in s]\n\n\ndef add(*args):\n    \"\"\"将多个数字相加    >>> add(1, 2, 3)\n    6\n    \"\"\"\n    ax = 0\n    for num in args:\n        ax = ax + num\n    return ax\n\n\ndef minus(a, *args):\n    \"\"\"减去多个数字相加    >>> minus(5, 1, 2, 3)\n    -5\n    \"\"\"\n    ax = a\n    for num in args:\n        ax = ax - num\n    return ax\n\n\ndef multiplication(a, *args):\n    \"\"\"将多个"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    return [l[0]] + [l[i] for i in range(1, len(l)) if l[i] != l[i - 1]]\n\n\ndef get_diff_keys(d1: dict, d2: dict):\n    \"\"\"返回两个字典中不同的键。    >>> d1 = {'a': 1, 'b': 2, 'c': 3}    >>> d2 = {'b': 2, 'c': 4}    >>> get_diff_keys(d1, d2)\n    ['a']    >>> d3 = {'a': 1, 'b': 2, 'c': 3}    >>> d4 = {'b': 2, 'c': 3}    >>> get_diff_keys(d3, d4)\n    []    \"\"\"\n    diff_keys = set(list(d1.keys()))\n    diff_keys = diff_keys.symmetric_difference(set(list(d2.keys())))\n    return list(diff_keys)\n\n\ndef get_intersection_keys(d1: dict", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return [l[0]] + [l[i] for i in range(1, len(l)) if l[i] != l[i - 1]]\n\n\ndef get_diff_keys(d1: dict, d2: dict):\n    \"\"\"返回两个字典中不同的键。    >>> d1 = {'a': 1, 'b': 2, 'c': 3}    >>> d2 = {'b': 2, 'c': 4}    >>> get_diff_keys(d1, d2)\n    ['a']    >>> d3 = {'a': 1, 'b': 2, 'c': 3}    >>> d4 = {'b': 2, 'c': 3}    >>> get_diff_keys(d3, d4)\n    []    \"\"\"\n    diff_keys = set(list(d1.keys()))\n    diff_keys = diff_keys.symmetric_difference(set(list(d2.keys())))\n    return list(diff_keys)\n\n\ndef get_intersection_keys(d1: dict"}
{"task_id": "HumanEval/34", "completion": "    s = []\n    for t in sorted(l):\n        if t not in s:\n            s.append(t)\n    return s\n\n\ndef invert(d: dict):\n    \"\"\"将字典的值反转，返回一个以值作为键值，以键作为值值的新的字典。\n    >>> invert({3:'foo', 2:'bar', 4:'bar'})\n    {'bar': 2, 'foo': 3, 4: 4}\n    \"\"\"\n    inverted_dict = {}\n    for key in d:\n        inverted_dict[d[key]] = key\n    return inverted_dict\n\n\ndef invert_dict_recursive(d: dict):\n    \"\"\"将一个字典的值反转，但同时保持两个键与值一一对应。\n    >>> invert_dict_recursive({3:'foo', 2:'bar', 4:'bar'})\n    {'foo': 3, 'bar': 4}\n    \"\"\"\n    inverted_dict = {}\n    for key in d:\n        inverted_dict[d[key]] =", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    s = []\n    for t in sorted(l):\n        if t not in s:\n            s.append(t)\n    return s\n\n\ndef invert(d: dict):\n    \"\"\"将字典的值反转，返回一个以值作为键值，以键作为值值的新的字典。\n    >>> invert({3:'foo', 2:'bar', 4:'bar'})\n    {'bar': 2, 'foo': 3, 4: 4}\n    \"\"\"\n    inverted_dict = {}\n    for key in d:\n        inverted_dict[d[key]] = key\n    return inverted_dict\n\n\ndef invert_dict_recursive(d: dict):\n    \"\"\"将一个字典的值反转，但同时保持两个键与值一一对应。\n    >>> invert_dict_recursive({3:'foo', 2:'bar', 4:'bar'})\n    {'foo': 3, 'bar': 4}\n    \"\"\"\n    inverted_dict = {}\n    for key in d:\n        inverted_dict[d[key]] ="}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    return list(itertools.ifilterfalse(lambda x: l[1:].count(x) != 0, l))\n\n\ndef dict_is_empty(d: dict) -> bool:\n    \"\"\"检查字典是否为空\n    >>> print(dict_is_empty({'a': 1, 'b': 1}))\n    False\n    >>> print(dict_is_empty({}))\n    True\n    \"\"\"\n    return bool(len(d))\n\n\ndef dict_to_tuple(d: dict) -> tuple:\n    \"\"\"\n    将字典转换为元组，以便进行比较\n    >>> dict_to_tuple({'a': 1, 'b': 2})\n    (('a', 1), ('b', 2))\n    \"\"\"\n    return tuple(sorted(d.items()))\n\n\ndef dict_from_keys_to_list(d: dict) -> list:\n    \"\"\"\n    将字典转换为列表，以便进行比较\n    >>> dict_from_keys_to_list({'a': 1", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return list(itertools.ifilterfalse(lambda x: l[1:].count(x) != 0, l))\n\n\ndef dict_is_empty(d: dict) -> bool:\n    \"\"\"检查字典是否为空\n    >>> print(dict_is_empty({'a': 1, 'b': 1}))\n    False\n    >>> print(dict_is_empty({}))\n    True\n    \"\"\"\n    return bool(len(d))\n\n\ndef dict_to_tuple(d: dict) -> tuple:\n    \"\"\"\n    将字典转换为元组，以便进行比较\n    >>> dict_to_tuple({'a': 1, 'b': 2})\n    (('a', 1), ('b', 2))\n    \"\"\"\n    return tuple(sorted(d.items()))\n\n\ndef dict_from_keys_to_list(d: dict) -> list:\n    \"\"\"\n    将字典转换为列表，以便进行比较\n    >>> dict_from_keys_to_list({'a': 1"}
{"task_id": "HumanEval/34", "completion": "    return list({}.fromkeys(l).keys())\n\n\ndef set_diff(l1: list, l2: list):\n    \"\"\"返回列表1与2之间在彼此之?中的元素\n    >>>set_diff([2,3,4],[1,2,3,4,5])\n    [5]\n    \"\"\"\n    return list(set(l1).difference(l2))\n\n\ndef dict_merge(dict1: dict, dict2: dict):\n    \"\"\"合并两个可迭代对象，返回其中键值对合并后的字典\n    >>> dict_merge({2: 1, 3: 4, 4: 100}, {3: 55, 4: 999})\n    {2: 1, 3: 55, 4: 1000}\n    \"\"\"\n    return dict(chain(dict1.items(), dict2.items()))\n\n\ndef dict_slice(source_dict: dict, *args):\n    \"\"\"使用*args生成字典中需要的键，返回与*args相匹配的键值对字典", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list({}.fromkeys(l).keys())\n\n\ndef set_diff(l1: list, l2: list):\n    \"\"\"返回列表1与2之间在彼此之?中的元素\n    >>>set_diff([2,3,4],[1,2,3,4,5])\n    [5]\n    \"\"\"\n    return list(set(l1).difference(l2))\n\n\ndef dict_merge(dict1: dict, dict2: dict):\n    \"\"\"合并两个可迭代对象，返回其中键值对合并后的字典\n    >>> dict_merge({2: 1, 3: 4, 4: 100}, {3: 55, 4: 999})\n    {2: 1, 3: 55, 4: 1000}\n    \"\"\"\n    return dict(chain(dict1.items(), dict2.items()))\n\n\ndef dict_slice(source_dict: dict, *args):\n    \"\"\"使用*args生成字典中需要的键，返回与*args相匹配的键值对字典"}
{"task_id": "HumanEval/34", "completion": "\n    # l1 = l[:]\n    # l1.sort()\n    # print(l1)\n    # l3 = [l1[0]]\n    # for i in range(1, len(l1)):\n    #     if l1[i] != l1[i-1]:\n    #         l3.append(l1[i])\n    # return l3\n\n    # l1 = l[:]\n    # l1.sort()\n    # print(l1)\n    # l3 = []\n    # for i in range(1, len(l1)):\n    #     if l1[i] != l1[i-1]:\n    #         l3.append(l1[i])\n    return list(set(l))\n\n\ndef uniq(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n    # l1 = l[:]\n    # l1.sort()\n    # print(l1)\n    # l3 = [l1[0]]\n    # for i in range(1, len(l1)):\n    #     if l1[i] != l1[i-1]:\n    #         l3.append(l1[i])\n    # return l3\n\n    # l1 = l[:]\n    # l1.sort()\n    # print(l1)\n    # l3 = []\n    # for i in range(1, len(l1)):\n    #     if l1[i] != l1[i-1]:\n    #         l3.append(l1[i])\n    return list(set(l))\n\n\ndef uniq(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123"}
{"task_id": "HumanEval/34", "completion": "    return list(set(l))\n\n\ndef sort(l, func):\n    \"\"\"\n    Return a list of `l` elements, sorted using a function `func`\n    >>> sort([{'a': 1, 'b': 5}, {'a': 2, 'b': 0}, {'a': 0, 'b': 3}], lambda x: x['a'])\n    [{'a': 0, 'b': 3}, {'a': 0, 'b': 5}, {'a': 2, 'b': 0}]\n    \"\"\"\n    return sorted(l, key=func)\n\n\ndef groupby(l, func):\n    \"\"\"Return a dict of {func(key): values} grouped by keys.\"\"\"\n    ret = {}\n    for v in l:\n        key = func(v)\n        if ret.get(key) is None:\n            ret[key] = [v]\n        else:\n            ret[key].append(v)\n    return ret\n\n\ndef remove_empty(l):\n    \"\"\"Return a list of `l` without None", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n\n\ndef sort(l, func):\n    \"\"\"\n    Return a list of `l` elements, sorted using a function `func`\n    >>> sort([{'a': 1, 'b': 5}, {'a': 2, 'b': 0}, {'a': 0, 'b': 3}], lambda x: x['a'])\n    [{'a': 0, 'b': 3}, {'a': 0, 'b': 5}, {'a': 2, 'b': 0}]\n    \"\"\"\n    return sorted(l, key=func)\n\n\ndef groupby(l, func):\n    \"\"\"Return a dict of {func(key): values} grouped by keys.\"\"\"\n    ret = {}\n    for v in l:\n        key = func(v)\n        if ret.get(key) is None:\n            ret[key] = [v]\n        else:\n            ret[key].append(v)\n    return ret\n\n\ndef remove_empty(l):\n    \"\"\"Return a list of `l` without None"}
{"task_id": "HumanEval/34", "completion": "    l.sort()\n    k = l[0]\n    for i in range(1, len(l)):\n        if l[i] == k:\n            k = None\n        else:\n            k = l[i]\n            return l[:i]", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    k = l[0]\n    for i in range(1, len(l)):\n        if l[i] == k:\n            k = None\n        else:\n            k = l[i]\n            return l[:i]"}
{"task_id": "HumanEval/34", "completion": "    if l is None:\n        return None\n    else:\n        l.sort()\n        y = []\n        for x in l:\n            if x not in y:\n                y.append(x)\n        return y\n\n\ndef flatten(l: list):\n    \"\"\"\n    将列表中嵌套的列表展平\n    >>> flatten([1,2,3, [4,5, [6]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    result = []\n    for element in l:\n        if isinstance(element, list):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\ndef flatten2(l: list):\n    \"\"\"\n    展平嵌套列表\n    >>> flatten([1,2,3, [4,5, [6]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n\n    def _flatten(l):\n        result = []\n        if isinstance(l, list):", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if l is None:\n        return None\n    else:\n        l.sort()\n        y = []\n        for x in l:\n            if x not in y:\n                y.append(x)\n        return y\n\n\ndef flatten(l: list):\n    \"\"\"\n    将列表中嵌套的列表展平\n    >>> flatten([1,2,3, [4,5, [6]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    result = []\n    for element in l:\n        if isinstance(element, list):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\ndef flatten2(l: list):\n    \"\"\"\n    展平嵌套列表\n    >>> flatten([1,2,3, [4,5, [6]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n\n    def _flatten(l):\n        result = []\n        if isinstance(l, list):"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/35", "completion": "    if not isinstance(l, list):\n        return\n    return reduce(lambda i, j: i if i > j else j, l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([4, 3, 2, 1])\n    1\n    >>> min_element([5, 3, -5, -3, 2, -2])\n    -5\n    \"\"\"\n    if not isinstance(l, list):\n        return\n    return reduce(lambda i, j: i if i < j else j, l)\n\n\ndef reverse_list(l: list):\n    \"\"\"反转列表    >>> reverse_list([4, 3, 2, 1])\n    [1, 2, 3, 4]\n    >>> reverse_list([5, 3, -5, -3, 3, 2, -2])\n    [-2, -3, 2, 3, -5, 5]\n    \"\"\"\n    if not isinstance(l, list):\n        return\n    return l[::-1]", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not isinstance(l, list):\n        return\n    return reduce(lambda i, j: i if i > j else j, l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([4, 3, 2, 1])\n    1\n    >>> min_element([5, 3, -5, -3, 2, -2])\n    -5\n    \"\"\"\n    if not isinstance(l, list):\n        return\n    return reduce(lambda i, j: i if i < j else j, l)\n\n\ndef reverse_list(l: list):\n    \"\"\"反转列表    >>> reverse_list([4, 3, 2, 1])\n    [1, 2, 3, 4]\n    >>> reverse_list([5, 3, -5, -3, 3, 2, -2])\n    [-2, -3, 2, 3, -5, 5]\n    \"\"\"\n    if not isinstance(l, list):\n        return\n    return l[::-1]"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef remove_element(l: list, num: int):\n    \"\"\"删除列表中所有的目标元素    >>> remove_element([1, 2, 3, 2, 2, 3, 2], 2)\n    [1, 3, 3, 3, 2, 2, 3]\n    >>> remove_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n    [5, 3, -5, 2, -3, 3, 9, 123, 1, -10", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef remove_element(l: list, num: int):\n    \"\"\"删除列表中所有的目标元素    >>> remove_element([1, 2, 3, 2, 2, 3, 2], 2)\n    [1, 3, 3, 3, 2, 2, 3]\n    >>> remove_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n    [5, 3, -5, 2, -3, 3, 9, 123, 1, -10"}
{"task_id": "HumanEval/35", "completion": "    max_elem = l[0]\n    for i in l:\n        if max_elem < i:\n            max_elem = i\n    return max_elem\n\n\ndef max_of_min(l: list):\n    \"\"\"返回列表中的最小元素  >>> max_of_min([1, 2, 3])\n    2\n    >>> max_of_min([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_elem = l[0]\n    for i in l:\n        if min_elem > i:\n            min_elem = i\n    return min_elem\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素  >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_elem = l[0]\n    for i in l:\n        if max_elem < i:\n            max_elem = i\n    return max_elem\n\n\ndef max_of_min(l: list):\n    \"\"\"返回列表中的最小元素  >>> max_of_min([1, 2, 3])\n    2\n    >>> max_of_min([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_elem = l[0]\n    for i in l:\n        if min_elem > i:\n            min_elem = i\n    return min_elem\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素  >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\n\ndef sum_elements(l: list):\n    \"\"\"返回列表中的所有元素之和    >>> sum_elements([1, 2, 3])\n    6\n    >>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    124\n    \"\"\"\n    sum_temp = 0\n    for i in l:\n        sum_temp = sum_temp + i\n    return sum_temp\n\n\ndef sorted_sequence(l: list):\n    \"\"\"按升序返回列表中的元素    >>> sorted_sequence([1, 2, 3])\n    [1, 2, 3]\n    >>> sorted_sequence([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [0, 1, 2, 3, 3, 5, 9, 123, 10, -3", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\n\ndef sum_elements(l: list):\n    \"\"\"返回列表中的所有元素之和    >>> sum_elements([1, 2, 3])\n    6\n    >>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    124\n    \"\"\"\n    sum_temp = 0\n    for i in l:\n        sum_temp = sum_temp + i\n    return sum_temp\n\n\ndef sorted_sequence(l: list):\n    \"\"\"按升序返回列表中的元素    >>> sorted_sequence([1, 2, 3])\n    [1, 2, 3]\n    >>> sorted_sequence([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [0, 1, 2, 3, 3, 5, 9, 123, 10, -3"}
{"task_id": "HumanEval/35", "completion": "    l.sort(reverse=True)\n    return l[0]\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素     >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    l.sort()\n    return l[0]\n\n\ndef remove_duplicates(l: list):\n    \"\"\"删除列表中的重复项     >>> remove_duplicates([1, 2, 3])\n    [1, 2, 3]\n    >>> remove_duplicates([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, 2, -3, 3, 9, 0, 123, 1, -10]\n    \"\"\"\n    new_l = []\n", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    l.sort(reverse=True)\n    return l[0]\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素     >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    l.sort()\n    return l[0]\n\n\ndef remove_duplicates(l: list):\n    \"\"\"删除列表中的重复项     >>> remove_duplicates([1, 2, 3])\n    [1, 2, 3]\n    >>> remove_duplicates([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, 2, -3, 3, 9, 0, 123, 1, -10]\n    \"\"\"\n    new_l = []\n"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef average(l: list):\n    \"\"\"返回列表的平均数    >>> average([1, 2, 3])\n    2.0\n    >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    21.0\n    \"\"\"\n    return sum(l) / len(l)\n\n\ndef product(l: list):\n    \"\"\"返回列表中所有数的乘积    >>> product([1, 2, 3])\n    6\n    >>> product([5, 3, -5, 2, -3, 3, 9, ", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef average(l: list):\n    \"\"\"返回列表的平均数    >>> average([1, 2, 3])\n    2.0\n    >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    21.0\n    \"\"\"\n    return sum(l) / len(l)\n\n\ndef product(l: list):\n    \"\"\"返回列表中所有数的乘积    >>> product([1, 2, 3])\n    6\n    >>> product([5, 3, -5, 2, -3, 3, 9, "}
{"task_id": "HumanEval/35", "completion": "    if l == []:\n        return\n    max = l[0]\n    for i in l:\n        if i > max:\n            max = i\n    return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if l == []:\n        return\n    min = l[0]\n    for i in l:\n        if i < min:\n            min = i\n    return min\n\n\ndef max_min_element(l: list):\n    if l == []:\n        return\n    max = l[0]\n    min = l[0]\n    for i in l:\n        if i > max:\n            max = i\n        if i < min:\n            min = i\n    return max, min\n\n\nif __name__ == \"__main__", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if l == []:\n        return\n    max = l[0]\n    for i in l:\n        if i > max:\n            max = i\n    return max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    if l == []:\n        return\n    min = l[0]\n    for i in l:\n        if i < min:\n            min = i\n    return min\n\n\ndef max_min_element(l: list):\n    if l == []:\n        return\n    max = l[0]\n    min = l[0]\n    for i in l:\n        if i > max:\n            max = i\n        if i < min:\n            min = i\n    return max, min\n\n\nif __name__ == \"__main__"}
{"task_id": "HumanEval/35", "completion": "    max_ele = None\n    for ele in l:\n        if max_ele is None or ele > max_ele:\n            max_ele = ele\n    return max_ele", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_ele = None\n    for ele in l:\n        if max_ele is None or ele > max_ele:\n            max_ele = ele\n    return max_ele"}
{"task_id": "HumanEval/35", "completion": "    if len(l) == 0:\n        return None\n    m = l[0]\n    for i in range(1, len(l)):\n        if l[i] > m:\n            m = l[i]\n    return m\n\n\ndef max_elements(l: list):\n    \"\"\"返回列表中的最大元素, 多个返回第一个     >>> max_elements([1, 2, 3])\n    3\n    >>> max_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        return None\n    m = l[0]\n    for i in range(1, len(l)):\n        if l[i] > m:\n            m = l[i]\n    return m\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5,", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        return None\n    m = l[0]\n    for i in range(1, len(l)):\n        if l[i] > m:\n            m = l[i]\n    return m\n\n\ndef max_elements(l: list):\n    \"\"\"返回列表中的最大元素, 多个返回第一个     >>> max_elements([1, 2, 3])\n    3\n    >>> max_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        return None\n    m = l[0]\n    for i in range(1, len(l)):\n        if l[i] > m:\n            m = l[i]\n    return m\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5,"}
{"task_id": "HumanEval/36", "completion": "    return fizz_and_buzz(n, 7)\n\n\ndef fizz_and_buzz(n: int, divisor: int) -> int:\n    \"\"\"返回在能同时被 divisor 和(divisor+1) 整除的小于n 的整数中，数字divisor 出现的次数    >>> fizz_and_buzz(50, 5)\n    0\n    >>> fizz_and_buzz(50, 7)\n    1\n    >>> fizz_and_buzz(61, 7)\n    4\"\"\"\n    counter = 0\n    for i in range(1, n):\n        if i % (divisor) == 0 and i % (divisor + 1) == 0:\n            counter += 1\n    return counter\n\n\ndef test_fizz_buzz():\n    assert fizz_and_buzz(0, 0) == 1\n    assert fizz_buzz(50) == 0\n    assert fizz_buzz(78) == 2\n\n\ndef test_fizz_", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return fizz_and_buzz(n, 7)\n\n\ndef fizz_and_buzz(n: int, divisor: int) -> int:\n    \"\"\"返回在能同时被 divisor 和(divisor+1) 整除的小于n 的整数中，数字divisor 出现的次数    >>> fizz_and_buzz(50, 5)\n    0\n    >>> fizz_and_buzz(50, 7)\n    1\n    >>> fizz_and_buzz(61, 7)\n    4\"\"\"\n    counter = 0\n    for i in range(1, n):\n        if i % (divisor) == 0 and i % (divisor + 1) == 0:\n            counter += 1\n    return counter\n\n\ndef test_fizz_buzz():\n    assert fizz_and_buzz(0, 0) == 1\n    assert fizz_buzz(50) == 0\n    assert fizz_buzz(78) == 2\n\n\ndef test_fizz_"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += 1\n        elif i % 11 == 0:\n            count += 1\n        elif i % 13 == 0:\n            count += 1\n        elif i % 11 == 7:\n            count += 1\n        elif i % 13 == 7:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(fizz_buzz(13))\n    print(fizz_buzz(15))\n    print(fizz_buzz(17))\n    print(fizz_buzz(20))\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += 1\n        elif i % 11 == 0:\n            count += 1\n        elif i % 13 == 0:\n            count += 1\n        elif i % 11 == 7:\n            count += 1\n        elif i % 13 == 7:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(fizz_buzz(13))\n    print(fizz_buzz(15))\n    print(fizz_buzz(17))\n    print(fizz_buzz(20))\n    print(fizz_buzz(50))\n    print(fizz_buzz(78))\n    print(fizz_buzz(79))"}
{"task_id": "HumanEval/36", "completion": "    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += 3\n        elif i % 11 == 0:\n            count += 1\n        elif i % 13 == 0:\n            count += 1\n        elif i % 11 == 7 or i % 13 == 7:\n            count += 1\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 and i % 13 == 0:\n            count += 3\n        elif i % 11 == 0:\n            count += 1\n        elif i % 13 == 0:\n            count += 1\n        elif i % 11 == 7 or i % 13 == 7:\n            count += 1\n\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/36", "completion": "    return sum(\n        [k for k in range(1, n + 1) if k % 11 == 0 or k % 13 == 0 and not k % 7 == 0]\n    )\n\n\nif __name__ == \"__main__\":\n    # pass\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum(\n        [k for k in range(1, n + 1) if k % 11 == 0 or k % 13 == 0 and not k % 7 == 0]\n    )\n\n\nif __name__ == \"__main__\":\n    # pass\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/36", "completion": "    return sum(1 for i in range(1, n) if i % 11 == 0 and i % 13 == 0 and i % 7 == 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum(1 for i in range(1, n) if i % 11 == 0 and i % 13 == 0 and i % 7 == 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/36", "completion": "    result, factor = 0, 11\n    while factor <= n:\n        result += n // factor % 10 == 7\n        factor = factor * 10\n    return result\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        print(fizz_buzz(n))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    result, factor = 0, 11\n    while factor <= n:\n        result += n // factor % 10 == 7\n        factor = factor * 10\n    return result\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        print(fizz_buzz(n))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/36", "completion": "    sum = 0\n    for i in range(1, n + 1):\n        if is_fizzbuzz(i):\n            sum += 1\n    return sum\n\n\nif __name__ == \"__main__\":\n    with open(\"fizzbuzz.txt\") as file:\n        n = int(file.read())\n    print fizz_buzz(n)", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        if is_fizzbuzz(i):\n            sum += 1\n    return sum\n\n\nif __name__ == \"__main__\":\n    with open(\"fizzbuzz.txt\") as file:\n        n = int(file.read())\n    print fizz_buzz(n)"}
{"task_id": "HumanEval/36", "completion": "    if n < 1:\n        return 0\n    if n < 31:\n        return fizz_buzz(n - 1)\n    if not (n % 11) and not (n % 13):\n        return 1 + fizz_buzz(n - 1)\n    if not (n % 11):\n        return 1 + fizz_buzz(n - 1)\n    if not (n % 13):\n        return 1 + fizz_buzz(n - 1)\n    return fizz_buzz(n - 1)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n < 1:\n        return 0\n    if n < 31:\n        return fizz_buzz(n - 1)\n    if not (n % 11) and not (n % 13):\n        return 1 + fizz_buzz(n - 1)\n    if not (n % 11):\n        return 1 + fizz_buzz(n - 1)\n    if not (n % 13):\n        return 1 + fizz_buzz(n - 1)\n    return fizz_buzz(n - 1)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/36", "completion": "    i = 0\n    for num in range(1, n):\n        if num % 11 == 0 and num % 13 == 0:\n            i += 3\n        elif num % 11 == 0:\n            i += 2\n        elif num % 13 == 0:\n            i += 2\n        else:\n            i += 1\n    return i", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    i = 0\n    for num in range(1, n):\n        if num % 11 == 0 and num % 13 == 0:\n            i += 3\n        elif num % 11 == 0:\n            i += 2\n        elif num % 13 == 0:\n            i += 2\n        else:\n            i += 1\n    return i"}
{"task_id": "HumanEval/36", "completion": "    return sum([int(str(i).replace('7', '2')) for i in range(1, n + 1)\n                if str(i).replace('7', '2')[:2] == '11' or str(i).replace('7', '2')[:2] == '13'])", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return sum([int(str(i).replace('7', '2')) for i in range(1, n + 1)\n                if str(i).replace('7', '2')[:2] == '11' or str(i).replace('7', '2')[:2] == '13'])"}
{"task_id": "HumanEval/43", "completion": "    l = sorted(l)\n    for i, v in enumerate(l):\n        if v == 0:\n            # 列表中至少存在两个0\n            if i == 0:\n                continue\n            else:\n                target = -v\n                # 判断是否存在相加为target的两个数\n                if target in l[0:i] and target in l[i + 1:]:\n                    return True\n        else:\n            # 如果列表中含有2个非零数且和为0即为所求\n            # 因为已经排好序，所以前面的数肯定都小于0，后面的肯定都大于0\n            if target in l[0:i] and target in l[i + 1:]:\n                return True\n    return False\n\n\ndef sum_to_zero(l):\n    \"\"\"\n    sum_to_zero 将整数列表作为输入，如果列表中含有两个相同元素加起来的和为零，\n    则返回True，否则返回False    >>> sum_to_zero([1, 3, 5, 0])\n    False\n    >>> sum_to_zero([1, 3", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l = sorted(l)\n    for i, v in enumerate(l):\n        if v == 0:\n            # 列表中至少存在两个0\n            if i == 0:\n                continue\n            else:\n                target = -v\n                # 判断是否存在相加为target的两个数\n                if target in l[0:i] and target in l[i + 1:]:\n                    return True\n        else:\n            # 如果列表中含有2个非零数且和为0即为所求\n            # 因为已经排好序，所以前面的数肯定都小于0，后面的肯定都大于0\n            if target in l[0:i] and target in l[i + 1:]:\n                return True\n    return False\n\n\ndef sum_to_zero(l):\n    \"\"\"\n    sum_to_zero 将整数列表作为输入，如果列表中含有两个相同元素加起来的和为零，\n    则返回True，否则返回False    >>> sum_to_zero([1, 3, 5, 0])\n    False\n    >>> sum_to_zero([1, 3"}
{"task_id": "HumanEval/43", "completion": "    if len(l) == 1:\n        return False\n    if len(l) == 2:\n        return l[0] + l[1] == 0\n    else:\n        # 列表中前两个元素的和小于等于第三个元素的值\n        if sum(l[:2]) <= l[2]:\n            # 列表中前两个元素的和大于第三个元素的值，则返回False\n            if sum(l[:2]) > l[2]:\n                return False\n            else:\n                # 列表中前两个元素的和等于第三个元素的值，则再对列表进行切片，直到列表中只有两个元素\n                if sum(l[:2]) == l[2]:\n                    return pairs_sum_to_zero(l[2:])\n                # 列表中前两个元素的和小于等于第三个元素的值，则返回True\n                else:\n                    return True\n        else:\n            return False\n\n\n# 测试\ndef test():\n    import doctest\n\n    doctest.testmod()\n\n\n# 主程序入口\nif __name__ == \"__main__\":\n    test()", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) == 1:\n        return False\n    if len(l) == 2:\n        return l[0] + l[1] == 0\n    else:\n        # 列表中前两个元素的和小于等于第三个元素的值\n        if sum(l[:2]) <= l[2]:\n            # 列表中前两个元素的和大于第三个元素的值，则返回False\n            if sum(l[:2]) > l[2]:\n                return False\n            else:\n                # 列表中前两个元素的和等于第三个元素的值，则再对列表进行切片，直到列表中只有两个元素\n                if sum(l[:2]) == l[2]:\n                    return pairs_sum_to_zero(l[2:])\n                # 列表中前两个元素的和小于等于第三个元素的值，则返回True\n                else:\n                    return True\n        else:\n            return False\n\n\n# 测试\ndef test():\n    import doctest\n\n    doctest.testmod()\n\n\n# 主程序入口\nif __name__ == \"__main__\":\n    test()"}
{"task_id": "HumanEval/43", "completion": "    return False if len(l) < 2 else (any((x + y == 0) for x in l for y in l if x != y))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    return False if len(l) < 2 else (any((x + y == 0) for x in l for y in l if x != y))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/43", "completion": "    return any(a + b == 0 for a, b in combinations(l, 2))", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    return any(a + b == 0 for a, b in combinations(l, 2))"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(len(l) - 1):\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(len(l) - 1):\n        if l[i] + l[i + 1] == 0:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/43", "completion": "    s = set()\n    for i in l:\n        if -i in s:\n            return True\n        else:\n            s.add(i)\n    return False\n\n\ndef pairs_equal_sum(l):\n    \"\"\"\n    pairs_equal_sum 将整数列表作为输入，如果列表中有一个相同元素，\n    如果两个相同元素的和等于零，则返回True，否则返回False    >>> pairs_equal_sum([1, 3, 5, 0])\n    False\n    >>> pairs_equal_sum([1, 3, -2, 1])\n    True\n    >>> pairs_equal_sum([1, 2, 3, 7])\n    False\n    >>> pairs_equal_sum([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_equal_sum([1])\n    False\n    \"\"\"\n    s = set()\n    for i in l:\n        if i in s:\n            return True\n        else:\n            s.add(i)\n    return False\n\n\ndef check_pairs", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    s = set()\n    for i in l:\n        if -i in s:\n            return True\n        else:\n            s.add(i)\n    return False\n\n\ndef pairs_equal_sum(l):\n    \"\"\"\n    pairs_equal_sum 将整数列表作为输入，如果列表中有一个相同元素，\n    如果两个相同元素的和等于零，则返回True，否则返回False    >>> pairs_equal_sum([1, 3, 5, 0])\n    False\n    >>> pairs_equal_sum([1, 3, -2, 1])\n    True\n    >>> pairs_equal_sum([1, 2, 3, 7])\n    False\n    >>> pairs_equal_sum([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_equal_sum([1])\n    False\n    \"\"\"\n    s = set()\n    for i in l:\n        if i in s:\n            return True\n        else:\n            s.add(i)\n    return False\n\n\ndef check_pairs"}
{"task_id": "HumanEval/43", "completion": "\n    def _pairs_sum_to_zero(nums):\n        l = len(nums)\n        if l <= 1:\n            return False\n        else:\n            for i in range(l):\n                for j in range(i + 1, l):\n                    if nums[i] + nums[j] == 0:\n                        return True\n            return False\n\n    return _pairs_sum_to_zero(l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(\n        verbose=True,\n        extraglobs={\n            \"pairs_sum_to_zero\": pairs_sum_to_zero,\n            \"two_smallest\": two_smallest,\n            \"two_largest\": two_largest,\n            \"is_anagram\": is_anagram,\n            \"is_palindrome\": is_palindrome,\n        },\n    )", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n\n    def _pairs_sum_to_zero(nums):\n        l = len(nums)\n        if l <= 1:\n            return False\n        else:\n            for i in range(l):\n                for j in range(i + 1, l):\n                    if nums[i] + nums[j] == 0:\n                        return True\n            return False\n\n    return _pairs_sum_to_zero(l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(\n        verbose=True,\n        extraglobs={\n            \"pairs_sum_to_zero\": pairs_sum_to_zero,\n            \"two_smallest\": two_smallest,\n            \"two_largest\": two_largest,\n            \"is_anagram\": is_anagram,\n            \"is_palindrome\": is_palindrome,\n        },\n    )"}
{"task_id": "HumanEval/43", "completion": "    for i in range(0, len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\n# -----------------------------------------------\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for i in range(0, len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\n# -----------------------------------------------\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/43", "completion": "    if l != []:  # 判断列表是否为空\n        for i, j in enumerate(l):\n            for z in l[i + 1 :]:  # 遍历列表的剩余部分\n                if j + z == 0:  # 判断是否为0\n                    return True  # 返回ture\n    return False  # 返回False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if l != []:  # 判断列表是否为空\n        for i, j in enumerate(l):\n            for z in l[i + 1 :]:  # 遍历列表的剩余部分\n                if j + z == 0:  # 判断是否为0\n                    return True  # 返回ture\n    return False  # 返回False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/43", "completion": "    if not l:\n        return False\n\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\ndef max_consecutive_ones(n):\n    \"\"\"\n    max_consecutive_ones 将整数作为输入，如果整数比特为1的个数最多，则返回该数的值，\n    否则返回0    >>> max_consecutive_ones(1234)\n    0\n    >>> max_consecutive_ones(1000000000)\n    1000000000\n    >>> max_consecutive_ones(1111111111111111111111111)\n    1111111111111111111111111\n    >>> max_consecutive_ones(11111111111111", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if not l:\n        return False\n\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n\n\ndef max_consecutive_ones(n):\n    \"\"\"\n    max_consecutive_ones 将整数作为输入，如果整数比特为1的个数最多，则返回该数的值，\n    否则返回0    >>> max_consecutive_ones(1234)\n    0\n    >>> max_consecutive_ones(1000000000)\n    1000000000\n    >>> max_consecutive_ones(1111111111111111111111111)\n    1111111111111111111111111\n    >>> max_consecutive_ones(11111111111111"}
{"task_id": "HumanEval/52", "completion": "    return all(x < t for x in l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i < t:\n            continue\n        else:\n            return False\n    return True\n\n\ndef flatten(a: list):\n    \"\"\"将嵌套列表展平，生成一个列表，列表中没有嵌套列表。   >>> flatten([1, 2, 3, [4, 5], 6])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if len(a) == 0:\n        return []\n    elif type(a[0]) == list:\n        return flatten(a[0]) + flatten(a[1:])\n    else:\n        return a[:1] + flatten(a[1:])\n\n\ndef normal_sort(a: list):\n    \"\"\"\n    排序不规则列表   >>> normal_sort([3, 6, 1, [2, 5], 9])\n    [1, 3, 2, 5, 6, 9]\n    \"\"\"\n    l = a.copy()\n    l.sort(key=lambda x: len(x))", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i < t:\n            continue\n        else:\n            return False\n    return True\n\n\ndef flatten(a: list):\n    \"\"\"将嵌套列表展平，生成一个列表，列表中没有嵌套列表。   >>> flatten([1, 2, 3, [4, 5], 6])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if len(a) == 0:\n        return []\n    elif type(a[0]) == list:\n        return flatten(a[0]) + flatten(a[1:])\n    else:\n        return a[:1] + flatten(a[1:])\n\n\ndef normal_sort(a: list):\n    \"\"\"\n    排序不规则列表   >>> normal_sort([3, 6, 1, [2, 5], 9])\n    [1, 3, 2, 5, 6, 9]\n    \"\"\"\n    l = a.copy()\n    l.sort(key=lambda x: len(x))"}
{"task_id": "HumanEval/52", "completion": "    return all([i < t for i in l])\n\n\ndef max_subarray(l: list, x: int):\n    \"\"\"找到列表中所有和为 x 的子列表，并返回这些子列表的起始索引和结束索引构成的列表。\n    如果列表中不存在这样的子列表，则返回 None\n    >>> max_subarray([1, 2, 3, 4, 10], 15)\n    [1, 4]\n    >>> max_subarray([1, 2, 3, 4, 10], 2)\n    [1, 1]\n    >>> max_subarray([1, 2, 3, 4, 10], 11)\n    [3, 4]\n    >>> max_subarray([1, 2, 3, 4, 10], 20) # 只有一个子列表\n    [1, 5]\n    >>> max_subarray([1, 20, 3, 40, 50], 50)\n    [3, 4]\n    >>> max_", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all([i < t for i in l])\n\n\ndef max_subarray(l: list, x: int):\n    \"\"\"找到列表中所有和为 x 的子列表，并返回这些子列表的起始索引和结束索引构成的列表。\n    如果列表中不存在这样的子列表，则返回 None\n    >>> max_subarray([1, 2, 3, 4, 10], 15)\n    [1, 4]\n    >>> max_subarray([1, 2, 3, 4, 10], 2)\n    [1, 1]\n    >>> max_subarray([1, 2, 3, 4, 10], 11)\n    [3, 4]\n    >>> max_subarray([1, 2, 3, 4, 10], 20) # 只有一个子列表\n    [1, 5]\n    >>> max_subarray([1, 20, 3, 40, 50], 50)\n    [3, 4]\n    >>> max_"}
{"task_id": "HumanEval/52", "completion": "    # 异常处理\n    if not isinstance(t, int):\n        raise TypeError(\"TypeError\")\n    if not isinstance(l, list):\n        raise TypeError(\"TypeError\")\n    if len(l) == 0:\n        raise ValueError(\"l can not be empty\")\n    # 异常处理结束\n    for i in l:\n        if i > t:\n            return False\n    return True\n\n\ndef is_sorted(l: list):\n    \"\"\"如果列表 l 排序正确则返回 True，否则返回 False。   >>> is_sorted([\"b\", \"a\", \"c\"])\n    True\n    >>> is_sorted([\"c\", \"a\", \"b\"])\n    False\n    \"\"\"\n    for i in range(0, len(l) - 1):\n        if l[i] > l[i + 1]:\n            return False\n    return True\n\n\ndef linear_merge(l1: list, l2: list):\n    \"\"\"合并两个排序列表 l1 和 l2 并将其合并到一个列表中，其中元素已按升序排序。   >>> linear", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    # 异常处理\n    if not isinstance(t, int):\n        raise TypeError(\"TypeError\")\n    if not isinstance(l, list):\n        raise TypeError(\"TypeError\")\n    if len(l) == 0:\n        raise ValueError(\"l can not be empty\")\n    # 异常处理结束\n    for i in l:\n        if i > t:\n            return False\n    return True\n\n\ndef is_sorted(l: list):\n    \"\"\"如果列表 l 排序正确则返回 True，否则返回 False。   >>> is_sorted([\"b\", \"a\", \"c\"])\n    True\n    >>> is_sorted([\"c\", \"a\", \"b\"])\n    False\n    \"\"\"\n    for i in range(0, len(l) - 1):\n        if l[i] > l[i + 1]:\n            return False\n    return True\n\n\ndef linear_merge(l1: list, l2: list):\n    \"\"\"合并两个排序列表 l1 和 l2 并将其合并到一个列表中，其中元素已按升序排序。   >>> linear"}
{"task_id": "HumanEval/52", "completion": "    if all(x < t for x in l):\n        return True\n    else:\n        return False\n\n\ndef has_duplicates(l: list):\n    \"\"\"检查列表l是否包含重复元素 \n    >>> has_duplicates([1, 2, 3, 4, 1, 2, 3])\n    True\n    \"\"\"\n    if len(l) == len(set(l)):\n        return False\n    else:\n        return True", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    if all(x < t for x in l):\n        return True\n    else:\n        return False\n\n\ndef has_duplicates(l: list):\n    \"\"\"检查列表l是否包含重复元素 \n    >>> has_duplicates([1, 2, 3, 4, 1, 2, 3])\n    True\n    \"\"\"\n    if len(l) == len(set(l)):\n        return False\n    else:\n        return True"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i < t:\n            return True\n    return False\n\n\n# 5. 回文\n# 5.1 判断一个字符串是否是回文\ndef is_palindrome(s: str):\n    \"\"\"判断一个字符串是否是回文\n    >>> is_palindrome('noon')\n    True\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('abcde')\n    False\n    >>> is_palindrome(12)\n    False\n    \"\"\"\n    s = str(s)\n    if len(s) <= 1:\n        return True\n    elif s[0] == s[-1]:\n        return is_palindrome(s[1:-1])\n    else:\n        return False\n\n\n# 5.2 回文字符串\ndef find_palindrome(s: str):\n    \"\"\"寻找字符串中的回文串，返回其开始和结束的位置\n    >>> find_palindrome('abcba')\n    0, 4\n    >>> find", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i < t:\n            return True\n    return False\n\n\n# 5. 回文\n# 5.1 判断一个字符串是否是回文\ndef is_palindrome(s: str):\n    \"\"\"判断一个字符串是否是回文\n    >>> is_palindrome('noon')\n    True\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('abcde')\n    False\n    >>> is_palindrome(12)\n    False\n    \"\"\"\n    s = str(s)\n    if len(s) <= 1:\n        return True\n    elif s[0] == s[-1]:\n        return is_palindrome(s[1:-1])\n    else:\n        return False\n\n\n# 5.2 回文字符串\ndef find_palindrome(s: str):\n    \"\"\"寻找字符串中的回文串，返回其开始和结束的位置\n    >>> find_palindrome('abcba')\n    0, 4\n    >>> find"}
{"task_id": "HumanEval/52", "completion": "    for var in l:\n        if var >= t:\n            return False\n    return True\n\n\ndef f(x):\n    \"\"\"\n    >>> f(1)\n    (1, 2)\n    \"\"\"\n    return x, x * x\n\n\ndef is_weekday():\n    \"\"\"\n    >>> is_weekday()\n    False\n    \"\"\"\n    return time.strftime(\"%w\", time.localtime()) in [\"0\", \"1\", \"2\", \"3\", \"4\"]\n\n\ndef multi_and(lst, x):\n    \"\"\"\n    >>> multi_and([1, 2, 3, 4], 4)\n    []\n    \"\"\"\n    res = []\n    for var in lst:\n        if var & x:\n            res.append(var)\n    return res\n\n\ndef reverse(lst):\n    \"\"\"\n    >>> reverse([1, 2, 3])\n    [3, 2, 1]\n    \"\"\"\n    res = []\n    for var in lst:\n        res.insert(0, var)\n    return res", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for var in l:\n        if var >= t:\n            return False\n    return True\n\n\ndef f(x):\n    \"\"\"\n    >>> f(1)\n    (1, 2)\n    \"\"\"\n    return x, x * x\n\n\ndef is_weekday():\n    \"\"\"\n    >>> is_weekday()\n    False\n    \"\"\"\n    return time.strftime(\"%w\", time.localtime()) in [\"0\", \"1\", \"2\", \"3\", \"4\"]\n\n\ndef multi_and(lst, x):\n    \"\"\"\n    >>> multi_and([1, 2, 3, 4], 4)\n    []\n    \"\"\"\n    res = []\n    for var in lst:\n        if var & x:\n            res.append(var)\n    return res\n\n\ndef reverse(lst):\n    \"\"\"\n    >>> reverse([1, 2, 3])\n    [3, 2, 1]\n    \"\"\"\n    res = []\n    for var in lst:\n        res.insert(0, var)\n    return res"}
{"task_id": "HumanEval/52", "completion": "    for item in l:\n        if item < t:\n            True\n    return False\n\n\nif __name__ == \"__main__\":\n    temp = below_threshold([1, 2, 4, 10], 100)\n    print(temp)", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for item in l:\n        if item < t:\n            True\n    return False\n\n\nif __name__ == \"__main__\":\n    temp = below_threshold([1, 2, 4, 10], 100)\n    print(temp)"}
{"task_id": "HumanEval/52", "completion": "    \"*** YOUR CODE HERE ***\"\n    for x in l:\n        if x >= t:\n            return False\n    return True\n\n\ndef add_up(s: set):\n    \"\"\"\n    >>> add_up({1, 2, 3, 4})\n    10\n    >>> add_up(set())\n    0\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    for x in l:\n        if x >= t:\n            return False\n    return True\n\n\ndef add_up(s: set):\n    \"\"\"\n    >>> add_up({1, 2, 3, 4})\n    10\n    >>> add_up(set())\n    0\n    \"\"\"\n    \"*** YOUR CODE HERE ***\""}
{"task_id": "HumanEval/52", "completion": "    return all(x < t for x in l)\n\n\ndef simple_filter(l, t):\n    \"\"\"根据阈值过滤掉列表中的小数字，返回新列表\n\n    >>> simple_filter([1, 2, 4, 10], 100)\n    [10]\n    >>> simple_filter([1, 20, 4, 10], 5)\n    [1, 20, 10]\n    \"\"\"\n    return [x for x in l if x >= t]\n\n\ndef main():\n    with open(\"../temp/3/tmp.txt\", \"r\") as f:\n        lines = [line.strip() for line in f.readlines()]\n        l = to_int(lines)\n        print(below_threshold(l, 100))\n        print(simple_filter(l, 100))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)\n\n\ndef simple_filter(l, t):\n    \"\"\"根据阈值过滤掉列表中的小数字，返回新列表\n\n    >>> simple_filter([1, 2, 4, 10], 100)\n    [10]\n    >>> simple_filter([1, 20, 4, 10], 5)\n    [1, 20, 10]\n    \"\"\"\n    return [x for x in l if x >= t]\n\n\ndef main():\n    with open(\"../temp/3/tmp.txt\", \"r\") as f:\n        lines = [line.strip() for line in f.readlines()]\n        l = to_int(lines)\n        print(below_threshold(l, 100))\n        print(simple_filter(l, 100))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/54", "completion": "    # 这里偷了个懒，没有用正则，使用字符串判断即可\n    assert len(s0) == len(s1), \"s0:{} s1:{} 长度不一致，无法进行字符比较\".format(s0, s1)\n    for i in range(len(s0)):\n        if s0[i] == s1[i]:\n            continue\n        else:\n            return False\n    return True\n\n\ndef same_chars_2(s0: str, s1: str) -> bool:\n    \"\"\"\n    检查两个单词是否包含相同的字符     \n    >>> same_chars_2('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_2('abcd', 'dddddddabc')\n    True\n    >>> same_chars_2('dddddddabc', 'abcd')\n    True\n    >>> same_chars_2('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_2('abcd', 'dddd", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # 这里偷了个懒，没有用正则，使用字符串判断即可\n    assert len(s0) == len(s1), \"s0:{} s1:{} 长度不一致，无法进行字符比较\".format(s0, s1)\n    for i in range(len(s0)):\n        if s0[i] == s1[i]:\n            continue\n        else:\n            return False\n    return True\n\n\ndef same_chars_2(s0: str, s1: str) -> bool:\n    \"\"\"\n    检查两个单词是否包含相同的字符     \n    >>> same_chars_2('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_2('abcd', 'dddddddabc')\n    True\n    >>> same_chars_2('dddddddabc', 'abcd')\n    True\n    >>> same_chars_2('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_2('abcd', 'dddd"}
{"task_id": "HumanEval/54", "completion": "    return set(s0) == set(s1)\n\n\ndef count_chars(s: str):\n    \"\"\"\n    统计每个字符出现的次数，并返回字典>>> count_chars('001100110011')\n    {'0': 12, '1': 12}\n    \"\"\"\n    return dict(Counter(s))\n\n\ndef most_char(s: str):\n    \"\"\"\n    返回字符串中出现次数最多的字符\n    >>> most_char('001100110011')\n    '1'\n    >>> most_char('111111111111')\n    '1'\n    >>> most_char('101010101010')\n    '1'\n    >>> most_char('001010101010')\n    '0'\n    >>> most_char('0010101010100')\n    '0'\n    \"\"\"\n    return max(count_chars(s), key", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)\n\n\ndef count_chars(s: str):\n    \"\"\"\n    统计每个字符出现的次数，并返回字典>>> count_chars('001100110011')\n    {'0': 12, '1': 12}\n    \"\"\"\n    return dict(Counter(s))\n\n\ndef most_char(s: str):\n    \"\"\"\n    返回字符串中出现次数最多的字符\n    >>> most_char('001100110011')\n    '1'\n    >>> most_char('111111111111')\n    '1'\n    >>> most_char('101010101010')\n    '1'\n    >>> most_char('001010101010')\n    '0'\n    >>> most_char('0010101010100')\n    '0'\n    \"\"\"\n    return max(count_chars(s), key"}
{"task_id": "HumanEval/54", "completion": "    return all(c in s1 for c in s0) and all(c in s0 for c in s1)\n\n\ndef same_chars_v1(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_v1('abcd', 'dddddddabc')\n    True\n    >>> same_chars_v1('dddddddabc', 'abcd')\n    True\n    >>> same_chars_v1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_v1('abcd', 'dddddddabce')\n    False\n    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0) != len(s1):\n        return False\n    for c in s0:\n        ", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return all(c in s1 for c in s0) and all(c in s0 for c in s1)\n\n\ndef same_chars_v1(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars_v1('abcd', 'dddddddabc')\n    True\n    >>> same_chars_v1('dddddddabc', 'abcd')\n    True\n    >>> same_chars_v1('eabcd', 'dddddddabc')\n    False\n    >>> same_chars_v1('abcd', 'dddddddabce')\n    False\n    >>> same_chars_v1('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0) != len(s1):\n        return False\n    for c in s0:\n        "}
{"task_id": "HumanEval/54", "completion": "    return len(set(s0)) == len(set(s1)) and all(c in s1 for c in s0)\n\n\ndef count_differences(s0: str, s1: str):\n    \"\"\"\n    返回两个单词中所有字符不同的个数\n    >>> count_differences('abcd', 'dddddddabc')\n    4\n    >>> count_differences('eabcd', 'dddddddabc')\n    4\n    >>> count_differences('abcd', 'dddddddabce')\n    4\n    >>> count_differences('eabcdzzzz', 'dddzzzzzzzddddabc')\n    4\n    >>> count_differences('abcd', 'd')\n    4\n    \"\"\"\n    return sum(s0[i] != s1[i] for i in range(min(len(s0), len(s1))))\n\n\ndef find_k_most_similar_words(k: int, word: str):\n    \"\"\"\n    寻找最接近的一个单词\n    >>> sort", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return len(set(s0)) == len(set(s1)) and all(c in s1 for c in s0)\n\n\ndef count_differences(s0: str, s1: str):\n    \"\"\"\n    返回两个单词中所有字符不同的个数\n    >>> count_differences('abcd', 'dddddddabc')\n    4\n    >>> count_differences('eabcd', 'dddddddabc')\n    4\n    >>> count_differences('abcd', 'dddddddabce')\n    4\n    >>> count_differences('eabcdzzzz', 'dddzzzzzzzddddabc')\n    4\n    >>> count_differences('abcd', 'd')\n    4\n    \"\"\"\n    return sum(s0[i] != s1[i] for i in range(min(len(s0), len(s1))))\n\n\ndef find_k_most_similar_words(k: int, word: str):\n    \"\"\"\n    寻找最接近的一个单词\n    >>> sort"}
{"task_id": "HumanEval/54", "completion": "    return (\n        sorted(s0) == sorted(s1)\n        and sorted(s0, key=lambda x: x * 2) == sorted(s1, key=lambda x: x * 2)\n        and s0 == s1\n    )\n\n\ndef reverse(s: str):\n    \"\"\"\n    反转字符串    >>> reverse(\"hello world!\")\n    '!dlrow olleh'\n    >>> reverse('helloworld')\n    'dlrowehol'\n    >>> reverse('hello')\n    'hello'\n\n    \"\"\"\n    return s[::-1]\n\n\ndef is_palindrome(s: str):\n    \"\"\"\n    判断一个单词是否是回文    >>> is_palindrome('hello world!')\n    False\n    >>> is_palindrome('helloworld')\n    True\n    >>> is_palindrome('hello')\n    True\n    >>> is_palindrome('abc')\n    True\n    >>> is_palindrome('dvd')\n    True\n\n    \"\"\"\n    r = 0", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return (\n        sorted(s0) == sorted(s1)\n        and sorted(s0, key=lambda x: x * 2) == sorted(s1, key=lambda x: x * 2)\n        and s0 == s1\n    )\n\n\ndef reverse(s: str):\n    \"\"\"\n    反转字符串    >>> reverse(\"hello world!\")\n    '!dlrow olleh'\n    >>> reverse('helloworld')\n    'dlrowehol'\n    >>> reverse('hello')\n    'hello'\n\n    \"\"\"\n    return s[::-1]\n\n\ndef is_palindrome(s: str):\n    \"\"\"\n    判断一个单词是否是回文    >>> is_palindrome('hello world!')\n    False\n    >>> is_palindrome('helloworld')\n    True\n    >>> is_palindrome('hello')\n    True\n    >>> is_palindrome('abc')\n    True\n    >>> is_palindrome('dvd')\n    True\n\n    \"\"\"\n    r = 0"}
{"task_id": "HumanEval/54", "completion": "    return \"\".join(sorted(s0)) == \"\".join(sorted(s1))\n\n\nif __name__ == \"__main__\":\n    print(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    print(same_chars(\"abcd\", \"dddddddabc\"))\n    print(same_chars(\"dddddddabc\", \"abcd\"))\n    print(same_chars(\"eabcd\", \"dddddddabc\"))\n    print(same_chars(\"abcd\", \"dddddddabce\"))\n    print(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return \"\".join(sorted(s0)) == \"\".join(sorted(s1))\n\n\nif __name__ == \"__main__\":\n    print(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    print(same_chars(\"abcd\", \"dddddddabc\"))\n    print(same_chars(\"dddddddabc\", \"abcd\"))\n    print(same_chars(\"eabcd\", \"dddddddabc\"))\n    print(same_chars(\"abcd\", \"dddddddabce\"))\n    print(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))"}
{"task_id": "HumanEval/54", "completion": "    return sorted(s0) == sorted(s1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/54", "completion": "    for char in s0 + s1:\n        if s0.count(char) != s1.count(char):\n            return False\n    return True\n\n\ndef random_digits(n=10):\n    \"\"\"\n    生成由0-9组成的随机数    >>> random_digits(1)\n    '2'\n    >>> random_digits(2)\n    '4'\n    \"\"\"\n    return str(random.randint(0, 9))\n\n\ndef random_chars(n=2):\n    \"\"\"\n    生成由0-9a-zA-Z组成的随机数    >>> random_chars(1)\n    'n'\n    >>> random_chars(2)\n    'D'\n    \"\"\"\n    return chr(random.randint(0, 9) + 97)\n\n\ndef random_str(n=2):\n    \"\"\"\n    生成由0-9a-zA-Z组成的随机数    >>> random_str(1)\n    's'\n    >>> random_str(2)\n    'x'\n    \"\"\"", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    for char in s0 + s1:\n        if s0.count(char) != s1.count(char):\n            return False\n    return True\n\n\ndef random_digits(n=10):\n    \"\"\"\n    生成由0-9组成的随机数    >>> random_digits(1)\n    '2'\n    >>> random_digits(2)\n    '4'\n    \"\"\"\n    return str(random.randint(0, 9))\n\n\ndef random_chars(n=2):\n    \"\"\"\n    生成由0-9a-zA-Z组成的随机数    >>> random_chars(1)\n    'n'\n    >>> random_chars(2)\n    'D'\n    \"\"\"\n    return chr(random.randint(0, 9) + 97)\n\n\ndef random_str(n=2):\n    \"\"\"\n    生成由0-9a-zA-Z组成的随机数    >>> random_str(1)\n    's'\n    >>> random_str(2)\n    'x'\n    \"\"\""}
{"task_id": "HumanEval/54", "completion": "    l = [False] * 256\n    for c in s0:\n        l[ord(c)] = True\n    for c in s1:\n        if l[ord(c)]:\n            l[ord(c)] = False\n            return True\n    return False\n\n\ndef longest_palindrome(s: str) -> str:\n    \"\"\"\n    检查字符串中是否存在最长的回文子串    >>> longest_palindrome('eabcdzzzz')\n    'zzzz'\n    >>> longest_palindrome('dddzzzzzzzddd')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('dddzzzzzzzddeddd')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('dddzzzzzzzdddabc')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('eabcdzzzz')\n    'zzzz'\n    >>> longest_palindrome('ccccccccccccccccccccccz')\n    ", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    l = [False] * 256\n    for c in s0:\n        l[ord(c)] = True\n    for c in s1:\n        if l[ord(c)]:\n            l[ord(c)] = False\n            return True\n    return False\n\n\ndef longest_palindrome(s: str) -> str:\n    \"\"\"\n    检查字符串中是否存在最长的回文子串    >>> longest_palindrome('eabcdzzzz')\n    'zzzz'\n    >>> longest_palindrome('dddzzzzzzzddd')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('dddzzzzzzzddeddd')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('dddzzzzzzzdddabc')\n    'dddzzzzzzzddd'\n    >>> longest_palindrome('eabcdzzzz')\n    'zzzz'\n    >>> longest_palindrome('ccccccccccccccccccccccz')\n    "}
{"task_id": "HumanEval/54", "completion": "    return set(s0) <= set(s1)  # set(s0)和set(s1)的差集为空集，则说明s0和s1共有的字符相同\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) <= set(s1)  # set(s0)和set(s1)的差集为空集，则说明s0和s1共有的字符相同\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/58", "completion": "    result = set(l1) & set(l2)\n    result_list = list(result)\n    result_list = sort_list(result_list, l1)\n    return result_list\n\n\ndef different(l1: list, l2: list):\n    \"\"\"返回不在对方列表中的元素，返回列表要求排过序且每个元素只出现一次    >>> different([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 2, 8, 9, 121]\n    >>> different([5, 3, 2, 8], [3, 2])\n    [8]\n    \"\"\"\n    result = set(l1) ^ set(l2)\n    result_list = list(result)\n    result_list = sort_list(result_list, l1)\n    return result_list\n\n\ndef sort_list(lst: list, base: list):\n", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    result = set(l1) & set(l2)\n    result_list = list(result)\n    result_list = sort_list(result_list, l1)\n    return result_list\n\n\ndef different(l1: list, l2: list):\n    \"\"\"返回不在对方列表中的元素，返回列表要求排过序且每个元素只出现一次    >>> different([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 2, 8, 9, 121]\n    >>> different([5, 3, 2, 8], [3, 2])\n    [8]\n    \"\"\"\n    result = set(l1) ^ set(l2)\n    result_list = list(result)\n    result_list = sort_list(result_list, l1)\n    return result_list\n\n\ndef sort_list(lst: list, base: list):\n"}
{"task_id": "HumanEval/58", "completion": "    return [item for item in l1 if item in l2]\n\n\ndef no_common(l1: list, l2: list):\n    \"\"\"返回两个列表中没有出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> no_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 8]\n    >>> no_common([5, 3, 2, 8], [3, 2])\n    [5, 8]\n    \"\"\"\n    return [item for item in l1 if item not in l2]\n\n\ndef remove_dup(ls: list):\n    \"\"\"删除列表中的重复元素，返回列表要求排过序且每个元素只出现一次    >>> remove_dup([1, 4, 3, 34, 653, 2, 5])\n    [1, 4, 34, 653,", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return [item for item in l1 if item in l2]\n\n\ndef no_common(l1: list, l2: list):\n    \"\"\"返回两个列表中没有出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> no_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 8]\n    >>> no_common([5, 3, 2, 8], [3, 2])\n    [5, 8]\n    \"\"\"\n    return [item for item in l1 if item not in l2]\n\n\ndef remove_dup(ls: list):\n    \"\"\"删除列表中的重复元素，返回列表要求排过序且每个元素只出现一次    >>> remove_dup([1, 4, 3, 34, 653, 2, 5])\n    [1, 4, 34, 653,"}
{"task_id": "HumanEval/58", "completion": "    return [item for item in l1 if item in l2]\n\n\nif __name__ == \"__main__\":\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    print(common([5, 3, 2, 8], [3, 2]))", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return [item for item in l1 if item in l2]\n\n\nif __name__ == \"__main__\":\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    print(common([5, 3, 2, 8], [3, 2]))"}
{"task_id": "HumanEval/58", "completion": "    result = []\n    for i in l2:\n        if i in l1:\n            result.append(i)\n    return sorted(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    result = []\n    for i in l2:\n        if i in l1:\n            result.append(i)\n    return sorted(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/58", "completion": "    res = []\n    if len(l1) > len(l2):\n        small = l1\n    else:\n        small = l2\n    for item in small:\n        if item in l2 and item in l1 and item not in res:\n            res.append(item)\n    if len(small) > len(res):\n        res.sort()\n    return res\n\n\ndef _set_intersection_test():\n    return _test(set_intersection, common, \"^\", 25)\n\n\ndef _set_union_test():\n    return _test(set_union, common, \"^\", 30)\n\n\ndef _set_difference_test():\n    return _test(set_difference, common, \"^\", 30)\n\n\ndef _test(test_func, common_func, symbol, max_tests):\n    assert test_func(\n        [1, 4, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = []\n    if len(l1) > len(l2):\n        small = l1\n    else:\n        small = l2\n    for item in small:\n        if item in l2 and item in l1 and item not in res:\n            res.append(item)\n    if len(small) > len(res):\n        res.sort()\n    return res\n\n\ndef _set_intersection_test():\n    return _test(set_intersection, common, \"^\", 25)\n\n\ndef _set_union_test():\n    return _test(set_union, common, \"^\", 30)\n\n\ndef _set_difference_test():\n    return _test(set_difference, common, \"^\", 30)\n\n\ndef _test(test_func, common_func, symbol, max_tests):\n    assert test_func(\n        [1, 4, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, "}
{"task_id": "HumanEval/58", "completion": "    return [i for i in l1 if i in l2]\n\n\ndef findnum(l1: list, l2: list):\n    \"\"\"返回两个列表中各元素不重复出现的元素，返回列表要求排过序且每个元素只出现一次    >>> findnum([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 653]\n    >>> findnum([5, 3, 2, 8], [3, 2])\n    [8]\n\n    \"\"\"\n    return [i for i in l1 + l2 if i not in common(l1, l2)]", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return [i for i in l1 if i in l2]\n\n\ndef findnum(l1: list, l2: list):\n    \"\"\"返回两个列表中各元素不重复出现的元素，返回列表要求排过序且每个元素只出现一次    >>> findnum([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 653]\n    >>> findnum([5, 3, 2, 8], [3, 2])\n    [8]\n\n    \"\"\"\n    return [i for i in l1 + l2 if i not in common(l1, l2)]"}
{"task_id": "HumanEval/58", "completion": "    l3 = []\n    for i in l1:\n        if i in l2:\n            l3.append(i)\n    l3.sort()\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l3 = []\n    for i in l1:\n        if i in l2:\n            l3.append(i)\n    l3.sort()\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/58", "completion": "    return sorted(list(set(l1).intersection(set(l2))))\n\n\ndef remove_common(l1: list, l2: list):\n    \"\"\"返回列表2中除去列表1中共同出现的元素的元素\"\"\"\n    return sorted(list(set(l2) - set(l1)))\n    # return sorted(list(set(l2).difference(set(l1))))\n\n\ndef remove_common_from_list(lst: list):\n    \"\"\"去除列表lst中所有相同元素\"\"\"\n    return [sorted([lst[0]] + [i for i in lst[1:] if i != lst[0]])]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1).intersection(set(l2))))\n\n\ndef remove_common(l1: list, l2: list):\n    \"\"\"返回列表2中除去列表1中共同出现的元素的元素\"\"\"\n    return sorted(list(set(l2) - set(l1)))\n    # return sorted(list(set(l2).difference(set(l1))))\n\n\ndef remove_common_from_list(lst: list):\n    \"\"\"去除列表lst中所有相同元素\"\"\"\n    return [sorted([lst[0]] + [i for i in lst[1:] if i != lst[0]])]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))"}
{"task_id": "HumanEval/58", "completion": "    res = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n    return res\n\n\ndef exclusive(l1: list, l2: list):\n    \"\"\"返回两个列表中的不同的元素，返回列表要求排过序且每个元素只出现一次    >>>exclusive([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 2, 5, 8, 9, 121]\n    >>> exclusive([5, 3, 2, 8], [3, 2])\n    [1, 5, 8]\"\"\"\n\n    res = []\n    for i in l1:\n        if not i in l2:\n            res.append(i)\n    return res\n\n\ndef order(l1: list):\n    \"\"\"\n    返回一个列表所有元素升序排序后的新列表，列表要求排过序且每个元素只出现", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    res = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n    return res\n\n\ndef exclusive(l1: list, l2: list):\n    \"\"\"返回两个列表中的不同的元素，返回列表要求排过序且每个元素只出现一次    >>>exclusive([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [4, 34, 2, 5, 8, 9, 121]\n    >>> exclusive([5, 3, 2, 8], [3, 2])\n    [1, 5, 8]\"\"\"\n\n    res = []\n    for i in l1:\n        if not i in l2:\n            res.append(i)\n    return res\n\n\ndef order(l1: list):\n    \"\"\"\n    返回一个列表所有元素升序排序后的新列表，列表要求排过序且每个元素只出现"}
{"task_id": "HumanEval/58", "completion": "    return [k for k in l1 if k in l2]\n\n\ndef unique_append(t1: list, t2: list):\n    \"\"\"\n    将t2中的元素插入t1的尾部，同时保持t1中元素的排序不乱序\n    >>> unique_append([3, 1, 78, 5, 3], [2, 5, 62])\n    [3, 1, 78, 5, 2, 62, 3]\n    >>> unique_append([1, 2, 3], [2, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> unique_append([1, 3, 6], [1, 2, 3])\n    [1, 2, 3, 6]\n    \"\"\"\n    for i in t2:\n        if i in t1:\n            continue\n        elif i > t1[-1]:\n            t1.append(i)\n        elif i in t1:\n            continue\n        elif i < t1[0", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return [k for k in l1 if k in l2]\n\n\ndef unique_append(t1: list, t2: list):\n    \"\"\"\n    将t2中的元素插入t1的尾部，同时保持t1中元素的排序不乱序\n    >>> unique_append([3, 1, 78, 5, 3], [2, 5, 62])\n    [3, 1, 78, 5, 2, 62, 3]\n    >>> unique_append([1, 2, 3], [2, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> unique_append([1, 3, 6], [1, 2, 3])\n    [1, 2, 3, 6]\n    \"\"\"\n    for i in t2:\n        if i in t1:\n            continue\n        elif i > t1[-1]:\n            t1.append(i)\n        elif i in t1:\n            continue\n        elif i < t1[0"}
{"task_id": "HumanEval/59", "completion": "    factor = _factor_list(n)\n    return n // max(factor)\n\n\ndef _factor_list(n: int):\n    \"\"\"返回 n 的因子列表。假设 n > 1 且不是质数 >>> _factor_list(13195)\n    [5, 7, 13, 29]\n    \"\"\"\n    factor = []\n    j = 1\n    if n % 2 == 0:\n        factor.append(2)\n    while j <= n:\n        if n % j == 0:\n            factor.append(j)\n            n = n // j\n        else:\n            j += 2\n    return factor\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = _factor_list(n)\n    return n // max(factor)\n\n\ndef _factor_list(n: int):\n    \"\"\"返回 n 的因子列表。假设 n > 1 且不是质数 >>> _factor_list(13195)\n    [5, 7, 13, 29]\n    \"\"\"\n    factor = []\n    j = 1\n    if n % 2 == 0:\n        factor.append(2)\n    while j <= n:\n        if n % j == 0:\n            factor.append(j)\n            n = n // j\n        else:\n            j += 2\n    return factor\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while i < n:\n        if not n % i:\n            n /= i\n        else:\n            i += 1\n        if n == i:\n            return i\n    return n\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # ans = largest_prime_number(n)\n    # ans = divisor_sum(n)\n    # ans = divisor_sum_list(n)\n    # ans = powerful_number(a, b)\n    # ans = powerful_number_list(a, b)\n    # ans = prime_number_sum(n)\n    # ans = prime_number_sum_list(n)", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i < n:\n        if not n % i:\n            n /= i\n        else:\n            i += 1\n        if n == i:\n            return i\n    return n\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    # ans = largest_prime_number(n)\n    # ans = divisor_sum(n)\n    # ans = divisor_sum_list(n)\n    # ans = powerful_number(a, b)\n    # ans = powerful_number_list(a, b)\n    # ans = prime_number_sum(n)\n    # ans = prime_number_sum_list(n)"}
{"task_id": "HumanEval/59", "completion": "    if n == 1:\n        return 1\n    i = 2\n    max = 1\n    # 试除法:\n    # 试除最大的质因数，在 1..n-1 范围内循环\n    while i <= n - 1:\n        if n % i == 0:\n            # 该数是质数\n            if is_prime(i):\n                max = i\n            # 除到质因数即可求最大质因数了，后面不再循环\n            while n % i == 0:\n                n /= i\n        i += 1\n    return max\n\n\ndef test():\n    assert largest_prime_factor(13195) == 29\n    assert largest_prime_factor(2048) == 2\n    print(\"测试成功!\")\n\n\nif __name__ == \"__main__\":\n    test()", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n == 1:\n        return 1\n    i = 2\n    max = 1\n    # 试除法:\n    # 试除最大的质因数，在 1..n-1 范围内循环\n    while i <= n - 1:\n        if n % i == 0:\n            # 该数是质数\n            if is_prime(i):\n                max = i\n            # 除到质因数即可求最大质因数了，后面不再循环\n            while n % i == 0:\n                n /= i\n        i += 1\n    return max\n\n\ndef test():\n    assert largest_prime_factor(13195) == 29\n    assert largest_prime_factor(2048) == 2\n    print(\"测试成功!\")\n\n\nif __name__ == \"__main__\":\n    test()"}
{"task_id": "HumanEval/59", "completion": "    if n < 2:\n        return None\n\n    prime_list = []\n\n    def _find_prime_factors(number):\n        \"\"\"find all prime factors of a given integer n (> 1). \n        \"\"\"\n        while number % 2 == 0:\n            prime_list.append(2)\n            number //= 2\n\n        for i in range(3, int((number ** 0.5) / 2) + 1, 2):\n            while number % i == 0:\n                prime_list.append(i)\n                number //= i\n\n        if number > 2:\n            prime_list.append(number)  # if number wasn't 2 then it is prime\n\n    _find_prime_factors(n)\n\n    return max(prime_list)\n\n\ndef is_pandigital(n: str):\n    \"\"\"判断n是不是一个全排列   >>> is_pandigital(\"987654321\")\n    True\n    >>> is_pandigital(\"1234567", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n < 2:\n        return None\n\n    prime_list = []\n\n    def _find_prime_factors(number):\n        \"\"\"find all prime factors of a given integer n (> 1). \n        \"\"\"\n        while number % 2 == 0:\n            prime_list.append(2)\n            number //= 2\n\n        for i in range(3, int((number ** 0.5) / 2) + 1, 2):\n            while number % i == 0:\n                prime_list.append(i)\n                number //= i\n\n        if number > 2:\n            prime_list.append(number)  # if number wasn't 2 then it is prime\n\n    _find_prime_factors(n)\n\n    return max(prime_list)\n\n\ndef is_pandigital(n: str):\n    \"\"\"判断n是不是一个全排列   >>> is_pandigital(\"987654321\")\n    True\n    >>> is_pandigital(\"1234567"}
{"task_id": "HumanEval/59", "completion": "    k = 2\n    while n > 1:\n        if n % k == 0:\n            n = n / k\n        else:\n            k += 1\n    return k\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    k = 2\n    while n > 1:\n        if n % k == 0:\n            n = n / k\n        else:\n            k += 1\n    return k\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "HumanEval/59", "completion": "    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n = n / factor\n        else:\n            factor += 1\n    return int(factor)\n\n\ndef divisor_count(n: int):\n    \"\"\"n 的约数个数。 >>> divisor_count(2048)\n    3\n    >>> divisor_count(4)\n    2\n    \"\"\"\n    if n == 1:\n        return 1\n    result = 0\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            result += 1\n            n /= factor\n        else:\n            factor += 1\n    return result\n\n\ndef divisor_sum(n: int, m: int):\n    \"\"\"n 的 m 约数之和。假设 n > 0，m >= 0。   >>> divisor_sum(2048, 10)\n    13198\n    >>> divisor_sum(2048, 2)\n    14\n    \"\"\"\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n = n / factor\n        else:\n            factor += 1\n    return int(factor)\n\n\ndef divisor_count(n: int):\n    \"\"\"n 的约数个数。 >>> divisor_count(2048)\n    3\n    >>> divisor_count(4)\n    2\n    \"\"\"\n    if n == 1:\n        return 1\n    result = 0\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            result += 1\n            n /= factor\n        else:\n            factor += 1\n    return result\n\n\ndef divisor_sum(n: int, m: int):\n    \"\"\"n 的 m 约数之和。假设 n > 0，m >= 0。   >>> divisor_sum(2048, 10)\n    13198\n    >>> divisor_sum(2048, 2)\n    14\n    \"\"\"\n"}
{"task_id": "HumanEval/59", "completion": "    prime_factors = []\n\n    if n <= 1:\n        raise ValueError(\"Must give a positive integer greater than one.\")\n\n    if n == 2:\n        return n\n\n    # 2 是唯一的偶数质因数\n    if n % 2 == 0:\n        prime_factors.append(2)\n        n = n // 2\n\n    for i in range(3, n + 1, 2):\n        # 首先判断是否为素数\n        if is_prime(i):\n            prime_factors.append(i)\n            n = n / i\n            break\n\n    # n 可能为 1\n    if n > 1:\n        prime_factors.append(n)\n\n    return max(prime_factors)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"\n    最小公倍数\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n\n    def gcd(a: int, b: int):\n        \"\"\"\n        最大公约数\n        :param", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    prime_factors = []\n\n    if n <= 1:\n        raise ValueError(\"Must give a positive integer greater than one.\")\n\n    if n == 2:\n        return n\n\n    # 2 是唯一的偶数质因数\n    if n % 2 == 0:\n        prime_factors.append(2)\n        n = n // 2\n\n    for i in range(3, n + 1, 2):\n        # 首先判断是否为素数\n        if is_prime(i):\n            prime_factors.append(i)\n            n = n / i\n            break\n\n    # n 可能为 1\n    if n > 1:\n        prime_factors.append(n)\n\n    return max(prime_factors)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"\n    最小公倍数\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n\n    def gcd(a: int, b: int):\n        \"\"\"\n        最大公约数\n        :param"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\n\ndef prime_factorize(n: int):\n    \"\"\"分解质因数（质因数列）  >>> prime_factorize(13195)\n    [5, 7, 13, 29]\n    >>> prime_factorize(2048)\n    [2, 2, 2, 2, 2, 2, 2]\n    \"\"\"\n    i = 2\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            p = i\n            res = prime_factorize(n // i)\n            res.append(p)\n            res.sort()\n            return res\n        i += 1\n    return [n]\n\n\ndef is_prime(n: int):\n    \"\"\"是否是素数？   >>> is_prime(13195)\n    False\n    >>> is_prime(2048)", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\n\ndef prime_factorize(n: int):\n    \"\"\"分解质因数（质因数列）  >>> prime_factorize(13195)\n    [5, 7, 13, 29]\n    >>> prime_factorize(2048)\n    [2, 2, 2, 2, 2, 2, 2]\n    \"\"\"\n    i = 2\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            p = i\n            res = prime_factorize(n // i)\n            res.append(p)\n            res.sort()\n            return res\n        i += 1\n    return [n]\n\n\ndef is_prime(n: int):\n    \"\"\"是否是素数？   >>> is_prime(13195)\n    False\n    >>> is_prime(2048)"}
{"task_id": "HumanEval/59", "completion": "    return max(prime_factors(n))\n\n\ndef prime_factors(n: int):\n    \"\"\"\n        求n 的所有素因数。\n    >>> prime_factors(13195)\n    [5, 7, 13, 29]\n    >>> prime_factors(2048)\n    [2, 2, 2, 2, 2, 2]\n    \"\"\"\n    assert n > 1\n    max_factor = largest_prime_factor(n)\n    factors = []\n    while max_factor ** 2 <= n:\n        while n % max_factor == 0:\n            factors.append(max_factor)\n            n /= max_factor\n        max_factor = largest_prime_factor(n)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef is_prime(n: int):\n    \"\"\"\n    判断 n 是不是质数\n    >>> is_prime(77)\n    False\n    \"\"\"\n    return largest_prime_factor(", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return max(prime_factors(n))\n\n\ndef prime_factors(n: int):\n    \"\"\"\n        求n 的所有素因数。\n    >>> prime_factors(13195)\n    [5, 7, 13, 29]\n    >>> prime_factors(2048)\n    [2, 2, 2, 2, 2, 2]\n    \"\"\"\n    assert n > 1\n    max_factor = largest_prime_factor(n)\n    factors = []\n    while max_factor ** 2 <= n:\n        while n % max_factor == 0:\n            factors.append(max_factor)\n            n /= max_factor\n        max_factor = largest_prime_factor(n)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef is_prime(n: int):\n    \"\"\"\n    判断 n 是不是质数\n    >>> is_prime(77)\n    False\n    \"\"\"\n    return largest_prime_factor("}
{"task_id": "HumanEval/59", "completion": "    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n = n / factor\n        else:\n            factor += 1\n    return factor\n\n\nif __name__ == '__main__':\n    n = 600851475143\n    print(largest_prime_factor(n))", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n = n / factor\n        else:\n            factor += 1\n    return factor\n\n\nif __name__ == '__main__':\n    n = 600851475143\n    print(largest_prime_factor(n))"}
{"task_id": "HumanEval/60", "completion": "    return (n * (n + 1)) // 2\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return (n * (n + 1)) // 2\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/60", "completion": "    return n * (1 + n) / 2\n\n\ndef sum_to_n_1(n: int):\n    \"\"\"使用递归的方式计算从1到n的数字的和.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n_1(n - 1)\n\n\ndef factorial(n: int):\n    \"\"\"计算n的阶乘.\n    >>> factorial(3)\n    6\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\ndef fib", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (1 + n) / 2\n\n\ndef sum_to_n_1(n: int):\n    \"\"\"使用递归的方式计算从1到n的数字的和.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n_1(n - 1)\n\n\ndef factorial(n: int):\n    \"\"\"计算n的阶乘.\n    >>> factorial(3)\n    6\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\ndef fib"}
{"task_id": "HumanEval/60", "completion": "    return (n * (n + 1) / 2)", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return (n * (n + 1) / 2)"}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\n\ndef sum_func(n):\n    \"\"\"sum_func 计算从1到n的数字的和,使用递归方式.  >>> sum_func(30)\n    465\n    >>> sum_func(100)\n    5050\n    >>> sum_func(5)\n    15\n    >>> sum_func(10)\n    55\n    >>> sum_func(1)\n    1\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return n + sum_func(n - 1)\n\n\ndef sum_func_v1(n):\n    \"\"\"sum_func_v1 计算从1到n的数字的和,使用递归方式.  >>> sum_func_v1(30)\n    465\n    >>> sum_func_v1(100)\n    5050\n    >>> sum_func_v1(5)\n    15\n    >>> sum_func_v1(10)\n    55\n    ", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\n\ndef sum_func(n):\n    \"\"\"sum_func 计算从1到n的数字的和,使用递归方式.  >>> sum_func(30)\n    465\n    >>> sum_func(100)\n    5050\n    >>> sum_func(5)\n    15\n    >>> sum_func(10)\n    55\n    >>> sum_func(1)\n    1\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return n + sum_func(n - 1)\n\n\ndef sum_func_v1(n):\n    \"\"\"sum_func_v1 计算从1到n的数字的和,使用递归方式.  >>> sum_func_v1(30)\n    465\n    >>> sum_func_v1(100)\n    5050\n    >>> sum_func_v1(5)\n    15\n    >>> sum_func_v1(10)\n    55\n    "}
{"task_id": "HumanEval/60", "completion": "    sum_ = 0\n    for i in range(1, n + 1):\n        sum_ += i\n    return sum_\n\n\ndef main():\n    print(sum_to_n(5))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\"\n15\n\"\"\"", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    sum_ = 0\n    for i in range(1, n + 1):\n        sum_ += i\n    return sum_\n\n\ndef main():\n    print(sum_to_n(5))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\"\"\"\n15\n\"\"\""}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\n\n\"\"\"\nPython中的函数非常强大，它可以定义可调用的对象，也就是函数。\n\"\"\"\n\n\ndef fact(n: int):\n    \"\"\" fact 计算阶乘.   >>> fact(5)\n    120\n    >>> fact(16)\n    20922789888000\n    \"\"\"\n    return 1 if n < 2 else n * fact(n - 1)\n\n\ndef print_func(num: int):\n    \"\"\"print_func 打印func_info,并退出.   >>> print_func(5)\n    num: 5\n    \"\"\"\n    print(f\"num: {num}\")\n    sys.exit(0)\n\n\n# 类\ndef class_example():\n    \"\"\"class_example 类的简单示例.\n    >>> class_example()\n    1\n    2\n    3\n    4\n    5\n    \"\"\"\n    # 实例化类，用类的某个实例来调用类的方法\n    class A:\n        def method_a(self", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\n\n\"\"\"\nPython中的函数非常强大，它可以定义可调用的对象，也就是函数。\n\"\"\"\n\n\ndef fact(n: int):\n    \"\"\" fact 计算阶乘.   >>> fact(5)\n    120\n    >>> fact(16)\n    20922789888000\n    \"\"\"\n    return 1 if n < 2 else n * fact(n - 1)\n\n\ndef print_func(num: int):\n    \"\"\"print_func 打印func_info,并退出.   >>> print_func(5)\n    num: 5\n    \"\"\"\n    print(f\"num: {num}\")\n    sys.exit(0)\n\n\n# 类\ndef class_example():\n    \"\"\"class_example 类的简单示例.\n    >>> class_example()\n    1\n    2\n    3\n    4\n    5\n    \"\"\"\n    # 实例化类，用类的某个实例来调用类的方法\n    class A:\n        def method_a(self"}
{"task_id": "HumanEval/60", "completion": "    return n * (n + 1) // 2\n\n\ndef sum_to_n_v2(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n_v2(30)\n    465\n    >>> sum_to_n_v2(100)\n    5050\n    >>> sum_to_n_v2(5)\n    15\n    >>> sum_to_n_v2(10)\n    55\n    >>> sum_to_n_v2(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n\n\ndef sum_to_n_v2(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n_v2(30)\n    465\n    >>> sum_to_n_v2(100)\n    5050\n    >>> sum_to_n_v2(5)\n    15\n    >>> sum_to_n_v2(10)\n    55\n    >>> sum_to_n_v2(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))"}
{"task_id": "HumanEval/60", "completion": "    return (n * (n + 1)) / 2\n\n\ndef reverse_iter(n: int):\n    \"\"\"reverse_iter 迭代形式求逆转数字.    >>> reverse_iter(123)\n    321\n    >>> reverse_iter(1234)\n    4321\n    >>> reverse_iter(12345)\n    53214\n    >>> reverse_iter(120000)\n    541\n    \"\"\"\n    s = str(n)\n    r = s[::-1]\n    return int(r)\n\n\ndef reverse_rec(n: int):\n    \"\"\"reverse_rec 递归方式求逆转数字.   >>> reverse_rec(123)\n    321\n    >>> reverse_rec(1234)\n    4321\n    >>> reverse_rec(12345)\n    53214\n    \"\"\"\n    s = str(n)\n    r = s[-1]\n    if len(s) == 1:\n        return int(r", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return (n * (n + 1)) / 2\n\n\ndef reverse_iter(n: int):\n    \"\"\"reverse_iter 迭代形式求逆转数字.    >>> reverse_iter(123)\n    321\n    >>> reverse_iter(1234)\n    4321\n    >>> reverse_iter(12345)\n    53214\n    >>> reverse_iter(120000)\n    541\n    \"\"\"\n    s = str(n)\n    r = s[::-1]\n    return int(r)\n\n\ndef reverse_rec(n: int):\n    \"\"\"reverse_rec 递归方式求逆转数字.   >>> reverse_rec(123)\n    321\n    >>> reverse_rec(1234)\n    4321\n    >>> reverse_rec(12345)\n    53214\n    \"\"\"\n    s = str(n)\n    r = s[-1]\n    if len(s) == 1:\n        return int(r"}
{"task_id": "HumanEval/60", "completion": "    if not isinstance(n, int):\n        raise TypeError(\"请输入整数\")\n    if n < 0:\n        raise ValueError(\"输入整数必须大于0\")\n    return sum(generate_n(n))\n\n\ndef test_sum_to_n_1():\n    \"\"\"测试sum_to_n函数\"\"\"\n    print(\"测试sum_to_n函数\")\n    assert sum_to_n(30) == 465\n    assert sum_to_n(100) == 5050\n    assert sum_to_n(5) == 15\n    assert sum_to_n(10) == 55\n    assert sum_to_n(1) == 1\n    print(\"ok\")\n\n\nif __name__ == \"__main__\":\n    test_sum_to_n_1()", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"请输入整数\")\n    if n < 0:\n        raise ValueError(\"输入整数必须大于0\")\n    return sum(generate_n(n))\n\n\ndef test_sum_to_n_1():\n    \"\"\"测试sum_to_n函数\"\"\"\n    print(\"测试sum_to_n函数\")\n    assert sum_to_n(30) == 465\n    assert sum_to_n(100) == 5050\n    assert sum_to_n(5) == 15\n    assert sum_to_n(10) == 55\n    assert sum_to_n(1) == 1\n    print(\"ok\")\n\n\nif __name__ == \"__main__\":\n    test_sum_to_n_1()"}
{"task_id": "HumanEval/60", "completion": "    return sum(range(1, n + 1))\n\n\ndef sum_squares_to_n(n: int):\n    \"\"\"sum_squares_to_n 计算从1到n的数字平方的和.   >>> sum_squares_to_n(30)\n    5454\n    >>> sum_squares_to_n(100)\n    338350\n    >>> sum_squares_to_n(1000000)\n    1001001000000\n    >>> sum_squares_to_n(5)\n    55\n    >>> sum_squares_to_n(10)\n    1205\n    >>> sum_squares_to_n(1)\n    1\n    \"\"\"\n    return sum(x ** 2 for x in range(1, n + 1))\n\n\ndef print_prime_factors(n):\n    \"\"\"print_prime_factors 打印除数分解质因数.\n    prime_factors 计算除以最小因数的数字", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))\n\n\ndef sum_squares_to_n(n: int):\n    \"\"\"sum_squares_to_n 计算从1到n的数字平方的和.   >>> sum_squares_to_n(30)\n    5454\n    >>> sum_squares_to_n(100)\n    338350\n    >>> sum_squares_to_n(1000000)\n    1001001000000\n    >>> sum_squares_to_n(5)\n    55\n    >>> sum_squares_to_n(10)\n    1205\n    >>> sum_squares_to_n(1)\n    1\n    \"\"\"\n    return sum(x ** 2 for x in range(1, n + 1))\n\n\ndef print_prime_factors(n):\n    \"\"\"print_prime_factors 打印除数分解质因数.\n    prime_factors 计算除以最小因数的数字"}
{"task_id": "HumanEval/70", "completion": "    return sorted(sorted(lst), lambda x,y: y-x)\n\n\ndef test_strange_sort_list():\n    print('Testing strange_sort_list...')\n    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert strange_sort_list([]) == []\n    print('Passed!')\n\ntest_strange_sort_list()", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    return sorted(sorted(lst), lambda x,y: y-x)\n\n\ndef test_strange_sort_list():\n    print('Testing strange_sort_list...')\n    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert strange_sort_list([]) == []\n    print('Passed!')\n\ntest_strange_sort_list()"}
{"task_id": "HumanEval/70", "completion": "    if not lst:\n        return []\n    lst.sort(key=lambda x: (-x % 2, abs(x)))\n    return lst\n\n\ndef strange_sort_two_lists(a, b):\n    '''\n    给定两个整数列表，返回一个列表，这个列表将一个列表中的所有整数与第二个列表中的所有整数相加。\n    如果存在多个有效解，则返回列表中最小的一个。\n    示例  a = [0, 1, 2, 3] b = [0, 1, 2, 3] strange_sort_lists(a, b) == [0, 1, 2, 3]\n    strange_sort_lists(a, b) == [0, 1, 2, 3]\n    strange_sort_lists(a, a) == [0, 1, 2, 3]\n    strange_sort_lists(a, [0]) == [0, 1, 2, 3]\n    strange_sort_lists([0], b) == [0, ", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    lst.sort(key=lambda x: (-x % 2, abs(x)))\n    return lst\n\n\ndef strange_sort_two_lists(a, b):\n    '''\n    给定两个整数列表，返回一个列表，这个列表将一个列表中的所有整数与第二个列表中的所有整数相加。\n    如果存在多个有效解，则返回列表中最小的一个。\n    示例  a = [0, 1, 2, 3] b = [0, 1, 2, 3] strange_sort_lists(a, b) == [0, 1, 2, 3]\n    strange_sort_lists(a, b) == [0, 1, 2, 3]\n    strange_sort_lists(a, a) == [0, 1, 2, 3]\n    strange_sort_lists(a, [0]) == [0, 1, 2, 3]\n    strange_sort_lists([0], b) == [0, "}
{"task_id": "HumanEval/70", "completion": "    new_lst = []\n    if len(lst) < 2:\n        return lst\n    lst.sort()\n    n = 0\n    while len(lst) != 0:\n        if lst[0] % 2 == 0:\n            lst.pop(0)\n        else:\n            new_lst.append(lst.pop(-1))\n            n += 1\n        if n == len(lst):\n            return new_lst\n            break\n    return new_lst", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    new_lst = []\n    if len(lst) < 2:\n        return lst\n    lst.sort()\n    n = 0\n    while len(lst) != 0:\n        if lst[0] % 2 == 0:\n            lst.pop(0)\n        else:\n            new_lst.append(lst.pop(-1))\n            n += 1\n        if n == len(lst):\n            return new_lst\n            break\n    return new_lst"}
{"task_id": "HumanEval/70", "completion": "    lst = sorted(lst)\n    lst.sort(key=lambda x:x%2)\n    return lst\n\nprint(strange_sort_list([1, 2, 3, 4]))\nprint(strange_sort_list([5, 5, 5, 5]))\nprint(strange_sort_list([]))", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    lst = sorted(lst)\n    lst.sort(key=lambda x:x%2)\n    return lst\n\nprint(strange_sort_list([1, 2, 3, 4]))\nprint(strange_sort_list([5, 5, 5, 5]))\nprint(strange_sort_list([]))"}
{"task_id": "HumanEval/70", "completion": "    if not lst:\n        return []\n    lst1 = list()\n    lst2 = list()\n    for i in lst:\n        if i%2:\n            lst1.append(i)\n        else:\n            lst2.append(i)\n    return lst1 + lst2\n\n\nif __name__ == '__main__':\n    test1 = [2, 3, 4, 5, 1]\n    test2 = [1, 2, 3, 4, 5]\n    test3 = []\n    print(test1)\n    print(strange_sort_list(test1))\n    print(test2)\n    print(strange_sort_list(test2))\n    print(test3)\n    print(strange_sort_list(test3))", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    lst1 = list()\n    lst2 = list()\n    for i in lst:\n        if i%2:\n            lst1.append(i)\n        else:\n            lst2.append(i)\n    return lst1 + lst2\n\n\nif __name__ == '__main__':\n    test1 = [2, 3, 4, 5, 1]\n    test2 = [1, 2, 3, 4, 5]\n    test3 = []\n    print(test1)\n    print(strange_sort_list(test1))\n    print(test2)\n    print(strange_sort_list(test2))\n    print(test3)\n    print(strange_sort_list(test3))"}
{"task_id": "HumanEval/70", "completion": "    if not lst:\n        return []\n\n    return sorted(lst, key=lambda x: x*100+random.randint(1,100))\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    if not lst:\n        return []\n\n    lst.sort(key=lambda x: (x % 2 == 0, x))\n    return lst\n\nif __name__ == '__main__':\n    print(strange_sort_list([1,2,3,4]))\n    print(strange_sort_list([-1, -2, -3, -4, -5]))", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n\n    return sorted(lst, key=lambda x: x*100+random.randint(1,100))\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    if not lst:\n        return []\n\n    lst.sort(key=lambda x: (x % 2 == 0, x))\n    return lst\n\nif __name__ == '__main__':\n    print(strange_sort_list([1,2,3,4]))\n    print(strange_sort_list([-1, -2, -3, -4, -5]))"}
{"task_id": "HumanEval/70", "completion": "    l = []\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            l.append(min(lst))\n            lst.remove(min(lst))\n        else:\n            l.append(max(lst))\n            lst.remove(max(lst))\n    return l\n\n\ndef sort_colors(nums):\n    '''\n    给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n    此题中，我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。\n    注意:\n        不能使用代码库中的排序函数来解决这道题。\n    示例:\n        输入: [2,0,2,1,1,0]\n        输出: [0,0,1,1,2,2]\n    '''\n    return [1 if i >= 1 else 0 for i in lst]\n\n\ndef two_sum_1(nums, target", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    l = []\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            l.append(min(lst))\n            lst.remove(min(lst))\n        else:\n            l.append(max(lst))\n            lst.remove(max(lst))\n    return l\n\n\ndef sort_colors(nums):\n    '''\n    给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n    此题中，我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。\n    注意:\n        不能使用代码库中的排序函数来解决这道题。\n    示例:\n        输入: [2,0,2,1,1,0]\n        输出: [0,0,1,1,2,2]\n    '''\n    return [1 if i >= 1 else 0 for i in lst]\n\n\ndef two_sum_1(nums, target"}
{"task_id": "HumanEval/70", "completion": "    lst.sort(key=return_key)\n    return lst\n\n\ndef test_strange_sort_list():\n    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert strange_sort_list([]) == []\n\n\nif __name__ == '__main__':\n    test_strange_sort_list()", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    lst.sort(key=return_key)\n    return lst\n\n\ndef test_strange_sort_list():\n    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert strange_sort_list([]) == []\n\n\nif __name__ == '__main__':\n    test_strange_sort_list()"}
{"task_id": "HumanEval/70", "completion": "    lst.sort()\n\n    even = []\n    odd = []\n    out = []\n\n    for i in lst:\n        if i % 2 != 0:\n            odd.append(i)\n        else:\n            even.append(i)\n\n    odd.sort()\n    even.sort(reverse=True)\n\n    for i in range(0, len(lst)):\n        if i % 2 != 0:\n            out.append(odd[0])\n            odd.pop(0)\n        else:\n            out.append(even[0])\n            even.pop(0)\n    return out\n\n\ndef strange_sort_list_2(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类比。\n    示例\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    lst.sort()\n\n    even = []\n    odd = []\n    out = []\n\n    for i in lst:\n        if i % 2 != 0:\n            odd.append(i)\n        else:\n            even.append(i)\n\n    odd.sort()\n    even.sort(reverse=True)\n\n    for i in range(0, len(lst)):\n        if i % 2 != 0:\n            out.append(odd[0])\n            odd.pop(0)\n        else:\n            out.append(even[0])\n            even.pop(0)\n    return out\n\n\ndef strange_sort_list_2(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类比。\n    示例\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5"}
{"task_id": "HumanEval/70", "completion": "    if lst == []:\n        return lst\n    if lst[0] % 2 == 0:\n        return [lst[0]] + strange_sort_list(lst[1:])\n    else:\n        return strange_sort_list(lst[1:]) + [lst[0]]\n\n\nif __name__ == '__main__':\n    print(strange_sort_list([1, 2, 3, 4]))\n    print(strange_sort_list([5, 5, 5, 5]))\n    print(strange_sort_list([]))", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if lst == []:\n        return lst\n    if lst[0] % 2 == 0:\n        return [lst[0]] + strange_sort_list(lst[1:])\n    else:\n        return strange_sort_list(lst[1:]) + [lst[0]]\n\n\nif __name__ == '__main__':\n    print(strange_sort_list([1, 2, 3, 4]))\n    print(strange_sort_list([5, 5, 5, 5]))\n    print(strange_sort_list([]))"}
{"task_id": "HumanEval/73", "completion": "    N = len(arr)\n\n    # 记录原数组arr中最小最大值\n    mins = sys.maxsize\n    maxs = -sys.maxsize\n    for v in arr:\n        mins = min(mins, v)\n        maxs = max(maxs, v)\n\n    # 构造dp数组\n    dp = [[0 for _ in range(maxs - mins + 1)] for _ in range(N)]\n\n    # 初始化条件\n    for i in range(N):\n        dp[i][arr[i] - mins] = 1\n\n    # 状态转移方程\n    for i in range(1, N):\n        for j in range(mins, maxs):\n            k = N - i - 1\n            if arr[i] == arr[k] and dp[i - 1][j - mins]:\n                dp[i][j] = dp[i - 1][j - mins]\n            elif arr[i] != arr[k]:\n                if j > arr[k] - mins:\n                    dp[", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    N = len(arr)\n\n    # 记录原数组arr中最小最大值\n    mins = sys.maxsize\n    maxs = -sys.maxsize\n    for v in arr:\n        mins = min(mins, v)\n        maxs = max(maxs, v)\n\n    # 构造dp数组\n    dp = [[0 for _ in range(maxs - mins + 1)] for _ in range(N)]\n\n    # 初始化条件\n    for i in range(N):\n        dp[i][arr[i] - mins] = 1\n\n    # 状态转移方程\n    for i in range(1, N):\n        for j in range(mins, maxs):\n            k = N - i - 1\n            if arr[i] == arr[k] and dp[i - 1][j - mins]:\n                dp[i][j] = dp[i - 1][j - mins]\n            elif arr[i] != arr[k]:\n                if j > arr[k] - mins:\n                    dp["}
{"task_id": "HumanEval/73", "completion": "\n    def helper(arr):\n        \"\"\"\n        辅助函数，用于计算单次转换的最大值\n        Args:\n            arr:  需要转换的数组\n        Returns:\n            n:  转换需要的最小次数\n        \"\"\"\n        # 边界处理\n        if not arr:\n            return 0\n        if len(arr) == 1:\n            return 0\n        if len(arr) % 2 != 0:\n            arr.append(arr[0])\n            n = 1\n        else:\n            n = 0\n        # 最大值\n        max_num = max(arr)\n        # 计算索引\n        j = len(arr) - 1\n        i = 0\n        while i < j:\n            # 记录最大值和最小值\n            if arr[i] != max_num:\n                max_num = arr[i]\n            if arr[j] != max_num:\n                max_num = arr[j]\n            # 相等则直接比较下一个\n            if arr[i] == arr[j]:\n                i += 1\n                ", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n\n    def helper(arr):\n        \"\"\"\n        辅助函数，用于计算单次转换的最大值\n        Args:\n            arr:  需要转换的数组\n        Returns:\n            n:  转换需要的最小次数\n        \"\"\"\n        # 边界处理\n        if not arr:\n            return 0\n        if len(arr) == 1:\n            return 0\n        if len(arr) % 2 != 0:\n            arr.append(arr[0])\n            n = 1\n        else:\n            n = 0\n        # 最大值\n        max_num = max(arr)\n        # 计算索引\n        j = len(arr) - 1\n        i = 0\n        while i < j:\n            # 记录最大值和最小值\n            if arr[i] != max_num:\n                max_num = arr[i]\n            if arr[j] != max_num:\n                max_num = arr[j]\n            # 相等则直接比较下一个\n            if arr[i] == arr[j]:\n                i += 1\n                "}
{"task_id": "HumanEval/73", "completion": "    lenarr = len(arr)\n    if lenarr == 0 or lenarr == 1:\n        return 0\n    if lenarr == 2:\n        if arr[0] == arr[1]:\n            return 0\n        else:\n            return 1\n\n    dic = dict()\n    for i in range(lenarr):\n        if i < lenarr - 1:\n            dic_append(dic, i, i + 1, arr[i], arr[i + 1])\n        if i > 0:\n            dic_append(dic, i, i - 1, arr[i], arr[i - 1])\n        if i > 1:\n            dic_append(dic, i, i - 2, arr[i], arr[i - 2])\n\n    # 创建一个列表d，d[i]表示对于长度为i的回文串arr的最少改变次数\n    d = [0] * (lenarr + 1)\n    # 更新d列表\n    for i in dic.keys():\n        d[", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    lenarr = len(arr)\n    if lenarr == 0 or lenarr == 1:\n        return 0\n    if lenarr == 2:\n        if arr[0] == arr[1]:\n            return 0\n        else:\n            return 1\n\n    dic = dict()\n    for i in range(lenarr):\n        if i < lenarr - 1:\n            dic_append(dic, i, i + 1, arr[i], arr[i + 1])\n        if i > 0:\n            dic_append(dic, i, i - 1, arr[i], arr[i - 1])\n        if i > 1:\n            dic_append(dic, i, i - 2, arr[i], arr[i - 2])\n\n    # 创建一个列表d，d[i]表示对于长度为i的回文串arr的最少改变次数\n    d = [0] * (lenarr + 1)\n    # 更新d列表\n    for i in dic.keys():\n        d["}
{"task_id": "HumanEval/73", "completion": "    l = len(arr)\n    dp = [[0] * l for _ in range(l)]\n    for i in range(l):\n        dp[i][i] = 1\n    for i in range(l - 2, -1, -1):\n        for j in range(i + 1, l):\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j - 1] + 1, min(dp[i][j - 1] + 2, dp[i + 1][j] + 2))\n    return dp[0][l - 1]\n\n\nprint(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))\nprint(smallest_change([1, 2, 3, 4, 3, 2, 2]))\nprint(smallest_change([1, 2,", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    l = len(arr)\n    dp = [[0] * l for _ in range(l)]\n    for i in range(l):\n        dp[i][i] = 1\n    for i in range(l - 2, -1, -1):\n        for j in range(i + 1, l):\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j - 1] + 1, min(dp[i][j - 1] + 2, dp[i + 1][j] + 2))\n    return dp[0][l - 1]\n\n\nprint(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))\nprint(smallest_change([1, 2, 3, 4, 3, 2, 2]))\nprint(smallest_change([1, 2,"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n    length = len(arr)\n    dp = [[0] * length for _ in range(length)]\n    for i in range(length):\n        dp[i][i] = 0\n    for i in range(length - 2, -1, -1):\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n    return dp[0][-1]\n\n\ndef max_non_overlapping(arr, k):\n    \"\"\"\n    给定一个字符串s，找出其中最长的不含重复字符的子字符串的长度。\n    Input: s = \"abcabcbb\"\n    Output: 3\n    Explanation: The answer is \"abc\", with the length of 3.\n    Input: s = \"", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    length = len(arr)\n    dp = [[0] * length for _ in range(length)]\n    for i in range(length):\n        dp[i][i] = 0\n    for i in range(length - 2, -1, -1):\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n    return dp[0][-1]\n\n\ndef max_non_overlapping(arr, k):\n    \"\"\"\n    给定一个字符串s，找出其中最长的不含重复字符的子字符串的长度。\n    Input: s = \"abcabcbb\"\n    Output: 3\n    Explanation: The answer is \"abc\", with the length of 3.\n    Input: s = \""}
{"task_id": "HumanEval/73", "completion": "    n = len(arr)\n    if n == 0 or n == 1:\n        return 0\n\n    dp = [[n ** 2 for _ in range(n)] for _ in range(n)]\n    length = 0\n\n    def is_palindrome(s, i, j):\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    def DFS(s, i, j):\n        if not is_palindrome(s, i, j):\n            return n\n\n        if dp[i][j] < n:\n            return dp[i][j]\n\n        if i == j and i == 0:\n            return 0\n        if i == j and i == 1:\n            return 0\n        if i == j - 1:\n            return min(change(s, i, j), 1)\n\n        dp[i][j] = n\n        res = n\n\n        for k in range(i + 1", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    n = len(arr)\n    if n == 0 or n == 1:\n        return 0\n\n    dp = [[n ** 2 for _ in range(n)] for _ in range(n)]\n    length = 0\n\n    def is_palindrome(s, i, j):\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    def DFS(s, i, j):\n        if not is_palindrome(s, i, j):\n            return n\n\n        if dp[i][j] < n:\n            return dp[i][j]\n\n        if i == j and i == 0:\n            return 0\n        if i == j and i == 1:\n            return 0\n        if i == j - 1:\n            return min(change(s, i, j), 1)\n\n        dp[i][j] = n\n        res = n\n\n        for k in range(i + 1"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n\n    length = len(arr)\n    dp = [0] * length\n    for i in range(length - 2, -1, -1):\n        # 初始化\n        min_num = 0\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                min_num = 0\n                break\n            min_num = min(min_num, dp[j] + 1)\n        dp[i] = min_num\n\n    return dp[0]", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n\n    length = len(arr)\n    dp = [0] * length\n    for i in range(length - 2, -1, -1):\n        # 初始化\n        min_num = 0\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                min_num = 0\n                break\n            min_num = min(min_num, dp[j] + 1)\n        dp[i] = min_num\n\n    return dp[0]"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n    l = len(arr)\n    dp = [[0] * l for _ in range(l)]\n    for i in range(l - 2, -1, -1):\n        for j in range(i + 1, l):\n            if i == j - 1:\n                dp[i][j] = 0 if arr[i] == arr[j] else 1\n            else:\n                dp[i][j] = min(dp[i + 1][j - 1], 1) + 1 if arr[i] == arr[j] else dp[i + 1][j - 1] + 1\n    return dp[0][l - 1]\n\n\ndef test_smallest_change():\n    assert smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n    assert smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert smallest_change([1,", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    l = len(arr)\n    dp = [[0] * l for _ in range(l)]\n    for i in range(l - 2, -1, -1):\n        for j in range(i + 1, l):\n            if i == j - 1:\n                dp[i][j] = 0 if arr[i] == arr[j] else 1\n            else:\n                dp[i][j] = min(dp[i + 1][j - 1], 1) + 1 if arr[i] == arr[j] else dp[i + 1][j - 1] + 1\n    return dp[0][l - 1]\n\n\ndef test_smallest_change():\n    assert smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n    assert smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert smallest_change([1,"}
{"task_id": "HumanEval/73", "completion": "    n = len(arr)\n    if n <= 1:\n        return 0\n    else:\n        count = []\n        for i in range(n):\n            count.append(abs(arr[i] - (arr[n - i - 1])))\n        return min(count)", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n    else:\n        count = []\n        for i in range(n):\n            count.append(abs(arr[i] - (arr[n - i - 1])))\n        return min(count)"}
{"task_id": "HumanEval/73", "completion": "    len_arr = len(arr)\n    dp = [0 for _ in range(len_arr)]\n\n    def check(x):\n        return x == x[::-1]\n\n    for i, num in enumerate(arr):\n        dp[i] = dp[i - 1] + 1\n        if num == arr[len_arr - 1 - i]:\n            dp[i] = min(dp[i], dp[i - 1])\n        elif num != arr[len_arr - 1 - i] and check(arr[: len_arr - i]):\n            if i == len_arr - 1:\n                dp[i] = dp[i] + 1\n            else:\n                for j in range(i, len_arr - 1):\n                    if arr[len_arr - 1 - i] == arr[j]:\n                        dp[i] = min(dp[i], check(arr[: j + 1]) + dp[j - i])\n        else:\n            dp[i] = dp[i] + 1\n", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    len_arr = len(arr)\n    dp = [0 for _ in range(len_arr)]\n\n    def check(x):\n        return x == x[::-1]\n\n    for i, num in enumerate(arr):\n        dp[i] = dp[i - 1] + 1\n        if num == arr[len_arr - 1 - i]:\n            dp[i] = min(dp[i], dp[i - 1])\n        elif num != arr[len_arr - 1 - i] and check(arr[: len_arr - i]):\n            if i == len_arr - 1:\n                dp[i] = dp[i] + 1\n            else:\n                for j in range(i, len_arr - 1):\n                    if arr[len_arr - 1 - i] == arr[j]:\n                        dp[i] = min(dp[i], check(arr[: j + 1]) + dp[j - i])\n        else:\n            dp[i] = dp[i] + 1\n"}
{"task_id": "HumanEval/82", "completion": "    if is_prime(len(string)) == True:\n        return True\n    else:\n        return False\n    pass\n\n\ndef list_rotate(items, n):\n    \"\"\"定义一个函数，它接受一个列表和一个整数作为参数，并将这个列表的值向右移动N位。注意：如果N大于列表的长度，则会向右循环移动列表中的值。    示例：\n    list_rotate([1,2,3,4,5], 2) == [3,4,5,1,2]\n    list_rotate([1,2,3,4,5], 0) == [1,2,3,4,5]\n    list_rotate([1,2,3,4,5], 5) == [1,2,3,4,5]\n    list_rotate([1,2,3,4,5], -2) == [3,4,5,1,2]\n    print \"OK\"\n    \"\"\"\n    return items[n:] + items[:n]\n\n\ndef last(items):\n    \"\"\"定义一个函数，", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if is_prime(len(string)) == True:\n        return True\n    else:\n        return False\n    pass\n\n\ndef list_rotate(items, n):\n    \"\"\"定义一个函数，它接受一个列表和一个整数作为参数，并将这个列表的值向右移动N位。注意：如果N大于列表的长度，则会向右循环移动列表中的值。    示例：\n    list_rotate([1,2,3,4,5], 2) == [3,4,5,1,2]\n    list_rotate([1,2,3,4,5], 0) == [1,2,3,4,5]\n    list_rotate([1,2,3,4,5], 5) == [1,2,3,4,5]\n    list_rotate([1,2,3,4,5], -2) == [3,4,5,1,2]\n    print \"OK\"\n    \"\"\"\n    return items[n:] + items[:n]\n\n\ndef last(items):\n    \"\"\"定义一个函数，"}
{"task_id": "HumanEval/82", "completion": "    for i in range(2,int(len(string))):\n        if len(string) % i == 0:\n            return False\n    return True\n\n\n# 2.斐波那契\ndef fib(n):\n    \"\"\"斐波那契数列\n    fib(1) == 1\n    fib(2) == 1\n    fib(5) == 5\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    return fib(n-1)+fib(n-2)\n\n\ndef fib2(n):\n    \"\"\"\n    >>> fib2(1)\n    1\n    >>> fib2(2)\n    1\n    >>> fib2(5)\n    5\n    >>> fib2(10)\n    55\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n\n# 3.回文\ndef is_palindrome(s):\n    \"\"\"验证回文字符串\n    >>> is", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    for i in range(2,int(len(string))):\n        if len(string) % i == 0:\n            return False\n    return True\n\n\n# 2.斐波那契\ndef fib(n):\n    \"\"\"斐波那契数列\n    fib(1) == 1\n    fib(2) == 1\n    fib(5) == 5\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n    return fib(n-1)+fib(n-2)\n\n\ndef fib2(n):\n    \"\"\"\n    >>> fib2(1)\n    1\n    >>> fib2(2)\n    1\n    >>> fib2(5)\n    5\n    >>> fib2(10)\n    55\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n\n# 3.回文\ndef is_palindrome(s):\n    \"\"\"验证回文字符串\n    >>> is"}
{"task_id": "HumanEval/82", "completion": "    if string.isdigit():\n        if int(string) == 1:\n            return False\n        else:\n            for i in range(2, int(string)):\n                if int(string) % i == 0:\n                    return False\n            return True\n    elif is_prime(string):\n        return True\n    else:\n        return False\n\n\n# 测试:\noutput = prime_length(\"Hello\")\nprint(\"测试 prime_length('Hello'):\", output)\nif prime_length(\"Hello\") != True:\n    print(\"测试失败!\")\nelse:\n    print(\"测试成功!\")\n\noutput = prime_length(\"kittens\")\nprint(\"测试 prime_length('kittens'):\", output)\nif prime_length(\"kittens\") != True:\n    print(\"测试失败!\")\nelse:\n    print(\"测试成功!\")\n\noutput = prime_length(\"orange\")\nprint(\"测试 prime_length('orange'):\", output)\nif prime_length(\"orange\") != False:\n    print(\"测试失败!\")\nelse:\n    print(\"测试", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if string.isdigit():\n        if int(string) == 1:\n            return False\n        else:\n            for i in range(2, int(string)):\n                if int(string) % i == 0:\n                    return False\n            return True\n    elif is_prime(string):\n        return True\n    else:\n        return False\n\n\n# 测试:\noutput = prime_length(\"Hello\")\nprint(\"测试 prime_length('Hello'):\", output)\nif prime_length(\"Hello\") != True:\n    print(\"测试失败!\")\nelse:\n    print(\"测试成功!\")\n\noutput = prime_length(\"kittens\")\nprint(\"测试 prime_length('kittens'):\", output)\nif prime_length(\"kittens\") != True:\n    print(\"测试失败!\")\nelse:\n    print(\"测试成功!\")\n\noutput = prime_length(\"orange\")\nprint(\"测试 prime_length('orange'):\", output)\nif prime_length(\"orange\") != False:\n    print(\"测试失败!\")\nelse:\n    print(\"测试"}
{"task_id": "HumanEval/82", "completion": "    if not string:\n        return False\n    if len(string) == 1:\n        return True\n    if string[0] == \"0\":\n        return False\n    if len(string) == 2:\n        if string[0] == \"1\" or string[0] == \"2\":\n            return True\n        else:\n            return False\n    for i in range(2, len(string)):\n        if string[i] == \"0\":\n            return False\n        elif string[i] == \"1\" or string[i] == \"2\":\n            continue\n        elif string[i] == \"3\" or string[i] == \"4\" or string[i] == \"5\" or string[i] == \"6\" or string[\n                i] == \"7\" or string[i] == \"8\" or string[i] == \"9\":\n            # 先判断是否为素数\n            for j in range(2, len(string)):\n                if string[j] == \"0\":\n                    return False\n                elif string[j] == \"1\" or string[j] ==", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if not string:\n        return False\n    if len(string) == 1:\n        return True\n    if string[0] == \"0\":\n        return False\n    if len(string) == 2:\n        if string[0] == \"1\" or string[0] == \"2\":\n            return True\n        else:\n            return False\n    for i in range(2, len(string)):\n        if string[i] == \"0\":\n            return False\n        elif string[i] == \"1\" or string[i] == \"2\":\n            continue\n        elif string[i] == \"3\" or string[i] == \"4\" or string[i] == \"5\" or string[i] == \"6\" or string[\n                i] == \"7\" or string[i] == \"8\" or string[i] == \"9\":\n            # 先判断是否为素数\n            for j in range(2, len(string)):\n                if string[j] == \"0\":\n                    return False\n                elif string[j] == \"1\" or string[j] =="}
{"task_id": "HumanEval/82", "completion": "    if len(string) != 2:\n        for i in range(2, len(string)):\n            if len(string) % i == 0:\n                return False\n    else:\n        return False\n    return True\n\n\ndef prime_number(number):\n    \"\"\"编写一个函数，接收一个整数，检查其是否为质数，如果是则返回True，否则返回False    示例：\n    prime_number(11) == False\n    prime_number(7) == True\n    \"\"\"\n    for i in range(2, number):\n        if number % i == 0:\n            return False\n    return True\n\n\ndef prime_number_2(number):\n    \"\"\"编写一个函数，接收一个整数，检查其是否为质数，如果是则返回True，否则返回False    示例：\n    prime_number_2(25) == False\n    prime_number_2(11) == True\n    \"\"\"\n    if number < 2:\n        return False\n    for i in range(2, number):\n        if number % i == 0:\n            return False\n", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) != 2:\n        for i in range(2, len(string)):\n            if len(string) % i == 0:\n                return False\n    else:\n        return False\n    return True\n\n\ndef prime_number(number):\n    \"\"\"编写一个函数，接收一个整数，检查其是否为质数，如果是则返回True，否则返回False    示例：\n    prime_number(11) == False\n    prime_number(7) == True\n    \"\"\"\n    for i in range(2, number):\n        if number % i == 0:\n            return False\n    return True\n\n\ndef prime_number_2(number):\n    \"\"\"编写一个函数，接收一个整数，检查其是否为质数，如果是则返回True，否则返回False    示例：\n    prime_number_2(25) == False\n    prime_number_2(11) == True\n    \"\"\"\n    if number < 2:\n        return False\n    for i in range(2, number):\n        if number % i == 0:\n            return False\n"}
{"task_id": "HumanEval/82", "completion": "    # 判断长度是否是质数\n    if len(string) == 1:\n        return False\n    else:\n        a = len(string)\n        b = range(1, a)\n        # print b\n        for i in b:\n            if a % i == 0:\n                return False\n            else:\n                return True\n\n\n#    print prime_length(string)\n\n\ndef remove_tags(string):\n    \"\"\"编写一个函数，去除字符串中的HTML标记    示例：\n    remove_tags('<b>Hello</b>') == 'Hello'\n    remove_tags('<p>Hello<p>') == 'Hello'\n    \"\"\"\n    # 替换掉所有HTML标签\n    while \"<\" in string and \">\" in string:\n        string = string.replace(string[string.index(\"<\") : string.index(\">\") + 1], \"\")\n        string = string.replace(\"  \", \" \")\n        string = string.replace(\"  \", \" \")\n    return string\n\n\ndef replace_words(string, word_dic):\n    ", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    # 判断长度是否是质数\n    if len(string) == 1:\n        return False\n    else:\n        a = len(string)\n        b = range(1, a)\n        # print b\n        for i in b:\n            if a % i == 0:\n                return False\n            else:\n                return True\n\n\n#    print prime_length(string)\n\n\ndef remove_tags(string):\n    \"\"\"编写一个函数，去除字符串中的HTML标记    示例：\n    remove_tags('<b>Hello</b>') == 'Hello'\n    remove_tags('<p>Hello<p>') == 'Hello'\n    \"\"\"\n    # 替换掉所有HTML标签\n    while \"<\" in string and \">\" in string:\n        string = string.replace(string[string.index(\"<\") : string.index(\">\") + 1], \"\")\n        string = string.replace(\"  \", \" \")\n        string = string.replace(\"  \", \" \")\n    return string\n\n\ndef replace_words(string, word_dic):\n    "}
{"task_id": "HumanEval/82", "completion": "    p_num = 1\n    for i in range(2, int(string[1])):\n        if string.find(str(i)) == -1:\n            p_num += 1\n            if p_num == int(string[1]):\n                return True\n        else:\n            continue\n    return False\n\n\nif __name__ == \"__main__\":\n    print(prime_length(\"Hello\"))", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    p_num = 1\n    for i in range(2, int(string[1])):\n        if string.find(str(i)) == -1:\n            p_num += 1\n            if p_num == int(string[1]):\n                return True\n        else:\n            continue\n    return False\n\n\nif __name__ == \"__main__\":\n    print(prime_length(\"Hello\"))"}
{"task_id": "HumanEval/82", "completion": "    num = len(string)\n    if num == 1:\n        return False\n    elif num == 2 or num == 3:\n        return True\n    else:\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n            print(num % i)\n        return True\n\n\ndef count_vowel(string):\n    \"\"\"编写一个函数，接收一个字符串，统计字符串中元音字母的个数\n    vowels_count('sweet') == 3\n    vowels_count('sweetbv') == 4\n    vowels_count('st') == 0\n    vowels_count('yay!') == 2\n    \"\"\"\n    count1 = 0\n    for i in string:\n        if i in \"aeiou\":\n            count1 += 1\n    return count1\n\n\ndef unique_list(list):\n    \"\"\"编写一个函数，接收一个列表，该函数返回列表中唯一元素的最小个数\n    list_count('sweet') == 3\n    list_", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    num = len(string)\n    if num == 1:\n        return False\n    elif num == 2 or num == 3:\n        return True\n    else:\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n            print(num % i)\n        return True\n\n\ndef count_vowel(string):\n    \"\"\"编写一个函数，接收一个字符串，统计字符串中元音字母的个数\n    vowels_count('sweet') == 3\n    vowels_count('sweetbv') == 4\n    vowels_count('st') == 0\n    vowels_count('yay!') == 2\n    \"\"\"\n    count1 = 0\n    for i in string:\n        if i in \"aeiou\":\n            count1 += 1\n    return count1\n\n\ndef unique_list(list):\n    \"\"\"编写一个函数，接收一个列表，该函数返回列表中唯一元素的最小个数\n    list_count('sweet') == 3\n    list_"}
{"task_id": "HumanEval/82", "completion": "    if len(string) > 1:\n        if string.isalpha():\n            string = string.lower()\n            letter_count = []\n            for letter in string:\n                letter_count.append(string.count(letter))\n            if prime(letter_count):\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n\ndef prime_sum(number):\n    \"\"\"\n    编写一个函数，接收一个正整数，如果该数字是质数，则返回True，否则返回False\n    \"\"\"\n    if number > 1:\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n        return True\n    else:\n        return False\n\n\ndef prime_sum_2(number):\n    \"\"\"\n    编写一个函数，接收一个正整数，如果该数字是质数，则返回True，否则返回False\n    \"\"\"\n    if number > 1:\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) > 1:\n        if string.isalpha():\n            string = string.lower()\n            letter_count = []\n            for letter in string:\n                letter_count.append(string.count(letter))\n            if prime(letter_count):\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n\ndef prime_sum(number):\n    \"\"\"\n    编写一个函数，接收一个正整数，如果该数字是质数，则返回True，否则返回False\n    \"\"\"\n    if number > 1:\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n        return True\n    else:\n        return False\n\n\ndef prime_sum_2(number):\n    \"\"\"\n    编写一个函数，接收一个正整数，如果该数字是质数，则返回True，否则返回False\n    \"\"\"\n    if number > 1:\n        for i in range(2, number):\n            if number % i == 0:\n                return False\n"}
{"task_id": "HumanEval/82", "completion": "    return len(string) in prime_list\n\n\ndef prime_factor(number):\n    \"\"\"编写一个函数，接收一个整数， 判断其是否是质数，并返回一个列表包含了其所有质因数    示例：\n    prime_factor(1) == []\n    prime_factor(8) == [2,2,2]\n    prime_factor(13) == [13]\n    prime_factor(37) == [7,13]\n    \"\"\"\n    result = [number]\n    for base in range(2, number + 1):\n        if number % base == 0 and is_prime(base):\n            result.append(base)\n    return result\n\n\ndef prime_factor_multiple(number):\n    \"\"\"编写一个函数，接收一个整数， 判断其是否是质数，并返回一个列表包含了其所有质因数，乘积是原数字的倍数    示例：\n    prime_factor_multiple(2) == []\n    prime_factor_multiple(12) == []\n    prime_factor_multiple(15", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return len(string) in prime_list\n\n\ndef prime_factor(number):\n    \"\"\"编写一个函数，接收一个整数， 判断其是否是质数，并返回一个列表包含了其所有质因数    示例：\n    prime_factor(1) == []\n    prime_factor(8) == [2,2,2]\n    prime_factor(13) == [13]\n    prime_factor(37) == [7,13]\n    \"\"\"\n    result = [number]\n    for base in range(2, number + 1):\n        if number % base == 0 and is_prime(base):\n            result.append(base)\n    return result\n\n\ndef prime_factor_multiple(number):\n    \"\"\"编写一个函数，接收一个整数， 判断其是否是质数，并返回一个列表包含了其所有质因数，乘积是原数字的倍数    示例：\n    prime_factor_multiple(2) == []\n    prime_factor_multiple(12) == []\n    prime_factor_multiple(15"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 0:\n        return None\n    if len(lst) == 1:\n        return lst[0]\n    if len(lst) == 2:\n        if lst[0] > lst[1]:\n            return lst[1]\n        else:\n            return lst[0]\n    sorted_lst = sorted(lst)\n    lst_set = set(lst)\n    for e in sorted_lst:\n        if e != sorted_lst[0] and e in lst_set:\n            return e", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 0:\n        return None\n    if len(lst) == 1:\n        return lst[0]\n    if len(lst) == 2:\n        if lst[0] > lst[1]:\n            return lst[1]\n        else:\n            return lst[0]\n    sorted_lst = sorted(lst)\n    lst_set = set(lst)\n    for e in sorted_lst:\n        if e != sorted_lst[0] and e in lst_set:\n            return e"}
{"task_id": "HumanEval/90", "completion": "    if lst == []:\n        return None\n    if len(lst) == 1:\n        return lst[0]\n    s1 = sorted(lst)\n    if s1[0] < s1[1]:\n        return s1[1]\n    else:\n        return s1[-1]\n\n\ndef next_smallest_2(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    s1 = sorted(lst)\n    if s1 == []:\n        return None\n    elif len(s1) == 1:\n        return s1[0]\n    elif s1[0] < s1[1", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if lst == []:\n        return None\n    if len(lst) == 1:\n        return lst[0]\n    s1 = sorted(lst)\n    if s1[0] < s1[1]:\n        return s1[1]\n    else:\n        return s1[-1]\n\n\ndef next_smallest_2(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    s1 = sorted(lst)\n    if s1 == []:\n        return None\n    elif len(s1) == 1:\n        return s1[0]\n    elif s1[0] < s1[1"}
{"task_id": "HumanEval/90", "completion": "    smallest = min(lst)\n    for i in lst:\n        if i < smallest and i > next_smallest:\n            next_smallest = i\n    return next_smallest\n\n\nif __name__ == \"__main__\":\n    print(next_smallest([4, 2, 5, 3, 1]))", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    smallest = min(lst)\n    for i in lst:\n        if i < smallest and i > next_smallest:\n            next_smallest = i\n    return next_smallest\n\n\nif __name__ == \"__main__\":\n    print(next_smallest([4, 2, 5, 3, 1]))"}
{"task_id": "HumanEval/90", "completion": "    if lst == []:\n        return None\n    if lst[1:] == []:\n        return lst[0]\n\n    l = [lst[1]]\n    l.extend(lst[:-1])\n    return sorted(l)[1]", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if lst == []:\n        return None\n    if lst[1:] == []:\n        return lst[0]\n\n    l = [lst[1]]\n    l.extend(lst[:-1])\n    return sorted(l)[1]"}
{"task_id": "HumanEval/90", "completion": "    if lst == []:\n        return None\n    lst.sort()\n    if len(lst) == 1:\n        return lst[0]\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        else:\n            return lst[1]\n    else:\n        if lst[0] == lst[1]:\n            return next_smallest(lst[2:])\n        else:\n            return lst[1]\n\n\nif __name__ == \"__main__\":\n    a = [5, 2, 1, 4, 3, 1]\n    print(next_smallest(a))", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if lst == []:\n        return None\n    lst.sort()\n    if len(lst) == 1:\n        return lst[0]\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        else:\n            return lst[1]\n    else:\n        if lst[0] == lst[1]:\n            return next_smallest(lst[2:])\n        else:\n            return lst[1]\n\n\nif __name__ == \"__main__\":\n    a = [5, 2, 1, 4, 3, 1]\n    print(next_smallest(a))"}
{"task_id": "HumanEval/90", "completion": "    pass", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    pass"}
{"task_id": "HumanEval/90", "completion": "    lst = sorted(lst)\n    if not lst or len(lst) == 1:\n        return None\n    second = lst[1]\n    if second not in lst:\n        return None\n    return second\n\n\ndef next_smallest_2(lst):\n    \"\"\"\n    next_smallest_2([1, 2, 3, 4, 5]) == 2\n    next_smallest_2([5, 1, 4, 3, 2]) == 2\n    next_smallest_2([]) == None\n    next_smallest_2([1, 1]) == None\n    next_smallest_2([2, 2]) == None\n    \"\"\"\n    lst = sorted(lst)\n    if not lst or len(lst) == 1:\n        return None\n    second = lst[1]\n    if second not in lst:\n        for item in lst:\n            if item > lst[0] and (item not in lst or item < second):\n                second = item\n    ", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst = sorted(lst)\n    if not lst or len(lst) == 1:\n        return None\n    second = lst[1]\n    if second not in lst:\n        return None\n    return second\n\n\ndef next_smallest_2(lst):\n    \"\"\"\n    next_smallest_2([1, 2, 3, 4, 5]) == 2\n    next_smallest_2([5, 1, 4, 3, 2]) == 2\n    next_smallest_2([]) == None\n    next_smallest_2([1, 1]) == None\n    next_smallest_2([2, 2]) == None\n    \"\"\"\n    lst = sorted(lst)\n    if not lst or len(lst) == 1:\n        return None\n    second = lst[1]\n    if second not in lst:\n        for item in lst:\n            if item > lst[0] and (item not in lst or item < second):\n                second = item\n    "}
{"task_id": "HumanEval/90", "completion": "    lst.sort()\n    if len(lst) < 2:\n        return None\n    if lst[0] < lst[1]:\n        return lst[1]\n    else:\n        return lst[0]\n\n\nif __name__ == \"__main__\":\n    test_list = [1, 2, 3, 4, 5]\n    print \"test list is \" + str(test_list)\n    print \"first smallest element is \" + str(first_smallest(test_list))\n    print \"next smallest element is  \" + str(next_smallest(test_list))", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    if lst[0] < lst[1]:\n        return lst[1]\n    else:\n        return lst[0]\n\n\nif __name__ == \"__main__\":\n    test_list = [1, 2, 3, 4, 5]\n    print \"test list is \" + str(test_list)\n    print \"first smallest element is \" + str(first_smallest(test_list))\n    print \"next smallest element is  \" + str(next_smallest(test_list))"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) < 1:\n        return None\n    first = lst[0]\n    lst = lst[1:]\n    if first < lst[0]:\n        return first\n    elif first > lst[0]:\n        return next_smallest(lst)\n    else:\n        return next_smallest(lst)\n\n\ndef max_repeating(s):\n    \"\"\"\n    给出一个字符串，你需要找出这个字符串中的最大重复子串的长度。\n    max_repeating('ababc') == 2\n    max_repeating('abcabcab') == 3\n    max_repeating('abc') == 1\n    max_repeating('') == 0\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"input should be string.\")\n    if len(s) < 1:\n        return 0\n    if s[::-1] == s:\n        return len(s)\n    else:\n        return max(max_repeating(s[:-1]), max_repeating(", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 1:\n        return None\n    first = lst[0]\n    lst = lst[1:]\n    if first < lst[0]:\n        return first\n    elif first > lst[0]:\n        return next_smallest(lst)\n    else:\n        return next_smallest(lst)\n\n\ndef max_repeating(s):\n    \"\"\"\n    给出一个字符串，你需要找出这个字符串中的最大重复子串的长度。\n    max_repeating('ababc') == 2\n    max_repeating('abcabcab') == 3\n    max_repeating('abc') == 1\n    max_repeating('') == 0\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"input should be string.\")\n    if len(s) < 1:\n        return 0\n    if s[::-1] == s:\n        return len(s)\n    else:\n        return max(max_repeating(s[:-1]), max_repeating("}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 0:\n        return None\n    m1 = min(lst)\n    lst.remove(m1)\n    if len(lst) == 0:\n        return None\n    m2 = min(lst)\n    return m2\n\n\ndef merge(lst1: list, lst2: list) -> list:\n    \"\"\"\n    给你两个整数数组 nums1 和 nums2，请你实现一个函数，\n    将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\n    初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。\n    你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。\n    \"\"\"\n    if len(lst1) == 0 and len(lst2) == 0:\n        return lst1\n    m = len(lst1)\n    n = len(lst2)\n    i = 0\n    j = 0\n    k = 0\n    if", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 0:\n        return None\n    m1 = min(lst)\n    lst.remove(m1)\n    if len(lst) == 0:\n        return None\n    m2 = min(lst)\n    return m2\n\n\ndef merge(lst1: list, lst2: list) -> list:\n    \"\"\"\n    给你两个整数数组 nums1 和 nums2，请你实现一个函数，\n    将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\n    初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。\n    你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。\n    \"\"\"\n    if len(lst1) == 0 and len(lst2) == 0:\n        return lst1\n    m = len(lst1)\n    n = len(lst2)\n    i = 0\n    j = 0\n    k = 0\n    if"}
{"task_id": "HumanEval/94", "completion": "    max_prime = 1\n    for i in range(2, 71):  # 质数范围0-70，因为质数的最大质因子是70\n        max_prime = i\n        for j in range(2, max_prime):\n            if i % j == 0:\n                break\n    return max_prime", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    max_prime = 1\n    for i in range(2, 71):  # 质数范围0-70，因为质数的最大质因子是70\n        max_prime = i\n        for j in range(2, max_prime):\n            if i % j == 0:\n                break\n    return max_prime"}
{"task_id": "HumanEval/94", "completion": "    # 第一步：判断输入是否为空\n    # 第一步：遍历输入的元素，并设置最大值\n    if not lst:\n        return -1\n    else:\n        max = lst[0]\n    for i in range(1, len(lst)):\n        if max < lst[i]:\n            max = lst[i]\n    print(\"最大值为%s\" % max)\n    max_value = 0\n    while max > 0:\n        max_value += max % 10\n        max = int(max / 10)\n    print(\"最大值对应的位数和为%s\" % max_value)\n    return max_value", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    # 第一步：判断输入是否为空\n    # 第一步：遍历输入的元素，并设置最大值\n    if not lst:\n        return -1\n    else:\n        max = lst[0]\n    for i in range(1, len(lst)):\n        if max < lst[i]:\n            max = lst[i]\n    print(\"最大值为%s\" % max)\n    max_value = 0\n    while max > 0:\n        max_value += max % 10\n        max = int(max / 10)\n    print(\"最大值对应的位数和为%s\" % max_value)\n    return max_value"}
{"task_id": "HumanEval/94", "completion": "    res = 0\n\n    for elem in lst:\n        if elem == 0:\n            continue\n        if is_prime(elem):\n            res += get_len_of_prime(elem)\n\n    return res\n\n\ndef test_get_len_of_prime(elem):\n    \"\"\"\n    请输出一个数字elem的质数位数\n    :param elem:\n    :return:\n    \"\"\"\n    print(\"the prime digit of {0} is {1}\".format(elem, get_len_of_prime(elem)))\n\n\ndef test_skjkasdkd(lst):\n    \"\"\"\n    测试skjkasdkd\n    :return:\n    \"\"\"\n    print(\"the result of {0} is {1}\".format(lst, skjkasdkd(lst)))\n\n\nif __name__ == \"__main__\":\n    test_get_len_of_prime(1)\n    test_get_len_of_prime(10)\n    test_get_len_of_prime(80000000000000", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    res = 0\n\n    for elem in lst:\n        if elem == 0:\n            continue\n        if is_prime(elem):\n            res += get_len_of_prime(elem)\n\n    return res\n\n\ndef test_get_len_of_prime(elem):\n    \"\"\"\n    请输出一个数字elem的质数位数\n    :param elem:\n    :return:\n    \"\"\"\n    print(\"the prime digit of {0} is {1}\".format(elem, get_len_of_prime(elem)))\n\n\ndef test_skjkasdkd(lst):\n    \"\"\"\n    测试skjkasdkd\n    :return:\n    \"\"\"\n    print(\"the result of {0} is {1}\".format(lst, skjkasdkd(lst)))\n\n\nif __name__ == \"__main__\":\n    test_get_len_of_prime(1)\n    test_get_len_of_prime(10)\n    test_get_len_of_prime(80000000000000"}
{"task_id": "HumanEval/94", "completion": "    max_prime, max_prime_len = 0, 0\n    for num in lst:\n        if is_prime(num):\n            prime, prime_len = num, count_prime_bits(num)\n            if prime_len > max_prime_len:\n                max_prime, max_prime_len = prime, prime_len\n    return max_prime_len\n\n\ndef main():\n    lst = [0, 81, 12, 3, 1, 21]\n    print(skjkasdkd(lst))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    max_prime, max_prime_len = 0, 0\n    for num in lst:\n        if is_prime(num):\n            prime, prime_len = num, count_prime_bits(num)\n            if prime_len > max_prime_len:\n                max_prime, max_prime_len = prime, prime_len\n    return max_prime_len\n\n\ndef main():\n    lst = [0, 81, 12, 3, 1, 21]\n    print(skjkasdkd(lst))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/94", "completion": "    d = {0}\n    for num in lst:\n        if num in d:\n            continue\n        d.add(num)\n        while num != 1:\n            if num % 2 == 0:\n                num /= 2\n            else:\n                num = num * 3 + 1\n            d.add(num)\n    max_num = max(d)\n    return int((math.log10(max_num) + 1) * max_num)\n\n\nclass Solution:\n    # @param {int} num a positive integer\n    # @return {int} the number of steps to reduce it to 1\n    def nP(self, num):\n        count = 0\n        while num > 1:\n            if num % 2 == 0:\n                num /= 2\n                count += 1\n            else:\n                num = num * 3 + 1\n                count += 1\n        return count\n\n    def nN(self, num):\n        count = 0\n        while num > 1:\n            if num % 2 == 0:\n                num /= ", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    d = {0}\n    for num in lst:\n        if num in d:\n            continue\n        d.add(num)\n        while num != 1:\n            if num % 2 == 0:\n                num /= 2\n            else:\n                num = num * 3 + 1\n            d.add(num)\n    max_num = max(d)\n    return int((math.log10(max_num) + 1) * max_num)\n\n\nclass Solution:\n    # @param {int} num a positive integer\n    # @return {int} the number of steps to reduce it to 1\n    def nP(self, num):\n        count = 0\n        while num > 1:\n            if num % 2 == 0:\n                num /= 2\n                count += 1\n            else:\n                num = num * 3 + 1\n                count += 1\n        return count\n\n    def nN(self, num):\n        count = 0\n        while num > 1:\n            if num % 2 == 0:\n                num /= "}
{"task_id": "HumanEval/94", "completion": "    max = 0\n    # lst = lst[:]\n    for i in range(len(lst)):\n        flag = 1\n        for j in range(2, int(lst[i]) + 1):\n            if lst[i] % j == 0:\n                flag = 0\n                break\n        if flag == 1 and max < len(str(lst[i])):\n            max = len(str(lst[i]))\n    return max\n\n\ndef q1(lst):\n    \"\"\"\n    给定一个整数列表，返回两个整数，它们的和为8， 且第一数小于第二个数。如果没有满足条件的两个整数，则返回空列表 [3,5]\n    示例如下：对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 [3, 5]\n    对于 lst = [1,0,1,8,2,4597,2,1,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    max = 0\n    # lst = lst[:]\n    for i in range(len(lst)):\n        flag = 1\n        for j in range(2, int(lst[i]) + 1):\n            if lst[i] % j == 0:\n                flag = 0\n                break\n        if flag == 1 and max < len(str(lst[i])):\n            max = len(str(lst[i]))\n    return max\n\n\ndef q1(lst):\n    \"\"\"\n    给定一个整数列表，返回两个整数，它们的和为8， 且第一数小于第二个数。如果没有满足条件的两个整数，则返回空列表 [3,5]\n    示例如下：对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 [3, 5]\n    对于 lst = [1,0,1,8,2,4597,2,1,"}
{"task_id": "HumanEval/94", "completion": "    nums = []\n    t = []\n    for i in lst:\n        if i in nums:\n            pass\n        else:\n            nums.append(i)\n            if i != 0:\n                i = int(i)\n                while i > 0:\n                    t.append(i % 10)\n                    i //= 10\n            else:\n                t.append(0)\n    lst = []\n    for i in t:\n        lst.append(i)\n    lst = lst[::-1]\n    p = 0\n    for i in lst:\n        p += i\n    return p", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    nums = []\n    t = []\n    for i in lst:\n        if i in nums:\n            pass\n        else:\n            nums.append(i)\n            if i != 0:\n                i = int(i)\n                while i > 0:\n                    t.append(i % 10)\n                    i //= 10\n            else:\n                t.append(0)\n    lst = []\n    for i in t:\n        lst.append(i)\n    lst = lst[::-1]\n    p = 0\n    for i in lst:\n        p += i\n    return p"}
{"task_id": "HumanEval/94", "completion": "    num_list = []\n    for num in lst:\n        num_list.append(num)\n    max_num = max(num_list)\n    result = 0\n    while max_num > 0:\n        result += max_num % 10\n        max_num = max_num // 10\n    return result\n\n\ndef ffff(lst):\n    \"\"\"您有一个整数列表，例如 [0,81,12,3,1,21]。将列表中的所有 0 移动到列表的末尾，同时保持列表中其他元素的相对顺序。\n    例如：对于列表 [0,81,12,3,1,21]，您应该返回 [1,81,12,3,1,21,0]。\n    对于列表 [83278,99,32,71,99,32,6,0,5,91,83,0,5,6]，您应该返回 [83278,99,32,71,99,32,6,0,5,91,83,0,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    num_list = []\n    for num in lst:\n        num_list.append(num)\n    max_num = max(num_list)\n    result = 0\n    while max_num > 0:\n        result += max_num % 10\n        max_num = max_num // 10\n    return result\n\n\ndef ffff(lst):\n    \"\"\"您有一个整数列表，例如 [0,81,12,3,1,21]。将列表中的所有 0 移动到列表的末尾，同时保持列表中其他元素的相对顺序。\n    例如：对于列表 [0,81,12,3,1,21]，您应该返回 [1,81,12,3,1,21,0]。\n    对于列表 [83278,99,32,71,99,32,6,0,5,91,83,0,5,6]，您应该返回 [83278,99,32,71,99,32,6,0,5,91,83,0,"}
{"task_id": "HumanEval/94", "completion": "    lst = lst\n\n    def get_prime(num):\n        for i in range(2, num):\n            for j in range(2, i):\n                if j == i:\n                    lst.append(i)\n\n    get_prime(max(lst))\n    return max(lst)\n\n\ndef lll(lst):\n    \"\"\"您有一个整数列表。对于每个整数，通过添加零的数量，我们可以得到另一个整数列表。\n    示例如下：   对于lst = [4,19,48,14,22,34,53,62,53,39,73,27]输出应为[4,0000,0000,19,0000,0000,48,0000,0000,14,0000,0000,22,0000,0000,34,0000,0000,53,0000,0000,62,0000,0000,53", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = lst\n\n    def get_prime(num):\n        for i in range(2, num):\n            for j in range(2, i):\n                if j == i:\n                    lst.append(i)\n\n    get_prime(max(lst))\n    return max(lst)\n\n\ndef lll(lst):\n    \"\"\"您有一个整数列表。对于每个整数，通过添加零的数量，我们可以得到另一个整数列表。\n    示例如下：   对于lst = [4,19,48,14,22,34,53,62,53,39,73,27]输出应为[4,0000,0000,19,0000,0000,48,0000,0000,14,0000,0000,22,0000,0000,34,0000,0000,53,0000,0000,62,0000,0000,53"}
{"task_id": "HumanEval/94", "completion": "    lst = [int(i) for i in str(lst)]\n    nums = {2: 0, 3: 0, 5: 0, 7: 0, 11: 0, 13: 0, 17: 0, 19: 0, 23: 0, 29: 0, 31: 0, 37: 0}\n    for i in lst:\n        for key in nums:\n            if i % key == 0:\n                nums[key] = nums[key] + 1\n        if i == 1:\n            nums[2] = nums[2] + 1\n    if 1 in nums:\n        max_val = 1\n    elif 2 in nums:\n        max_val = 2\n    elif 3 in nums:\n        max_val = 3\n    else:\n        max_val = 5\n\n    for key in nums:\n        if nums[key] == max_val:\n            return key\n    return None\n\n\n# print", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = [int(i) for i in str(lst)]\n    nums = {2: 0, 3: 0, 5: 0, 7: 0, 11: 0, 13: 0, 17: 0, 19: 0, 23: 0, 29: 0, 31: 0, 37: 0}\n    for i in lst:\n        for key in nums:\n            if i % key == 0:\n                nums[key] = nums[key] + 1\n        if i == 1:\n            nums[2] = nums[2] + 1\n    if 1 in nums:\n        max_val = 1\n    elif 2 in nums:\n        max_val = 2\n    elif 3 in nums:\n        max_val = 3\n    else:\n        max_val = 5\n\n    for key in nums:\n        if nums[key] == max_val:\n            return key\n    return None\n\n\n# print"}
{"task_id": "HumanEval/103", "completion": "\n    if n > m:\n        return -1\n    aver = (n + m) / 2\n    binary = bin(int(aver))\n    return (str(binary)[2:]).rjust(len(str(n)), \"0\")", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n\n    if n > m:\n        return -1\n    aver = (n + m) / 2\n    binary = bin(int(aver))\n    return (str(binary)[2:]).rjust(len(str(n)), \"0\")"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    total = 0\n    for i in range(m + 1):\n        total = total + i\n    return \"0b\" + bin(round(total / (m - n + 1)))[2:]\n\n\nif __name__ == \"__main__\":\n    assert rounded_avg(1, 5) == \"0b11\", \"First\"\n    assert rounded_avg(7, 5) == -1, \"Second\"\n    assert rounded_avg(10, 20) == \"0b1111\", \"Third\"\n    assert rounded_avg(20, 33) == \"0b11010\", \"Fourth\"\n    print(\"Coding complete? Click 'Check' to review your tests and earn cool rewards!\")", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    total = 0\n    for i in range(m + 1):\n        total = total + i\n    return \"0b\" + bin(round(total / (m - n + 1)))[2:]\n\n\nif __name__ == \"__main__\":\n    assert rounded_avg(1, 5) == \"0b11\", \"First\"\n    assert rounded_avg(7, 5) == -1, \"Second\"\n    assert rounded_avg(10, 20) == \"0b1111\", \"Third\"\n    assert rounded_avg(20, 33) == \"0b11010\", \"Fourth\"\n    print(\"Coding complete? Click 'Check' to review your tests and earn cool rewards!\")"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    return '0b' + bin(n + m)", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    return '0b' + bin(n + m)"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    return bin(round(abs((n + m) / 2.0)))\n\n\ndef count_digits(n):\n    \"\"\"写一个函数count_digits，它接受一个正整数作为输入并返回该数字的位数。   Example:\n    count_digits(5) => 2\n    count_digits(10) => 2\n    count_digits(100) => 3\n    count_digits(35) => 2\n    count_digits(89735) => 4\n    \"\"\"\n    return len(str(n))\n\n\ndef count_vowels(string):\n    \"\"\"写一个程序，接受一个字符串并计算其中元音字母的数目。 您忽略大小写。  Example:\n    count_vowels(\"HIV\") => 2\n    count_vowels(\"aeiou\") => 5\n    count_vowels(\"fdskl\") => 0\n    count_vowels(\"alien\") => 4\n    \"\"\"\n    v", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    return bin(round(abs((n + m) / 2.0)))\n\n\ndef count_digits(n):\n    \"\"\"写一个函数count_digits，它接受一个正整数作为输入并返回该数字的位数。   Example:\n    count_digits(5) => 2\n    count_digits(10) => 2\n    count_digits(100) => 3\n    count_digits(35) => 2\n    count_digits(89735) => 4\n    \"\"\"\n    return len(str(n))\n\n\ndef count_vowels(string):\n    \"\"\"写一个程序，接受一个字符串并计算其中元音字母的数目。 您忽略大小写。  Example:\n    count_vowels(\"HIV\") => 2\n    count_vowels(\"aeiou\") => 5\n    count_vowels(\"fdskl\") => 0\n    count_vowels(\"alien\") => 4\n    \"\"\"\n    v"}
{"task_id": "HumanEval/103", "completion": "    n = int(n)\n    m = int(m)\n    if n > m:\n        return -1\n    else:\n        return bin(int((n + m) / 2)).replace(\"0b\", \"\")\n\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n\n\n\"\"\"\n题目：\n您正在参加一个多天会议。 您想快速找到与您关联的所有会议。\n每个会议都有一个主题，每个主题都与给定单词列表中的一个单词相关。\n您将获得有关会议的列表。 您的工作是为每个单词输出包含关联的会议数量。\n\nExample:\n\"\"\"\n\n\ndef find_meetings(meetings):\n    \"\"\"您正在参加一个多天会议。 您想快速找到与您关联的所有会议。\n每个会议都有一个主题，每个主题都与给定单词列表中的一个单词相关。\n您将获得有关会议的列表。 您的工作", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    n = int(n)\n    m = int(m)\n    if n > m:\n        return -1\n    else:\n        return bin(int((n + m) / 2)).replace(\"0b\", \"\")\n\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n\n\n\"\"\"\n题目：\n您正在参加一个多天会议。 您想快速找到与您关联的所有会议。\n每个会议都有一个主题，每个主题都与给定单词列表中的一个单词相关。\n您将获得有关会议的列表。 您的工作是为每个单词输出包含关联的会议数量。\n\nExample:\n\"\"\"\n\n\ndef find_meetings(meetings):\n    \"\"\"您正在参加一个多天会议。 您想快速找到与您关联的所有会议。\n每个会议都有一个主题，每个主题都与给定单词列表中的一个单词相关。\n您将获得有关会议的列表。 您的工作"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        return b2h(round(n + m) / 2)\n\nprint(rounded_avg(2, 100))", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        return b2h(round(n + m) / 2)\n\nprint(rounded_avg(2, 100))"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        return bin(int(round((n + m) / 2.0)))\n\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        return bin(int(round((n + m) / 2.0)))\n\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))"}
{"task_id": "HumanEval/103", "completion": "    n = int(n)\n    m = int(m)\n    if n > m:\n        return False\n    sum = 0\n    two_to_n = 2 ** n\n    two_to_m = 2 ** m\n    for i in range(two_to_n, two_to_m + 1):\n        sum += i\n    return \"{0:b}\".format(sum // (m - n + 1))", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    n = int(n)\n    m = int(m)\n    if n > m:\n        return False\n    sum = 0\n    two_to_n = 2 ** n\n    two_to_m = 2 ** m\n    for i in range(two_to_n, two_to_m + 1):\n        sum += i\n    return \"{0:b}\".format(sum // (m - n + 1))"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        return \"0b\" + bin(int((n + m) * (2 ** (len(bin(n)) - 2) - 1) / 2))[2:].zfill(\n            len(bin(n)) - 2\n        )\n\n\ndef binary_average(n, m):\n    \"\"\"\n    用n和m之间的整数的二进制平均值。\n    将答案四舍五入为最接近的整数，并将其转换为二进制。\n    如果n大于m，则返回-1。\n    例如:\n    rounded_average(1, 5) => \"0b11\"\n    rounded_average(7, 5) => -1\n    rounded_average(10, 20) => \"0b1111\"\n    rounded_average(20, 33) => \"0b11010\"\n    \"\"\"\n    return -1 if n > m else \"0b\" + bin(\n        int((n + m) * (2", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        return \"0b\" + bin(int((n + m) * (2 ** (len(bin(n)) - 2) - 1) / 2))[2:].zfill(\n            len(bin(n)) - 2\n        )\n\n\ndef binary_average(n, m):\n    \"\"\"\n    用n和m之间的整数的二进制平均值。\n    将答案四舍五入为最接近的整数，并将其转换为二进制。\n    如果n大于m，则返回-1。\n    例如:\n    rounded_average(1, 5) => \"0b11\"\n    rounded_average(7, 5) => -1\n    rounded_average(10, 20) => \"0b1111\"\n    rounded_average(20, 33) => \"0b11010\"\n    \"\"\"\n    return -1 if n > m else \"0b\" + bin(\n        int((n + m) * (2"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    result = '{0:b}'.format(int((n + m) / 2))\n    return result", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    result = '{0:b}'.format(int((n + m) / 2))\n    return result"}
{"task_id": "HumanEval/109", "completion": "    l = len(arr)\n    if l == 0:\n        return True\n\n    smallest = arr[0]\n    for i in range(1, l):\n        if arr[i] < smallest:\n            smallest = arr[i]\n\n    for i in range(l):\n        if arr[i] != smallest:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(move_one_ball([3, 4, 5, 1, 2]))\n    print(move_one_ball([3, 5, 4, 1, 2]))", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    l = len(arr)\n    if l == 0:\n        return True\n\n    smallest = arr[0]\n    for i in range(1, l):\n        if arr[i] < smallest:\n            smallest = arr[i]\n\n    for i in range(l):\n        if arr[i] != smallest:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(move_one_ball([3, 4, 5, 1, 2]))\n    print(move_one_ball([3, 5, 4, 1, 2]))"}
{"task_id": "HumanEval/109", "completion": "    array = list(arr)\n    array.sort()\n    if array == arr:\n        return True\n    else:\n        return False", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    array = list(arr)\n    array.sort()\n    if array == arr:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/109", "completion": "    return False\n\n\ndef max_sum(lst):\n    \"\"\"给定一个整数列表，求所有非空连续子序列中最大和的连续子序列。    \n    For example:  \n    \n    max_sum([3, 2, -6, 4, 0])==>6\n    max_sum([-2, -3 ,4])==>4\n    max_sum([-2, 1, -4, 10, -1, 0, 2])==>15\n    max_sum([1 ,2 ,-5 ,-7, -4])==>15\n    max_sum([1 ,2 ,-5 ,-7, -4, 5, -6, -2, 90, 5, -6, 7])==>123\n    max_sum([-1, -4, -5, 0, 7, 1, -2])==>9\n    max_sum([])==>0\n    max_sum([-1000000]==>-1000000\n    \"\"\"", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    return False\n\n\ndef max_sum(lst):\n    \"\"\"给定一个整数列表，求所有非空连续子序列中最大和的连续子序列。    \n    For example:  \n    \n    max_sum([3, 2, -6, 4, 0])==>6\n    max_sum([-2, -3 ,4])==>4\n    max_sum([-2, 1, -4, 10, -1, 0, 2])==>15\n    max_sum([1 ,2 ,-5 ,-7, -4])==>15\n    max_sum([1 ,2 ,-5 ,-7, -4, 5, -6, -2, 90, 5, -6, 7])==>123\n    max_sum([-1, -4, -5, 0, 7, 1, -2])==>9\n    max_sum([])==>0\n    max_sum([-1000000]==>-1000000\n    \"\"\""}
{"task_id": "HumanEval/109", "completion": "    if arr == None:\n        return True\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\n\nprint(move_one_ball([3, 4, 5, 1, 2]))", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if arr == None:\n        return True\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\n\nprint(move_one_ball([3, 4, 5, 1, 2]))"}
{"task_id": "HumanEval/109", "completion": "    n = len(arr)\n    if n == 0:\n        return True\n    if n == 1:\n        return True\n    sorted_ele = sorted(arr)\n    print(sorted_ele)\n    for i in range(n):\n        if not sorted_ele[i] == arr[i]:\n            return False\n    return True", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return True\n    if n == 1:\n        return True\n    sorted_ele = sorted(arr)\n    print(sorted_ele)\n    for i in range(n):\n        if not sorted_ele[i] == arr[i]:\n            return False\n    return True"}
{"task_id": "HumanEval/109", "completion": "    arr.sort()\n    return arr == sorted(arr)\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input().strip())\n\n    arr = list(map(int, input().rstrip().split()))\n\n    result = move_one_ball(arr)\n\n    fptr.write('true\\n' if result else 'false\\n')\n    fptr.close()\n\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nclass BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef buildTree(s):\n    if (s[0] == \"N\"):\n        return None\n    currNode = BinaryTreeNode(int(s[0]))\n    size = 1\n    isLeft = True\n    ", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    arr.sort()\n    return arr == sorted(arr)\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input().strip())\n\n    arr = list(map(int, input().rstrip().split()))\n\n    result = move_one_ball(arr)\n\n    fptr.write('true\\n' if result else 'false\\n')\n    fptr.close()\n\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nclass BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef buildTree(s):\n    if (s[0] == \"N\"):\n        return None\n    currNode = BinaryTreeNode(int(s[0]))\n    size = 1\n    isLeft = True\n    "}
{"task_id": "HumanEval/109", "completion": "    return _move_one_ball(2, arr)\n\n\ndef _move_one_ball(k, arr):\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    # 把arr[k-1]挪到开头，arr[0]挪到arr[k-1]的后面\n    if k == 2:\n        if arr[0] > arr[1]:\n            return False\n    else:\n        if arr[k - 1] > arr[k - 2]:\n            return False\n    # 移动arr[0]和arr[k-2]\n    if k == 2:\n        # 判断arr[0]是否大于arr[1]\n        # 如果是，说明可以排成非降序，返回True\n        if _move_one_ball(2, arr[1:]):\n            return True\n        # 如果不是，说明不能排成非降序，返回False\n        return False\n    else:\n        if _move_one_ball(k - 1, arr[1", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    return _move_one_ball(2, arr)\n\n\ndef _move_one_ball(k, arr):\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    # 把arr[k-1]挪到开头，arr[0]挪到arr[k-1]的后面\n    if k == 2:\n        if arr[0] > arr[1]:\n            return False\n    else:\n        if arr[k - 1] > arr[k - 2]:\n            return False\n    # 移动arr[0]和arr[k-2]\n    if k == 2:\n        # 判断arr[0]是否大于arr[1]\n        # 如果是，说明可以排成非降序，返回True\n        if _move_one_ball(2, arr[1:]):\n            return True\n        # 如果不是，说明不能排成非降序，返回False\n        return False\n    else:\n        if _move_one_ball(k - 1, arr[1"}
{"task_id": "HumanEval/109", "completion": "    # arr = sorted(arr)\n    # print(arr)\n    # return arr == sorted(arr)\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\nprint(move_one_ball([3, 5, 4, 1, 2]))", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    # arr = sorted(arr)\n    # print(arr)\n    # return arr == sorted(arr)\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n\nprint(move_one_ball([3, 5, 4, 1, 2]))"}
{"task_id": "HumanEval/109", "completion": "    if len(arr) == 0:\n        return True\n\n    def get_next_max_index(arr, max_idx, direction):\n        if direction == 'left':\n            if (max_idx - 1) >= 0:\n                return max_idx - 1\n            else:\n                return len(arr) - 1\n        else:\n            if (max_idx + 1) < len(arr):\n                return max_idx + 1\n            else:\n                return 0\n\n    def move_one_ball_helper(arr, max_idx):\n        next_idx = get_next_max_index(arr, max_idx, 'left')\n        if arr[next_idx] < arr[max_idx]:\n            return False\n        else:\n            arr[max_idx], arr[next_idx] = arr[next_idx], arr[max_idx]\n            return move_one_ball_helper(arr, get_next_max_index(arr, max_idx, 'left'))\n\n    return move_one_ball_helper(arr, len(", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if len(arr) == 0:\n        return True\n\n    def get_next_max_index(arr, max_idx, direction):\n        if direction == 'left':\n            if (max_idx - 1) >= 0:\n                return max_idx - 1\n            else:\n                return len(arr) - 1\n        else:\n            if (max_idx + 1) < len(arr):\n                return max_idx + 1\n            else:\n                return 0\n\n    def move_one_ball_helper(arr, max_idx):\n        next_idx = get_next_max_index(arr, max_idx, 'left')\n        if arr[next_idx] < arr[max_idx]:\n            return False\n        else:\n            arr[max_idx], arr[next_idx] = arr[next_idx], arr[max_idx]\n            return move_one_ball_helper(arr, get_next_max_index(arr, max_idx, 'left'))\n\n    return move_one_ball_helper(arr, len("}
{"task_id": "HumanEval/109", "completion": "    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            return False\n    return True\n\n\n# move_one_ball([3,4,5,1,2])\n\n\ndef minimum_absolute_difference(arr):\n    \"\"\"给定一个数字数组，找到两个数字使得它们之间的绝对差最小。返回绝对差值。\n    For example,\n    \n    minimum_absolute_difference([3, 4, 2, 1]) ==> 1    \n    Explanation: Minimum absolute difference is 1 between 3 and 4. Minimum absolute difference is 1 between 2 and 1.\n    \"\"\"\n    min_absolute = abs(arr[0] - arr[1])\n    for i in range(0, len(arr) - 1):\n        temp = abs(arr[i] - arr[i + 1])\n        if min_absolute > temp:\n            min_absolute = temp\n    return min_absolute\n\n\n\n\ndef min_", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            return False\n    return True\n\n\n# move_one_ball([3,4,5,1,2])\n\n\ndef minimum_absolute_difference(arr):\n    \"\"\"给定一个数字数组，找到两个数字使得它们之间的绝对差最小。返回绝对差值。\n    For example,\n    \n    minimum_absolute_difference([3, 4, 2, 1]) ==> 1    \n    Explanation: Minimum absolute difference is 1 between 3 and 4. Minimum absolute difference is 1 between 2 and 1.\n    \"\"\"\n    min_absolute = abs(arr[0] - arr[1])\n    for i in range(0, len(arr) - 1):\n        temp = abs(arr[i] - arr[i + 1])\n        if min_absolute > temp:\n            min_absolute = temp\n    return min_absolute\n\n\n\n\ndef min_"}
{"task_id": "HumanEval/114", "completion": "    min_sum = float(\"inf\")\n    for i, num in enumerate(nums):\n        sum_num = num\n        for j in range(i + 1, len(nums)):\n            sum_num += nums[j]\n            if sum_num < min_sum:\n                min_sum = sum_num\n    return min_sum\n\n\ndef minAbsoluteSum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minAbsoluteSum([1, 2, 3]) == 1\n    minAbsoluteSum([-1, -2, -3]) == 1\n    minAbsoluteSum([-1, -2, -3]) = 1\n    \"\"\"\n    min_sum = float(\"inf\")\n    for i, num in enumerate(nums):\n        sum_num = num\n        for j in range(i + 1, len(nums)):\n            sum_num += nums[j]\n            if sum_num < min_sum", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    min_sum = float(\"inf\")\n    for i, num in enumerate(nums):\n        sum_num = num\n        for j in range(i + 1, len(nums)):\n            sum_num += nums[j]\n            if sum_num < min_sum:\n                min_sum = sum_num\n    return min_sum\n\n\ndef minAbsoluteSum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minAbsoluteSum([1, 2, 3]) == 1\n    minAbsoluteSum([-1, -2, -3]) == 1\n    minAbsoluteSum([-1, -2, -3]) = 1\n    \"\"\"\n    min_sum = float(\"inf\")\n    for i, num in enumerate(nums):\n        sum_num = num\n        for j in range(i + 1, len(nums)):\n            sum_num += nums[j]\n            if sum_num < min_sum"}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return 0\n    min_sum = float(\"inf\")\n    sum = 0\n    for num in nums:\n        sum += num\n        # 当前缀和为负数，则丢弃，重新开始\n        if sum < 0:\n            sum = 0\n        # 更新最小值\n        min_sum = min(min_sum, sum)\n    # 整个数组之和都小于0，则返回整个数组之和\n    if min_sum == float(\"inf\"):\n        min_sum = sum\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float(\"inf\")\n    sum = 0\n    for num in nums:\n        sum += num\n        # 当前缀和为负数，则丢弃，重新开始\n        if sum < 0:\n            sum = 0\n        # 更新最小值\n        min_sum = min(min_sum, sum)\n    # 整个数组之和都小于0，则返回整个数组之和\n    if min_sum == float(\"inf\"):\n        min_sum = sum\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))"}
{"task_id": "HumanEval/114", "completion": "    start, min_sum = 0, sys.maxsize\n    temp_sum = 0\n    for i in range(len(nums)):\n        temp_sum += nums[i]\n        if temp_sum < min_sum:\n            min_sum = temp_sum\n        if temp_sum < 0:\n            temp_sum = 0\n            start = i + 1\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 4, 1, 2, 4]\n    # output = [2, 3, 4, 1, 2, 4]\n    output = [-1, -2, -3]\n    output = minSubArraySum(nums)\n    print(output)\n\n    # 测试\n    assert output == 1", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    start, min_sum = 0, sys.maxsize\n    temp_sum = 0\n    for i in range(len(nums)):\n        temp_sum += nums[i]\n        if temp_sum < min_sum:\n            min_sum = temp_sum\n        if temp_sum < 0:\n            temp_sum = 0\n            start = i + 1\n    return min_sum\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 4, 1, 2, 4]\n    # output = [2, 3, 4, 1, 2, 4]\n    output = [-1, -2, -3]\n    output = minSubArraySum(nums)\n    print(output)\n\n    # 测试\n    assert output == 1"}
{"task_id": "HumanEval/114", "completion": "    return minSubArraySumCore(nums)\n\n\ndef minSubArraySumCore(nums):\n    \"\"\"\n    最小子数组和计算函数核心实现\n    :param nums:\n    :return:\n    \"\"\"\n    if len(nums) == 0:\n        raise Exception('Input error, empty arrays')\n\n    min_sum = sys.maxsize\n    sum_arr = 0\n    for num in nums:\n        sum_arr += num\n        if sum_arr < min_sum:\n            min_sum = sum_arr\n\n    return min_sum\n\n\ndef minSubArraySumBruteForce(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    :param nums:\n    :return:\n    \"\"\"\n    if len(nums", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    return minSubArraySumCore(nums)\n\n\ndef minSubArraySumCore(nums):\n    \"\"\"\n    最小子数组和计算函数核心实现\n    :param nums:\n    :return:\n    \"\"\"\n    if len(nums) == 0:\n        raise Exception('Input error, empty arrays')\n\n    min_sum = sys.maxsize\n    sum_arr = 0\n    for num in nums:\n        sum_arr += num\n        if sum_arr < min_sum:\n            min_sum = sum_arr\n\n    return min_sum\n\n\ndef minSubArraySumBruteForce(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    :param nums:\n    :return:\n    \"\"\"\n    if len(nums"}
{"task_id": "HumanEval/114", "completion": "    if len(nums) == 0:\n        raise ValueError(\"Invalid input\")\n\n    # 先求前缀和数组\n    preSum = [nums[0]]\n    for i in range(1, len(nums)):\n        preSum.append(preSum[i - 1] + nums[i])\n\n    # 遍历前缀和数组，如果某个位置的前缀和减去最左边的数大于0， 则这个位置和最左边的数的和最小，\n    # 继续与最左边的数比下一个位置，如果还是大于0， 那么这个位置就是满足要求的连续子数组的左边界，继续向右搜索右边界\n    minSum, minIndex = sys.maxsize, 0\n    for i in range(1, len(preSum)):\n        if preSum[i] - preSum[minIndex] > 0:\n            minIndex = i\n            minSum = preSum[i]\n        elif preSum[i] - preSum[i - 1] < preSum[i]:\n            minIndex = i - 1\n            minSum =", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"Invalid input\")\n\n    # 先求前缀和数组\n    preSum = [nums[0]]\n    for i in range(1, len(nums)):\n        preSum.append(preSum[i - 1] + nums[i])\n\n    # 遍历前缀和数组，如果某个位置的前缀和减去最左边的数大于0， 则这个位置和最左边的数的和最小，\n    # 继续与最左边的数比下一个位置，如果还是大于0， 那么这个位置就是满足要求的连续子数组的左边界，继续向右搜索右边界\n    minSum, minIndex = sys.maxsize, 0\n    for i in range(1, len(preSum)):\n        if preSum[i] - preSum[minIndex] > 0:\n            minIndex = i\n            minSum = preSum[i]\n        elif preSum[i] - preSum[i - 1] < preSum[i]:\n            minIndex = i - 1\n            minSum ="}
{"task_id": "HumanEval/114", "completion": "    return min([sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums) + 1)])\n\n\nif __name__ == '__main__':\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))\n    print(minSubArraySum([-1, -2, -3]))", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    return min([sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums) + 1)])\n\n\nif __name__ == '__main__':\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))\n    print(minSubArraySum([-1, -2, -3]))"}
{"task_id": "HumanEval/114", "completion": "    min_sum = float('inf')\n    sum_ = 0\n    for num in nums:\n        sum_ += num\n        min_sum = min(sum_, min_sum)\n        if sum_ < 0:\n            sum_ = 0\n\n    return min_sum\n\n\nif __name__ == '__main__':\n    nums = [2, 3, -1, -2, 4, 1, 2, 4]\n    # 5\n    print(minSubArraySum(nums))", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    min_sum = float('inf')\n    sum_ = 0\n    for num in nums:\n        sum_ += num\n        min_sum = min(sum_, min_sum)\n        if sum_ < 0:\n            sum_ = 0\n\n    return min_sum\n\n\nif __name__ == '__main__':\n    nums = [2, 3, -1, -2, 4, 1, 2, 4]\n    # 5\n    print(minSubArraySum(nums))"}
{"task_id": "HumanEval/114", "completion": "    res = count = minSum = 0\n    for i in nums:\n        count += i\n        res += count\n        if count < 0:\n            count = 0\n        minSum = min(minSum, res)\n    return minSum\n\n\ndef minSubArraySum2(nums):\n    \"\"\"利用滑动窗口思想\"\"\"\n    max_sub_sum, window_sum = 0, 0\n    for r in range(len(nums)):\n        window_sum += nums[r]\n        if window_sum < window_sum:\n            window_sum = 0\n        if window_sum > max_sub_sum:\n            max_sub_sum = window_sum\n    return max_sub_sum\n\n\ndef minSubArraySum3(nums):\n    \"\"\"利用滑动窗口思想\"\"\"\n    window_sum = max_sub_sum = 0\n    for l in range(len(nums)):\n        window_sum += nums[l]\n        while window_sum < max_sub_sum:\n            window_sum -= nums[r]\n            r", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    res = count = minSum = 0\n    for i in nums:\n        count += i\n        res += count\n        if count < 0:\n            count = 0\n        minSum = min(minSum, res)\n    return minSum\n\n\ndef minSubArraySum2(nums):\n    \"\"\"利用滑动窗口思想\"\"\"\n    max_sub_sum, window_sum = 0, 0\n    for r in range(len(nums)):\n        window_sum += nums[r]\n        if window_sum < window_sum:\n            window_sum = 0\n        if window_sum > max_sub_sum:\n            max_sub_sum = window_sum\n    return max_sub_sum\n\n\ndef minSubArraySum3(nums):\n    \"\"\"利用滑动窗口思想\"\"\"\n    window_sum = max_sub_sum = 0\n    for l in range(len(nums)):\n        window_sum += nums[l]\n        while window_sum < max_sub_sum:\n            window_sum -= nums[r]\n            r"}
{"task_id": "HumanEval/114", "completion": "    if len(nums) == 0:\n        return 0\n    sum_nums = 0\n    sum_nums_min = nums[0]\n    for i in range(len(nums)):\n        sum_nums += nums[i]\n        if sum_nums<sum_nums_min:\n            sum_nums_min = sum_nums\n    return sum_nums_min", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    sum_nums = 0\n    sum_nums_min = nums[0]\n    for i in range(len(nums)):\n        sum_nums += nums[i]\n        if sum_nums<sum_nums_min:\n            sum_nums_min = sum_nums\n    return sum_nums_min"}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return 0\n\n    min_sum = nums[0]\n    cur_min = nums[0]\n    for i in range(1, len(nums)):\n        cur_min += nums[i]\n        if cur_min > 0:\n            min_sum = min(min_sum, cur_min)\n        else:\n            cur_min = 0\n    return min_sum if min_sum else 0\n\n\ndef minSubArrayLen(nums, s):\n    \"\"\"\n    给定一个含有正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，如果不存在符合条件的子数组，返回 0。\n    minSubArrayLen([2, 3, 1, 2, 4, 3], 7) == 2\n    minSubArrayLen([2, 3, 1, 2, 4, 3], 6) == 1\n    minSubArrayLen([2, 3, 1, 2, 4, ", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n\n    min_sum = nums[0]\n    cur_min = nums[0]\n    for i in range(1, len(nums)):\n        cur_min += nums[i]\n        if cur_min > 0:\n            min_sum = min(min_sum, cur_min)\n        else:\n            cur_min = 0\n    return min_sum if min_sum else 0\n\n\ndef minSubArrayLen(nums, s):\n    \"\"\"\n    给定一个含有正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，如果不存在符合条件的子数组，返回 0。\n    minSubArrayLen([2, 3, 1, 2, 4, 3], 7) == 2\n    minSubArrayLen([2, 3, 1, 2, 4, 3], 6) == 1\n    minSubArrayLen([2, 3, 1, 2, 4, "}
{"task_id": "MBPP/12", "completion": "\n    sum_arr = list()\n    for i in range(len(M)):\n        sums = sum(M[i])\n        sum_arr.append(sums)\n    sum_arr.sort(reverse=True)\n\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = sum_arr[i]\n\n    return M\n\n\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 计算每行的总和\n    sums = [sum(M[i]) for i in range(len(M))]\n    # 对每行的总和新进行排序\n    # 重新填入矩阵\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = sums[i]\n    return M\n\n\ndef sort_matrix(M: List[float]):\n    '''\n    ", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    sum_arr = list()\n    for i in range(len(M)):\n        sums = sum(M[i])\n        sum_arr.append(sums)\n    sum_arr.sort(reverse=True)\n\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = sum_arr[i]\n\n    return M\n\n\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 计算每行的总和\n    sums = [sum(M[i]) for i in range(len(M))]\n    # 对每行的总和新进行排序\n    # 重新填入矩阵\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            M[i][j] = sums[i]\n    return M\n\n\ndef sort_matrix(M: List[float]):\n    '''\n    "}
{"task_id": "MBPP/12", "completion": "\n    # 直接sort\n    return sorted(M, key=lambda x: sum(x))\n\nif __name__ == \"__main__\":\n    print(sort_matrix([[4, 11, 25],\n                       [9, 14, 21],\n                       [9, 13, 22]]))", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 直接sort\n    return sorted(M, key=lambda x: sum(x))\n\nif __name__ == \"__main__\":\n    print(sort_matrix([[4, 11, 25],\n                       [9, 14, 21],\n                       [9, 13, 22]]))"}
{"task_id": "MBPP/12", "completion": "\n    sum_each_row=[0]*len(M)\n    for i in range(len(M)):\n        for j in range(len(M[0])):\n            sum_each_row[i]+=M[i][j]\n\n    sum_each_row.sort()\n\n    for i in range(len(M)):\n        for j in range(len(M[0])):\n            M[i][j]=sum_each_row[i]\n\n    return M\n\nif __name__ == '__main__':\n    # M = [[1, 2, 3], [3, 5, 6], [5, 9, 6]]\n    M=[[1,2,3],[3,5,6],[7,1,2]]\n    print(sort_matrix(M))\n    # M = [[1, 2, 3], [3, 5, 6], [5, 9, 6], [3, 4, 6]]\n    # print(sort_matrix(M))", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    sum_each_row=[0]*len(M)\n    for i in range(len(M)):\n        for j in range(len(M[0])):\n            sum_each_row[i]+=M[i][j]\n\n    sum_each_row.sort()\n\n    for i in range(len(M)):\n        for j in range(len(M[0])):\n            M[i][j]=sum_each_row[i]\n\n    return M\n\nif __name__ == '__main__':\n    # M = [[1, 2, 3], [3, 5, 6], [5, 9, 6]]\n    M=[[1,2,3],[3,5,6],[7,1,2]]\n    print(sort_matrix(M))\n    # M = [[1, 2, 3], [3, 5, 6], [5, 9, 6], [3, 4, 6]]\n    # print(sort_matrix(M))"}
{"task_id": "MBPP/12", "completion": "\n    pass\n\n\n\nif __name__ == '__main__':\n    n = int(input())\n    A = []\n    \n    for _ in range(n):\n        A.append(list(map(int, input().split())))\n    result = matrix_column_sum(A)\n    print(result)", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    pass\n\n\n\nif __name__ == '__main__':\n    n = int(input())\n    A = []\n    \n    for _ in range(n):\n        A.append(list(map(int, input().split())))\n    result = matrix_column_sum(A)\n    print(result)"}
{"task_id": "MBPP/12", "completion": "\n    M = sorted(M, key=lambda x: sum(x))\n    return M\n\ndef test_sort_matrix():\n    M = [[2, 1, 5], [4, 0, 3], [6, 7, 8]]\n    print(sort_matrix(M))\n\ntest_sort_matrix()", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    M = sorted(M, key=lambda x: sum(x))\n    return M\n\ndef test_sort_matrix():\n    M = [[2, 1, 5], [4, 0, 3], [6, 7, 8]]\n    print(sort_matrix(M))\n\ntest_sort_matrix()"}
{"task_id": "MBPP/12", "completion": "\n    # 把每行求和结果存入一个数组\n    sum_M = []\n    for i in range(len(M)):\n        M[i].sort()\n        sum = 0\n        for j in range(len(M[i])):\n            sum += M[i][j]\n        sum_M.append(sum)\n    # 把排序后的数组进行排序\n    sum_M.sort()\n    for i in range(len(sum_M)):\n        for j in range(len(sum_M[i])):\n             M[i][j] = sum_M[i][j]\n    return M\n\n\nif __name__ == '__main__':\n    M = [[1, 2, 3], [4, 6, 5], [7, 9, 8], [9, 7, 4]]\n    print(sort_matrix(M))", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 把每行求和结果存入一个数组\n    sum_M = []\n    for i in range(len(M)):\n        M[i].sort()\n        sum = 0\n        for j in range(len(M[i])):\n            sum += M[i][j]\n        sum_M.append(sum)\n    # 把排序后的数组进行排序\n    sum_M.sort()\n    for i in range(len(sum_M)):\n        for j in range(len(sum_M[i])):\n             M[i][j] = sum_M[i][j]\n    return M\n\n\nif __name__ == '__main__':\n    M = [[1, 2, 3], [4, 6, 5], [7, 9, 8], [9, 7, 4]]\n    print(sort_matrix(M))"}
{"task_id": "MBPP/12", "completion": "\n    pass\n\n\ndef search_insert(nums: List[int], target: int):\n    '''\n    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n    '''\n    pass\n\n\ndef plusOne(digits: List[int]) -> List[int]:\n    '''\n    给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n    '''\n    pass\n\n\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    '''\n    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n    '''\n    pass\n\n\ndef maxProfit(prices: List[int]) -> int:\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    pass\n\n\ndef search_insert(nums: List[int], target: int):\n    '''\n    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n    '''\n    pass\n\n\ndef plusOne(digits: List[int]) -> List[int]:\n    '''\n    给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n    '''\n    pass\n\n\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    '''\n    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n    '''\n    pass\n\n\ndef maxProfit(prices: List[int]) -> int:\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你"}
{"task_id": "MBPP/12", "completion": "\n \n    for i in range(len(M)):\n        s = sum(M[i])\n        M[i] = [x / s for x in M[i]]\n    M = sorted(M, key=lambda x: sum(x))\n    for i in range(len(M)):\n        s = sum(M[i])\n        M[i] = [x / s for x in M[i]]\n    return M\nif __name__=='__main__':\n    M = [[1, 2, 3, 4], [7, 2, 1, 3], [3, 1, 2, 4]]\n    print(sort_matrix(M))", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n \n    for i in range(len(M)):\n        s = sum(M[i])\n        M[i] = [x / s for x in M[i]]\n    M = sorted(M, key=lambda x: sum(x))\n    for i in range(len(M)):\n        s = sum(M[i])\n        M[i] = [x / s for x in M[i]]\n    return M\nif __name__=='__main__':\n    M = [[1, 2, 3, 4], [7, 2, 1, 3], [3, 1, 2, 4]]\n    print(sort_matrix(M))"}
{"task_id": "MBPP/12", "completion": "\n    matrix = M.copy()\n    for i in range(len(matrix)):\n        matrix[i] = sum(matrix[i])\n    matrix = sorted(matrix)\n    for i in range(len(matrix)):\n        M[i] = matrix[i] - sum(matrix[:i])\n    return M\n```", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    matrix = M.copy()\n    for i in range(len(matrix)):\n        matrix[i] = sum(matrix[i])\n    matrix = sorted(matrix)\n    for i in range(len(matrix)):\n        M[i] = matrix[i] - sum(matrix[:i])\n    return M\n```"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=lambda x:x[0])\n\n\nif __name__ == '__main__':\n    line = \"4 1\"\n    M = eval(line)\n    print(sort_matrix(M))\n    pass", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    return sorted(M, key=lambda x:x[0])\n\n\nif __name__ == '__main__':\n    line = \"4 1\"\n    M = eval(line)\n    print(sort_matrix(M))\n    pass"}
{"task_id": "MBPP/24", "completion": "\n    decimal, i, n = 0, 0, 0\n    while(binum != 0):\n        dec = binum % 10\n        decimal = decimal + dec * pow(2, i)\n        binum = binum // 10\n        i += 1\n    return decimal", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal, i, n = 0, 0, 0\n    while(binum != 0):\n        dec = binum % 10\n        decimal = decimal + dec * pow(2, i)\n        binum = binum // 10\n        i += 1\n    return decimal"}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    pow = 1\n    while binum > 0:\n        rem = binum % 10\n        dec += rem * pow\n        binum //= 10\n        pow *= 2\n    return dec\n\ndef test():\n    '''\n    >>> test()\n    106\n    148\n    126\n    126\n    128\n    126\n    110\n    126\n    126\n    104\n    100\n    102\n    106\n    '''\n    for i in range(0,11):\n        print(binary_to_decimal(i))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    pow = 1\n    while binum > 0:\n        rem = binum % 10\n        dec += rem * pow\n        binum //= 10\n        pow *= 2\n    return dec\n\ndef test():\n    '''\n    >>> test()\n    106\n    148\n    126\n    126\n    128\n    126\n    110\n    126\n    126\n    104\n    100\n    102\n    106\n    '''\n    for i in range(0,11):\n        print(binary_to_decimal(i))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/24", "completion": "\n    return int(binum, 2)\n    \ndef decimal_to_binary(num, bits):\n    '''\n    将给定的十进制数转化位指定长度的二进制数。\n    >>> decimal_to_binary(255)\n    '11111111'\n    >>> decimal_to_binary(1024, 16)\n    '000000000000000010000'\n    >>> decimal_to_binary(10, 3)\n    '100'\n    '''\n    strbits = ''.join(['0' for i in range(bits)])\n    i = 0\n    while num > 1:\n        num = num >> 1\n        i += 1\n        strbits = strbits[:i] + str(num % 2) + strbits[i:]\n    return strbits\n\ndef binary_to_hex(bits):\n    '''\n    将二进制数转化为十六进制。\n    >>> binary_", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(binum, 2)\n    \ndef decimal_to_binary(num, bits):\n    '''\n    将给定的十进制数转化位指定长度的二进制数。\n    >>> decimal_to_binary(255)\n    '11111111'\n    >>> decimal_to_binary(1024, 16)\n    '000000000000000010000'\n    >>> decimal_to_binary(10, 3)\n    '100'\n    '''\n    strbits = ''.join(['0' for i in range(bits)])\n    i = 0\n    while num > 1:\n        num = num >> 1\n        i += 1\n        strbits = strbits[:i] + str(num % 2) + strbits[i:]\n    return strbits\n\ndef binary_to_hex(bits):\n    '''\n    将二进制数转化为十六进制。\n    >>> binary_"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i in range(len(binum)-1,-1,-1):\n        decimal+=int(binum[i])*2**(len(binum)-1-i)\n    return decimal\n\ndef decimal_to_binary(dec_number):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(5)\n    '101'\n    >>> decimal_to_binary(8)\n    '1000'\n    '''\n    return bin(dec_number)[2:]\n\ndef binary_to_hex(binum):\n    '''\n    将给定的二进制数转化为十六进制数。\n    >>> binary_to_hex(1010)\n    'a'\n    >>> binary_to_hex(10101010)\n    'aa'\n    '''\n    if len(binum)%4!=0:\n        binum='0'*(4-len(binum)%4)+binum\n", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    for i in range(len(binum)-1,-1,-1):\n        decimal+=int(binum[i])*2**(len(binum)-1-i)\n    return decimal\n\ndef decimal_to_binary(dec_number):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(5)\n    '101'\n    >>> decimal_to_binary(8)\n    '1000'\n    '''\n    return bin(dec_number)[2:]\n\ndef binary_to_hex(binum):\n    '''\n    将给定的二进制数转化为十六进制数。\n    >>> binary_to_hex(1010)\n    'a'\n    >>> binary_to_hex(10101010)\n    'aa'\n    '''\n    if len(binum)%4!=0:\n        binum='0'*(4-len(binum)%4)+binum\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i in range(len(binum)):\n        decimal += int(binum[i])*(2**(len(binum)-1-i))\n    return decimal\n\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    '1010'\n    >>> decimal_to_binary(15)\n    '1111'\n    '''\n    binum = ''\n    while decimal:\n        if decimal % 2:\n            binum = '1' + binum\n        else:\n            binum = '0' + binum\n        decimal //= 2\n    return binum\n\ndef decimal_to_hex(decimal):\n    '''\n    将给定的十进制数转化为十六进制数。\n    >>> decimal_to_hex(28)\n    '1c'\n    >>> decimal_to_hex(55)\n    '3", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    for i in range(len(binum)):\n        decimal += int(binum[i])*(2**(len(binum)-1-i))\n    return decimal\n\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    '1010'\n    >>> decimal_to_binary(15)\n    '1111'\n    '''\n    binum = ''\n    while decimal:\n        if decimal % 2:\n            binum = '1' + binum\n        else:\n            binum = '0' + binum\n        decimal //= 2\n    return binum\n\ndef decimal_to_hex(decimal):\n    '''\n    将给定的十进制数转化为十六进制数。\n    >>> decimal_to_hex(28)\n    '1c'\n    >>> decimal_to_hex(55)\n    '3"}
{"task_id": "MBPP/24", "completion": "\n    decimal, i, n = 0, 0, 0\n    while (n := n + (binum >> i) & 1) != 0:\n        decimal = decimal + (n << i)\n        i += 1\n    return decimal\n\n\n\ndef decimal_to_binary(decimal, length=None):\n    '''\n    将给定的十进制数转化为二进制数\n    >>> decimal_to_binary(6)\n    110\n    >>> decimal_to_binary(6, 16)\n    0b110\n    >>> decimal_to_binary(6, 8)\n    110\n    '''\n    if length is None:\n        return bin(decimal)[2:]\n    else:\n        return f'0b{decimal:0{length}b}'\n\n\ndef test_binary_to_decimal():\n    assert binary_to_decimal(1010) == 10\n    assert binary_to_decimal(1001) == 9", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal, i, n = 0, 0, 0\n    while (n := n + (binum >> i) & 1) != 0:\n        decimal = decimal + (n << i)\n        i += 1\n    return decimal\n\n\n\ndef decimal_to_binary(decimal, length=None):\n    '''\n    将给定的十进制数转化为二进制数\n    >>> decimal_to_binary(6)\n    110\n    >>> decimal_to_binary(6, 16)\n    0b110\n    >>> decimal_to_binary(6, 8)\n    110\n    '''\n    if length is None:\n        return bin(decimal)[2:]\n    else:\n        return f'0b{decimal:0{length}b}'\n\n\ndef test_binary_to_decimal():\n    assert binary_to_decimal(1010) == 10\n    assert binary_to_decimal(1001) == 9"}
{"task_id": "MBPP/24", "completion": "\n    return int(binum,2)\n\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    0b1010\n    >>> decimal_to_binary(9)\n    0b1001\n    '''\n    return bin(num)\n\ndef bin_to_list(binum):\n    '''\n    把二进制数中各位上的数字存入列表\n    >>> bin_to_list(1001)\n    [1,0,0,1]\n    >>> bin_to_list(01)\n    [0,1]\n    '''\n    # 把二进制数转换成列表\n    return list(map(int,binum))\n\ndef dec_to_list(num):\n    '''\n    把十进制数转换成列表\n    >>> dec_to_list(10)\n    [0, 0, 1, 0, 1, 0]\n    >>> dec", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(binum,2)\n\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    0b1010\n    >>> decimal_to_binary(9)\n    0b1001\n    '''\n    return bin(num)\n\ndef bin_to_list(binum):\n    '''\n    把二进制数中各位上的数字存入列表\n    >>> bin_to_list(1001)\n    [1,0,0,1]\n    >>> bin_to_list(01)\n    [0,1]\n    '''\n    # 把二进制数转换成列表\n    return list(map(int,binum))\n\ndef dec_to_list(num):\n    '''\n    把十进制数转换成列表\n    >>> dec_to_list(10)\n    [0, 0, 1, 0, 1, 0]\n    >>> dec"}
{"task_id": "MBPP/24", "completion": "\n    return int(binum,2)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(binum,2)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/24", "completion": "\n    return int(str(binum),2)\n\n\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    1010\n    >>> decimal_to_binary(19)\n    11001\n    '''\n    return bin(decimal)\n\n\ndef char_to_number(char):\n    '''\n    将给定的字符转化为对应的Unicode整数。\n    >>> char_to_number('a')\n    97\n    >>> char_to_number('A')\n    65\n    >>> char_to_number('1')\n    49\n    '''\n    return ord(char)\n\n\ndef number_to_char(number):\n    '''\n    将给定的Unicode整数转化为对应的character。\n    >>> number_to_char(97)\n    'a'\n    >>> number_to_char(65)\n    'A'\n    >>> number_to_char(49)\n    ", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(str(binum),2)\n\n\ndef decimal_to_binary(decimal):\n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(10)\n    1010\n    >>> decimal_to_binary(19)\n    11001\n    '''\n    return bin(decimal)\n\n\ndef char_to_number(char):\n    '''\n    将给定的字符转化为对应的Unicode整数。\n    >>> char_to_number('a')\n    97\n    >>> char_to_number('A')\n    65\n    >>> char_to_number('1')\n    49\n    '''\n    return ord(char)\n\n\ndef number_to_char(number):\n    '''\n    将给定的Unicode整数转化为对应的character。\n    >>> number_to_char(97)\n    'a'\n    >>> number_to_char(65)\n    'A'\n    >>> number_to_char(49)\n    "}
{"task_id": "MBPP/24", "completion": "\n    number = 0\n    length = len(binum)\n    for i in range(length):\n        if binum[length-1-i] == '0':\n            number += 2**i\n    return number\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    number = 0\n    length = len(binum)\n    for i in range(length):\n        if binum[length-1-i] == '0':\n            number += 2**i\n    return number\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/27", "completion": "\n    res = []\n    for i in range(len(strlist)):\n        res.append(''.join(j for j in strlist[i] if j not in '0123456789'))\n    return res\n\n\n# 100 组合问题\ndef combination(n,m):\n    '''\n    给定两个正整数n和m，输出所有不同的m个数中的组合，这里m是m个数，而不是m个下标，\n    另外这里面的n是n个数的集合\n    >>> combination(2, 1)\n    [[1, 1], [2, 2]]\n    >>> combination(3, 1)\n    [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n    >>> combination(3, 3)\n    [[1, 1, 1], [1, 2, 2], [1, 3, 3], [2, 2, 3], [2, 3, 3], [3, 3, 1], [3, 3", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    res = []\n    for i in range(len(strlist)):\n        res.append(''.join(j for j in strlist[i] if j not in '0123456789'))\n    return res\n\n\n# 100 组合问题\ndef combination(n,m):\n    '''\n    给定两个正整数n和m，输出所有不同的m个数中的组合，这里m是m个数，而不是m个下标，\n    另外这里面的n是n个数的集合\n    >>> combination(2, 1)\n    [[1, 1], [2, 2]]\n    >>> combination(3, 1)\n    [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n    >>> combination(3, 3)\n    [[1, 1, 1], [1, 2, 2], [1, 3, 3], [2, 2, 3], [2, 3, 3], [3, 3, 1], [3, 3"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d+', '', i) for i in strlist]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'\\d+', '', i) for i in strlist]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r\"\\d+\",\"\",i) for i in strlist]\n\ndef test(strlist):\n    return [\"abc\", \"def\", \"ghi\"]\n\nif __name__ == \"__main__\":\n    strlist = [\n        \"abc123\",\n        \"def456\",\n        \"ghi789\"\n    ]\n    print remove(strlist)\n    print test(strlist)", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r\"\\d+\",\"\",i) for i in strlist]\n\ndef test(strlist):\n    return [\"abc\", \"def\", \"ghi\"]\n\nif __name__ == \"__main__\":\n    strlist = [\n        \"abc123\",\n        \"def456\",\n        \"ghi789\"\n    ]\n    print remove(strlist)\n    print test(strlist)"}
{"task_id": "MBPP/27", "completion": "\n    res = [re.sub(r'\\d+', '', i) for i in strlist]\n    return res\nprint(remove([\n'abc123',\n'def456',\n'ghi789']))\n\n\n# 3. 将字符串反转\n# 给定一个字符串，逐个翻转字符串中的每个单词。\n# \n# \n# \n# \n# \n# \n# \n# 示例 1：\n# \n# 输入: \"the sky is blue\"\n# 输出:\"blue is sky the\"\n# 示例 2：\n# \n# 输入: \" hello world! \"\n# 输出:\"world! hello\"\n# 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n# 示例 3：\n# \n# 输入: \"a good  example\"\n# 输出:\"example good a\"\n# 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n# \n", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    res = [re.sub(r'\\d+', '', i) for i in strlist]\n    return res\nprint(remove([\n'abc123',\n'def456',\n'ghi789']))\n\n\n# 3. 将字符串反转\n# 给定一个字符串，逐个翻转字符串中的每个单词。\n# \n# \n# \n# \n# \n# \n# \n# 示例 1：\n# \n# 输入: \"the sky is blue\"\n# 输出:\"blue is sky the\"\n# 示例 2：\n# \n# 输入: \" hello world! \"\n# 输出:\"world! hello\"\n# 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n# 示例 3：\n# \n# 输入: \"a good  example\"\n# 输出:\"example good a\"\n# 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n# \n"}
{"task_id": "MBPP/27", "completion": "\n    return list(map(lambda x: re.sub(\"[0-9]\",\"\",x),strlist))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return list(map(lambda x: re.sub(\"[0-9]\",\"\",x),strlist))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d+','',s) for s in strlist]\n\ndef isValid(s):\n    '''\n    给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。\n    回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。\n    >>> isValid('tact coa')\n    True\n    >>> isValid('hello world')\n    False\n    '''\n    count = Counter(s)\n    return all(count[c] % 2 == 0 for c in count)\n\ndef maxProfit(prices):\n    '''\n    给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。\n    设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n    >>> maxProfit([7, 1, 5, 3, 6, 4])\n    7\n    >>> maxProfit([7", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'\\d+','',s) for s in strlist]\n\ndef isValid(s):\n    '''\n    给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。\n    回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。\n    >>> isValid('tact coa')\n    True\n    >>> isValid('hello world')\n    False\n    '''\n    count = Counter(s)\n    return all(count[c] % 2 == 0 for c in count)\n\ndef maxProfit(prices):\n    '''\n    给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。\n    设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n    >>> maxProfit([7, 1, 5, 3, 6, 4])\n    7\n    >>> maxProfit([7"}
{"task_id": "MBPP/27", "completion": "\n    \n    return list(map(lambda s: re.sub('\\d+', '', s), strlist))\n\nif __name__ =='__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    \n    return list(map(lambda s: re.sub('\\d+', '', s), strlist))\n\nif __name__ =='__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'[0-9]', '', x) for x in strlist]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return [re.sub(r'[0-9]', '', x) for x in strlist]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/27", "completion": "\n    ans = []\n    for s in strlist:\n        ans.append(''.join(re.findall(r'[^\\d]', s)))\n    return ans\n    \nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    ans = []\n    for s in strlist:\n        ans.append(''.join(re.findall(r'[^\\d]', s)))\n    return ans\n    \nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/27", "completion": "\n    try:\n        return [[item.translate(None, '0123456789') for item in strlist]]\n    except:\n        print \"type error\"\n\n\n# 18.移除字母\n# 编写一个程序，移除字符串中不需要的字符，获得一个新的字符串。\n# 函数签名如下：\n#     def remove_letter(str):\n# 样例如下：\n#     >>> remove_letter('A aba  b ab ')\n#     'ba'\n#     >>> remove_letter('1a aa 1b aa aab')\n#     'ab'\n#     >>> remove_letter('')\n#     ''\n#     >>> remove_letter('ab')\n#     'ab'\n# 注意：\n#     移除过程对大小写不敏感。\n#     在字符串首尾是否保留，将取决于实际输入，请参考样例。\ndef remove_letter(str):\n    '''\n    给定一个字符串str，编写一个函数，移除字符串中不需要的字符，获得一个新的字符串。\n    >>>", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    try:\n        return [[item.translate(None, '0123456789') for item in strlist]]\n    except:\n        print \"type error\"\n\n\n# 18.移除字母\n# 编写一个程序，移除字符串中不需要的字符，获得一个新的字符串。\n# 函数签名如下：\n#     def remove_letter(str):\n# 样例如下：\n#     >>> remove_letter('A aba  b ab ')\n#     'ba'\n#     >>> remove_letter('1a aa 1b aa aab')\n#     'ab'\n#     >>> remove_letter('')\n#     ''\n#     >>> remove_letter('ab')\n#     'ab'\n# 注意：\n#     移除过程对大小写不敏感。\n#     在字符串首尾是否保留，将取决于实际输入，请参考样例。\ndef remove_letter(str):\n    '''\n    给定一个字符串str，编写一个函数，移除字符串中不需要的字符，获得一个新的字符串。\n    >>>"}
{"task_id": "MBPP/42", "completion": "\n    ans = 0\n    for i in set(arr):\n        ans += arr.count(i) * i\n    return ans\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    ans = 0\n    for i in set(arr):\n        ans += arr.count(i) * i\n    return ans\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/42", "completion": "\n    x_dict = {}\n    res = 0\n    for i in arr:\n        if i not in x_dict:\n            x_dict[i] = 1\n        else:\n            x_dict[i] += 1\n    for key,value in x_dict.items():\n        if value >= 2:\n            res += key\n    return res\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    x_dict = {}\n    res = 0\n    for i in arr:\n        if i not in x_dict:\n            x_dict[i] = 1\n        else:\n            x_dict[i] += 1\n    for key,value in x_dict.items():\n        if value >= 2:\n            res += key\n    return res\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/42", "completion": "\n    dic = {}\n    for num in arr:\n        dic[num] = dic.get(num, 0) + 1\n    return sum(k for k, v in dic.items() if v > 1)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dic = {}\n    for num in arr:\n        dic[num] = dic.get(num, 0) + 1\n    return sum(k for k, v in dic.items() if v > 1)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/42", "completion": "\n    # 先用一个字典来保存数组中的元素，键为元素，值为出现的次数。\n    dic = {}\n    for i in arr:\n        dic[i] = dic.get(i, 0) + 1\n    # 遍历字典，如果当前数字出现次数大于1，那么就加上该数字。\n    ans = 0\n    for v in dic.values():\n        if v > 1:\n            ans += v  * (v - 1) // 2\n    return ans\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    # 先用一个字典来保存数组中的元素，键为元素，值为出现的次数。\n    dic = {}\n    for i in arr:\n        dic[i] = dic.get(i, 0) + 1\n    # 遍历字典，如果当前数字出现次数大于1，那么就加上该数字。\n    ans = 0\n    for v in dic.values():\n        if v > 1:\n            ans += v  * (v - 1) // 2\n    return ans\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "MBPP/42", "completion": "\n    l = len(arr)\n    s = 0\n    if l == 0:\n        return 0\n    \n    for i in range(l):\n        for j in range(i + 1, l):\n            if arr[i] == arr[j]:\n                s += arr[i]\n    return s\n          \n# 数组中出现次数超过一半的数字。\ndef find_Mid(arr):\n    '''\n        求数组中出现次数超过一半的数。\n    >>> find_Mid([1,1,2,1,1])\n    1\n    >>> find_Mid([1,1,2,1,1,3,4,5,6,7,3,2,1,6,7,2,1,3,4,5])\n    4\n    '''\n    l = len(arr)\n    if l == 0:\n        return 0\n    \n    dic = dict()\n    for i in range(l):\n        if arr[i] in dic:\n            dic[arr[i]] += 1\n        else", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    l = len(arr)\n    s = 0\n    if l == 0:\n        return 0\n    \n    for i in range(l):\n        for j in range(i + 1, l):\n            if arr[i] == arr[j]:\n                s += arr[i]\n    return s\n          \n# 数组中出现次数超过一半的数字。\ndef find_Mid(arr):\n    '''\n        求数组中出现次数超过一半的数。\n    >>> find_Mid([1,1,2,1,1])\n    1\n    >>> find_Mid([1,1,2,1,1,3,4,5,6,7,3,2,1,6,7,2,1,3,4,5])\n    4\n    '''\n    l = len(arr)\n    if l == 0:\n        return 0\n    \n    dic = dict()\n    for i in range(l):\n        if arr[i] in dic:\n            dic[arr[i]] += 1\n        else"}
{"task_id": "MBPP/42", "completion": "\n    sum = 0\n    for i in arr:\n        if arr.count(i) > 1:\n            sum += i * arr.count(i)\n    return sum\n\ndef find_min_max(arr):\n    '''\n        返回一维数组中的最小值和最大值\n    >>> find_min_max([1,2,3])      \n    (1, 3)\n    >>> find_min_max([1,-40,40,38,-9,-2,18,-500,300,-1000,400])\n    (-40, 400)\n    >>> find_min_max([1,2,3])\n    (1, 3)\n    '''\n    return (min(arr), max(arr))\n\ndef find_avg(arr):\n    '''\n        返回一维数组中的平均值\n    >>> find_avg([1,2,3])\n    2.0\n    >>> find_avg([1,-40,40,38,-9,-2,18,-50", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    sum = 0\n    for i in arr:\n        if arr.count(i) > 1:\n            sum += i * arr.count(i)\n    return sum\n\ndef find_min_max(arr):\n    '''\n        返回一维数组中的最小值和最大值\n    >>> find_min_max([1,2,3])      \n    (1, 3)\n    >>> find_min_max([1,-40,40,38,-9,-2,18,-500,300,-1000,400])\n    (-40, 400)\n    >>> find_min_max([1,2,3])\n    (1, 3)\n    '''\n    return (min(arr), max(arr))\n\ndef find_avg(arr):\n    '''\n        返回一维数组中的平均值\n    >>> find_avg([1,2,3])\n    2.0\n    >>> find_avg([1,-40,40,38,-9,-2,18,-50"}
{"task_id": "MBPP/42", "completion": "\n    \n    num_dict = {} \n    \n    for i in range(len(arr)):\n        \n        if arr[i] not in num_dict:\n            num_dict[arr[i]] = 1\n        \n        else:\n            num_dict[arr[i]] = num_dict[arr[i]] + 1\n    \n    \n    sum_list = []\n    \n    for item in num_dict.values():\n        sum_list.append(item)\n    \n    sum_list.sort(reverse=True)\n    result = 0\n    \n    for sum_i in sum_list:\n        result = result + sum_i\n    return result\n\ndef find_count(nums1, nums2):\n    '''\n        统计两个数组中重复出现的元素个数。\n    两个数组中重复出现的元素，只统计一次即可。\n    >>> find_count([1, 2, 3, 4, 5, 5, 6], [7, 7, 8, 8])\n    [3, 2, 1]", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    \n    num_dict = {} \n    \n    for i in range(len(arr)):\n        \n        if arr[i] not in num_dict:\n            num_dict[arr[i]] = 1\n        \n        else:\n            num_dict[arr[i]] = num_dict[arr[i]] + 1\n    \n    \n    sum_list = []\n    \n    for item in num_dict.values():\n        sum_list.append(item)\n    \n    sum_list.sort(reverse=True)\n    result = 0\n    \n    for sum_i in sum_list:\n        result = result + sum_i\n    return result\n\ndef find_count(nums1, nums2):\n    '''\n        统计两个数组中重复出现的元素个数。\n    两个数组中重复出现的元素，只统计一次即可。\n    >>> find_count([1, 2, 3, 4, 5, 5, 6], [7, 7, 8, 8])\n    [3, 2, 1]"}
{"task_id": "MBPP/42", "completion": "\n    res = 0\n    s = set(arr)\n    for i in s:\n        res += sum(arr.count(i))\n    print(res)\n    return res\n\n\nif __name__ == '__main__':\n    # import random\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2]\n    # arr = [4, 5, 7, 5, 4, 8]\n    # print(arr)\n    # print(find_Sum(arr))\n    #\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2]\n    # arr = [4, 5, 7, 5, 4, 8]\n    # print(arr)\n    # print(find_Sum(arr))\n    #\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res = 0\n    s = set(arr)\n    for i in s:\n        res += sum(arr.count(i))\n    print(res)\n    return res\n\n\nif __name__ == '__main__':\n    # import random\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2]\n    # arr = [4, 5, 7, 5, 4, 8]\n    # print(arr)\n    # print(find_Sum(arr))\n    #\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2]\n    # arr = [4, 5, 7, 5, 4, 8]\n    # print(arr)\n    # print(find_Sum(arr))\n    #\n    # arr = random.sample(range(1, 100), 10)\n    # arr = [1, 1, 2"}
{"task_id": "MBPP/42", "completion": "\n    dic, sum = {}, 0\n    for i in arr:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    for j in dic:\n        if dic[j] >= 2:\n            sum += j * dic[j]\n    return sum\n\nif __name__ == \"__main__\":\n    \n    '''\n    找到一个数组中出现次数最少的数字\n    '''\n    # num = [8, 8, 8, 8, 8, 8, 8, 7, 8, 7]\n\n    '''\n    计算一个数组中的元素和\n    '''\n\n    '''\n    在给定的数组中，求两个数的和为目标值target的所有组合\n    [3, 12, 9, 24, 5, 3] --target=24\n    '''\n    # num = [3, 12, 9, 24, 5, 3]\n\n    '''\n    在给定的数组中", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dic, sum = {}, 0\n    for i in arr:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    for j in dic:\n        if dic[j] >= 2:\n            sum += j * dic[j]\n    return sum\n\nif __name__ == \"__main__\":\n    \n    '''\n    找到一个数组中出现次数最少的数字\n    '''\n    # num = [8, 8, 8, 8, 8, 8, 8, 7, 8, 7]\n\n    '''\n    计算一个数组中的元素和\n    '''\n\n    '''\n    在给定的数组中，求两个数的和为目标值target的所有组合\n    [3, 12, 9, 24, 5, 3] --target=24\n    '''\n    # num = [3, 12, 9, 24, 5, 3]\n\n    '''\n    在给定的数组中"}
{"task_id": "MBPP/42", "completion": "\n    res = {}\n    sum = 0\n    for i in arr:\n        res[i] = res.get(i, 0) + 1\n    for j in res:\n        sum += j * res[j] * (res[j] - 1) // 2\n    return sum\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    res = {}\n    sum = 0\n    for i in arr:\n        res[i] = res.get(i, 0) + 1\n    for j in res:\n        sum += j * res[j] * (res[j] - 1) // 2\n    return sum\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    stack=[0]*len(arr)\n    top=0\n    stack[top]=-int(1e9)\n    for num in arr:\n        if num>stack[top]:\n            stack[top+1]=num\n            top+=1\n        elif num<stack[top]:\n            while num<stack[top]:\n                top-=1\n            stack[top+1]=num\n            top+=1\n    return top\n\nif __name__==\"__main__\":\n    arr=[1, 2, 3, 4, 5, 3, 2]\n    print(max_len_sub(arr))", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    stack=[0]*len(arr)\n    top=0\n    stack[top]=-int(1e9)\n    for num in arr:\n        if num>stack[top]:\n            stack[top+1]=num\n            top+=1\n        elif num<stack[top]:\n            while num<stack[top]:\n                top-=1\n            stack[top+1]=num\n            top+=1\n    return top\n\nif __name__==\"__main__\":\n    arr=[1, 2, 3, 4, 5, 3, 2]\n    print(max_len_sub(arr))"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    \n    max_len = 0\n    dp = [0] * len(arr)\n    dp[0] = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]+1:\n            dp[i] = dp[i-1]+1\n        else:\n            dp[i] = 1\n        max_len = max(max_len, dp[i])\n\n    return max_len\n\n\n# 最长递增子序列\n# 1、dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。\n# 2、如果存在 j 使得 nums[j] < nums[i] 且 dp[j] + 1 ≥ dp[i]，则dp[i] = dp[j] + 1。\n# 3、初始化dp数组都为1，因为以自己本身为结尾，最小长度为1。\n# 4、从前往后遍历数组，如果前面的数小于当前的数，则该数的dp[i]为前面数的dp", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    \n    max_len = 0\n    dp = [0] * len(arr)\n    dp[0] = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]+1:\n            dp[i] = dp[i-1]+1\n        else:\n            dp[i] = 1\n        max_len = max(max_len, dp[i])\n\n    return max_len\n\n\n# 最长递增子序列\n# 1、dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。\n# 2、如果存在 j 使得 nums[j] < nums[i] 且 dp[j] + 1 ≥ dp[i]，则dp[i] = dp[j] + 1。\n# 3、初始化dp数组都为1，因为以自己本身为结尾，最小长度为1。\n# 4、从前往后遍历数组，如果前面的数小于当前的数，则该数的dp[i]为前面数的dp"}
{"task_id": "MBPP/149", "completion": "\n    stack = []\n    res = 0\n    for i in range(len(arr)):\n        if stack and stack[-1] == arr[i] - 1:\n            stack.pop()\n        else:\n            stack.append(arr[i])\n        res = max(res, len(stack))\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    stack = []\n    res = 0\n    for i in range(len(arr)):\n        if stack and stack[-1] == arr[i] - 1:\n            stack.pop()\n        else:\n            stack.append(arr[i])\n        res = max(res, len(stack))\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    arr = sorted(arr, reverse=True)\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[j]-arr[j-1]==1:\n                result = max(result, j-i+1)\n    return result\n\ndef max_len(arr:List[int]):\n    '''\n    >>> max_len([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    return max_len_sub(arr)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    arr = sorted(arr, reverse=True)\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[j]-arr[j-1]==1:\n                result = max(result, j-i+1)\n    return result\n\ndef max_len(arr:List[int]):\n    '''\n    >>> max_len([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    return max_len_sub(arr)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    max_value = 0\n    min_value = 9999999\n    for i in range(len(arr)):\n        tmp = arr[i]\n        max_value = max(max_value, tmp)\n        min_value = min(min_value, tmp)\n    return max_value - min_value - 1\n                \nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    max_value = 0\n    min_value = 9999999\n    for i in range(len(arr)):\n        tmp = arr[i]\n        max_value = max(max_value, tmp)\n        min_value = min(min_value, tmp)\n    return max_value - min_value - 1\n                \nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    if len(arr) < 2:\n        return len(arr)\n    max_len = 1\n    dp = [1 for _ in range(len(arr))]\n    for i in range(1, len(arr)):\n        if i > 0 and arr[i] - arr[i-1] == 1:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] = 1\n        if dp[i] > max_len:\n            max_len = dp[i]\n    return max_len\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr) < 2:\n        return len(arr)\n    max_len = 1\n    dp = [1 for _ in range(len(arr))]\n    for i in range(1, len(arr)):\n        if i > 0 and arr[i] - arr[i-1] == 1:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] = 1\n        if dp[i] > max_len:\n            max_len = dp[i]\n    return max_len\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    size = len(arr)\n    dp = [1 for _ in range(size)]\n    \n    for i in range(1, size):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    size = len(arr)\n    dp = [1 for _ in range(size)]\n    \n    for i in range(1, size):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/149", "completion": "\n    res = 1\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] == 1:\n            res += 1\n        else:\n            res = 1\n    return res\ndef num_decodings(s:str):\n    '''\n    给定一个不含重复数字的数组，编写一个方法来判断该数组是否可以由它的单个元素组成新的数组拼接而成\n    >>> num_decodings('232123')\n    True\n    >>> num_decodings('12325')\n    False\n    '''\n    n = len(s)\n    if n == 1:\n        return True\n    if n == 2:\n        if s[0] == '0' or int(s) > 26:\n            return False\n        else:\n            return True\n\n    if s[0]=='0':\n        return False\n\n    def dfs(s):\n        if s == '':\n            return True\n        if len(s) > 1 and s[0] == '0':\n            return False\n        if s[0] == '", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    res = 1\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] == 1:\n            res += 1\n        else:\n            res = 1\n    return res\ndef num_decodings(s:str):\n    '''\n    给定一个不含重复数字的数组，编写一个方法来判断该数组是否可以由它的单个元素组成新的数组拼接而成\n    >>> num_decodings('232123')\n    True\n    >>> num_decodings('12325')\n    False\n    '''\n    n = len(s)\n    if n == 1:\n        return True\n    if n == 2:\n        if s[0] == '0' or int(s) > 26:\n            return False\n        else:\n            return True\n\n    if s[0]=='0':\n        return False\n\n    def dfs(s):\n        if s == '':\n            return True\n        if len(s) > 1 and s[0] == '0':\n            return False\n        if s[0] == '"}
{"task_id": "MBPP/149", "completion": "\n    if len(arr)==1:\n        return 1\n    record = [1]*len(arr)\n    for i in range(1, len(arr)):\n        for j in range(0, i):\n            if arr[i]-arr[j]==1:\n                record[i] = max(record[i], record[j]+1)\n    return max(record)\n\n## 最长递增子序列\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums)==0:\n            return 0\n        dp = [1]*len(nums)\n        for k in range(1, len(nums)):\n            for j in range(0, k):\n                if nums[k]>nums[j]:\n                    dp[k] = max(dp[k], dp[j]+1)\n        return max(dp)\n\n## 3. 最大子序和\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if len(nums)==1:\n            return nums[0]", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if len(arr)==1:\n        return 1\n    record = [1]*len(arr)\n    for i in range(1, len(arr)):\n        for j in range(0, i):\n            if arr[i]-arr[j]==1:\n                record[i] = max(record[i], record[j]+1)\n    return max(record)\n\n## 最长递增子序列\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums)==0:\n            return 0\n        dp = [1]*len(nums)\n        for k in range(1, len(nums)):\n            for j in range(0, k):\n                if nums[k]>nums[j]:\n                    dp[k] = max(dp[k], dp[j]+1)\n        return max(dp)\n\n## 3. 最大子序和\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if len(nums)==1:\n            return nums[0]"}
{"task_id": "MBPP/149", "completion": "\n    arr.sort()\n    ans = 1\n    for i in range(len(arr)-1):\n        if arr[i+1]-arr[i] == 1:\n            ans += 1\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    arr.sort()\n    ans = 1\n    for i in range(len(arr)-1):\n        if arr[i+1]-arr[i] == 1:\n            ans += 1\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "MBPP/v522", "completion": "\n   dp = [1 for _ in range(len(arr))]\n   res = 0\n   for i in range(1, len(arr)):\n       j = i - 1\n       while j >= 0 and arr[j] < arr[i]:\n           dp[i] = max(dp[i], dp[j] + 1)\n           j -= 1\n       res = max(res, dp[i])\n   return res\n\n# 最长公共子串\ndef lcs(arr1, arr2): \n   '''\n   求两个字符串的最长公共子序列\n   >>> lcs('abcde', 'ace')\n   3\n   >>> lcs('abcde', 'adcfe')\n   2\n   >>> lcs('abcde', 'aceb')\n   2\n   '''\n   dp = [[0 for _ in range(len(arr2) + 1)] for _ in range(len(arr1) + 1)]\n   dp = np.array(dp)\n   res = 0\n   for i in range(1, len(arr1) + 1):\n       for j in range(1, len(arr2) + 1):\n           if arr1[i-1] == arr2[j-1]:\n               dp[i,j] = dp[i-1, j-1] + 1\n               res = max(dp[i,j], res)\n           else:\n               dp[i,j] = dp[i-1,j]\n   return res\n\n\n\ndef num_decoding(num): \n   '''\n   [1,2,3]的编码个数\n   >>> num_decoding(123)\n   4\n   >>> num_decoding(165)\n   3\n   >>> num_decoding(278)\n   4\n   '''\n   if num == 0: return 0\n   if num == 1 or num == 2 or num == 3: return 1\n   if num % 100 < 10 or num % 10", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   dp = [1 for _ in range(len(arr))]\n   res = 0\n   for i in range(1, len(arr)):\n       j = i - 1\n       while j >= 0 and arr[j] < arr[i]:\n           dp[i] = max(dp[i], dp[j] + 1)\n           j -= 1\n       res = max(res, dp[i])\n   return res\n\n# 最长公共子串\ndef lcs(arr1, arr2): \n   '''\n   求两个字符串的最长公共子序列\n   >>> lcs('abcde', 'ace')\n   3\n   >>> lcs('abcde', 'adcfe')\n   2\n   >>> lcs('abcde', 'aceb')\n   2\n   '''\n   dp = [[0 for _ in range(len(arr2) + 1)] for _ in range(len(arr1) + 1)]\n   dp = np.array(dp)\n   res = 0\n   for i in range(1, len(arr1) + 1):\n       for j in range(1, len(arr2) + 1):\n           if arr1[i-1] == arr2[j-1]:\n               dp[i,j] = dp[i-1, j-1] + 1\n               res = max(dp[i,j], res)\n           else:\n               dp[i,j] = dp[i-1,j]\n   return res\n\n\n\ndef num_decoding(num): \n   '''\n   [1,2,3]的编码个数\n   >>> num_decoding(123)\n   4\n   >>> num_decoding(165)\n   3\n   >>> num_decoding(278)\n   4\n   '''\n   if num == 0: return 0\n   if num == 1 or num == 2 or num == 3: return 1\n   if num % 100 < 10 or num % 10"}
{"task_id": "MBPP/v522", "completion": "\n   if not arr:\n       return 0\n\n   res = 0\n   n = len(arr)\n   dp = [0] * n\n   for i in range(n):\n       dp[i] = 1\n       for j in range(i):\n           if arr[i] > arr[j] and dp[j]+1 > dp[i]:\n               dp[i] = dp[j]+1\n       res = max(res, dp[i])\n   return res\n\n\ndef main():\n   print(lbs([1, 2, 3, 4, 5, 3, 2]))\n\nif __name__ == \"__main__\":\n   main()", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   if not arr:\n       return 0\n\n   res = 0\n   n = len(arr)\n   dp = [0] * n\n   for i in range(n):\n       dp[i] = 1\n       for j in range(i):\n           if arr[i] > arr[j] and dp[j]+1 > dp[i]:\n               dp[i] = dp[j]+1\n       res = max(res, dp[i])\n   return res\n\n\ndef main():\n   print(lbs([1, 2, 3, 4, 5, 3, 2]))\n\nif __name__ == \"__main__\":\n   main()"}
{"task_id": "MBPP/v522", "completion": "\n   arr = sum(arr, [])\n   arr.sort()\n   return max([len(a) for a in [[arr[i], arr[j]] for i in range(len(arr)) for j in range(i+1, len(arr)) if arr[i] < arr[j] and arr[i] < arr[j]-1 and arr[j] - 1 > arr[i] ]])\n\ndef is_balanced(arr): \n    '''给定一个数组arr，编写一个函数，判断arr是否平衡，平衡数组是指一个数组中不存在连续的三个元素，这\n    三个元素同时满足：它们是三个大于等于0的整数，同时它们的和等于其索引加1。\n    >>> is_balanced([2,4,6,8,1,3,5])\n    False\n    >>> is_balanced([2,4,6,7,1,3,5])\n    True\n    >>> is_balanced([2,4,6,8,1,2,5])\n    True\n    >>> is_balanced([2,4,6,8,1,2,5,5,5,9])\n    False\n    >>> is_balanced([100,1,2,3,4,5,6,7,8])\n    False\n    '''\n    arr = sum(arr, [])\n    for i in range(len(arr)):\n        if arr[i] + 1 == arr[i+1] and arr[i] + 2 == arr[i+2]:\n            return False\n    return True\n\ndef gcd(v1, v2):\n    '''给定两个整数m和n，编写一个函数计算它们的最大公约数，要求时间复杂度为O(log(min(m,n))。\n    >>> gcd(200,100)\n    100\n    >>> gcd(100,200)\n    100\n    >>> gcd(62,39)\n    13\n    >>> gcd(39,62)\n    13\n    '''\n    v1", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   arr = sum(arr, [])\n   arr.sort()\n   return max([len(a) for a in [[arr[i], arr[j]] for i in range(len(arr)) for j in range(i+1, len(arr)) if arr[i] < arr[j] and arr[i] < arr[j]-1 and arr[j] - 1 > arr[i] ]])\n\ndef is_balanced(arr): \n    '''给定一个数组arr，编写一个函数，判断arr是否平衡，平衡数组是指一个数组中不存在连续的三个元素，这\n    三个元素同时满足：它们是三个大于等于0的整数，同时它们的和等于其索引加1。\n    >>> is_balanced([2,4,6,8,1,3,5])\n    False\n    >>> is_balanced([2,4,6,7,1,3,5])\n    True\n    >>> is_balanced([2,4,6,8,1,2,5])\n    True\n    >>> is_balanced([2,4,6,8,1,2,5,5,5,9])\n    False\n    >>> is_balanced([100,1,2,3,4,5,6,7,8])\n    False\n    '''\n    arr = sum(arr, [])\n    for i in range(len(arr)):\n        if arr[i] + 1 == arr[i+1] and arr[i] + 2 == arr[i+2]:\n            return False\n    return True\n\ndef gcd(v1, v2):\n    '''给定两个整数m和n，编写一个函数计算它们的最大公约数，要求时间复杂度为O(log(min(m,n))。\n    >>> gcd(200,100)\n    100\n    >>> gcd(100,200)\n    100\n    >>> gcd(62,39)\n    13\n    >>> gcd(39,62)\n    13\n    '''\n    v1"}
{"task_id": "MBPP/v522", "completion": "\n\n   # 如果列表长小于2，直接返回\n   if len(arr) <= 2: return len(arr)\n   # 存储元素和下标，方便后面计算\n   dic = {}\n   for i, ele in enumerate(arr):\n       dic[ele] = i\n   # 使用一个单调递增栈\n   stack = []\n   res = 0\n\n   for i, ele in enumerate(arr):\n       # 先看栈顶是否大于等于当前元素\n       while stack and stack[-1][0] >= ele:\n           # 如果大于等于，栈顶元素出栈，并记录长度\n           top = stack.pop()\n           res = max(res, i - stack[-1][1] + 1 if stack else i + 1)\n       # 如果栈为空或者栈顶元素小于当前元素，则当前元素入栈\n       stack.append((ele, i))\n   \n   return res\n\n   \n\ndef lcs(s1,s2):\n   '''\n   给定两个字符串s1和s2，返回最小的交换次数，使得s1和s2相同\n   >>> lcs('ABCD', 'CDA')\n   2\n   >>> lcs('ABC', 'DAC')\n   3\n   >>> lcs('ABC', 'DF')\n   0\n   >>> lcs('ABC', 'CA')\n   3\n   >>> lcs('AA', 'AA')\n   0\n   >>> lcs('', 'CDA')\n   4\n   '''\n   m, n = len(s1), len(s2)\n   dp = [[0] * (n + 1) for _ in range(m + 1)]\n   a, b = [], []\n\n   for i in range(m):\n       for j in range(n):\n           if s1[i] == s2[j]:\n               dp[i + 1][j + 1] = dp[i][j] + 1\n           else:\n               dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n\n   # 如果列表长小于2，直接返回\n   if len(arr) <= 2: return len(arr)\n   # 存储元素和下标，方便后面计算\n   dic = {}\n   for i, ele in enumerate(arr):\n       dic[ele] = i\n   # 使用一个单调递增栈\n   stack = []\n   res = 0\n\n   for i, ele in enumerate(arr):\n       # 先看栈顶是否大于等于当前元素\n       while stack and stack[-1][0] >= ele:\n           # 如果大于等于，栈顶元素出栈，并记录长度\n           top = stack.pop()\n           res = max(res, i - stack[-1][1] + 1 if stack else i + 1)\n       # 如果栈为空或者栈顶元素小于当前元素，则当前元素入栈\n       stack.append((ele, i))\n   \n   return res\n\n   \n\ndef lcs(s1,s2):\n   '''\n   给定两个字符串s1和s2，返回最小的交换次数，使得s1和s2相同\n   >>> lcs('ABCD', 'CDA')\n   2\n   >>> lcs('ABC', 'DAC')\n   3\n   >>> lcs('ABC', 'DF')\n   0\n   >>> lcs('ABC', 'CA')\n   3\n   >>> lcs('AA', 'AA')\n   0\n   >>> lcs('', 'CDA')\n   4\n   '''\n   m, n = len(s1), len(s2)\n   dp = [[0] * (n + 1) for _ in range(m + 1)]\n   a, b = [], []\n\n   for i in range(m):\n       for j in range(n):\n           if s1[i] == s2[j]:\n               dp[i + 1][j + 1] = dp[i][j] + 1\n           else:\n               dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j"}
{"task_id": "MBPP/v522", "completion": "\n   n=len(arr)\n   dp=[0]*n\n   ans=[0]*n\n   dp[0]=1\n   ans[0]=1\n   for i in range(1,n): \n      dp[i]=1\n      ans[i]=1\n      for j in range(0,i):\n         if arr[i]>arr[j]:\n            dp[i]=max(dp[j]+1,dp[i])\n            ans[i]=max(ans[j]+1,ans[i])\n   result=0\n   for i in range(n):\n      result=max(result,ans[i])\n   return result\n\ndef lbs2(arr): \n   '''\n   给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n   >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n   7\n   >>> lbs2([5,1,2,3,4,5,4,3,2])\n   8\n   '''\n   n=len(arr)\n   dp=[0]*n\n   ans=[0]*n\n   dp[0]=1\n   ans[0]=1\n   for i in range(1,n): \n      dp[i]=1\n      ans[i]=1\n      for j in range(n-1,-1,-1):\n         if arr[i]>arr[j]:\n            dp[i]=max(dp[j]+1,dp[i])\n            ans[i]=max(ans[j]+1,ans[i])\n   result=0\n   for i in range(n):\n      result=max(result,ans[i])\n   return result\n\ndef lcs(arr1,arr2): \n   '''\n   给定两个数组arr1和arr2，编写一个函数，求arr1和arr2的最长公共子序列的长度。\n   >>> lcs([1, 2, 3, 4, 5, 3, ", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n=len(arr)\n   dp=[0]*n\n   ans=[0]*n\n   dp[0]=1\n   ans[0]=1\n   for i in range(1,n): \n      dp[i]=1\n      ans[i]=1\n      for j in range(0,i):\n         if arr[i]>arr[j]:\n            dp[i]=max(dp[j]+1,dp[i])\n            ans[i]=max(ans[j]+1,ans[i])\n   result=0\n   for i in range(n):\n      result=max(result,ans[i])\n   return result\n\ndef lbs2(arr): \n   '''\n   给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n   >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n   7\n   >>> lbs2([5,1,2,3,4,5,4,3,2])\n   8\n   '''\n   n=len(arr)\n   dp=[0]*n\n   ans=[0]*n\n   dp[0]=1\n   ans[0]=1\n   for i in range(1,n): \n      dp[i]=1\n      ans[i]=1\n      for j in range(n-1,-1,-1):\n         if arr[i]>arr[j]:\n            dp[i]=max(dp[j]+1,dp[i])\n            ans[i]=max(ans[j]+1,ans[i])\n   result=0\n   for i in range(n):\n      result=max(result,ans[i])\n   return result\n\ndef lcs(arr1,arr2): \n   '''\n   给定两个数组arr1和arr2，编写一个函数，求arr1和arr2的最长公共子序列的长度。\n   >>> lcs([1, 2, 3, 4, 5, 3, "}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   dp = [0] * n\n   for i in range(0, n):\n      maxVal = 1\n      for j in range(0, i):\n         if arr[j] < arr[i] and maxVal < dp[j] + 1:\n            maxVal = dp[j] + 1\n      dp[i] = maxVal\n   \n   maxVal = 0\n   for i in range(0, n):\n      if maxVal < dp[i]:\n         maxVal = dp[i]\n   return maxVal\n\n# def lbs(arr): \n#    '''\n#     给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n#     >>> lbs([1, 2, 3, 4, 5, 3, 2])\n#     7\n#     >>> lbs([5,1,2,3,4,5,4,3,2])\n#     8\n#     '''\n#    n = len(arr)\n#    dp = [0] * n\n#    for i in range(0, n):\n#       maxVal = 1\n#       for j in range(0, i):\n#          if arr[j] < arr[i] and maxVal < dp[j] + 1:\n#             maxVal = dp[j] + 1\n#       dp[i] = maxVal\n            \n#    maxVal = 0\n#    for i in range(0, n):\n#       if maxVal < dp[i]:\n#          maxVal = dp[i]\n#    return maxVal\n\ndef lcs(str1, str2):\n   '''\n    给定两个字符串str1和str2，编写一个程序，找出str1中所有str2的字符\n    >>> lcs('ABCBDAB','BDACB')\n    3\n    >>> lcs('123','123')\n    9\n    '''\n   n = len(str1)", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   dp = [0] * n\n   for i in range(0, n):\n      maxVal = 1\n      for j in range(0, i):\n         if arr[j] < arr[i] and maxVal < dp[j] + 1:\n            maxVal = dp[j] + 1\n      dp[i] = maxVal\n   \n   maxVal = 0\n   for i in range(0, n):\n      if maxVal < dp[i]:\n         maxVal = dp[i]\n   return maxVal\n\n# def lbs(arr): \n#    '''\n#     给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n#     >>> lbs([1, 2, 3, 4, 5, 3, 2])\n#     7\n#     >>> lbs([5,1,2,3,4,5,4,3,2])\n#     8\n#     '''\n#    n = len(arr)\n#    dp = [0] * n\n#    for i in range(0, n):\n#       maxVal = 1\n#       for j in range(0, i):\n#          if arr[j] < arr[i] and maxVal < dp[j] + 1:\n#             maxVal = dp[j] + 1\n#       dp[i] = maxVal\n            \n#    maxVal = 0\n#    for i in range(0, n):\n#       if maxVal < dp[i]:\n#          maxVal = dp[i]\n#    return maxVal\n\ndef lcs(str1, str2):\n   '''\n    给定两个字符串str1和str2，编写一个程序，找出str1中所有str2的字符\n    >>> lcs('ABCBDAB','BDACB')\n    3\n    >>> lcs('123','123')\n    9\n    '''\n   n = len(str1)"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   # 初始化f[i]表示以第i个数结尾的递减序列\n   f = dict()\n   # 初始化g[i]表示以第i个数开始的最长递增子序列的长度\n   g = dict()\n   for i in range(n):\n       g[i] = 1\n       for j in range(i):\n           if arr[j] < arr[i]:\n               g[i] = max(g[i], g[j]+1)\n   res = 1\n   for i in range(n):\n       for j in range(i):\n           if arr[j] > arr[i] and f.get(j) and (g[j]+1) > f.get(i):\n               f[i] = g[j]+1\n               res = max(res, f[i])\n   return res\n\ndef test():\n   assert lbs([1, 2, 3, 4, 5, 3, 2]) == 7\n   assert lbs([5,1,2,3,4,5,4,3,2]) == 8\n\nif __name__ == \"__main__\":\n   test()", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   # 初始化f[i]表示以第i个数结尾的递减序列\n   f = dict()\n   # 初始化g[i]表示以第i个数开始的最长递增子序列的长度\n   g = dict()\n   for i in range(n):\n       g[i] = 1\n       for j in range(i):\n           if arr[j] < arr[i]:\n               g[i] = max(g[i], g[j]+1)\n   res = 1\n   for i in range(n):\n       for j in range(i):\n           if arr[j] > arr[i] and f.get(j) and (g[j]+1) > f.get(i):\n               f[i] = g[j]+1\n               res = max(res, f[i])\n   return res\n\ndef test():\n   assert lbs([1, 2, 3, 4, 5, 3, 2]) == 7\n   assert lbs([5,1,2,3,4,5,4,3,2]) == 8\n\nif __name__ == \"__main__\":\n   test()"}
{"task_id": "MBPP/v522", "completion": "\n   dp = [0] * len(arr)\n   dp[0] = 1\n   for i in range(1, len(arr)):\n       maxx = 1\n       for j in range(0, i):\n           if (arr[j] < arr[i]):\n               maxx = max(maxx, dp[j]+1)\n       dp[i] = maxx\n   return max(dp)\n\narr = [1,2,3,4,5,3,2]\nprint(lbs(arr))\narr =[5,1,2,3,4,5,4,3,2]\nprint(lbs(arr))", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   dp = [0] * len(arr)\n   dp[0] = 1\n   for i in range(1, len(arr)):\n       maxx = 1\n       for j in range(0, i):\n           if (arr[j] < arr[i]):\n               maxx = max(maxx, dp[j]+1)\n       dp[i] = maxx\n   return max(dp)\n\narr = [1,2,3,4,5,3,2]\nprint(lbs(arr))\narr =[5,1,2,3,4,5,4,3,2]\nprint(lbs(arr))"}
{"task_id": "MBPP/v522", "completion": "\n   ans = []\n   for x in arr: ans.append([])\n   idx = 0\n   while idx < len(arr):\n      mini = 0\n      maxi = 0\n      for i in xrange(idx+1, len(arr)):\n         if arr[i] < arr[idx]: mini = max(mini, ans[i])\n         if arr[i] > arr[idx]: maxi = max(maxi, ans[i])\n      if mini == 0 and maxi == 0: ans[idx].append(1)\n      if mini != 0 and maxi != 0: ans[idx].append(mini[0]+maxi[0]+1)\n      if maxi == 0: idx += 1\n      else: idx = maxi[0]-1\n   return max(ans[-1])\n\n\n\n\ndef LCS(X, Y):\n    '''最长公共子序列\n    给定两个字符串X和Y,以及X和Y的最长公共子序列,求X和Y的最长公共子序列的长度\n    >>> LCS('011', '111')\n    2\n    >>> LCS('011', '1111')\n    1\n    '''\n    m = len(X)\n    n = len(Y)\n\n    X = ''.join(['0' for _ in range(n - m)]) + X\n    Y = ''.join(['0' for _ in range(m - n)]) + Y\n    print X, Y\n    dp = [[0 for j in range(len(X))] for i in range (len(Y))]\n    for i in range(len(X)):\n        for j in range(len(Y)):\n            if X[i] == Y[j]: dp[i][j] = dp[i-1][j-1] + 1     \n            else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n\ndef LongestCommonPrefix(X):\n", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   ans = []\n   for x in arr: ans.append([])\n   idx = 0\n   while idx < len(arr):\n      mini = 0\n      maxi = 0\n      for i in xrange(idx+1, len(arr)):\n         if arr[i] < arr[idx]: mini = max(mini, ans[i])\n         if arr[i] > arr[idx]: maxi = max(maxi, ans[i])\n      if mini == 0 and maxi == 0: ans[idx].append(1)\n      if mini != 0 and maxi != 0: ans[idx].append(mini[0]+maxi[0]+1)\n      if maxi == 0: idx += 1\n      else: idx = maxi[0]-1\n   return max(ans[-1])\n\n\n\n\ndef LCS(X, Y):\n    '''最长公共子序列\n    给定两个字符串X和Y,以及X和Y的最长公共子序列,求X和Y的最长公共子序列的长度\n    >>> LCS('011', '111')\n    2\n    >>> LCS('011', '1111')\n    1\n    '''\n    m = len(X)\n    n = len(Y)\n\n    X = ''.join(['0' for _ in range(n - m)]) + X\n    Y = ''.join(['0' for _ in range(m - n)]) + Y\n    print X, Y\n    dp = [[0 for j in range(len(X))] for i in range (len(Y))]\n    for i in range(len(X)):\n        for j in range(len(Y)):\n            if X[i] == Y[j]: dp[i][j] = dp[i-1][j-1] + 1     \n            else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n\ndef LongestCommonPrefix(X):\n"}
{"task_id": "MBPP/v522", "completion": "\n   # 思路，用一个栈，每次入栈的元素都小于栈顶元素，则栈顶元素出栈，否则保留\n   # 用一个表，表示每个元素入栈时，栈顶元素到该元素的距离\n   stack = []\n   for x in arr:\n      while stack and stack[-1]>x: stack.pop()\n      # 栈为空，push x，否则，比较x到栈顶元素的距离和栈顶元素到栈底元素距离取最小值\n      stack.append(x)\n      dist.append(0 if not stack else stack[-1]-x+len(stack))\n   return max(dist)\n\ndef getMinFit(arr):\n   '''\n    给定一个数组，求数组中的最小差值\n    >>> getMinFit([1, 3, 4])\n    1\n    >>> getMinFit([5, 23, 21, 3, 2, 2])\n    1\n    '''\n   if not arr: return 0\n   arr.sort()\n   return min(arr[i]-arr[i-1] for i in range(1,len(arr)))\n\ndef getMinFit1(arr):\n   '''\n    给定一个数组，求数组中的最小差值\n    >>> getMinFit1([1, 3, 4])\n    1\n    >>> getMinFit1([5, 23, 21, 3, 2, 2])\n    1\n    '''\n   if not arr: return 0\n   arr.sort()\n   return min([arr[i]-arr[i-1] for i in range(1,len(arr))])\n\n\ndef getMinFit2(arr):\n   if not arr: return 0\n   arr.sort()\n   return min(arr[i]-arr[i-1] for i in range(1,len(arr)))\n   \n\ndef getMinFit3(arr):\n   if not arr: return 0\n   arr.sort()\n   return min([arr[i]-arr[i-1]", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   # 思路，用一个栈，每次入栈的元素都小于栈顶元素，则栈顶元素出栈，否则保留\n   # 用一个表，表示每个元素入栈时，栈顶元素到该元素的距离\n   stack = []\n   for x in arr:\n      while stack and stack[-1]>x: stack.pop()\n      # 栈为空，push x，否则，比较x到栈顶元素的距离和栈顶元素到栈底元素距离取最小值\n      stack.append(x)\n      dist.append(0 if not stack else stack[-1]-x+len(stack))\n   return max(dist)\n\ndef getMinFit(arr):\n   '''\n    给定一个数组，求数组中的最小差值\n    >>> getMinFit([1, 3, 4])\n    1\n    >>> getMinFit([5, 23, 21, 3, 2, 2])\n    1\n    '''\n   if not arr: return 0\n   arr.sort()\n   return min(arr[i]-arr[i-1] for i in range(1,len(arr)))\n\ndef getMinFit1(arr):\n   '''\n    给定一个数组，求数组中的最小差值\n    >>> getMinFit1([1, 3, 4])\n    1\n    >>> getMinFit1([5, 23, 21, 3, 2, 2])\n    1\n    '''\n   if not arr: return 0\n   arr.sort()\n   return min([arr[i]-arr[i-1] for i in range(1,len(arr))])\n\n\ndef getMinFit2(arr):\n   if not arr: return 0\n   arr.sort()\n   return min(arr[i]-arr[i-1] for i in range(1,len(arr)))\n   \n\ndef getMinFit3(arr):\n   if not arr: return 0\n   arr.sort()\n   return min([arr[i]-arr[i-1]"}
{"task_id": "MBPP/v564", "completion": "\n    from collections import Counter\n    from collections import defaultdict\n    d = Counter(arr)\n    for i in d:\n        d[i] -= 1\n    res = 0\n    for i in d:\n        res += d[i] * (d[i] - 1) // 2\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    from collections import Counter\n    from collections import defaultdict\n    d = Counter(arr)\n    for i in d:\n        d[i] -= 1\n    res = 0\n    for i in d:\n        res += d[i] * (d[i] - 1) // 2\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/v564", "completion": "\n    size = len(arr)\n    count = 0\n    for i in range(size - 1):\n        for j in range(i + 1, size):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\n\n# 30. 串联所有单词的子串\ndef subString(string):\n    '''\n    如果字符串中的所有单词都按照字典序排列连接起来，那么该字符串就称之为回环的。\n    现在给定一个字符串str，要求你找出其中最长的回环子串。\n    >>> subString(\"cbaebabacd\")\n    \"ababac\"\n    >>> subString(\"abcd\")\n    \"abcd\"\n    '''\n    maxStr = string[0]\n    size = len(string)\n    for i in range(size):\n        j = i + 1\n        while string[j] in string[i]:\n            if j - i + 1 > len(maxStr):\n                maxStr = string[i:j + 1]\n            j += 1\n    return", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    size = len(arr)\n    count = 0\n    for i in range(size - 1):\n        for j in range(i + 1, size):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\n\n# 30. 串联所有单词的子串\ndef subString(string):\n    '''\n    如果字符串中的所有单词都按照字典序排列连接起来，那么该字符串就称之为回环的。\n    现在给定一个字符串str，要求你找出其中最长的回环子串。\n    >>> subString(\"cbaebabacd\")\n    \"ababac\"\n    >>> subString(\"abcd\")\n    \"abcd\"\n    '''\n    maxStr = string[0]\n    size = len(string)\n    for i in range(size):\n        j = i + 1\n        while string[j] in string[i]:\n            if j - i + 1 > len(maxStr):\n                maxStr = string[i:j + 1]\n            j += 1\n    return"}
{"task_id": "MBPP/v564", "completion": "\n\n    size = len(arr)\n    if not arr or size < 2:\n        return 0\n\n    result = 0\n    for i in range(size):\n        for j in range(i+1, size):\n            if arr[i] == arr[j]:\n                result += 1\n\n    return result\n\n\ndef two_sum(nums, target):\n    '''\n    给定一个整数数组nums和目标值target，请你在该数组中找出和为目标值的那两个整数，\n    并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n    >>> two_sum([3,2,4], 6)\n    [1,2]\n    '''\n\n    visited = {}\n\n    for index, num in enumerate(nums):\n        if target - num in visited:\n            return [visited[target - num], index]\n        visited[num] = index\n\n    return None\n\n\ndef two_sum_v2(nums, target):\n    ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n\n    size = len(arr)\n    if not arr or size < 2:\n        return 0\n\n    result = 0\n    for i in range(size):\n        for j in range(i+1, size):\n            if arr[i] == arr[j]:\n                result += 1\n\n    return result\n\n\ndef two_sum(nums, target):\n    '''\n    给定一个整数数组nums和目标值target，请你在该数组中找出和为目标值的那两个整数，\n    并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n    >>> two_sum([3,2,4], 6)\n    [1,2]\n    '''\n\n    visited = {}\n\n    for index, num in enumerate(nums):\n        if target - num in visited:\n            return [visited[target - num], index]\n        visited[num] = index\n\n    return None\n\n\ndef two_sum_v2(nums, target):\n    "}
{"task_id": "MBPP/v564", "completion": "\n    res = 0\n    map = {}\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n\n\n# ### 有效的数对\n# 给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n# 不相等的元素对指的是两个不同的位置(arr[i],arr[j]) 满足 i < j 且arr[i] != arr[j]，求所有不相等的元素对的总数。\n# 输入输出示例\n# 输入是一个数组，对应给定的数组arr\n# 输出是一个整数，即arr中所有不相等的元素对的总数。\n# 输入描述:\n# arr是给定的数组\n# 输出描述:\n# 返回arr中所有不相等的元素对的总数，数据范围0 <= arr.length <= 10000\n# 输入例子1:\n# [1, 2, 3, 4]\n# 输出例子1:\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    res = 0\n    map = {}\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n\n\n# ### 有效的数对\n# 给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n# 不相等的元素对指的是两个不同的位置(arr[i],arr[j]) 满足 i < j 且arr[i] != arr[j]，求所有不相等的元素对的总数。\n# 输入输出示例\n# 输入是一个数组，对应给定的数组arr\n# 输出是一个整数，即arr中所有不相等的元素对的总数。\n# 输入描述:\n# arr是给定的数组\n# 输出描述:\n# 返回arr中所有不相等的元素对的总数，数据范围0 <= arr.length <= 10000\n# 输入例子1:\n# [1, 2, 3, 4]\n# 输出例子1:\n"}
{"task_id": "MBPP/v564", "completion": "\n    arr.sort()\n    count = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                count += 1\n            elif arr[i] > arr[j]:\n                break\n    return count\n\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    arr.sort()\n    count = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                count += 1\n            elif arr[i] > arr[j]:\n                break\n    return count\n\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/v564", "completion": "\n    arr.sort()\n    length = len(arr)\n    count = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                count += 1\n                break\n    return count\n\n\n# 5. 数字转字符串\ndef to_string(number, base):\n    '''\n    将数字number，以指定的进制base转换为字符串。\n    >>> to_string(10, 2)\n    '1010'\n    >>> to_string(2, 5)\n    '10'\n    >>> to_string(3, 5)\n    '11'\n    '''\n    result = ''\n    flag = True\n    while number > 0:\n        remainder = number % base\n        if remainder < 10:\n            result += str(remainder)\n        else:\n            result += chr(ord('a') + remainder - 10)\n        number //= base\n    return result[::-1]\n\n\nif", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    arr.sort()\n    length = len(arr)\n    count = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            if arr[i] == arr[j]:\n                count += 1\n                break\n    return count\n\n\n# 5. 数字转字符串\ndef to_string(number, base):\n    '''\n    将数字number，以指定的进制base转换为字符串。\n    >>> to_string(10, 2)\n    '1010'\n    >>> to_string(2, 5)\n    '10'\n    >>> to_string(3, 5)\n    '11'\n    '''\n    result = ''\n    flag = True\n    while number > 0:\n        remainder = number % base\n        if remainder < 10:\n            result += str(remainder)\n        else:\n            result += chr(ord('a') + remainder - 10)\n        number //= base\n    return result[::-1]\n\n\nif"}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    p1 = 0\n    p2 = 1\n    ans = 0\n    while p1 < n:\n        while p2 < n and arr[p1] == arr[p2]:\n            p2 += 1\n        ans += (p2 - p1 - 1)\n        p1 += 1\n        p2 = p1 + 1\n    return ans\n\ndef count_Pairs2(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两组相邻的元素对，它们之间至少有一个其他元素。\n    如果两个元素相等，它们不会同时出现在一个元素对的左右两半部分。\n    >>> count_Pairs2([1, 2, 3, 4])\n    6\n    >>> count_Pairs2([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    p1 = 0\n    p2 = 1\n    ans = 0\n    while p1", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    p1 = 0\n    p2 = 1\n    ans = 0\n    while p1 < n:\n        while p2 < n and arr[p1] == arr[p2]:\n            p2 += 1\n        ans += (p2 - p1 - 1)\n        p1 += 1\n        p2 = p1 + 1\n    return ans\n\ndef count_Pairs2(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两组相邻的元素对，它们之间至少有一个其他元素。\n    如果两个元素相等，它们不会同时出现在一个元素对的左右两半部分。\n    >>> count_Pairs2([1, 2, 3, 4])\n    6\n    >>> count_Pairs2([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    p1 = 0\n    p2 = 1\n    ans = 0\n    while p1"}
{"task_id": "MBPP/v564", "completion": "\n    if not arr or len(arr) < 2:\n        return 0\n    \n    res = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n\n\ndef count_Pairs_v2(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两数之差为1的一组(arr[i],arr[j])，其中i < j。\n    >>> count_Pairs_v2([1, 2, 3, 4])\n    6\n    >>> count_Pairs_v2([1, 1, 1])\n    6\n    '''\n    if not arr or len(arr) < 2:\n        return 0\n    \n    res = 0\n    arr_set = set(arr)\n    for num in arr_set:\n        res += arr.count(num+1)\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    if not arr or len(arr) < 2:\n        return 0\n    \n    res = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                res += 1\n    return res\n\n\ndef count_Pairs_v2(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两数之差为1的一组(arr[i],arr[j])，其中i < j。\n    >>> count_Pairs_v2([1, 2, 3, 4])\n    6\n    >>> count_Pairs_v2([1, 1, 1])\n    6\n    '''\n    if not arr or len(arr) < 2:\n        return 0\n    \n    res = 0\n    arr_set = set(arr)\n    for num in arr_set:\n        res += arr.count(num+1)\n"}
{"task_id": "MBPP/v564", "completion": "\n    # 由于题目中说了arr中数字不会重复，因此可以先排序\n    # 可以使用双指针或二分法(不写了)\n    arr = sorted(arr)\n    def count(arr, target):\n        cnt = 0\n        for i in range(len(arr)):\n            cnt += i - bin_search_last(arr[:i] + arr[i + 1:], target)\n        return cnt\n\n    def bin_search_last(arr, target):\n        l, r = 0, len(arr) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if arr[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n\n    return count(arr, arr[-1])\n\nif __name__ == '__main__':\n    res = count_Pairs([1, 2, 3, 4])\n    print(res)", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    # 由于题目中说了arr中数字不会重复，因此可以先排序\n    # 可以使用双指针或二分法(不写了)\n    arr = sorted(arr)\n    def count(arr, target):\n        cnt = 0\n        for i in range(len(arr)):\n            cnt += i - bin_search_last(arr[:i] + arr[i + 1:], target)\n        return cnt\n\n    def bin_search_last(arr, target):\n        l, r = 0, len(arr) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if arr[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n\n    return count(arr, arr[-1])\n\nif __name__ == '__main__':\n    res = count_Pairs([1, 2, 3, 4])\n    print(res)"}
{"task_id": "MBPP/v564", "completion": "\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\ndef count_Pairs2(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两数不相等，且两数在数组中的位置不相邻。\n    注意:如果 arr[i] == arr[j] and i != j，这种对数不需要被计入结果中。\n    >>> count_Pairs2([1, 2, 3, 4])\n    7\n    >>> count_Pairs2([1, 1, 1])\n    0\n    '''\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+2,len(arr)):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\ndef getTotalMoney(n):\n    ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\ndef count_Pairs2(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是两数不相等，且两数在数组中的位置不相邻。\n    注意:如果 arr[i] == arr[j] and i != j，这种对数不需要被计入结果中。\n    >>> count_Pairs2([1, 2, 3, 4])\n    7\n    >>> count_Pairs2([1, 1, 1])\n    0\n    '''\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+2,len(arr)):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\ndef getTotalMoney(n):\n    "}
{"task_id": "MBPP/train620", "completion": "\n    # 用一个二维数组记录状态\n    n = len(arr)\n    if n == 0:\n        return 0\n    a = [[False]*n for _ in range(n)]\n    # 初始化\n    for i in range(n):\n        a[i][i] = True\n    for i in range(n-1):\n        if arr[i] % arr[i+1] == 0:\n            a[i][i+1] = True\n        else:\n            a[i][i+1] = False\n    for l in range(3, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if arr[i] % arr[j] == 0:\n                a[i][j] = a[i+1][j-1]\n            else:\n                a[i][j] = a[i+1][j-1] or a[i][j-1]\n    return sum(a[i][-1] for i in range(n))\n\ndef largest_subset2(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 用一个二维数组记录状态\n    n = len(arr)\n    if n == 0:\n        return 0\n    a = [[False]*n for _ in range(n)]\n    # 初始化\n    for i in range(n):\n        a[i][i] = True\n    for i in range(n-1):\n        if arr[i] % arr[i+1] == 0:\n            a[i][i+1] = True\n        else:\n            a[i][i+1] = False\n    for l in range(3, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if arr[i] % arr[j] == 0:\n                a[i][j] = a[i+1][j-1]\n            else:\n                a[i][j] = a[i+1][j-1] or a[i][j-1]\n    return sum(a[i][-1] for i in range(n))\n\ndef largest_subset2(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest"}
{"task_id": "MBPP/train620", "completion": "\n    if not arr:\n        return 0\n    res = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i + 1, l):\n            if arr[i] % arr[j] == 0:\n                res += 1\n    return res\n\n\ndef max_product_of_indices(arr):\n    '''\n    给定一个数组，求这个数组最大子数组乘积，子数组中元素两两相乘，子数组必须连续。\n    >>> max_product_of_indices([-2, 3, -4, 5, 1, -7, 8, 0])\n    100\n    >>> max_product_of_indices([10, -5, 0, -4])\n    0\n    '''\n    if not arr:\n        return 0\n\n    max_all = arr[0]\n    min_all = arr[0]\n    res = arr[0]\n    l = len(arr)\n    for i in range(1, l):\n        max_all = max(arr[i] * max_all, arr[i])\n        min_all = min(arr[i] * min_all, arr[i])\n", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if not arr:\n        return 0\n    res = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i + 1, l):\n            if arr[i] % arr[j] == 0:\n                res += 1\n    return res\n\n\ndef max_product_of_indices(arr):\n    '''\n    给定一个数组，求这个数组最大子数组乘积，子数组中元素两两相乘，子数组必须连续。\n    >>> max_product_of_indices([-2, 3, -4, 5, 1, -7, 8, 0])\n    100\n    >>> max_product_of_indices([10, -5, 0, -4])\n    0\n    '''\n    if not arr:\n        return 0\n\n    max_all = arr[0]\n    min_all = arr[0]\n    res = arr[0]\n    l = len(arr)\n    for i in range(1, l):\n        max_all = max(arr[i] * max_all, arr[i])\n        min_all = min(arr[i] * min_all, arr[i])\n"}
{"task_id": "MBPP/train620", "completion": "\n    for i, x in enumerate(arr):\n        if not all(x % x2 == 0 for x2 in arr[:i]):\n            arr[i] = 0\n    return arr.count(1)\n\n\ndef largest_subset2(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    res = 0\n    s = set()\n    for x in arr:\n        if all(x % x2 not in s for x2 in s):\n            res += 1\n            s.add(x)\n    return res\n\n\ndef max_consecutive_ones(arr): \n    '''\n    给定一个数组a，编写一个函数，返回a中最大连续1的个数，返回0表示没有1。\n    >>> max_consecutive_ones([1, 1, 0, 1, 1, 1])\n    3\n    >>> max_consecutive_ones([1, 0", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    for i, x in enumerate(arr):\n        if not all(x % x2 == 0 for x2 in arr[:i]):\n            arr[i] = 0\n    return arr.count(1)\n\n\ndef largest_subset2(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    res = 0\n    s = set()\n    for x in arr:\n        if all(x % x2 not in s for x2 in s):\n            res += 1\n            s.add(x)\n    return res\n\n\ndef max_consecutive_ones(arr): \n    '''\n    给定一个数组a，编写一个函数，返回a中最大连续1的个数，返回0表示没有1。\n    >>> max_consecutive_ones([1, 1, 0, 1, 1, 1])\n    3\n    >>> max_consecutive_ones([1, 0"}
{"task_id": "MBPP/train620", "completion": "\n    if not arr:\n        return 0\n    start = min(arr)\n    end = max(arr)\n    dp = [0] * (end + 1)\n    dp[start] = 1\n    for i in range(start + 1, end + 1):\n        dp[i] = 1\n        for j in range(i + 1, end + 1):\n            if i % j == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[end]\n\n\n# 62 题最大连续子序列和\ndef longest_subsequence(arr):\n    '''\n    给定一个数组a，编写一个函数，求a最大的连续子序列的和，子序列与子数组不同，序列中可以包含多个连续元素。\n    >>> longest_subsequence([1, -2, 3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> longest_subsequence([-1, -2, -3, -4, -1, -2, -1, -5, -4])\n    1\n    '''\n    if not arr:\n        return 0\n    dp = [0 for i in range(len", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if not arr:\n        return 0\n    start = min(arr)\n    end = max(arr)\n    dp = [0] * (end + 1)\n    dp[start] = 1\n    for i in range(start + 1, end + 1):\n        dp[i] = 1\n        for j in range(i + 1, end + 1):\n            if i % j == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[end]\n\n\n# 62 题最大连续子序列和\ndef longest_subsequence(arr):\n    '''\n    给定一个数组a，编写一个函数，求a最大的连续子序列的和，子序列与子数组不同，序列中可以包含多个连续元素。\n    >>> longest_subsequence([1, -2, 3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> longest_subsequence([-1, -2, -3, -4, -1, -2, -1, -5, -4])\n    1\n    '''\n    if not arr:\n        return 0\n    dp = [0 for i in range(len"}
{"task_id": "MBPP/train620", "completion": "\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    # 求最大子集，首先应该想到二分法\n    # 如果a[i]和a[i-1]有相同的质因子，则一定可以放到一个集合中\n    # 否则，不能放\n    arr.sort()\n    def prime_factors(num):\n        d = {}\n        while num % 2 == 0:\n            d[2] = d.get(2, 0) + 1\n            num = num // 2\n        f = math.sqrt(num)\n        for i in range(3, int(f) + 1, 2):\n            while num % i == 0:\n                d[i] = d.get(i, 0) + 1\n                num = num // i\n        if num > 2:\n            d[num] = d.get(num, 0) + 1\n        return d\n    m = 0\n    # 对于数组arr中的每一个元素，判断是否可以与之前的元素构成一个集合\n    for i in range(1, len(arr)):\n        # arr[i] 和 arr[i-1] 是否有相同质因子\n        if not prime_factors(", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    # 求最大子集，首先应该想到二分法\n    # 如果a[i]和a[i-1]有相同的质因子，则一定可以放到一个集合中\n    # 否则，不能放\n    arr.sort()\n    def prime_factors(num):\n        d = {}\n        while num % 2 == 0:\n            d[2] = d.get(2, 0) + 1\n            num = num // 2\n        f = math.sqrt(num)\n        for i in range(3, int(f) + 1, 2):\n            while num % i == 0:\n                d[i] = d.get(i, 0) + 1\n                num = num // i\n        if num > 2:\n            d[num] = d.get(num, 0) + 1\n        return d\n    m = 0\n    # 对于数组arr中的每一个元素，判断是否可以与之前的元素构成一个集合\n    for i in range(1, len(arr)):\n        # arr[i] 和 arr[i-1] 是否有相同质因子\n        if not prime_factors("}
{"task_id": "MBPP/train620", "completion": "\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    \n    def f(i):\n        for j in range(i):\n            if arr[j] and arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n        return dp[i]\n\n    arr.sort()\n    res = 1\n    for i in range(n):\n        res = max(res, f(i))\n    return res\n\n\ndef longest_palindrome(s: str) -> int:\n    \"\"\"\n    找到字符串的最长回文子串\n    :param s:\n    :return:\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    # 枚举子串长度\n    for l in range(2, n + 1):\n        for i in range(n):\n            j = l + i - 1\n            if j >= n:\n                break\n            if s[i] == s[j]:\n                dp[i][j] = d", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    \n    def f(i):\n        for j in range(i):\n            if arr[j] and arr[i] % arr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n        return dp[i]\n\n    arr.sort()\n    res = 1\n    for i in range(n):\n        res = max(res, f(i))\n    return res\n\n\ndef longest_palindrome(s: str) -> int:\n    \"\"\"\n    找到字符串的最长回文子串\n    :param s:\n    :return:\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    # 枚举子串长度\n    for l in range(2, n + 1):\n        for i in range(n):\n            j = l + i - 1\n            if j >= n:\n                break\n            if s[i] == s[j]:\n                dp[i][j] = d"}
{"task_id": "MBPP/train620", "completion": "\n    pass\n\ndef subset_sum(arr, sum):\n    '''\n    给定一个数组arr，求arr中是否存在连续子数组，其和等于sum。\n    对于arr中任意一个数，要么单独可以构成一个和为sum的子数组，要么与数组中任意一个存在的子数组相加，\n    得到一个和为sum的子数组，例如[1, 2, 3, 7], 和为12的子数组有[1], [1, 2], [1, 2, 3]\n    >>> subset_sum([1, 2, 3, 7], 12)\n    True\n    >>> subset_sum([1, 2], 3)\n    False\n    '''\n    pass\n\ndef subsets(arr):\n    '''\n    给定一个数组arr，求arr的所有子集。arr中可能有重复元素，例如对于arr=[1, 2, 3]，\n    它的子集有[],[1],[2],[3],[1, 2],[1, 3],[2, 3],[1, 2, 3]\n    >>> subsets([1, 2, 3])\n    [[], [1], [2], [3], [1, 2], [1", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    pass\n\ndef subset_sum(arr, sum):\n    '''\n    给定一个数组arr，求arr中是否存在连续子数组，其和等于sum。\n    对于arr中任意一个数，要么单独可以构成一个和为sum的子数组，要么与数组中任意一个存在的子数组相加，\n    得到一个和为sum的子数组，例如[1, 2, 3, 7], 和为12的子数组有[1], [1, 2], [1, 2, 3]\n    >>> subset_sum([1, 2, 3, 7], 12)\n    True\n    >>> subset_sum([1, 2], 3)\n    False\n    '''\n    pass\n\ndef subsets(arr):\n    '''\n    给定一个数组arr，求arr的所有子集。arr中可能有重复元素，例如对于arr=[1, 2, 3]，\n    它的子集有[],[1],[2],[3],[1, 2],[1, 3],[2, 3],[1, 2, 3]\n    >>> subsets([1, 2, 3])\n    [[], [1], [2], [3], [1, 2], [1"}
{"task_id": "MBPP/train620", "completion": "\n    # 动态规划\n    n = len(arr)\n    arr.sort()\n    dp = [1 for _ in range(n)] # dp[i] 表示以arr[i]为结尾的最大子集\n    for i in range(n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0 and dp[j] >= dp[i]:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\nif __name__ == '__main__':\n    arr = [1, 3, 6, 13, 17, 18]\n    arr = [2, 4, 8, 12]\n    print(largest_subset(arr))", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 动态规划\n    n = len(arr)\n    arr.sort()\n    dp = [1 for _ in range(n)] # dp[i] 表示以arr[i]为结尾的最大子集\n    for i in range(n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0 and dp[j] >= dp[i]:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\nif __name__ == '__main__':\n    arr = [1, 3, 6, 13, 17, 18]\n    arr = [2, 4, 8, 12]\n    print(largest_subset(arr))"}
{"task_id": "MBPP/train620", "completion": "\n    dp = [1] + [0] * len(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] % arr[i] == 0:\n                dp[j + 1] = max(dp[j + 1], dp[i] + 1)\n    return dp[-1]\n\ndef min_jump(arr):\n    '''\n    给定一个非负整数数组A，数组A中的第i个元素A[i]代表了第i个数字可以跳到的范围(i.e.,A[i]表示i可以跳到的范围是[i -A[i] , i +A[i]]，即表示i可以跳到第i-A[i]到i+A[i]个位置。现在从起始点A[0]出发，可以一次跳到A的任何一个位置。求对所有的1<=i<=n，从A[0]出发，跳到A[i]所跳过的数字之和的最小值。\n    >>> min_jump([2, 5, 1, 1, 2])\n    7\n    >>> min_jump([1, 1])\n    1\n    '''\n    dp = [0]", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    dp = [1] + [0] * len(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] % arr[i] == 0:\n                dp[j + 1] = max(dp[j + 1], dp[i] + 1)\n    return dp[-1]\n\ndef min_jump(arr):\n    '''\n    给定一个非负整数数组A，数组A中的第i个元素A[i]代表了第i个数字可以跳到的范围(i.e.,A[i]表示i可以跳到的范围是[i -A[i] , i +A[i]]，即表示i可以跳到第i-A[i]到i+A[i]个位置。现在从起始点A[0]出发，可以一次跳到A的任何一个位置。求对所有的1<=i<=n，从A[0]出发，跳到A[i]所跳过的数字之和的最小值。\n    >>> min_jump([2, 5, 1, 1, 2])\n    7\n    >>> min_jump([1, 1])\n    1\n    '''\n    dp = [0]"}
{"task_id": "MBPP/train620", "completion": "\n    \"\"\"\n    动态规划\n    令a[i]表示前i个元素可以组成的最大子集\n    则状态转移方程为\n    a[i] = a[i-1] + x;\n    其中x表示当a[i]加入时，可以增加的子集数\n    当a[i]等于1时，表示单独成一组，则x = 1\n    当a[i]大于1时，x = 0\n    在程序中，我们发现x始终是0或1，所以可以省去该维度。\n    \"\"\"\n    n = len(arr)\n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = a[i - 1] + (1 if arr[i-1] == 1 else 0)\n    return a[n]\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print(largest_subset([1, 3, 6, 13, 17, 18]))\n    print(largest_subset([2, 4, 8, 12]))\n\nif __name__ == \"__main__\":\n    main()", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    \"\"\"\n    动态规划\n    令a[i]表示前i个元素可以组成的最大子集\n    则状态转移方程为\n    a[i] = a[i-1] + x;\n    其中x表示当a[i]加入时，可以增加的子集数\n    当a[i]等于1时，表示单独成一组，则x = 1\n    当a[i]大于1时，x = 0\n    在程序中，我们发现x始终是0或1，所以可以省去该维度。\n    \"\"\"\n    n = len(arr)\n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = a[i - 1] + (1 if arr[i-1] == 1 else 0)\n    return a[n]\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print(largest_subset([1, 3, 6, 13, 17, 18]))\n    print(largest_subset([2, 4, 8, 12]))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "MBPP/train689", "completion": "\n    if len(arr) == 1:\n        return 0\n    \n    start = 0\n    end = 1\n    res = arr[0]\n    while end < len(arr):\n        if res >= 0:\n            res -= 1\n            end += 1\n        else:\n            next_res = [res-arr[i] for i in range(start+1, end)]\n            next_res.extend([res-arr[i] for i in range(start+1)])\n            next_res = min(next_res)\n            start = end - 1\n            res += next_res\n            end = start + 1\n    return res\n\ndef min_jumps(arr):\n    '''\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    length = len(arr)\n    dp = [length] * length\n    dp[length - 1] = 0\n    for i in range(length - 2, -1, -1):\n        step = arr[i]\n        for step_", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if len(arr) == 1:\n        return 0\n    \n    start = 0\n    end = 1\n    res = arr[0]\n    while end < len(arr):\n        if res >= 0:\n            res -= 1\n            end += 1\n        else:\n            next_res = [res-arr[i] for i in range(start+1, end)]\n            next_res.extend([res-arr[i] for i in range(start+1)])\n            next_res = min(next_res)\n            start = end - 1\n            res += next_res\n            end = start + 1\n    return res\n\ndef min_jumps(arr):\n    '''\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    length = len(arr)\n    dp = [length] * length\n    dp[length - 1] = 0\n    for i in range(length - 2, -1, -1):\n        step = arr[i]\n        for step_"}
{"task_id": "MBPP/train689", "completion": "\n    n = len (arr)\n    step = [0] * n\n    step[n-1] = 0\n    for i in range (n - 1, -1, -1):\n        step[i] = step[i+1] + 1\n        while (i + step[i] < n and arr[i]+ i + step[i] < n):\n            if step[i + step[i]] == 0:\n                step[i] = step[i] + 1\n            else:\n                break\n    return step[0], step\n\n\ndef binary_search(arr, target):\n    '''\n    给定一个 m个元素有序的（升序）整型数组nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n    >>> binary_search([1, 3, 4, 5, 6, 9], 9)\n    4\n    '''\n    n = len (arr)\n    low = 0\n    high = n-1\n    while low <= high:\n        mid = (low + high)", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len (arr)\n    step = [0] * n\n    step[n-1] = 0\n    for i in range (n - 1, -1, -1):\n        step[i] = step[i+1] + 1\n        while (i + step[i] < n and arr[i]+ i + step[i] < n):\n            if step[i + step[i]] == 0:\n                step[i] = step[i] + 1\n            else:\n                break\n    return step[0], step\n\n\ndef binary_search(arr, target):\n    '''\n    给定一个 m个元素有序的（升序）整型数组nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n    >>> binary_search([1, 3, 4, 5, 6, 9], 9)\n    4\n    '''\n    n = len (arr)\n    low = 0\n    high = n-1\n    while low <= high:\n        mid = (low + high)"}
{"task_id": "MBPP/train689", "completion": "\n    if not arr:\n        return -1\n    length = len(arr)\n    if length == 1:\n        return 0\n\n    dp = [length] * length\n    dp[0] = 0\n    for i in range(1, length):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min([dp[i], 1 + dp[j]])\n    return dp[-1]", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if not arr:\n        return -1\n    length = len(arr)\n    if length == 1:\n        return 0\n\n    dp = [length] * length\n    dp[0] = 0\n    for i in range(1, length):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min([dp[i], 1 + dp[j]])\n    return dp[-1]"}
{"task_id": "MBPP/train689", "completion": "\n    if not arr: return 0\n    if len(arr) == 1: return 0\n    if len(arr) == 2: return 1\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = 0\n    dp[1] = 1\n    for i in range(2, n):\n        dp[i] = dp[i - 1] + 1\n        for j in range(i - 1, 0, -1):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n                break\n    return dp[n-1]\n\ndef min_jumps_v2(nums):\n    '''\n    >>> min_jumps_v2([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if not nums: return 0\n    n = len(nums)\n    dp = [float(\"inf\")] * n\n    dp[0] = 0\n    for i in range(", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if not arr: return 0\n    if len(arr) == 1: return 0\n    if len(arr) == 2: return 1\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = 0\n    dp[1] = 1\n    for i in range(2, n):\n        dp[i] = dp[i - 1] + 1\n        for j in range(i - 1, 0, -1):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n                break\n    return dp[n-1]\n\ndef min_jumps_v2(nums):\n    '''\n    >>> min_jumps_v2([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    if not nums: return 0\n    n = len(nums)\n    dp = [float(\"inf\")] * n\n    dp[0] = 0\n    for i in range("}
{"task_id": "MBPP/train689", "completion": "\n    L = len(arr)\n    if arr == []:\n        return 0\n    elif L == 1:\n        return 0\n    else:\n        arr.insert(0,0)\n        arr.insert(0,0)\n        arr.append(0)\n        arr.append(0)\n        dp = [0]*(L+2)\n        for i in range(2,L+2):\n            dp[i] = min(dp[i-1],dp[i-2])+1\n            for j in range(i-1,0,-1):\n                if j + arr[j] >= i:\n                    dp[i] = min(dp[i],dp[j]+1)\n                else:\n                    break\n        return dp[L+1]\n\ndef max_jumps(arr):\n    '''\n    >>> max_jumps([7, 6, 4, 5, 9, 15, 1, 3, 10, 18])\n    7\n    '''\n    L = len(arr)\n    if arr == []:\n        return 0", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    L = len(arr)\n    if arr == []:\n        return 0\n    elif L == 1:\n        return 0\n    else:\n        arr.insert(0,0)\n        arr.insert(0,0)\n        arr.append(0)\n        arr.append(0)\n        dp = [0]*(L+2)\n        for i in range(2,L+2):\n            dp[i] = min(dp[i-1],dp[i-2])+1\n            for j in range(i-1,0,-1):\n                if j + arr[j] >= i:\n                    dp[i] = min(dp[i],dp[j]+1)\n                else:\n                    break\n        return dp[L+1]\n\ndef max_jumps(arr):\n    '''\n    >>> max_jumps([7, 6, 4, 5, 9, 15, 1, 3, 10, 18])\n    7\n    '''\n    L = len(arr)\n    if arr == []:\n        return 0"}
{"task_id": "MBPP/train689", "completion": "\n    # 动态规划\n    n = len(arr)\n    ans = [0]*n\n    for i in range(n):\n        if ans[i] != 0:\n            continue\n        if i == n-1:\n            ans[i] = 0\n        elif i < n-1:\n            ans[i] = min(ans[j]+1 for j in range(i+1, min(n, i+arr[i]+1)))\n    return ans[-1]\n\n\n\ndef get_min_jump_path(arr):\n    '''\n    获取最短路径\n    >>> get_min_jump_path([1, 3, 6, 13, 17, 18])\n    [0, 3, 6, 10, 13, 17]\n    '''\n    n = len(arr)\n    jump_steps = [0] + [float('inf')]*(n-1)\n    for i in range(1, n):\n        for j in range(i+1, min(n, i+arr[i]+1)):\n            if", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # 动态规划\n    n = len(arr)\n    ans = [0]*n\n    for i in range(n):\n        if ans[i] != 0:\n            continue\n        if i == n-1:\n            ans[i] = 0\n        elif i < n-1:\n            ans[i] = min(ans[j]+1 for j in range(i+1, min(n, i+arr[i]+1)))\n    return ans[-1]\n\n\n\ndef get_min_jump_path(arr):\n    '''\n    获取最短路径\n    >>> get_min_jump_path([1, 3, 6, 13, 17, 18])\n    [0, 3, 6, 10, 13, 17]\n    '''\n    n = len(arr)\n    jump_steps = [0] + [float('inf')]*(n-1)\n    for i in range(1, n):\n        for j in range(i+1, min(n, i+arr[i]+1)):\n            if"}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    # 到达最后一个位置的最小步数是0，只要到达就行，步数不重要\n    if n == 1:\n        return 0\n    # 动态规划数组\n    dp = [0] * n\n    dp[n - 1] = 0\n    step = 1\n    while step < n:\n        # 当前可达到位置\n        idx = n - step\n        # 遍历当前位置可经过的每一种跳数\n        for i in range(n - 1, idx - 1, -1):\n            # 当前位置的跳数大于等于当前位置-dp[idx-1]，因为是从idx-1跳跃过来，所以每次跳跃可跳跃的最大步数是之前跳跃过来的值 + 当前位置的跳数\n            if arr[i] >= step:\n                dp[i] = min(dp[i], dp[idx - 1] + 1)\n        # 更新步数\n        step += 1\n    return dp[n - 1]\n\ndef min_jumps_v2(arr):\n    '''\n    编写一个函数，找出从数组第 ", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    # 到达最后一个位置的最小步数是0，只要到达就行，步数不重要\n    if n == 1:\n        return 0\n    # 动态规划数组\n    dp = [0] * n\n    dp[n - 1] = 0\n    step = 1\n    while step < n:\n        # 当前可达到位置\n        idx = n - step\n        # 遍历当前位置可经过的每一种跳数\n        for i in range(n - 1, idx - 1, -1):\n            # 当前位置的跳数大于等于当前位置-dp[idx-1]，因为是从idx-1跳跃过来，所以每次跳跃可跳跃的最大步数是之前跳跃过来的值 + 当前位置的跳数\n            if arr[i] >= step:\n                dp[i] = min(dp[i], dp[idx - 1] + 1)\n        # 更新步数\n        step += 1\n    return dp[n - 1]\n\ndef min_jumps_v2(arr):\n    '''\n    编写一个函数，找出从数组第 "}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    # 创建一个全为0的数组\n    dp = [0] * n\n    # 设置起点位置的值\n    dp[0] = 0\n    # 设置终点位置的值\n    dp[n - 1] = -1\n    # 从起点开始遍历\n    for i in range(n):\n        # 判断当前数字是否到达终点\n        if i == n - 1: \n            break\n        # 正向遍历\n        for j in range(i + 1, min(i + 1 + arr[i], n)):\n            # 判断是否已经遍历过\n            if dp[j] != -1:\n                # 更新最短距离\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return dp[n - 1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    # 创建一个全为0的数组\n    dp = [0] * n\n    # 设置起点位置的值\n    dp[0] = 0\n    # 设置终点位置的值\n    dp[n - 1] = -1\n    # 从起点开始遍历\n    for i in range(n):\n        # 判断当前数字是否到达终点\n        if i == n - 1: \n            break\n        # 正向遍历\n        for j in range(i + 1, min(i + 1 + arr[i], n)):\n            # 判断是否已经遍历过\n            if dp[j] != -1:\n                # 更新最短距离\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return dp[n - 1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "MBPP/train689", "completion": "\n\n    # 动态规划\n    # 状态转移方程 dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3]) + 1\n\n    ## 递归（超时）\n    if len(arr) == 1:\n        return 0\n\n    min_jumps = float('inf')\n    for i in range(1, len(arr)):\n        min_jumps = min(arr[i] + min_jumps, min_jumps)\n\n    for i in range(1, len(arr) - 1):\n        if arr[i] >= len(arr) - 1 - i:\n            return i\n\n    return len(arr) - 1\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n\n    # 动态规划\n    # 状态转移方程 dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3]) + 1\n\n    ## 递归（超时）\n    if len(arr) == 1:\n        return 0\n\n    min_jumps = float('inf')\n    for i in range(1, len(arr)):\n        min_jumps = min(arr[i] + min_jumps, min_jumps)\n\n    for i in range(1, len(arr) - 1):\n        if arr[i] >= len(arr) - 1 - i:\n            return i\n\n    return len(arr) - 1\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "MBPP/train689", "completion": "\n    length = len(arr)\n    if length == 0:\n        return 0\n    jump = [i for i in range(length)]\n    def jump_count(index_num):\n        '''\n        返回index_num位置开始跳到结尾最少步数\n        '''\n        if index_num == length - 1:\n            return 0\n        if jump[index_num] != -1:\n            return jump[index_num]\n        res = float('inf')\n        for index in range(1, arr[index_num] + 1):\n            # 下一个位置\n            next_num = index_num + index\n            # 下一个位置不能越界\n            if next_num >= length:\n                break\n            res = min(res, jump_count(next_num) + 1)\n        jump[index_num] = res\n        return res\n    jump[length - 1] = -1\n    return jump_count(0)\n\ndef min_jumps2(arr):\n    '''\n    >>> min_jumps2([1, 3, 6, 13, 17,", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    length = len(arr)\n    if length == 0:\n        return 0\n    jump = [i for i in range(length)]\n    def jump_count(index_num):\n        '''\n        返回index_num位置开始跳到结尾最少步数\n        '''\n        if index_num == length - 1:\n            return 0\n        if jump[index_num] != -1:\n            return jump[index_num]\n        res = float('inf')\n        for index in range(1, arr[index_num] + 1):\n            # 下一个位置\n            next_num = index_num + index\n            # 下一个位置不能越界\n            if next_num >= length:\n                break\n            res = min(res, jump_count(next_num) + 1)\n        jump[index_num] = res\n        return res\n    jump[length - 1] = -1\n    return jump_count(0)\n\ndef min_jumps2(arr):\n    '''\n    >>> min_jumps2([1, 3, 6, 13, 17,"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeKLists(lists: List[Optional[ListNode]]):\n    '''\n    给你链表数组 lists ，每个链表都已经按升序排列。\n    请你将所有链表合并到一个升序链表中，返回合并后的链表。\n    >>> lists = [[1,4,5],[1,3,4],[2,6]]\n    >>> mergeKLists(lists)\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> lists = []\n    >>> mergeKLists(lists)\n    []\n    '''\n    if not lists:\n        return []\n    if len(lists) == 1:\n        return lists[0]\n\n    n = len(lists)\n    mid = n // 2\n    list_left = mergeKLists(lists[:mid])\n    list_right = mergeKLists(lists[mid:])\n\n    return mergeTwoLists(list_left, list_right)\n\nif __name__ == \"__main__\":\n    import doctest\n    do", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeKLists(lists: List[Optional[ListNode]]):\n    '''\n    给你链表数组 lists ，每个链表都已经按升序排列。\n    请你将所有链表合并到一个升序链表中，返回合并后的链表。\n    >>> lists = [[1,4,5],[1,3,4],[2,6]]\n    >>> mergeKLists(lists)\n    [1, 1, 2, 3, 4, 4, 5, 6]\n    >>> lists = []\n    >>> mergeKLists(lists)\n    []\n    '''\n    if not lists:\n        return []\n    if len(lists) == 1:\n        return lists[0]\n\n    n = len(lists)\n    mid = n // 2\n    list_left = mergeKLists(lists[:mid])\n    list_right = mergeKLists(lists[mid:])\n\n    return mergeTwoLists(list_left, list_right)\n\nif __name__ == \"__main__\":\n    import doctest\n    do"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            list_res.append(list1[i])\n            i += 1\n        else:\n            list_res.append(list2[j])\n            j += 1\n\n    if i < len(list1):\n        list_res.extend(list1[i:])\n    if j < len(list2):\n        list_res.extend(list2[j:])\n    return list_res\n\n\ndef mergeTwoL", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            list_res.append(list1[i])\n            i += 1\n        else:\n            list_res.append(list2[j])\n            j += 1\n\n    if i < len(list1):\n        list_res.extend(list1[i:])\n    if j < len(list2):\n        list_res.extend(list2[j:])\n    return list_res\n\n\ndef mergeTwoL"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef isValidSerialization(preorder):\n    \"\"\"\n    给你一棵树，输出是否是合法的序列化\n    :param preorder:\n    :return:\n    \"\"\"\n    stack = list()\n    nodes = preorder.split(',')\n    for node in nodes:\n        stack.append(node)\n        if len(stack) > 2 and stack[-2] == '#' and stack[-1] == '#' and stack[-3] != '#':\n            stack.pop()\n            stack.pop()\n            stack.pop()\n\n    return len(stack) == 1 and stack[0] == '#'\n\n\ndef isValidSerialization(preorder):\n    preorder, count = str(preorder).split(','), 1\n    for node in preorder:\n        if not count: return False\n        count -= 1\n        if node != '#': count += 1\n    return count == 0\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef isValidSerialization(preorder):\n    \"\"\"\n    给你一棵树，输出是否是合法的序列化\n    :param preorder:\n    :return:\n    \"\"\"\n    stack = list()\n    nodes = preorder.split(',')\n    for node in nodes:\n        stack.append(node)\n        if len(stack) > 2 and stack[-2] == '#' and stack[-1] == '#' and stack[-3] != '#':\n            stack.pop()\n            stack.pop()\n            stack.pop()\n\n    return len(stack) == 1 and stack[0] == '#'\n\n\ndef isValidSerialization(preorder):\n    preorder, count = str(preorder).split(','), 1\n    for node in preorder:\n        if not count: return False\n        count -= 1\n        if node != '#': count += 1\n    return count == 0\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef merge_sort(list1):\n    '''\n    归并排序，递归解决\n    >>> merge_sort([1, 3, 5])\n    [1, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([1])\n    [1]\n    '''\n    if len(list1) <= 1:\n        return list1\n\n    mid = len(list1) // 2\n\n    return merge(merge_sort(list1[:mid]), merge_sort(list1[mid:]))\n\n\ndef merge(list1, list2):\n    return [x for x in mergeTwoLists(list1, list2)]\n\n\nimport random\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef merge_sort(list1):\n    '''\n    归并排序，递归解决\n    >>> merge_sort([1, 3, 5])\n    [1, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([1])\n    [1]\n    '''\n    if len(list1) <= 1:\n        return list1\n\n    mid = len(list1) // 2\n\n    return merge(merge_sort(list1[:mid]), merge_sort(list1[mid:]))\n\n\ndef merge(list1, list2):\n    return [x for x in mergeTwoLists(list1, list2)]\n\n\nimport random\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/21", "completion": "", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True, optionflags=doctest.NORMALIZE_WHITESPACE)", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True, optionflags=doctest.NORMALIZE_WHITESPACE)"}
{"task_id": "leetcode/21", "completion": "\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/21", "completion": "", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res"}
{"task_id": "leetcode/35", "completion": "\n    n = len(nums)\n    l, r = 0, n - 1\n    while l <= r:\n        m = (l + r) // 2\n        if target == nums[m]:\n            return m\n        # target < nums[m]:\n        elif target < nums[m]:\n            r = m - 1\n        else:\n            l = m + 1\n    return l\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    l, r = 0, n - 1\n    while l <= r:\n        m = (l + r) // 2\n        if target == nums[m]:\n            return m\n        # target < nums[m]:\n        elif target < nums[m]:\n            r = m - 1\n        else:\n            l = m + 1\n    return l\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/35", "completion": "\n    if not nums: return 0\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        m = l + (r - l) // 2\n        if nums[m] == target: return m\n        if nums[m] < target: l = m + 1\n        if nums[m] > target: r = m - 1\n    return l", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums: return 0\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        m = l + (r - l) // 2\n        if nums[m] == target: return m\n        if nums[m] < target: l = m + 1\n        if nums[m] > target: r = m - 1\n    return l"}
{"task_id": "leetcode/35", "completion": "\n    if not nums:\n        return 0\n    if target < nums[0]:\n        return 0\n    if target > nums[-1]:\n        return len(nums)\n    # 二分查找法, 返回目标值所在的索引\n    # 第一个索引的位置\n    i = 0\n    j = len(nums)\n    while i < j:\n        # 防止整形溢出, 除以2来代替>>1运算\n        half = (i+j)//2\n        # 判断结果并移动指针\n        if target == nums[half]:\n            return half\n        elif target < nums[half]:\n            j = half\n        else:\n            i = half + 1\n    return i\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums:\n        return 0\n    if target < nums[0]:\n        return 0\n    if target > nums[-1]:\n        return len(nums)\n    # 二分查找法, 返回目标值所在的索引\n    # 第一个索引的位置\n    i = 0\n    j = len(nums)\n    while i < j:\n        # 防止整形溢出, 除以2来代替>>1运算\n        half = (i+j)//2\n        # 判断结果并移动指针\n        if target == nums[half]:\n            return half\n        elif target < nums[half]:\n            j = half\n        else:\n            i = half + 1\n    return i\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/35", "completion": "\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        index = int((left + right) / 2)\n        if target == nums[index]:\n            return index\n        if target > nums[index]:\n            left = index + 1\n        else:\n            right = index - 1\n    return left\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        index = int((left + right) / 2)\n        if target == nums[index]:\n            return index\n        if target > nums[index]:\n            left = index + 1\n        else:\n            right = index - 1\n    return left\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/35", "completion": "\n    if target in nums:\n        return nums.index(target)\n\n    if target > nums[-1]:\n        return len(nums)\n\n    for i, n in enumerate(nums):\n        # 相等时返回当前索引值\n        if target == n:\n            return i\n        # 在数组中且大于nums[i]\n        if nums[i] < target < nums[i+1]:\n            return i + 1\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthLargest([3,2,1,5,6,4], 2)\n    5\n    >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4)\n    4\n    '''\n    # 堆排序\n    heapq.heapify(nums)\n    ans =", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums:\n        return nums.index(target)\n\n    if target > nums[-1]:\n        return len(nums)\n\n    for i, n in enumerate(nums):\n        # 相等时返回当前索引值\n        if target == n:\n            return i\n        # 在数组中且大于nums[i]\n        if nums[i] < target < nums[i+1]:\n            return i + 1\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthLargest([3,2,1,5,6,4], 2)\n    5\n    >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4)\n    4\n    '''\n    # 堆排序\n    heapq.heapify(nums)\n    ans ="}
{"task_id": "leetcode/35", "completion": "\n    if not nums or not target:\n        return \n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) >> 1\n        if nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n        else:\n            return mid\n    return left", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums or not target:\n        return \n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) >> 1\n        if nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n        else:\n            return mid\n    return left"}
{"task_id": "leetcode/35", "completion": "\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/35", "completion": "\n    if target in nums:\n        return nums.index(target)\n    else:\n        return nums.index(max(nums)) + 1\n    # 思路1：直接返回目标值下标\n\n\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert2([1,3,5,6], 5)\n    2\n    >>> searchInsert2([1,3,5,6], 2)\n    1\n    >>> searchInsert2([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    # 返回插入元素的位置\n    left = 0\n    right = n - 1\n    while left <= right:\n        middle = left + (right - left) // 2\n        if target == nums[", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums:\n        return nums.index(target)\n    else:\n        return nums.index(max(nums)) + 1\n    # 思路1：直接返回目标值下标\n\n\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert2([1,3,5,6], 5)\n    2\n    >>> searchInsert2([1,3,5,6], 2)\n    1\n    >>> searchInsert2([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    # 返回插入元素的位置\n    left = 0\n    right = n - 1\n    while left <= right:\n        middle = left + (right - left) // 2\n        if target == nums["}
{"task_id": "leetcode/35", "completion": "\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + ((right - left) >> 1)\n        if nums[mid] == target:\n            return mid\n        if nums[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef searchInsert(nums, target):\n    '''\n    https://leetcode.com/discuss/9997/3-liner-python-solution\n    '''\n    hi = len(nums)\n    while hi > 0 and nums[hi - 1] > target:\n        hi -= 1\n    return hi\n\n\ndef main():\n    # Example 1: Output: 2\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    # Example 2: Output: 1\n    # nums1 = [1, 3, 5, 6]\n    # target1 = 2\n\n    ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + ((right - left) >> 1)\n        if nums[mid] == target:\n            return mid\n        if nums[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef searchInsert(nums, target):\n    '''\n    https://leetcode.com/discuss/9997/3-liner-python-solution\n    '''\n    hi = len(nums)\n    while hi > 0 and nums[hi - 1] > target:\n        hi -= 1\n    return hi\n\n\ndef main():\n    # Example 1: Output: 2\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    # Example 2: Output: 1\n    # nums1 = [1, 3, 5, 6]\n    # target1 = 2\n\n    "}
{"task_id": "leetcode/35", "completion": "\n    if 0 <= target < nums[len(nums) - 1]:\n        for idx in range(len(nums)):\n            if nums[idx] == target:\n                return idx\n            if nums[idx] < target:\n                return idx + 1\n    else:\n        return len(nums)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if 0 <= target < nums[len(nums) - 1]:\n        for idx in range(len(nums)):\n            if nums[idx] == target:\n                return idx\n            if nums[idx] < target:\n                return idx + 1\n    else:\n        return len(nums)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/217", "completion": "\n    dict_num = {}\n    for i in nums:\n        if i not in dict_num:\n            dict_num[i] = 1\n        else:\n            return True\n    return False\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    dict_num = {}\n    for i in nums:\n        if i not in dict_num:\n            dict_num[i] = 1\n        else:\n            return True\n    return False\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/217", "completion": "\n    # 先排序, 然后用set去重, 然后看长度, 等于长度的话肯定有重复的, 不等的话就没有重复的\n    nums.sort()\n    length = 1\n    for i in range(len(nums)):\n        if i != 0 and nums[i] == nums[i-1]:\n            length += 1\n    print(length)\n    if length == len(nums):\n        return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 先排序, 然后用set去重, 然后看长度, 等于长度的话肯定有重复的, 不等的话就没有重复的\n    nums.sort()\n    length = 1\n    for i in range(len(nums)):\n        if i != 0 and nums[i] == nums[i-1]:\n            length += 1\n    print(length)\n    if length == len(nums):\n        return True\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/217", "completion": "\n    dict = {}\n    for num in nums:\n        if num in dict.keys():\n            return True\n        dict[num] = num\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    dict = {}\n    for num in nums:\n        if num in dict.keys():\n            return True\n        dict[num] = num\n    return False\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/217", "completion": "\n    duplicated = {}\n    for num in nums:\n        if num in duplicated:\n            return True\n        duplicated[num]=num\n    return False\nprint(containsDuplicate([1,2,3,1]))\nprint(containsDuplicate([1,2,3,4]))\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums' 和一个整数 'k', 如果数组中存在两个不同的索引 i 和 j，使得nums[i] == nums[j]，并且 i 和 j的差的绝对值最大为 'k'，则返回 true, 否则返回 false。\n    >>> containsNearbyDuplicate([1,2,3,1],3)\n    True\n    >>> containsNearbyDuplicate([1,2,3,4],2)\n    False\n    '''\n    nums_dict={}\n    for index,num in enumerate(nums):\n        if num in nums_dict and index - nums_dict[num] <=", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    duplicated = {}\n    for num in nums:\n        if num in duplicated:\n            return True\n        duplicated[num]=num\n    return False\nprint(containsDuplicate([1,2,3,1]))\nprint(containsDuplicate([1,2,3,4]))\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums' 和一个整数 'k', 如果数组中存在两个不同的索引 i 和 j，使得nums[i] == nums[j]，并且 i 和 j的差的绝对值最大为 'k'，则返回 true, 否则返回 false。\n    >>> containsNearbyDuplicate([1,2,3,1],3)\n    True\n    >>> containsNearbyDuplicate([1,2,3,4],2)\n    False\n    '''\n    nums_dict={}\n    for index,num in enumerate(nums):\n        if num in nums_dict and index - nums_dict[num] <="}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for index in range(1, len(nums)):\n        if nums[index] == nums[index - 1]:\n            return True\n    return False", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for index in range(1, len(nums)):\n        if nums[index] == nums[index - 1]:\n            return True\n    return False"}
{"task_id": "leetcode/217", "completion": "\n    if not nums:\n        return False\n    n = len(nums)\n    d = dict()\n    for i in range(n):\n        if nums[i] in d:\n            return True\n        else:\n            d[nums[i]] = 1\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums', 其中N表示数组的长度。\n    如果一组整数 nums[i], nums[j] 满足 nums[i] == nums[j], i != j 并且 i < j, 则称这一组整数是一个「重复的数组」.\n    找到给定数组中任意一个重复的数组.\n    >>> containsNearbyDuplicate([1, 2, 3, 1], 2)\n    True\n    >>> containsNearbyDuplicate([1, 2, 3, 4], 2)\n    False\n    '''\n    if not nums:\n        return False\n    n", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    if not nums:\n        return False\n    n = len(nums)\n    d = dict()\n    for i in range(n):\n        if nums[i] in d:\n            return True\n        else:\n            d[nums[i]] = 1\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums', 其中N表示数组的长度。\n    如果一组整数 nums[i], nums[j] 满足 nums[i] == nums[j], i != j 并且 i < j, 则称这一组整数是一个「重复的数组」.\n    找到给定数组中任意一个重复的数组.\n    >>> containsNearbyDuplicate([1, 2, 3, 1], 2)\n    True\n    >>> containsNearbyDuplicate([1, 2, 3, 4], 2)\n    False\n    '''\n    if not nums:\n        return False\n    n"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums', 给定一个整数k, 找到 'nums' 中连续子数组, 且该子数组含有至少2个重复的元素\n    >>> containsNearbyDuplicate([1, 2, 3, 1], 3)\n    True\n    >>> containsNearbyDuplicate([2, 4, 5, 6, 1, 2, 3], 4)\n    True\n    >>> containsNearbyDuplicate([0, 1, 2, 1], 2)\n    True\n    >>> containsNearbyDuplicate([0, 1, 2, 1], 1)\n    False\n    '''\n    for i in range(len(nums)):\n        for j", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums', 给定一个整数k, 找到 'nums' 中连续子数组, 且该子数组含有至少2个重复的元素\n    >>> containsNearbyDuplicate([1, 2, 3, 1], 3)\n    True\n    >>> containsNearbyDuplicate([2, 4, 5, 6, 1, 2, 3], 4)\n    True\n    >>> containsNearbyDuplicate([0, 1, 2, 1], 2)\n    True\n    >>> containsNearbyDuplicate([0, 1, 2, 1], 1)\n    False\n    '''\n    for i in range(len(nums)):\n        for j"}
{"task_id": "leetcode/217", "completion": "\n    return len(set(nums)) != len(nums)\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n     给定一个整数数组和一个整数 'k'，你需要找到给定数组中任意两个数之间的最大差值。\n     返回这个最大差值。如果连相邻的两个数都有距离，则返回 0。\n    >>> containsNearbyAlmostDuplicate([1,5,9,1,5,9],1,3)\n    4\n    '''\n    n = len(nums)\n    if n <= 1:\n        return 0\n    if k < 1 or t < 0:\n        return False\n    if t == 0:\n        return not containsDuplicate(nums)\n\n    dic = {}\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n + 1)):\n            if j == n:\n                break\n            if abs(nums[i] - nums[j", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(set(nums)) != len(nums)\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n     给定一个整数数组和一个整数 'k'，你需要找到给定数组中任意两个数之间的最大差值。\n     返回这个最大差值。如果连相邻的两个数都有距离，则返回 0。\n    >>> containsNearbyAlmostDuplicate([1,5,9,1,5,9],1,3)\n    4\n    '''\n    n = len(nums)\n    if n <= 1:\n        return 0\n    if k < 1 or t < 0:\n        return False\n    if t == 0:\n        return not containsDuplicate(nums)\n\n    dic = {}\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n + 1)):\n            if j == n:\n                break\n            if abs(nums[i] - nums[j"}
{"task_id": "leetcode/217", "completion": "\n    return len(nums) != len(set(nums))\n    # return len(nums) != len(set(nums))\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums' 和一个整数 'k', 如果数组中存在两个元素的 绝对差值  小于等于 'k', 则返回 true, 否则返回 false。\n    >>> containsNearbyDuplicate([1,0,1,1], 1)\n    True\n    >>> containsNearbyDuplicate([1,5,9,1,5,9], 2)\n    False\n    '''\n    # 两层循环\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= k:\n                return True\n\n    return False\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n    给定一个整数", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums) != len(set(nums))\n    # return len(nums) != len(set(nums))\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 'nums' 和一个整数 'k', 如果数组中存在两个元素的 绝对差值  小于等于 'k', 则返回 true, 否则返回 false。\n    >>> containsNearbyDuplicate([1,0,1,1], 1)\n    True\n    >>> containsNearbyDuplicate([1,5,9,1,5,9], 2)\n    False\n    '''\n    # 两层循环\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= k:\n                return True\n\n    return False\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n    给定一个整数"}
{"task_id": "leetcode/217", "completion": "\n    # 1.使用集合\n    if not nums:\n        return False\n    return len(nums) != len(set(nums))\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n    给定一个整数数组 'nums', 一个整数 'k' 和一个整数 't'.\n    找到该数组中满足下述条件的的子数组：\n    * 子数组大小不小于 k,\n    * 子数组中的最大元素与最小元素之差小于等于 t.\n    如果这样的子数组不存在, 返回 -1.\n    >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0)\n    True\n    >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2)\n    True\n    >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2, 3)\n    False\n", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 1.使用集合\n    if not nums:\n        return False\n    return len(nums) != len(set(nums))\n\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    '''\n    给定一个整数数组 'nums', 一个整数 'k' 和一个整数 't'.\n    找到该数组中满足下述条件的的子数组：\n    * 子数组大小不小于 k,\n    * 子数组中的最大元素与最小元素之差小于等于 t.\n    如果这样的子数组不存在, 返回 -1.\n    >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0)\n    True\n    >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2)\n    True\n    >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2, 3)\n    False\n"}
{"task_id": "leetcode/697", "completion": "\n    dic = collections.Counter(nums)\n    d = dic.values()\n    degree = max(d)\n    start = -1\n    end = -1\n    minLen = len(nums)\n    for i in nums:\n        if degree == d[nums.index(i)]:\n            if start == -1:\n                start = nums.index(i)\n            else:\n                end = nums.index(i)\n        else:\n            if end != -1:\n                minLen = min(minLen, end - start)\n                start = end = -1\n            else:\n                pass\n            degree = d[nums.index(i)]\n    if end != -1:\n        minLen = min(minLen, end - start)\n    return minLen + 1\n\n\n\n    \n\nif __name__ == '__main__':\n    import doctest\n    \n    doctest.testmod()", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    dic = collections.Counter(nums)\n    d = dic.values()\n    degree = max(d)\n    start = -1\n    end = -1\n    minLen = len(nums)\n    for i in nums:\n        if degree == d[nums.index(i)]:\n            if start == -1:\n                start = nums.index(i)\n            else:\n                end = nums.index(i)\n        else:\n            if end != -1:\n                minLen = min(minLen, end - start)\n                start = end = -1\n            else:\n                pass\n            degree = d[nums.index(i)]\n    if end != -1:\n        minLen = min(minLen, end - start)\n    return minLen + 1\n\n\n\n    \n\nif __name__ == '__main__':\n    import doctest\n    \n    doctest.testmod()"}
{"task_id": "leetcode/697", "completion": "\n    d = {}\n    m = 0\n    for n in range(len(nums)):\n        d.setdefault(nums[n], []).append(n)\n    for key in d.keys():\n        d[key] = [d[key][0], d[key][-1], len(d[key])]\n        if d[key][2] > m:\n            m = d[key][2]\n    min_res = len(nums)\n    for n in range(len(nums)):\n        if d[nums[n]][2] == m:\n            if min_res > (d[nums[n]][1] - d[nums[n]][0] + 1):\n                min_res = d[nums[n]][1] - d[nums[n]][0] + 1\n    return min_res", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    d = {}\n    m = 0\n    for n in range(len(nums)):\n        d.setdefault(nums[n], []).append(n)\n    for key in d.keys():\n        d[key] = [d[key][0], d[key][-1], len(d[key])]\n        if d[key][2] > m:\n            m = d[key][2]\n    min_res = len(nums)\n    for n in range(len(nums)):\n        if d[nums[n]][2] == m:\n            if min_res > (d[nums[n]][1] - d[nums[n]][0] + 1):\n                min_res = d[nums[n]][1] - d[nums[n]][0] + 1\n    return min_res"}
{"task_id": "leetcode/697", "completion": "\n\n    if len(nums) == 1:\n        return 1\n    # 使用字典记录nums的每个元素出现的次数\n    dic = {}\n    for num in nums:\n        if num in dic:\n            dic[num] += 1\n        else:\n            dic[num] = 1\n    # 遍历字典，找到出现次数最多的数字及对应的次数\n    nums_sum = 0\n    degree = 0\n    for key in dic:\n        value = dic[key]        \n        if value > degree:\n            degree = value\n            nums_sum = key\n    # 遍历nums，找到第一个与nums_sum相同的数，计算距离\n    arr = [i for i, num in enumerate(nums) if num == nums_sum]\n    arr.append(len(nums))\n    shortest = arr[1] - arr[0]\n    for i in range(1, len(arr) - 1):\n        shortest = min(shortest, arr[i + 1] - arr[i - 1])\n    return shortest + 1\n\nif __name__ == '__main__':\n    import doctest\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n\n    if len(nums) == 1:\n        return 1\n    # 使用字典记录nums的每个元素出现的次数\n    dic = {}\n    for num in nums:\n        if num in dic:\n            dic[num] += 1\n        else:\n            dic[num] = 1\n    # 遍历字典，找到出现次数最多的数字及对应的次数\n    nums_sum = 0\n    degree = 0\n    for key in dic:\n        value = dic[key]        \n        if value > degree:\n            degree = value\n            nums_sum = key\n    # 遍历nums，找到第一个与nums_sum相同的数，计算距离\n    arr = [i for i, num in enumerate(nums) if num == nums_sum]\n    arr.append(len(nums))\n    shortest = arr[1] - arr[0]\n    for i in range(1, len(arr) - 1):\n        shortest = min(shortest, arr[i + 1] - arr[i - 1])\n    return shortest + 1\n\nif __name__ == '__main__':\n    import doctest\n"}
{"task_id": "leetcode/697", "completion": "\n    degree = 0\n    left = 0\n    result = len(nums)\n    dict = collections.defaultdict(list)\n    for index, num in enumerate(nums):\n        dict[num].append(index)\n    for _, v in dict.items():\n        if len(v) > degree:\n            degree = len(v)\n            left = v[0]\n            result = v[-1] - v[0] + 1\n        elif len(v) == degree:\n            if v[-1] - v[0] + 1 < result:\n                result = v[-1] - v[0] + 1\n                left = v[0]\n\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    degree = 0\n    left = 0\n    result = len(nums)\n    dict = collections.defaultdict(list)\n    for index, num in enumerate(nums):\n        dict[num].append(index)\n    for _, v in dict.items():\n        if len(v) > degree:\n            degree = len(v)\n            left = v[0]\n            result = v[-1] - v[0] + 1\n        elif len(v) == degree:\n            if v[-1] - v[0] + 1 < result:\n                result = v[-1] - v[0] + 1\n                left = v[0]\n\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/697", "completion": "\n    d = {}\n    s = collections.Counter(nums)\n    for i , item in enumerate(nums):\n        d[item] = d.get(item, []) + [i]\n    result = float('inf')\n    for k, v in s.items():\n        if v == len(d[k]):\n            result = min(result,d[k][-1] - d[k][0] + 1)\n    return result\n# if __name__ == '__main__':\n#     print(findShortestSubArray([1,2,2,3,1]))\n#     print(findShortestSubArray([1,2,2,3,1,4,2]))\n\n# nums = [1,2,2,3,1,4,2]\n# d = {}\n# for i , item in enumerate(nums):\n#     d[item] = d.get(item, []) + [i]\n# print(d)\n# for k,v in d.items():\n#     if len(d[k]) == 3:\n#         print(k)\n#         print(d[k])\n\ns = [1,2,3]\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    d = {}\n    s = collections.Counter(nums)\n    for i , item in enumerate(nums):\n        d[item] = d.get(item, []) + [i]\n    result = float('inf')\n    for k, v in s.items():\n        if v == len(d[k]):\n            result = min(result,d[k][-1] - d[k][0] + 1)\n    return result\n# if __name__ == '__main__':\n#     print(findShortestSubArray([1,2,2,3,1]))\n#     print(findShortestSubArray([1,2,2,3,1,4,2]))\n\n# nums = [1,2,2,3,1,4,2]\n# d = {}\n# for i , item in enumerate(nums):\n#     d[item] = d.get(item, []) + [i]\n# print(d)\n# for k,v in d.items():\n#     if len(d[k]) == 3:\n#         print(k)\n#         print(d[k])\n\ns = [1,2,3]\n"}
{"task_id": "leetcode/697", "completion": "\n    # 首先用一个字典保存每个数字出现的次数,和其第一次出现的位置\n    d = collections.defaultdict(list)\n    for i, x in enumerate(nums):\n        d[x].append(i)\n    # 找到出现最多的那个数字,并排序\n    maxv = max(d.values())\n    ans = len(nums)\n    for x in d:\n        if len(d[x]) == maxv:\n            # 找到出现最多的数字,并排序\n            l = sorted(d[x])\n            ans = min(ans, l[-1] - l[0] + 1)\n    return ans\nnums = [1,2,2,3,1,4,2]\nfindShortestSubArray(nums)\nprint(nums)\n\n\n\n\n# 25. Reverse Nodes in k-Group\n# 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n# k 是一个正整数，它的值小于或等于链表的长度。\n# 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n# \n# 示例 :\n# 给定", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 首先用一个字典保存每个数字出现的次数,和其第一次出现的位置\n    d = collections.defaultdict(list)\n    for i, x in enumerate(nums):\n        d[x].append(i)\n    # 找到出现最多的那个数字,并排序\n    maxv = max(d.values())\n    ans = len(nums)\n    for x in d:\n        if len(d[x]) == maxv:\n            # 找到出现最多的数字,并排序\n            l = sorted(d[x])\n            ans = min(ans, l[-1] - l[0] + 1)\n    return ans\nnums = [1,2,2,3,1,4,2]\nfindShortestSubArray(nums)\nprint(nums)\n\n\n\n\n# 25. Reverse Nodes in k-Group\n# 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n# k 是一个正整数，它的值小于或等于链表的长度。\n# 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n# \n# 示例 :\n# 给定"}
{"task_id": "leetcode/697", "completion": "\n    if not nums: return 0\n    record = collections.defaultdict(list)\n    for i, n in enumerate(nums):\n        if n in record:\n            record[n][0].append(i)\n            record[n][1] = max(record[n][1], i)\n        else:\n            record[n] = [\n                [i],\n                i\n            ]\n    lmin = len(nums)\n    for v in record.values():\n        lmin = min(lmin, v[1] - v[0][0] + 1)\n    return lmin\n\nprint(findShortestSubArray([1,2,2,3,1,4,2]))", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    if not nums: return 0\n    record = collections.defaultdict(list)\n    for i, n in enumerate(nums):\n        if n in record:\n            record[n][0].append(i)\n            record[n][1] = max(record[n][1], i)\n        else:\n            record[n] = [\n                [i],\n                i\n            ]\n    lmin = len(nums)\n    for v in record.values():\n        lmin = min(lmin, v[1] - v[0][0] + 1)\n    return lmin\n\nprint(findShortestSubArray([1,2,2,3,1,4,2]))"}
{"task_id": "leetcode/697", "completion": "\n    left, right, count, ans = {}, {}, {}, len(nums)\n    for i, num in enumerate(nums):\n        if num not in left:\n            left[num] = i\n        right[num] = i\n        count[num] = count.get(num, 0) + 1\n    degree = max(count.values())\n    for k, v in count.items():\n        if v == degree:\n            ans = min(ans, right[k] - left[k] + 1)\n    return ans\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含n 个整数的数组nums和 一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n    >>> threeSum([-1, 2, 1, -4])\n    2\n    >>> threeSum([0, 0, 0, 0])\n    0\n    >>> threeSum([0,0,0,1,-1,-4])\n    0\n    '''\n    nums.sort()\n    res = sum(nums[:3])\n    ans = abs(res -", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    left, right, count, ans = {}, {}, {}, len(nums)\n    for i, num in enumerate(nums):\n        if num not in left:\n            left[num] = i\n        right[num] = i\n        count[num] = count.get(num, 0) + 1\n    degree = max(count.values())\n    for k, v in count.items():\n        if v == degree:\n            ans = min(ans, right[k] - left[k] + 1)\n    return ans\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含n 个整数的数组nums和 一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n    >>> threeSum([-1, 2, 1, -4])\n    2\n    >>> threeSum([0, 0, 0, 0])\n    0\n    >>> threeSum([0,0,0,1,-1,-4])\n    0\n    '''\n    nums.sort()\n    res = sum(nums[:3])\n    ans = abs(res -"}
{"task_id": "leetcode/697", "completion": "\n    # 第一步, 统计nums中每个元素出现的次数\n    count = collections.Counter(nums)\n    # 第二步, 找出nums中出现频数最大的元素\n    max_count = max(count.values())\n    candidates = []\n    for k, v in count.items():\n        if v == max_count:\n            candidates.append(k)\n    # 第三步, 遍历数组中出现的每一个元素, 找到它出现的第一次和最后一次\n    ans = len(nums)\n    for candidate in candidates:\n        first, last = -1, -1\n        for i, num in enumerate(nums):\n            if num == candidate:\n                if first == -1:\n                    first = i\n                last = i\n        # 第四步, 计算子数组的长度, 并比较出最小的那个长度\n        ans = min(ans, last-first+1)\n    return ans\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 第一步, 统计nums中每个元素出现的次数\n    count = collections.Counter(nums)\n    # 第二步, 找出nums中出现频数最大的元素\n    max_count = max(count.values())\n    candidates = []\n    for k, v in count.items():\n        if v == max_count:\n            candidates.append(k)\n    # 第三步, 遍历数组中出现的每一个元素, 找到它出现的第一次和最后一次\n    ans = len(nums)\n    for candidate in candidates:\n        first, last = -1, -1\n        for i, num in enumerate(nums):\n            if num == candidate:\n                if first == -1:\n                    first = i\n                last = i\n        # 第四步, 计算子数组的长度, 并比较出最小的那个长度\n        ans = min(ans, last-first+1)\n    return ans\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/697", "completion": "\n    # 统计每个元素出现的频率和它第一次出现的索引\n    count1 = collections.Counter(nums)\n    max_freq1 = count1.most_common(1)[0][1]\n    # 记录所有出现频率等于max_freq1的元素和其索引\n    set1 = [k for k, v in count1.items() if v == max_freq1]\n    # 统计频率等于max_freq1的数的左边界和右边界\n    left, right = 0, len(nums) - 1\n    while nums[left] not in set1:\n        left += 1\n    while nums[right] not in set1:\n        right -= 1\n    # 返回左右边界差+1\n    return right - left + 1", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 统计每个元素出现的频率和它第一次出现的索引\n    count1 = collections.Counter(nums)\n    max_freq1 = count1.most_common(1)[0][1]\n    # 记录所有出现频率等于max_freq1的元素和其索引\n    set1 = [k for k, v in count1.items() if v == max_freq1]\n    # 统计频率等于max_freq1的数的左边界和右边界\n    left, right = 0, len(nums) - 1\n    while nums[left] not in set1:\n        left += 1\n    while nums[right] not in set1:\n        right -= 1\n    # 返回左右边界差+1\n    return right - left + 1"}
{"task_id": "leetcode/832", "completion": "\n    temp = []\n    for row in image:\n        temp.append(row[::-1])\n\n    for i in range(len(temp)):\n        for j in range(len(temp[0])):\n            temp[i][j] = 1 - temp[i][j]\n\n    return temp\n\n# 8.2\ndef permute(nums):\n    '''\n    Given a collection of distinct numbers, return all possible permutations.\n    >>> permute([1,2,3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    '''\n    results = []\n    def helper(results,nums,temp):\n        if len(temp) == len(nums):\n            results.append(temp[:])\n        else:\n            for i in range(len(nums)):\n                if nums[i] in temp:\n                    continue\n                temp.append(", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    temp = []\n    for row in image:\n        temp.append(row[::-1])\n\n    for i in range(len(temp)):\n        for j in range(len(temp[0])):\n            temp[i][j] = 1 - temp[i][j]\n\n    return temp\n\n# 8.2\ndef permute(nums):\n    '''\n    Given a collection of distinct numbers, return all possible permutations.\n    >>> permute([1,2,3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    '''\n    results = []\n    def helper(results,nums,temp):\n        if len(temp) == len(nums):\n            results.append(temp[:])\n        else:\n            for i in range(len(nums)):\n                if nums[i] in temp:\n                    continue\n                temp.append("}
{"task_id": "leetcode/832", "completion": "\n    # solution 1\n    # res = [[image[row][col]^1 for col in range(n-1,-1,-1)] for row in range(n)]\n    # solution 2\n    return [[1 if image[row][col]==0 else 0 for col in range(n)] for row in range(n)]\n\n    \nif __name__ == \"__main__\":\n    assert flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])==[[1, 0, 0], [0, 1, 0], [1, 1, 1]], \"test case 1\"\n    assert flipAndInvertImage([[1,0,0],[0,1,0],[0,0,1]])==[[1, 0, 0],[0, 0, 0],[0, 1, 0]], \"test case 2\"\n    assert flipAndInvertImage([[1,1,1,0],[1,0,0,1],[0,1,1,", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # solution 1\n    # res = [[image[row][col]^1 for col in range(n-1,-1,-1)] for row in range(n)]\n    # solution 2\n    return [[1 if image[row][col]==0 else 0 for col in range(n)] for row in range(n)]\n\n    \nif __name__ == \"__main__\":\n    assert flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])==[[1, 0, 0], [0, 1, 0], [1, 1, 1]], \"test case 1\"\n    assert flipAndInvertImage([[1,0,0],[0,1,0],[0,0,1]])==[[1, 0, 0],[0, 0, 0],[0, 1, 0]], \"test case 2\"\n    assert flipAndInvertImage([[1,1,1,0],[1,0,0,1],[0,1,1,"}
{"task_id": "leetcode/832", "completion": "\n    return [[image[i][-j-1] if i%2==1 else image[i][j] for j in range(len(image[i]))] for i in range(len(image))]\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [[image[i][-j-1] if i%2==1 else image[i][j] for j in range(len(image[i]))] for i in range(len(image))]\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))"}
{"task_id": "leetcode/832", "completion": "\n    rows = len(image)\n    cols = len(image[0])\n    flipped_image = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        flipped_image[i] = image[i][::-1]\n    inverted_image = []\n    for row in flipped_image:\n        inverted_image.append([1 if cell == 0 else 0 for cell in row])\n    return inverted_image\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    rows = len(image)\n    cols = len(image[0])\n    flipped_image = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        flipped_image[i] = image[i][::-1]\n    inverted_image = []\n    for row in flipped_image:\n        inverted_image.append([1 if cell == 0 else 0 for cell in row])\n    return inverted_image\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/832", "completion": "\n    return [list(reversed(x)) for x in image]\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        r = s[::-1]\n        table = [[0] * (len(s) + 1) for _ in range(len(r) + 1)]\n        res = 0\n        for i in range(len(s) + 1):\n            for j in range(len(r) + 1):\n                if s[i - 1] == r[j - 1]:\n                    table[i][j] = table[i - 1][j - 1] + 1\n                    res = max(res, table[i][j])\n        return 2 * res - 1", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [list(reversed(x)) for x in image]\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        r = s[::-1]\n        table = [[0] * (len(s) + 1) for _ in range(len(r) + 1)]\n        res = 0\n        for i in range(len(s) + 1):\n            for j in range(len(r) + 1):\n                if s[i - 1] == r[j - 1]:\n                    table[i][j] = table[i - 1][j - 1] + 1\n                    res = max(res, table[i][j])\n        return 2 * res - 1"}
{"task_id": "leetcode/832", "completion": "\n    return [[1-num for num in row[::-1]]for row in image]\n\n\n#Tests\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [[1-num for num in row[::-1]]for row in image]\n\n\n#Tests\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/832", "completion": "\n    \n    for row in image:\n        for i in range(len(row)//2):\n            row[i], row[len(row)-i-1] = row[len(row)-i-1], row[i]\n\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            if image[i][j] == 0:\n                image[i][j] = 1\n            else:\n                image[i][j] = 0\n    \n    return image", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    \n    for row in image:\n        for i in range(len(row)//2):\n            row[i], row[len(row)-i-1] = row[len(row)-i-1], row[i]\n\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            if image[i][j] == 0:\n                image[i][j] = 1\n            else:\n                image[i][j] = 0\n    \n    return image"}
{"task_id": "leetcode/832", "completion": "\n    # 1. Reverse the rows of the image\n    image = [row[::-1] for row in image]\n    return [row for row in image]\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n\nimport collections\ndef shiftGrid(grid, k):\n    \"\"\"\n    Given a 2D grid and a value k, shift all of the values in the grid\n    clockwise k times.\n    >>> shiftGrid([[1,2,3],[4,5,6],[7,8,9]],1)\n    [[4,5,6],[1,2,3],[7,8,9]]\n    >>> shiftGrid([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]],1)\n    [[15,", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # 1. Reverse the rows of the image\n    image = [row[::-1] for row in image]\n    return [row for row in image]\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n\nimport collections\ndef shiftGrid(grid, k):\n    \"\"\"\n    Given a 2D grid and a value k, shift all of the values in the grid\n    clockwise k times.\n    >>> shiftGrid([[1,2,3],[4,5,6],[7,8,9]],1)\n    [[4,5,6],[1,2,3],[7,8,9]]\n    >>> shiftGrid([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]],1)\n    [[15,"}
{"task_id": "leetcode/832", "completion": "\n    return [[1 - i for i in row[::-1]] for row in image]", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [[1 - i for i in row[::-1]] for row in image]"}
{"task_id": "leetcode/832", "completion": "\n    return [list(reversed(row)) for row in image][::-1]", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [list(reversed(row)) for row in image][::-1]"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    dp = [\n        1\n        for _ in range(len(nums))\n    ]\n    for idx, val in enumerate(nums):\n        for _idx, _val in enumerate(nums[idx + 1:], idx + 1):\n            if _val > val:\n                dp[_idx] = max(dp[_idx], dp[idx] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    dp = [\n        1\n        for _ in range(len(nums))\n    ]\n    for idx, val in enumerate(nums):\n        for _idx, _val in enumerate(nums[idx + 1:], idx + 1):\n            if _val > val:\n                dp[_idx] = max(dp[_idx], dp[idx] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    # dp[i]表示以nums[i]为结尾的最长子序列的长度\n    dp = [1 for _ in range(len(nums))]\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] <= nums[j]:\n                continue\n            else:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    nums = [7,7,7,7,7,7,7]\n    res = lengthOfLIS(nums)\n    print(res)", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    # dp[i]表示以nums[i]为结尾的最长子序列的长度\n    dp = [1 for _ in range(len(nums))]\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] <= nums[j]:\n                continue\n            else:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == '__main__':\n    nums = [7,7,7,7,7,7,7]\n    res = lengthOfLIS(nums)\n    print(res)"}
{"task_id": "leetcode/300", "completion": "\n    dp = [0 for _ in range(len(nums))]\n    for i in range(len(nums)):\n        dp[i] = 1\n        for j in range(0, i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [0 for _ in range(len(nums))]\n    for i in range(len(nums)):\n        dp[i] = 1\n        for j in range(0, i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/300", "completion": "\n    length = len(nums)\n    if length <= 1:\n        return length\n\n    dp = [0 for _ in range(length)]\n    max_length = 0\n\n    for i in range(length):\n        dp[i] = 1\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[j] + 1, dp[i])\n        max_length = max(dp[i], max_length)\n\n    return max_length", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    length = len(nums)\n    if length <= 1:\n        return length\n\n    dp = [0 for _ in range(length)]\n    max_length = 0\n\n    for i in range(length):\n        dp[i] = 1\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[j] + 1, dp[i])\n        max_length = max(dp[i], max_length)\n\n    return max_length"}
{"task_id": "leetcode/300", "completion": "\n    length = len(nums)\n    if length <= 1:\n        return length\n\n    dp = [1] * length\n    for i in range(1, length):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    length = len(nums)\n    if length <= 1:\n        return length\n\n    dp = [1] * length\n    for i in range(1, length):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/300", "completion": "\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    参考: 算法导论\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    tails = [0] * len(nums)\n    size = 0\n    for num in nums:\n        i, j = 0, size\n        while i < j:\n            m = (i + j) // 2\n            if tails[m] < num:\n                i = m + 1\n            else:\n                ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    参考: 算法导论\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    tails = [0] * len(nums)\n    size = 0\n    for num in nums:\n        i, j = 0, size\n        while i < j:\n            m = (i + j) // 2\n            if tails[m] < num:\n                i = m + 1\n            else:\n                "}
{"task_id": "leetcode/300", "completion": "\n    if not nums: return 0\n\n    # dp[i] 表示 nums[0:i] 中 LIS 的最大长度\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS1([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS2([7,7,", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums: return 0\n\n    # dp[i] 表示 nums[0:i] 中 LIS 的最大长度\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS1([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS2([7,7,"}
{"task_id": "leetcode/300", "completion": "\n    \"\"\"\n    O(N^2)的解法\n    \"\"\"\n    # res = 1\n    # l = len(nums)\n    # if l < 2:\n    #     return l\n    # for i in range(l):\n    #     temp = 1\n    #     for j in range(i):\n    #         if nums[i]>nums[j]:\n    #             temp = max(temp,res+1)\n    #     res = temp\n    # return res\n\n    \"\"\"\n    O(N)的解法\n    1、状态定义：f(i)为以nums[i]结尾的最长递增子序列的长度\n    2、状态转移方程：f(i) = max(f(i),f(j)+1,对于所有小于nums[i]的nums[j]\n    3、状态初始化：f(i)=1\n    4、状态输出：f(i)\n    \"\"\"\n    # res = 1\n    # l = len(nums)\n    # if l < 2:\n    #    ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    \"\"\"\n    O(N^2)的解法\n    \"\"\"\n    # res = 1\n    # l = len(nums)\n    # if l < 2:\n    #     return l\n    # for i in range(l):\n    #     temp = 1\n    #     for j in range(i):\n    #         if nums[i]>nums[j]:\n    #             temp = max(temp,res+1)\n    #     res = temp\n    # return res\n\n    \"\"\"\n    O(N)的解法\n    1、状态定义：f(i)为以nums[i]结尾的最长递增子序列的长度\n    2、状态转移方程：f(i) = max(f(i),f(j)+1,对于所有小于nums[i]的nums[j]\n    3、状态初始化：f(i)=1\n    4、状态输出：f(i)\n    \"\"\"\n    # res = 1\n    # l = len(nums)\n    # if l < 2:\n    #    "}
{"task_id": "leetcode/300", "completion": "\n    n = len(nums)\n    if n <= 1:\n        return n\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    n = len(nums)\n    if n <= 1:\n        return n\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    n = len(nums)\n    if n < 2:\n        return n\n\n    dp = [1 for _ in range(n)]\n    max_dp = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_dp = max(dp[i], max_dp)\n    return max_dp", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    n = len(nums)\n    if n < 2:\n        return n\n\n    dp = [1 for _ in range(n)]\n    max_dp = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_dp = max(dp[i], max_dp)\n    return max_dp"}
{"task_id": "leetcode/414", "completion": "\n\n    max1, max2, max3 = float('-inf'), float('-inf'), float('-inf')\n    for n in nums:\n        if n > max1:\n            max3 = max2\n            max2 = max1\n            max1 = n\n        elif n > max2 and n != max1:\n            max3 = max2\n            max2 = n\n        elif n > max3 and n != max1 and n != max2:\n            max3 = n\n\n    return max3 if max3 != float('-inf') else max1", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n\n    max1, max2, max3 = float('-inf'), float('-inf'), float('-inf')\n    for n in nums:\n        if n > max1:\n            max3 = max2\n            max2 = max1\n            max1 = n\n        elif n > max2 and n != max1:\n            max3 = max2\n            max2 = n\n        elif n > max3 and n != max1 and n != max2:\n            max3 = n\n\n    return max3 if max3 != float('-inf') else max1"}
{"task_id": "leetcode/414", "completion": "\n    l = len(nums)\n    if l < 3:\n        if l == 2:\n            return max(nums)\n        else:\n            return min(nums)\n    else:\n        nums = sorted(set(nums), reverse=True)\n        return nums[2] if l >= 3 else nums[0]\n\n\ndef thirdMax2(nums):\n    '''\n    >>> thirdMax2([3,2,1])\n    1\n    >>> thirdMax2([1,2,2,1])\n    2\n    '''\n    _max, _mid, _min = float('-inf'), float('-inf'), float('-inf') \n    for n in nums:\n        if n > _max:\n            _mid, _min = _max, _min\n            _max = n\n        elif _max > n > _mid:\n            _mid = n\n        elif _mid > n > _min:\n            _min = n\n    return _max if _mid == _min == float('-inf') else _min\n\n\ndef third", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    l = len(nums)\n    if l < 3:\n        if l == 2:\n            return max(nums)\n        else:\n            return min(nums)\n    else:\n        nums = sorted(set(nums), reverse=True)\n        return nums[2] if l >= 3 else nums[0]\n\n\ndef thirdMax2(nums):\n    '''\n    >>> thirdMax2([3,2,1])\n    1\n    >>> thirdMax2([1,2,2,1])\n    2\n    '''\n    _max, _mid, _min = float('-inf'), float('-inf'), float('-inf') \n    for n in nums:\n        if n > _max:\n            _mid, _min = _max, _min\n            _max = n\n        elif _max > n > _mid:\n            _mid = n\n        elif _mid > n > _min:\n            _min = n\n    return _max if _mid == _min == float('-inf') else _min\n\n\ndef third"}
{"task_id": "leetcode/414", "completion": "\n    nums_set = sorted(set(nums), reverse=True)\n    if len(nums_set) < 3:\n        return nums_set[0]\n    return nums_set[2]\n    \n```", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums_set = sorted(set(nums), reverse=True)\n    if len(nums_set) < 3:\n        return nums_set[0]\n    return nums_set[2]\n    \n```"}
{"task_id": "leetcode/414", "completion": "\n    if len(nums) < 3:\n        return sorted(nums)[-1]\n    nums = sorted(set(nums))\n    return nums[-3] if len(nums) >= 3 else nums[-1]", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if len(nums) < 3:\n        return sorted(nums)[-1]\n    nums = sorted(set(nums))\n    return nums[-3] if len(nums) >= 3 else nums[-1]"}
{"task_id": "leetcode/414", "completion": "\n    if not nums:\n        return\n    _nums = sorted(list(set(nums)), reverse=True)\n    if len(_nums) < 3:\n        return _nums[0]\n    return _nums[2]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if not nums:\n        return\n    _nums = sorted(list(set(nums)), reverse=True)\n    if len(_nums) < 3:\n        return _nums[0]\n    return _nums[2]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/414", "completion": "\n    # 先对数组进行排序\n    nums.sort()\n    '''\n    循环遍历数组，将数组从大到小进行排序，当遍历到倒数第二个元素时停止。此时将倒数第二个元素赋值给新的数组，并将其存入排序数组中。当遍历到第三个元素时，\n    此时数组中已经存在两个最大的元素，将第三个元素和第二个最大的元素进行判断，当两者相等时，返回第一个元素，当两者不等时，将第三个元素存入数组，并返回新的数组中的元素\n    '''\n    for i in range(len(nums)-2):\n        if (nums[-(i+2)] != nums[-(i+1)]):\n            break\n    if i + 2 == len(nums):\n        return nums[0]\n    return nums[-(i+2)]\n\n\ndef merge(nums1, m, nums2, n):\n    '''\n    >>> merge(nums1=[1,2,3,0,0,0], m=3, nums2=[2,", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    # 先对数组进行排序\n    nums.sort()\n    '''\n    循环遍历数组，将数组从大到小进行排序，当遍历到倒数第二个元素时停止。此时将倒数第二个元素赋值给新的数组，并将其存入排序数组中。当遍历到第三个元素时，\n    此时数组中已经存在两个最大的元素，将第三个元素和第二个最大的元素进行判断，当两者相等时，返回第一个元素，当两者不等时，将第三个元素存入数组，并返回新的数组中的元素\n    '''\n    for i in range(len(nums)-2):\n        if (nums[-(i+2)] != nums[-(i+1)]):\n            break\n    if i + 2 == len(nums):\n        return nums[0]\n    return nums[-(i+2)]\n\n\ndef merge(nums1, m, nums2, n):\n    '''\n    >>> merge(nums1=[1,2,3,0,0,0], m=3, nums2=[2,"}
{"task_id": "leetcode/414", "completion": "\n    if len(nums) < 3:\n        return max(nums)\n    else:\n        nums = set(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if len(nums) < 3:\n        return max(nums)\n    else:\n        nums = set(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/414", "completion": "\n    if not nums:\n        return\n\n    # 先去重\n    nums = list(set(nums))\n\n    # 排序\n    nums.sort()\n\n    # 取出第三大\n    if len(nums) < 3:\n        return nums[-1]\n    return nums[-3]", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if not nums:\n        return\n\n    # 先去重\n    nums = list(set(nums))\n\n    # 排序\n    nums.sort()\n\n    # 取出第三大\n    if len(nums) < 3:\n        return nums[-1]\n    return nums[-3]"}
{"task_id": "leetcode/414", "completion": "\n    nums.sort()\n    i = len(nums) - 1\n    while i > 0:\n        if nums[i] > nums[i-1]:\n            break\n        i -= 1\n    return nums[i] if i>0 else nums[0]", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums.sort()\n    i = len(nums) - 1\n    while i > 0:\n        if nums[i] > nums[i-1]:\n            break\n        i -= 1\n    return nums[i] if i>0 else nums[0]"}
{"task_id": "leetcode/414", "completion": "\n    nums = list(set(nums))\n    # 注意python的内置排序函数，默认是升序，如果要降序，记得传入key=lambda x:x[::-1]\n    nums.sort(reverse=True)\n    if len(nums) >= 3:\n        return nums[2]\n    else:\n        return nums[0]", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = list(set(nums))\n    # 注意python的内置排序函数，默认是升序，如果要降序，记得传入key=lambda x:x[::-1]\n    nums.sort(reverse=True)\n    if len(nums) >= 3:\n        return nums[2]\n    else:\n        return nums[0]"}
{"task_id": "leetcode/961", "completion": "\n    dict = {}\n    for i in nums:\n        if i in dict:\n            dict[i] = dict[i]+1\n        else:\n            dict[i]=1\n    sorted_dict = collections.OrderedDict(sorted(dict.items(), key=lambda x: x[1]))\n    return sorted_dict.popitem()[0]\n\n\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n=len(nums)\n    dict = {}\n    for i in nums:\n        if i in dict:\n            dict[i] = dict[i]+1\n        else:\n            dict[i]=1\n    for i in dict:\n        if dict[i]==n/2:\n            return i\n\nprint(repeated", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    dict = {}\n    for i in nums:\n        if i in dict:\n            dict[i] = dict[i]+1\n        else:\n            dict[i]=1\n    sorted_dict = collections.OrderedDict(sorted(dict.items(), key=lambda x: x[1]))\n    return sorted_dict.popitem()[0]\n\n\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n=len(nums)\n    dict = {}\n    for i in nums:\n        if i in dict:\n            dict[i] = dict[i]+1\n        else:\n            dict[i]=1\n    for i in dict:\n        if dict[i]==n/2:\n            return i\n\nprint(repeated"}
{"task_id": "leetcode/961", "completion": "\n    res = None\n    c = collections.Counter(nums)\n    for key, value in c.items():\n        if value == 2:\n            res = key\n            break\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    res = None\n    c = collections.Counter(nums)\n    for key, value in c.items():\n        if value == 2:\n            res = key\n            break\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/961", "completion": "\n    n=len(nums)\n    t=collections.Counter(nums)\n    return [k for k,v in t.items() if v==n//2][0]\n\n\n\ndef findLongestWord(s, d):\n    '''\n    找到一个最长的单词, 这个单词是由 d 中的一些单词串联形成的,单词顺序可以改变. 如果没有满足条件的单词, 返回空字符串 \"\"。\n    Find the longest word in d which can be composed of other words in d. If there is no such word, return an empty string.\n    >>> findLongestWord(\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"])\n    \"apple\"\n    '''\n    m=len(d)\n    ans=[]\n    for i in range(m):\n        tmp=[]\n        for w in d[i]:\n            tmp.append(s.find(w))\n        if all([t>=0 for t in tmp]):\n            if len(ans)==0 or len(d[i])>len(ans[1]):\n                ans=[d[i],tmp", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n=len(nums)\n    t=collections.Counter(nums)\n    return [k for k,v in t.items() if v==n//2][0]\n\n\n\ndef findLongestWord(s, d):\n    '''\n    找到一个最长的单词, 这个单词是由 d 中的一些单词串联形成的,单词顺序可以改变. 如果没有满足条件的单词, 返回空字符串 \"\"。\n    Find the longest word in d which can be composed of other words in d. If there is no such word, return an empty string.\n    >>> findLongestWord(\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"])\n    \"apple\"\n    '''\n    m=len(d)\n    ans=[]\n    for i in range(m):\n        tmp=[]\n        for w in d[i]:\n            tmp.append(s.find(w))\n        if all([t>=0 for t in tmp]):\n            if len(ans)==0 or len(d[i])>len(ans[1]):\n                ans=[d[i],tmp"}
{"task_id": "leetcode/961", "completion": "\n    for i in range(len(nums)):\n        if nums[i] in nums[:i] + nums[i+1:]:\n            return nums[i]\n\n#2\ndef maxProfit(k, prices):\n    '''\n    最大交易次数 k 次，最大利润\n    在最大交易次数限制下的最大利润。\n    >>> maxProfit(2, [3,3,5,0,0,3,1,4])\n    6\n    >>> maxProfit(2, [1,2,3,4,5])\n    4\n    >>> maxProfit(2, [7,6,4,3,1])\n    0\n    >>> maxProfit(1, [7,1,5,3,6,4])\n    5\n    >>> maxProfit(2, [7,6,4,3,1])\n    0\n    >>> maxProfit(10, [1,2,3,4,5])\n    4\n    '''\n    t = k + 1\n    n = len(prices)\n    max_h = [[None", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    for i in range(len(nums)):\n        if nums[i] in nums[:i] + nums[i+1:]:\n            return nums[i]\n\n#2\ndef maxProfit(k, prices):\n    '''\n    最大交易次数 k 次，最大利润\n    在最大交易次数限制下的最大利润。\n    >>> maxProfit(2, [3,3,5,0,0,3,1,4])\n    6\n    >>> maxProfit(2, [1,2,3,4,5])\n    4\n    >>> maxProfit(2, [7,6,4,3,1])\n    0\n    >>> maxProfit(1, [7,1,5,3,6,4])\n    5\n    >>> maxProfit(2, [7,6,4,3,1])\n    0\n    >>> maxProfit(10, [1,2,3,4,5])\n    4\n    '''\n    t = k + 1\n    n = len(prices)\n    max_h = [[None"}
{"task_id": "leetcode/961", "completion": "\n    n = len(nums) // 2\n    res = collections.Counter(nums).most_common(n)\n    for ele, cnt in res:\n        if cnt == n:\n            return ele\n        \nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n = len(nums) // 2\n    res = collections.Counter(nums).most_common(n)\n    for ele, cnt in res:\n        if cnt == n:\n            return ele\n        \nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/961", "completion": "\n    a=collections.Counter(nums)\n    res=[]\n    for k,v in a.items():\n        if v==3:\n            res.append(k)\n    return res[0]\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    a=collections.Counter(nums)\n    res=[]\n    for k,v in a.items():\n        if v==3:\n            res.append(k)\n    return res[0]\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/961", "completion": "\n    n = len(nums) // 2\n    counter = collections.Counter(nums)\n    return list(filter(lambda x: counter.get(x)==n, counter))[0]\n\n\ndef repeatedNTimes2(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n = len(nums) // 2\n    for i in nums:\n        if nums.count(i) == n:\n            return i\n\n\ndef repeatedNTimes3(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    for i in nums", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n = len(nums) // 2\n    counter = collections.Counter(nums)\n    return list(filter(lambda x: counter.get(x)==n, counter))[0]\n\n\ndef repeatedNTimes2(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n = len(nums) // 2\n    for i in nums:\n        if nums.count(i) == n:\n            return i\n\n\ndef repeatedNTimes3(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    for i in nums"}
{"task_id": "leetcode/961", "completion": "\n    return list(collections.Counter(nums).most_common(1)[0][0])\n\n#solution 2\nimport collections\nclass Solution(object):\n    def repeatedNTimes(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        return list(collections.Counter(A).most_common(1)[0][0])\n\nimport collections\n#solution 3\ndef repeatedNTimes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    counts = collections.Counter(nums)\n    for key, count in counts.items():\n        if count == len(nums) // 2:\n            return key\n\n#solution 4\nimport collections\nclass Solution(object):\n    def repeatedNTimes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return list(collections.Counter(nums).most_common(1)[0][", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return list(collections.Counter(nums).most_common(1)[0][0])\n\n#solution 2\nimport collections\nclass Solution(object):\n    def repeatedNTimes(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        return list(collections.Counter(A).most_common(1)[0][0])\n\nimport collections\n#solution 3\ndef repeatedNTimes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    counts = collections.Counter(nums)\n    for key, count in counts.items():\n        if count == len(nums) // 2:\n            return key\n\n#solution 4\nimport collections\nclass Solution(object):\n    def repeatedNTimes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return list(collections.Counter(nums).most_common(1)[0]["}
{"task_id": "leetcode/961", "completion": "\n    n = len(nums)\n    if n == 0:\n        return -1\n    elif n == 1:\n        return nums[0]\n    else:\n        i = 0\n        res = -1\n        while i < len(nums):\n            if nums.count(nums[i]) > 1:\n                res = nums[i]\n                break\n            i += 1\n        return res\n\ndef fizzBuzz(n):\n    '''\n    写一个程序，输出从 1 到 n 数字的字符串表示。\n    1. 如果该数字能被 3 整除，输出 “Fizz”；\n    2. 如果能被 5 整除，输出 “Buzz”；\n    3.如果同时能被 3 和 5 整除，输出 “FizzBuzz”。\n    >>> fizzBuzz(15)\n    [\n      \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\",\n      \"Fizz\", \"7\", \"8\", \"Fizz\",\n      \"Buzz\", \"11\",", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n = len(nums)\n    if n == 0:\n        return -1\n    elif n == 1:\n        return nums[0]\n    else:\n        i = 0\n        res = -1\n        while i < len(nums):\n            if nums.count(nums[i]) > 1:\n                res = nums[i]\n                break\n            i += 1\n        return res\n\ndef fizzBuzz(n):\n    '''\n    写一个程序，输出从 1 到 n 数字的字符串表示。\n    1. 如果该数字能被 3 整除，输出 “Fizz”；\n    2. 如果能被 5 整除，输出 “Buzz”；\n    3.如果同时能被 3 和 5 整除，输出 “FizzBuzz”。\n    >>> fizzBuzz(15)\n    [\n      \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\",\n      \"Fizz\", \"7\", \"8\", \"Fizz\",\n      \"Buzz\", \"11\","}
{"task_id": "leetcode/961", "completion": "\n    c = collections.Counter(nums)\n    return [i for i, v in c.items() if v == max(c.values())][0]\n\ndef repeatedNTimes(nums):\n    '''\n    将输入数组分成两个数组，使两个数组中的所有元素都只出现一次，\n    那么剩下的那个只出现一次的元素就是重复NTimes()的元素。\n    Return the single element that appears once in an array of distinct integers.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    i = set(nums)\n    for j in nums:\n        if j in i: i.remove(j)\n        else: return j\n\ndef repeatedNTimes(nums):\n    '''\n    使用二分查找将重复的数字放在数组的两侧。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i] == nums[i + 1]:\n", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    c = collections.Counter(nums)\n    return [i for i, v in c.items() if v == max(c.values())][0]\n\ndef repeatedNTimes(nums):\n    '''\n    将输入数组分成两个数组，使两个数组中的所有元素都只出现一次，\n    那么剩下的那个只出现一次的元素就是重复NTimes()的元素。\n    Return the single element that appears once in an array of distinct integers.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    i = set(nums)\n    for j in nums:\n        if j in i: i.remove(j)\n        else: return j\n\ndef repeatedNTimes(nums):\n    '''\n    使用二分查找将重复的数字放在数组的两侧。\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i] == nums[i + 1]:\n"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1:\n        return 0\n    nums = sorted(nums, reverse=True)\n    if nums[-1] >= 2*nums[-2]:\n        return nums.index(nums[0])\n    return -1\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1:\n        return 0\n    nums = sorted(nums, reverse=True)\n    if nums[-1] >= 2*nums[-2]:\n        return nums.index(nums[0])\n    return -1\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1: return 0\n    dominant = nums[0]\n    dominant_index = 0\n    for i, num in enumerate(nums):\n        if num > dominant:\n            dominant = num\n            dominant_index = i\n\n    for i, num in enumerate(nums):\n        if i == dominant_index:\n            continue\n        if nums[i] > dominant / 2:\n            return -1\n\n    return dominant_index\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1: return 0\n    dominant = nums[0]\n    dominant_index = 0\n    for i, num in enumerate(nums):\n        if num > dominant:\n            dominant = num\n            dominant_index = i\n\n    for i, num in enumerate(nums):\n        if i == dominant_index:\n            continue\n        if nums[i] > dominant / 2:\n            return -1\n\n    return dominant_index\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"}
{"task_id": "leetcode/747", "completion": "\n    tmp = max(nums)\n    for i in nums:\n        if i == tmp:\n            continue\n        elif i * 2 < tmp:\n            return -1\n    return nums.index(tmp)", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    tmp = max(nums)\n    for i in nums:\n        if i == tmp:\n            continue\n        elif i * 2 < tmp:\n            return -1\n    return nums.index(tmp)"}
{"task_id": "leetcode/747", "completion": "\n    ''' \n    1.先找到最大值,并记录下最大值的下标。\n    2.最大值本身不可能成为其他数字的两倍，所以只需要判断最大值与其它的数字的相对大小。如果最大值大于等于其他数字的两倍，那么就返回最大值下标。否则返回-1\n    '''\n    if not nums:\n        return -1\n    res = max(nums)\n    index = nums.index(res)\n    nums.remove(res)\n    if max(nums) * 2 > res:\n        return -1\n    return index\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    ''' \n    1.先找到最大值,并记录下最大值的下标。\n    2.最大值本身不可能成为其他数字的两倍，所以只需要判断最大值与其它的数字的相对大小。如果最大值大于等于其他数字的两倍，那么就返回最大值下标。否则返回-1\n    '''\n    if not nums:\n        return -1\n    res = max(nums)\n    index = nums.index(res)\n    nums.remove(res)\n    if max(nums) * 2 > res:\n        return -1\n    return index\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/747", "completion": "\n    max_index = 0\n    largest = nums[0]\n    for i in range(len(nums)):\n        if nums[i] > largest:\n            largest = nums[i]\n            max_index = i\n    for i in range(len(nums)):\n        if i != max_index and nums[i]*2 > largest:\n            return -1\n    return max_index\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    max_index = 0\n    largest = nums[0]\n    for i in range(len(nums)):\n        if nums[i] > largest:\n            largest = nums[i]\n            max_index = i\n    for i in range(len(nums)):\n        if i != max_index and nums[i]*2 > largest:\n            return -1\n    return max_index\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/747", "completion": "\n\n    max_n = -1\n    max_two = -1\n    index = -1\n    for i in range(len(nums)):\n        if nums[i] >= max_n:\n            max_two = max_n\n            max_n = nums[i]\n            index = i\n        elif nums[i] > max_two:\n            max_two = nums[i]\n\n    for i in range(len(nums)):\n        if i != index and 2 * nums[i] > max_two:\n            return -1\n\n    return index\n\ndef dominantIndex2(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>>", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n\n    max_n = -1\n    max_two = -1\n    index = -1\n    for i in range(len(nums)):\n        if nums[i] >= max_n:\n            max_two = max_n\n            max_n = nums[i]\n            index = i\n        elif nums[i] > max_two:\n            max_two = nums[i]\n\n    for i in range(len(nums)):\n        if i != index and 2 * nums[i] > max_two:\n            return -1\n\n    return index\n\ndef dominantIndex2(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>>"}
{"task_id": "leetcode/747", "completion": "\n    nums_sorted = sorted(nums, reverse=True)\n    for i in range(1, len(nums_sorted)):\n        if nums_sorted[i-1]**2 < nums_sorted[i]**2:\n            return nums.index(nums_sorted[i-1])\n    return -1\n\ndef dominantIndex1(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 1:\n        return 0\n    elif len(nums) == 2:\n        return nums.index(max(nums))\n\n    else:\n        maximum = max(nums)\n        maximum_index = nums.index(maximum)\n        nums.remove(maximum)\n        if maximum >= 2 * (max(nums)):\n            return maximum_index\n        else:\n            return -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    nums_sorted = sorted(nums, reverse=True)\n    for i in range(1, len(nums_sorted)):\n        if nums_sorted[i-1]**2 < nums_sorted[i]**2:\n            return nums.index(nums_sorted[i-1])\n    return -1\n\ndef dominantIndex1(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 1:\n        return 0\n    elif len(nums) == 2:\n        return nums.index(max(nums))\n\n    else:\n        maximum = max(nums)\n        maximum_index = nums.index(maximum)\n        nums.remove(maximum)\n        if maximum >= 2 * (max(nums)):\n            return maximum_index\n        else:\n            return -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n    m = 0\n    for each in nums:\n        if each > m:\n            m = each\n    for each in nums:\n        if each != m:\n            if m < 2 * each:\n                return -1\n    return nums.index(m)\n\n\ndef duplicate_zeros(arr):\n    '''\n    给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n    示例:\n    >>> duplicate_zeros([1,2,2,2,3,0,0,4,2])\n    [1,2,3,4,2,0,0,0,0]\n    '''\n    i = 0\n    while i < len(arr):\n        if arr[i] == 0:\n            del arr[i]\n            arr.insert(i + len(arr), 0)\n            i += 2\n        else:\n            i += 1\n    return arr\n\n\ndef count_of_smaller", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n    m = 0\n    for each in nums:\n        if each > m:\n            m = each\n    for each in nums:\n        if each != m:\n            if m < 2 * each:\n                return -1\n    return nums.index(m)\n\n\ndef duplicate_zeros(arr):\n    '''\n    给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n    示例:\n    >>> duplicate_zeros([1,2,2,2,3,0,0,4,2])\n    [1,2,3,4,2,0,0,0,0]\n    '''\n    i = 0\n    while i < len(arr):\n        if arr[i] == 0:\n            del arr[i]\n            arr.insert(i + len(arr), 0)\n            i += 2\n        else:\n            i += 1\n    return arr\n\n\ndef count_of_smaller"}
{"task_id": "leetcode/747", "completion": "\n    if not nums:\n        return -1\n\n    bigger_than_second = -1\n    second_bigger = -1\n    max_nums = 0\n    for i, num in enumerate(nums):\n        if num > max_nums:\n            bigger_than_second = second_bigger\n            second_bigger = max_nums\n            max_nums = num\n            max_index = i\n        elif num > second_bigger:\n            bigger_than_second = second_bigger\n            second_bigger = num\n    if second_bigger >= 0 and 2 * second_bigger > max_nums:\n        return -1\n    elif 2 * bigger_than_second > max_nums:\n        return -1\n    else:\n        return max_index", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if not nums:\n        return -1\n\n    bigger_than_second = -1\n    second_bigger = -1\n    max_nums = 0\n    for i, num in enumerate(nums):\n        if num > max_nums:\n            bigger_than_second = second_bigger\n            second_bigger = max_nums\n            max_nums = num\n            max_index = i\n        elif num > second_bigger:\n            bigger_than_second = second_bigger\n            second_bigger = num\n    if second_bigger >= 0 and 2 * second_bigger > max_nums:\n        return -1\n    elif 2 * bigger_than_second > max_nums:\n        return -1\n    else:\n        return max_index"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1: return 0\n    max_index = 0\n    second_max_index = 1\n    second_max = nums[1]\n    for i, num in enumerate(nums):\n        if num > nums[max_index]:\n            second_max_index = max_index\n            second_max = nums[max_index]\n            max_index = i\n        elif num > second_max:\n            second_max = num\n            second_max_index = i\n    if second_max * 2 > nums[max_index]:\n        return max_index\n    else:\n        return -1\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1: return 0\n    max_index = 0\n    second_max_index = 1\n    second_max = nums[1]\n    for i, num in enumerate(nums):\n        if num > nums[max_index]:\n            second_max_index = max_index\n            second_max = nums[max_index]\n            max_index = i\n        elif num > second_max:\n            second_max = num\n            second_max_index = i\n    if second_max * 2 > nums[max_index]:\n        return max_index\n    else:\n        return -1\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1200", "completion": "\n    # 解题思路，排序后枚举所有两两数对，寻找最小的绝对差\n    # 复杂度分析：时间复杂度O(nlgn)，空间复杂度O(1)\n    arr.sort()\n    diff = arr[-1] - arr[0]\n    ret = [[arr[0], arr[0]]]\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] - arr[j] < diff:\n                if arr[i] - arr[j] == diff:\n                    ret.append([arr[j], arr[i]])\n                else:\n                    ret = [[arr[j], arr[i]]]\n                diff = arr[i] - arr[j]\n    return ret\n\ndef test():\n    '''run test cases'''\n    test_args = [[4,2,1,3], [1,3,6,10,15], [1, 1, 3], [1, 2, 3, 4]]\n    test_res = [[[1, 2],", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 解题思路，排序后枚举所有两两数对，寻找最小的绝对差\n    # 复杂度分析：时间复杂度O(nlgn)，空间复杂度O(1)\n    arr.sort()\n    diff = arr[-1] - arr[0]\n    ret = [[arr[0], arr[0]]]\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] - arr[j] < diff:\n                if arr[i] - arr[j] == diff:\n                    ret.append([arr[j], arr[i]])\n                else:\n                    ret = [[arr[j], arr[i]]]\n                diff = arr[i] - arr[j]\n    return ret\n\ndef test():\n    '''run test cases'''\n    test_args = [[4,2,1,3], [1,3,6,10,15], [1, 1, 3], [1, 2, 3, 4]]\n    test_res = [[[1, 2],"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    minimum = arr[1] - arr[0]\n    ret = [[arr[0], arr[1]]]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] < minimum:\n            ret = [[arr[i - 1], arr[i]]]\n            minimum = arr[i] - arr[i - 1]\n        elif arr[i] - arr[i - 1] == minimum:\n            ret.append([arr[i - 1], arr[i]])\n    return ret", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    minimum = arr[1] - arr[0]\n    ret = [[arr[0], arr[1]]]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] < minimum:\n            ret = [[arr[i - 1], arr[i]]]\n            minimum = arr[i] - arr[i - 1]\n        elif arr[i] - arr[i - 1] == minimum:\n            ret.append([arr[i - 1], arr[i]])\n    return ret"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    min_abs_diff = 10000000\n    ret = []\n    for i in range(len(arr) - 1):\n        min_abs_diff = min(abs(arr[i] - arr[i + 1]), min_abs_diff)\n\n    for i in range(len(arr) - 1):\n        if abs(arr[i] - arr[i + 1]) == min_abs_diff:\n            ret.append([arr[i], arr[i + 1]])\n\n    return ret\n\n\ndef main():\n    print(minimumAbsDifference([4, 2, 1, 3]))\n    print(minimumAbsDifference([1, 3, 6, 10, 15]))\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    min_abs_diff = 10000000\n    ret = []\n    for i in range(len(arr) - 1):\n        min_abs_diff = min(abs(arr[i] - arr[i + 1]), min_abs_diff)\n\n    for i in range(len(arr) - 1):\n        if abs(arr[i] - arr[i + 1]) == min_abs_diff:\n            ret.append([arr[i], arr[i + 1]])\n\n    return ret\n\n\ndef main():\n    print(minimumAbsDifference([4, 2, 1, 3]))\n    print(minimumAbsDifference([1, 3, 6, 10, 15]))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "leetcode/1200", "completion": "\n    pass", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    pass"}
{"task_id": "leetcode/1200", "completion": "\n    if not arr or len(arr) < 2:\n        return []\n    # 排序arr\n    sorted_arr = sorted(arr)\n    abs_diff = sorted_arr[1] - sorted_arr[0]\n    m = abs_diff\n    rst = []\n    for i in range(1, len(sorted_arr)):\n        # 当前的绝对差值\n        abs_diff = sorted_arr[i] - sorted_arr[i - 1]\n        if abs_diff < m:\n            # 绝对差值比原来的小\n            rst.clear()\n            m = abs_diff\n        if abs_diff == m:\n            # 绝对差值和原来的相等，添加结果\n            rst.append([sorted_arr[i - 1], sorted_arr[i]])\n    return rst\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(inversionRecursive([1, 3, 2, 0, 4, 6]))", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if not arr or len(arr) < 2:\n        return []\n    # 排序arr\n    sorted_arr = sorted(arr)\n    abs_diff = sorted_arr[1] - sorted_arr[0]\n    m = abs_diff\n    rst = []\n    for i in range(1, len(sorted_arr)):\n        # 当前的绝对差值\n        abs_diff = sorted_arr[i] - sorted_arr[i - 1]\n        if abs_diff < m:\n            # 绝对差值比原来的小\n            rst.clear()\n            m = abs_diff\n        if abs_diff == m:\n            # 绝对差值和原来的相等，添加结果\n            rst.append([sorted_arr[i - 1], sorted_arr[i]])\n    return rst\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(inversionRecursive([1, 3, 2, 0, 4, 6]))"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    arr_len = len(arr)\n    min_abs_diff = float('inf')\n    result = []\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            abs_diff = abs(arr[i] - arr[j])\n            if abs_diff < min_abs_diff:\n                min_abs_diff = abs_diff\n                result = [[arr[i], arr[j]]]\n            elif abs_diff == min_abs_diff:\n                result.append([arr[i], arr[j]])\n    return result", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    arr_len = len(arr)\n    min_abs_diff = float('inf')\n    result = []\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            abs_diff = abs(arr[i] - arr[j])\n            if abs_diff < min_abs_diff:\n                min_abs_diff = abs_diff\n                result = [[arr[i], arr[j]]]\n            elif abs_diff == min_abs_diff:\n                result.append([arr[i], arr[j]])\n    return result"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    min_diff = float('inf')\n    res = []\n    for i, _ in enumerate(arr):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff < min_diff:\n                min_diff = diff\n                res = [[arr[i], arr[j]]]\n            elif diff == min_diff:\n                res.append([arr[i], arr[j]])\n    return sorted(res)", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    min_diff = float('inf')\n    res = []\n    for i, _ in enumerate(arr):\n        for j in range(i + 1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff < min_diff:\n                min_diff = diff\n                res = [[arr[i], arr[j]]]\n            elif diff == min_diff:\n                res.append([arr[i], arr[j]])\n    return sorted(res)"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    left = 0\n    right = 1\n    min_num = arr[-1] - arr[0]\n    res = []\n    res.append([arr[0], arr[1]])\n    while right < len(arr):\n        if arr[right] - arr[left] == min_num:\n            res.append([arr[left], arr[right]])\n        elif arr[right] - arr[left] < min_num:\n            min_num = arr[right] - arr[left]\n            res.clear()\n            res.append([arr[left], arr[right]])\n        left += 1\n        right += 1\n    return res", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    left = 0\n    right = 1\n    min_num = arr[-1] - arr[0]\n    res = []\n    res.append([arr[0], arr[1]])\n    while right < len(arr):\n        if arr[right] - arr[left] == min_num:\n            res.append([arr[left], arr[right]])\n        elif arr[right] - arr[left] < min_num:\n            min_num = arr[right] - arr[left]\n            res.clear()\n            res.append([arr[left], arr[right]])\n        left += 1\n        right += 1\n    return res"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    result = []\n    min_val = arr[-1] - arr[0]\n    for i in range(1, len(arr)):\n        for j in range(0, i):\n            if abs(arr[i] - arr[j]) == min_val:\n                result.append([arr[j], arr[i]])\n                break\n            elif abs(arr[i] - arr[j]) < min_val:\n                result = []\n                result.append([arr[j], arr[i]])\n                min_val = abs(arr[i] - arr[j])\n    return result\n\n\ndef minNumberOfCoinsForChange(n, denoms):\n    '''\n    给定一个总金额 n，一个数组 coins 表示每个硬币的面值，和一个数组 amount 表示总金额（包括硬币的总面值），\n    实现一个函数来计算可凑成总金额所需的硬币个数。假设每一种面值的硬币有无限个。\n    >>> minNumberOfCoinsForChange(5, [1, 2, 5])\n    2\n    ", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    result = []\n    min_val = arr[-1] - arr[0]\n    for i in range(1, len(arr)):\n        for j in range(0, i):\n            if abs(arr[i] - arr[j]) == min_val:\n                result.append([arr[j], arr[i]])\n                break\n            elif abs(arr[i] - arr[j]) < min_val:\n                result = []\n                result.append([arr[j], arr[i]])\n                min_val = abs(arr[i] - arr[j])\n    return result\n\n\ndef minNumberOfCoinsForChange(n, denoms):\n    '''\n    给定一个总金额 n，一个数组 coins 表示每个硬币的面值，和一个数组 amount 表示总金额（包括硬币的总面值），\n    实现一个函数来计算可凑成总金额所需的硬币个数。假设每一种面值的硬币有无限个。\n    >>> minNumberOfCoinsForChange(5, [1, 2, 5])\n    2\n    "}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    min_delta = 2**31 - 1\n    min_pair = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            delta = abs(arr[i] - arr[j])\n            if delta < min_delta:\n                min_pair = [arr[i], arr[j]]\n                min_delta = delta\n            elif delta == min_delta:\n                min_pair.extend([arr[i], arr[j]])\n    return min_pair\n\n    \nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    min_delta = 2**31 - 1\n    min_pair = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            delta = abs(arr[i] - arr[j])\n            if delta < min_delta:\n                min_pair = [arr[i], arr[j]]\n                min_delta = delta\n            elif delta == min_delta:\n                min_pair.extend([arr[i], arr[j]])\n    return min_pair\n\n    \nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    i = 0\n    j = 0\n    counter = 0\n    while i < len(arr1) and j < len(arr2):\n        if abs(arr1[i] - arr2[j]) > d:\n            counter += 1\n        if j == len(arr2) - 1:\n            break\n        if arr2[j] < arr1[i]:\n            j += 1\n        else:\n            i += 1\n    return counter\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    i = 0\n    j = 0\n    counter = 0\n    while i < len(arr1) and j < len(arr2):\n        if abs(arr1[i] - arr2[j]) > d:\n            counter += 1\n        if j == len(arr2) - 1:\n            break\n        if arr2[j] < arr1[i]:\n            j += 1\n        else:\n            i += 1\n    return counter\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    assert isinstance(arr1, list), \"arr1 必须是list类型\"\n    assert isinstance(arr2, list), \"arr2 必须是list类型\"\n    assert isinstance(d, int), \"d 必须是int类型\"\n    assert d >= 0, \"d必须大于等于0\"\n    s = set(arr2)\n    d2 = 0\n    for x in arr1:\n        for y in s:\n            if abs(x - y) <= d:\n                print(x, y, abs(x - y))\n                break\n        else:\n            d2 += 1\n    return d2\n\n\ndef findTheDistanceValue2(arr1, arr2, d):\n    return len(\n        [x for x in arr1 if not (any(abs(x - y) <= d for y in arr2))]\n    )\n\n\ndef findTheDistanceValue(arr1, arr2, d):\n    return reduce(lambda acc, x: acc + (0, 1)[abs(x - d) > d] if not\n                  (any(abs(x -", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    assert isinstance(arr1, list), \"arr1 必须是list类型\"\n    assert isinstance(arr2, list), \"arr2 必须是list类型\"\n    assert isinstance(d, int), \"d 必须是int类型\"\n    assert d >= 0, \"d必须大于等于0\"\n    s = set(arr2)\n    d2 = 0\n    for x in arr1:\n        for y in s:\n            if abs(x - y) <= d:\n                print(x, y, abs(x - y))\n                break\n        else:\n            d2 += 1\n    return d2\n\n\ndef findTheDistanceValue2(arr1, arr2, d):\n    return len(\n        [x for x in arr1 if not (any(abs(x - y) <= d for y in arr2))]\n    )\n\n\ndef findTheDistanceValue(arr1, arr2, d):\n    return reduce(lambda acc, x: acc + (0, 1)[abs(x - d) > d] if not\n                  (any(abs(x -"}
{"task_id": "leetcode/1385", "completion": "\n    arr1_len = len(arr1)\n    arr2_len = len(arr2)\n    count = 0\n    for i in range(arr1_len):\n        for j in range(arr2_len):\n            if abs(arr1[i] - arr2[j]) > d:\n                count += 1\n            else:\n                continue\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1_len = len(arr1)\n    arr2_len = len(arr2)\n    count = 0\n    for i in range(arr1_len):\n        for j in range(arr2_len):\n            if abs(arr1[i] - arr2[j]) > d:\n                count += 1\n            else:\n                continue\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    distances = []\n    for num in arr1:\n        temp = 0\n        for j in arr2:\n            if abs(num-j) > d:\n                temp += 1\n        if temp == len(arr2):\n            distances.append(temp)\n    return len(distances)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    distances = []\n    for num in arr1:\n        temp = 0\n        for j in arr2:\n            if abs(num-j) > d:\n                temp += 1\n        if temp == len(arr2):\n            distances.append(temp)\n    return len(distances)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    # 思路：对arr1进行遍历，通过遍历来判断arr2中的每个数是否满足条件\n    count = 0\n    for i in arr1:\n        for j in arr2:\n            if abs(i-j) > d:\n                count += 1\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # 思路：对arr1进行遍历，通过遍历来判断arr2中的每个数是否满足条件\n    count = 0\n    for i in arr1:\n        for j in arr2:\n            if abs(i-j) > d:\n                count += 1\n    return count\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    cnt = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                cnt += 1\n    return cnt\n\n\ndef testFindTheDistanceValue(n, d):\n    '''\n    >>> testFindTheDistanceValue(32, 16)\n    28\n    >>> testFindTheDistanceValue(32, 14)\n    22\n    >>> testFindTheDistanceValue(32, 13)\n    29\n    '''\n    data = random.sample(range(0, 32), n)\n    target = random.sample(range(0, 32), n)\n    print('data is ' + str(data))\n    print('target is ' + str(target))\n    print(findTheDistanceValue(data, target, d))\n\n\ndef main():\n    testFindTheDistanceValue(32, 16)\n\n\nif __name__ == '__main__", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    cnt = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                cnt += 1\n    return cnt\n\n\ndef testFindTheDistanceValue(n, d):\n    '''\n    >>> testFindTheDistanceValue(32, 16)\n    28\n    >>> testFindTheDistanceValue(32, 14)\n    22\n    >>> testFindTheDistanceValue(32, 13)\n    29\n    '''\n    data = random.sample(range(0, 32), n)\n    target = random.sample(range(0, 32), n)\n    print('data is ' + str(data))\n    print('target is ' + str(target))\n    print(findTheDistanceValue(data, target, d))\n\n\ndef main():\n    testFindTheDistanceValue(32, 16)\n\n\nif __name__ == '__main__"}
{"task_id": "leetcode/1385", "completion": "\n    count_num = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                count_num += 1\n    return count_num\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    count_num = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                count_num += 1\n    return count_num\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    return len([num for num in arr1 if not any((abs(num - i) > d for i in arr2))])\n\n\ndef findTheDistanceValue2(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue2([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue2([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue2([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return sum([", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return len([num for num in arr1 if not any((abs(num - i) > d for i in arr2))])\n\n\ndef findTheDistanceValue2(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue2([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue2([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue2([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return sum(["}
{"task_id": "leetcode/1385", "completion": "\n    res = 0\n    for i in range(len(arr1)):\n        if arr1[i] in arr2:\n            continue\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    res = 0\n    for i in range(len(arr1)):\n        if arr1[i] in arr2:\n            continue\n        for j in range(len(arr2)):\n            if abs(arr1[i] - arr2[j]) > d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1385", "completion": "\n    result = 0\n    arr1_set = set(arr1)\n    arr2_set = set(arr2)\n    for i in arr1_set:\n        for j in arr2_set:\n            if abs(i - j) > d:\n                result += 1\n    return result\n\nprint(findTheDistanceValue([4,5,8], [10,9,1,8], 2))\nprint(findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3))\nprint(findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6))", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    result = 0\n    arr1_set = set(arr1)\n    arr2_set = set(arr2)\n    for i in arr1_set:\n        for j in arr2_set:\n            if abs(i - j) > d:\n                result += 1\n    return result\n\nprint(findTheDistanceValue([4,5,8], [10,9,1,8], 2))\nprint(findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3))\nprint(findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6))"}
{"task_id": "leetcode/349", "completion": "\n    return list(set(nums1)&set(nums2))\n\ndef containsDuplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    d = dict(Counter(nums))\n    for i in d:\n        if d[i] > 1:\n            return True\n        return False\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的绝对差不超过 k。\n    >>> containsNearbyDuplicate([1,2,3,1], 3)\n    True\n    >>> containsN", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1)&set(nums2))\n\ndef containsDuplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    d = dict(Counter(nums))\n    for i in d:\n        if d[i] > 1:\n            return True\n        return False\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的绝对差不超过 k。\n    >>> containsNearbyDuplicate([1,2,3,1], 3)\n    True\n    >>> containsN"}
{"task_id": "leetcode/349", "completion": "\n    if nums1 is None or nums2 is None or len(nums1) == 0 or len(nums2) == 0:\n        return list()\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n\n    count = 0\n    res = list()\n    for i in nums1_set:\n        if i in nums2_set:\n            res.append(i)\n    return res\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    if nums1 is None or nums2 is None or len(nums1) == 0 or len(nums2) == 0:\n        return list()\n    nums1_set = set(nums1)\n    nums2_set = set(nums2)\n\n    count = 0\n    res = list()\n    for i in nums1_set:\n        if i in nums2_set:\n            res.append(i)\n    return res\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/349", "completion": "\n    hashmap = {}\n    # 字典记录第一个数组元素出现次数\n    for i in nums1:\n        if i not in hashmap:\n            hashmap[i] = 1\n    # 判断第二个数组元素是否在字典中\n    hashmap1 = {}\n    for j in nums2:\n        if j in hashmap and j not in hashmap1:\n            hashmap1[j] = 1\n    # 字典记录重复元素\n    result = []\n    for k in hashmap1:\n        result.append(k)\n    return result\n\n\ndef contains_duplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。\n    如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> contains_duplicate([1,2,3,1])\n    True\n    >>> contains_duplicate([1,2,3,4])\n    False\n    '''\n    # 记录数组元素出现次数\n    hashmap", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    hashmap = {}\n    # 字典记录第一个数组元素出现次数\n    for i in nums1:\n        if i not in hashmap:\n            hashmap[i] = 1\n    # 判断第二个数组元素是否在字典中\n    hashmap1 = {}\n    for j in nums2:\n        if j in hashmap and j not in hashmap1:\n            hashmap1[j] = 1\n    # 字典记录重复元素\n    result = []\n    for k in hashmap1:\n        result.append(k)\n    return result\n\n\ndef contains_duplicate(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。\n    如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n    >>> contains_duplicate([1,2,3,1])\n    True\n    >>> contains_duplicate([1,2,3,4])\n    False\n    '''\n    # 记录数组元素出现次数\n    hashmap"}
{"task_id": "leetcode/349", "completion": "\n    if not nums1 or not nums2:\n        return [] \n\n    n1, n2 = len(nums1), len(nums2)\n    nums1.sort()\n    nums2.sort()\n\n    i, j = 0, 0\n    length = len(nums1)\n    result = []\n\n    while i < length and j < length:\n        if nums1[i] == nums2[j]:\n            result.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(intersection([1,2,3],[2,3]))\n    print(intersection([1,2,2,1], [2,2]))\n    print(intersection([4,9,5], [9,4,9,8,4]))\n    print(intersection([4,9,", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    if not nums1 or not nums2:\n        return [] \n\n    n1, n2 = len(nums1), len(nums2)\n    nums1.sort()\n    nums2.sort()\n\n    i, j = 0, 0\n    length = len(nums1)\n    result = []\n\n    while i < length and j < length:\n        if nums1[i] == nums2[j]:\n            result.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(intersection([1,2,3],[2,3]))\n    print(intersection([1,2,2,1], [2,2]))\n    print(intersection([4,9,5], [9,4,9,8,4]))\n    print(intersection([4,9,"}
{"task_id": "leetcode/349", "completion": "\n    return sorted(list(set(nums1) & set(nums2)))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return sorted(list(set(nums1) & set(nums2)))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/349", "completion": "\n    nums1, nums2 = Counter(nums1), Counter(nums2)\n    return [key for key in nums1 if key in nums2]\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    nums1 = [1,2,2,1]\n    nums2 = [2,2]\n    logger.info('nums1:{},nums2:{}'.format(nums1,nums2))\n    result = intersection(nums1, nums2)\n    logger.info('result:{}'.format(result))", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1, nums2 = Counter(nums1), Counter(nums2)\n    return [key for key in nums1 if key in nums2]\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    nums1 = [1,2,2,1]\n    nums2 = [2,2]\n    logger.info('nums1:{},nums2:{}'.format(nums1,nums2))\n    result = intersection(nums1, nums2)\n    logger.info('result:{}'.format(result))"}
{"task_id": "leetcode/349", "completion": "\n    new_set = set(nums1) & set(nums2)\n    return list(new_set)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    new_set = set(nums1) & set(nums2)\n    return list(new_set)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/349", "completion": "\n    return sorted(set(nums1) & set(nums2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return sorted(set(nums1) & set(nums2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/349", "completion": "\n    return sorted(list(set(nums1).intersection(nums2)))\n\ndef intersection_v2(nums1, nums2):\n    return sorted(set(nums1)&set(nums2))\n\ndef union(nums1, nums2):\n    '''\n    给定两个数组，编写一个函数来计算它们的并集。\n    >>> union([1,2,2,1], [2,2])\n    [1,2,2,1,2]\n    >>> union([4,9,5], [9,4,9,8,4])\n    [4,9,5,8,4]\n    '''\n    return sorted(nums1 + nums2)\n\ndef union_v2(nums1, nums2):\n    return sorted(set(nums1)|set(nums2))\n\ndef relativeSortArray(nums1: list, nums2: list) -> list:\n    '''\n    给你两个数组，arr1 和arr2。\n    \narr2中的元素各不相同\narr2中的每个元素", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return sorted(list(set(nums1).intersection(nums2)))\n\ndef intersection_v2(nums1, nums2):\n    return sorted(set(nums1)&set(nums2))\n\ndef union(nums1, nums2):\n    '''\n    给定两个数组，编写一个函数来计算它们的并集。\n    >>> union([1,2,2,1], [2,2])\n    [1,2,2,1,2]\n    >>> union([4,9,5], [9,4,9,8,4])\n    [4,9,5,8,4]\n    '''\n    return sorted(nums1 + nums2)\n\ndef union_v2(nums1, nums2):\n    return sorted(set(nums1)|set(nums2))\n\ndef relativeSortArray(nums1: list, nums2: list) -> list:\n    '''\n    给你两个数组，arr1 和arr2。\n    \narr2中的元素各不相同\narr2中的每个元素"}
{"task_id": "leetcode/349", "completion": "\n    length1, length2 = len(nums1), len(nums2)\n    if length1 == 0 or length2 == 0:\n        return []\n    # 将长度较小的数组放入 nums1中\n    if length1 > length2:\n        nums1, nums2 = nums2, nums1\n    hash_nums = {}\n    hash_ans = []\n    for num in nums1:\n        hash_nums[num] = hash_nums.get(num, 0) + 1\n\n    for num in nums2:\n        if num in hash_nums and hash_nums[num] > 0:\n            hash_ans.append(num)\n            hash_nums[num] -= 1\n    return sorted(hash_ans)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print('SUCCESS!')\n\n\nif __name__ == \"__main__\":\n    main()", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    length1, length2 = len(nums1), len(nums2)\n    if length1 == 0 or length2 == 0:\n        return []\n    # 将长度较小的数组放入 nums1中\n    if length1 > length2:\n        nums1, nums2 = nums2, nums1\n    hash_nums = {}\n    hash_ans = []\n    for num in nums1:\n        hash_nums[num] = hash_nums.get(num, 0) + 1\n\n    for num in nums2:\n        if num in hash_nums and hash_nums[num] > 0:\n            hash_ans.append(num)\n            hash_nums[num] -= 1\n    return sorted(hash_ans)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print('SUCCESS!')\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "leetcode/1491", "completion": "\n    # 方法1：排序后，切片\n    return int(sum(sorted(salary)[1: -1]) / (len(salary) - 2))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    # 方法2：max和min\n    return int((sum(salary) - min(salary) - max(salary)) / (len(salary) - 2))\n\n\ndef average3(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    # 方法1：排序后，切片\n    return int(sum(sorted(salary)[1: -1]) / (len(salary) - 2))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    # 方法2：max和min\n    return int((sum(salary) - min(salary) - max(salary)) / (len(salary) - 2))\n\n\ndef average3(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资"}
{"task_id": "leetcode/1491", "completion": "\n    return round(sum(salary) - max(salary) - min(salary) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary) - max(salary) - min(salary) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1491", "completion": "\n    t = statistics.mean(salary)\n    return int(t)\n\n\ndef mode(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回最高工资，如果有多个员工同时拥有最高工资，则返回最低的员工工资。\n    >>> mode([4000,3000,1000,2000])\n    2000\n    >>> mode([1000,2000,3000])\n    2000\n    '''\n    m = max(salary)\n    return min(filter(lambda x: x == m, salary))\n\n\ndef median(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回薪水的中位数，如果数组是奇数，则返回中间的数值。\n    >>> median([1000,2000,3000])\n    2000\n    >>> median([1", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    t = statistics.mean(salary)\n    return int(t)\n\n\ndef mode(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回最高工资，如果有多个员工同时拥有最高工资，则返回最低的员工工资。\n    >>> mode([4000,3000,1000,2000])\n    2000\n    >>> mode([1000,2000,3000])\n    2000\n    '''\n    m = max(salary)\n    return min(filter(lambda x: x == m, salary))\n\n\ndef median(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回薪水的中位数，如果数组是奇数，则返回中间的数值。\n    >>> median([1000,2000,3000])\n    2000\n    >>> median([1"}
{"task_id": "leetcode/1491", "completion": "\n    return round(sum([s for s in salary if s != min(salary) and s != max(salary)]) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round(sum([s for s in salary if s != min(salary) and s != max(salary)]) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1491", "completion": "\n    average = (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n    return int(round(average))\n\nif __name__ == '__main__':\n    a = [37, 56, 12, 132, 63, 25, 14, 132, 44, 65, 67, 33, 44, 34, 23, 54, 123, 65, 34]\n    print(average(a))", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    average = (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n    return int(round(average))\n\nif __name__ == '__main__':\n    a = [37, 56, 12, 132, 63, 25, 14, 132, 44, 65, 67, 33, 44, 34, 23, 54, 123, 65, 34]\n    print(average(a))"}
{"task_id": "leetcode/1491", "completion": "\n    return int(round(sum(salary) / (len(salary) - 2)))\n\n\ndef first_non_repeat(text):\n    '''\n    给定一个非空字符串， 返回第一个只出现一次的字符。如果没有，\n    则返回一个单空格。\n    >>> first_non_repeat('abaccdeff')\n    'c'\n    >>> first_non_repeat('abaccdeff')\n    ' '\n    >>> first_non_repeat('abccdfff')\n    'd'\n    '''\n    chars = list(text)\n    s = []\n    for char in chars:\n        if text.count(char) == 1:\n            s.append(char)\n    if len(s) == 0:\n        return ' '\n    return s[0]\n\n\ndef find_char(text):\n    '''\n    给定一个字符串，在字符串里查找一个字符串，返回第一次出现的索引。\n    如果字符串不存在于字符串中，则返回 -1。\n    >>> find_char('", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return int(round(sum(salary) / (len(salary) - 2)))\n\n\ndef first_non_repeat(text):\n    '''\n    给定一个非空字符串， 返回第一个只出现一次的字符。如果没有，\n    则返回一个单空格。\n    >>> first_non_repeat('abaccdeff')\n    'c'\n    >>> first_non_repeat('abaccdeff')\n    ' '\n    >>> first_non_repeat('abccdfff')\n    'd'\n    '''\n    chars = list(text)\n    s = []\n    for char in chars:\n        if text.count(char) == 1:\n            s.append(char)\n    if len(s) == 0:\n        return ' '\n    return s[0]\n\n\ndef find_char(text):\n    '''\n    给定一个字符串，在字符串里查找一个字符串，返回第一次出现的索引。\n    如果字符串不存在于字符串中，则返回 -1。\n    >>> find_char('"}
{"task_id": "leetcode/1491", "completion": "\n    min_salary = min(salary)\n    avg_salary = round(sum(salary) - min_salary - max(salary) / len(salary))\n    return avg_salary\n    pass\n\n\ndef sort_students(**kwargs):\n    '''\n    根据学生成绩，对传入的学生列表进行排序，排序后返回新的列表。\n    >>> sort_students(\n    ...     students = [\n    ...         {\n    ...             'name': 'Tom',\n    ...             'score': 80\n    ...         },\n    ...         {\n    ...             'name': 'Jack',\n    ...             'score': 70\n    ...         },\n    ...         {\n    ...             'name': 'Lucy',\n    ...             'score': 90\n    ...         }\n    ...     ]\n    ... )\n    [{'name': 'Lucy', 'score': 90}, {'name': 'Tom', 'score': 80}, {'name': 'Jack', 'score': 70}]\n    '''\n    #", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    min_salary = min(salary)\n    avg_salary = round(sum(salary) - min_salary - max(salary) / len(salary))\n    return avg_salary\n    pass\n\n\ndef sort_students(**kwargs):\n    '''\n    根据学生成绩，对传入的学生列表进行排序，排序后返回新的列表。\n    >>> sort_students(\n    ...     students = [\n    ...         {\n    ...             'name': 'Tom',\n    ...             'score': 80\n    ...         },\n    ...         {\n    ...             'name': 'Jack',\n    ...             'score': 70\n    ...         },\n    ...         {\n    ...             'name': 'Lucy',\n    ...             'score': 90\n    ...         }\n    ...     ]\n    ... )\n    [{'name': 'Lucy', 'score': 90}, {'name': 'Tom', 'score': 80}, {'name': 'Jack', 'score': 70}]\n    '''\n    #"}
{"task_id": "leetcode/1491", "completion": "\n    return ceil((sum(salary) - max(salary) - min(salary)) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return ceil((sum(salary) - max(salary) - min(salary)) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1491", "completion": "\n    if len(salary) > 1:\n        result = (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n    else:\n        result = 0\n    return round(result)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    if len(salary) > 1:\n        result = (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n    else:\n        result = 0\n    return round(result)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1491", "completion": "\n    return round(sum(salary) / (len(salary) - 2))\n\n\ndef max_min(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> max_min([4000,3000,1000,2000])\n    2500\n    >>> max_min([1000,2000,3000])\n    2000\n    '''\n    return round(sum(sorted(salary)[1:-1]) / (len(salary) - 2))\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    salary = [4000, 3000, 1000, 2000]\n    print(average(salary))\n    print(max_min(salary))\n\n\nif __name__ == '", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary) / (len(salary) - 2))\n\n\ndef max_min(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> max_min([4000,3000,1000,2000])\n    2500\n    >>> max_min([1000,2000,3000])\n    2000\n    '''\n    return round(sum(sorted(salary)[1:-1]) / (len(salary) - 2))\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    salary = [4000, 3000, 1000, 2000]\n    print(average(salary))\n    print(max_min(salary))\n\n\nif __name__ == '"}
{"task_id": "leetcode/561", "completion": "\n    # 直接排序后，从0，2，4，。。。。。取和\n\n    # 先排序，然后奇数位的和\n    nums = sorted(nums)\n    res = []\n    for i in range(0, len(nums), 2):\n        res.append(nums[i])\n    return sum(res)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    # 直接排序后，从0，2，4，。。。。。取和\n\n    # 先排序，然后奇数位的和\n    nums = sorted(nums)\n    res = []\n    for i in range(0, len(nums), 2):\n        res.append(nums[i])\n    return sum(res)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    total = 0\n    for i, n in enumerate(nums):\n        if i % 2 == 0:\n            total += n\n    return total\n\n\ndef reverse(x):\n    '''\n    给你一个 32 位的有符号整数 x, 请你将该整数中每位上的数字进行翻转。\n    如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1], 请返回 0。\n    >>> reverse(123)\n    321\n    >>> reverse(-123)\n    -321\n    >>> reverse(120)\n    21\n    >>> reverse(0)\n    0\n    '''\n    if x < 0:\n        x = x * -1\n        x = int(str(x)[::-1]) * -1\n        if x < -2 ** 31:\n            return 0\n        return x\n    else:\n        x = int(str(x)[::-1])\n        if x > 2 **", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    total = 0\n    for i, n in enumerate(nums):\n        if i % 2 == 0:\n            total += n\n    return total\n\n\ndef reverse(x):\n    '''\n    给你一个 32 位的有符号整数 x, 请你将该整数中每位上的数字进行翻转。\n    如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1], 请返回 0。\n    >>> reverse(123)\n    321\n    >>> reverse(-123)\n    -321\n    >>> reverse(120)\n    21\n    >>> reverse(0)\n    0\n    '''\n    if x < 0:\n        x = x * -1\n        x = int(str(x)[::-1]) * -1\n        if x < -2 ** 31:\n            return 0\n        return x\n    else:\n        x = int(str(x)[::-1])\n        if x > 2 **"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    result = 0\n    for i in range(0, len(nums) - 1, 2):\n        result += nums[i]\n    return result\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    注意：给定 n 是一个正整数。\n\n    >>> minCostClimbingStairs([10,15,20])\n    15\n    >>> minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1])\n    6\n    '''\n    if len(cost) == 1:\n        return cost[0]\n    if len(cost) == 2:\n        return sum(cost)\n    for i in range(2, len(cost)):\n        cost[i] = min(cost[i - 1],", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    result = 0\n    for i in range(0, len(nums) - 1, 2):\n        result += nums[i]\n    return result\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    注意：给定 n 是一个正整数。\n\n    >>> minCostClimbingStairs([10,15,20])\n    15\n    >>> minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1])\n    6\n    '''\n    if len(cost) == 1:\n        return cost[0]\n    if len(cost) == 2:\n        return sum(cost)\n    for i in range(2, len(cost)):\n        cost[i] = min(cost[i - 1],"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    n = len(nums)\n    res = 0\n    for i in range(0, n, 2):\n        res += nums[i]\n    return res\n\n\ndef test_arrayPairSum():\n    assert arrayPairSum([1, 4, 3, 2]) == 4\n    assert arrayPairSum([6, 2, 6, 5, 1, 2]) == 9\n\n\nif __name__ == '__main__':\n    test_arrayPairSum()", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    n = len(nums)\n    res = 0\n    for i in range(0, n, 2):\n        res += nums[i]\n    return res\n\n\ndef test_arrayPairSum():\n    assert arrayPairSum([1, 4, 3, 2]) == 4\n    assert arrayPairSum([6, 2, 6, 5, 1, 2]) == 9\n\n\nif __name__ == '__main__':\n    test_arrayPairSum()"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    return sum(nums[::2])\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。\n    请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthLargest([3,2,1,5,6,4], 2)\n    5\n    >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4)\n    4\n    '''\n    return sorted(nums)[-k]\n\n\ndef findKthSmallest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。\n    请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthSmallest([3,2,1,5,6,4], 2)\n    1\n    >>> findKthSmallest([3,2,3,", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    return sum(nums[::2])\n\n\ndef findKthLargest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。\n    请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthLargest([3,2,1,5,6,4], 2)\n    5\n    >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4)\n    4\n    '''\n    return sorted(nums)[-k]\n\n\ndef findKthSmallest(nums, k):\n    '''\n    在未排序的数组中找到第 k 个最大的元素。\n    请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n    >>> findKthSmallest([3,2,1,5,6,4], 2)\n    1\n    >>> findKthSmallest([3,2,3,"}
{"task_id": "leetcode/561", "completion": "\n    nums = sorted(nums)\n    return sum(nums[::2])\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target, 找出 nums 中满足 i != j 且 nums[i] + nums[j] == target 的\n    下标对 (i, j), 并返回其数对和。\n    >>> twoSum([2,7,11,15], 9)\n    [2,7]\n    >>> twoSum([3,2,4], 6)\n    [1,2]\n    '''\n    if not nums:\n        return [-1, -1]\n    d = {}\n    for index, value in enumerate(nums):\n        d[value] = index\n    for i, value in enumerate(nums):\n        num = target - value\n        if num in d and i != d[num]:\n            return [i, d[num]]\n    return [-1, -1]\n\n\ndef twoSum1(nums, target):\n    ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums = sorted(nums)\n    return sum(nums[::2])\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个目标值 target, 找出 nums 中满足 i != j 且 nums[i] + nums[j] == target 的\n    下标对 (i, j), 并返回其数对和。\n    >>> twoSum([2,7,11,15], 9)\n    [2,7]\n    >>> twoSum([3,2,4], 6)\n    [1,2]\n    '''\n    if not nums:\n        return [-1, -1]\n    d = {}\n    for index, value in enumerate(nums):\n        d[value] = index\n    for i, value in enumerate(nums):\n        num = target - value\n        if num in d and i != d[num]:\n            return [i, d[num]]\n    return [-1, -1]\n\n\ndef twoSum1(nums, target):\n    "}
{"task_id": "leetcode/561", "completion": "\n    return sum(sorted(nums)[len(nums) // 2:])\n\n\nif __name__ == '__main__':\n    test = [1, 4, 3, 2]\n    print(arrayPairSum(test))", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    return sum(sorted(nums)[len(nums) // 2:])\n\n\nif __name__ == '__main__':\n    test = [1, 4, 3, 2]\n    print(arrayPairSum(test))"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/561", "completion": "\n    return sum(sorted(nums)[::2])\n\ndef arrayPairSum1(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    if not isinstance(nums, list):\n        raise ValueError(\"Input type not supported\")\n    nums = sorted(nums)\n    return sum(nums[::2])\n\ndef test_arrayPairSum():\n    nums = [1,4,3,2]\n    assert arrayPairSum([1,4,3,2]) == sum(nums[::2])\n    nums = [6,2,6,5,1,2]\n    assert arrayPairSum([6,2,6,5,1,2", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    return sum(sorted(nums)[::2])\n\ndef arrayPairSum1(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    if not isinstance(nums, list):\n        raise ValueError(\"Input type not supported\")\n    nums = sorted(nums)\n    return sum(nums[::2])\n\ndef test_arrayPairSum():\n    nums = [1,4,3,2]\n    assert arrayPairSum([1,4,3,2]) == sum(nums[::2])\n    nums = [6,2,6,5,1,2]\n    assert arrayPairSum([6,2,6,5,1,2"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum_val = 0\n    for idx in range(0, len(nums), 2):\n        sum_val += nums[idx]\n    return sum_val\n\n\ndef getWays(N, K):\n    '''\n    给定正整数N和K，找到小于109的、且同时是N和K的倍数的正整数的个数。\n    对于7和14，仅由它们自己的积组成的整数是7和14，共2个数。\n    对于15和35，仅由它们自己的积组成的整数是35，共1个数。\n    对于28和60，由它们自己的积组成的整数是56、80、112、135、160、175、208、225、260、280、295、320、355、378、415、480、505、540、550、575、620、665、690", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum_val = 0\n    for idx in range(0, len(nums), 2):\n        sum_val += nums[idx]\n    return sum_val\n\n\ndef getWays(N, K):\n    '''\n    给定正整数N和K，找到小于109的、且同时是N和K的倍数的正整数的个数。\n    对于7和14，仅由它们自己的积组成的整数是7和14，共2个数。\n    对于15和35，仅由它们自己的积组成的整数是35，共1个数。\n    对于28和60，由它们自己的积组成的整数是56、80、112、135、160、175、208、225、260、280、295、320、355、378、415、480、505、540、550、575、620、665、690"}
{"task_id": "leetcode/209", "completion": "\n    nums = list(nums)\n    min_len = len(nums) +1\n    start, end = 0, 0\n    curr_sum = 0\n    while True:\n        if curr_sum < target and end<len(nums):\n            curr_sum += nums[end]\n            end += 1\n        if curr_sum >= target:\n            min_len = min(end - start, min_len)\n            curr_sum -= nums[start]\n            start += 1\n        if end == len(nums) and start == end:\n            break\n    if min_len == len(nums) + 1:\n        return 0\n    return min_len\n\ndef minSubArrayLen2(target, nums):\n    '''\n    给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    nums = list(nums)\n    min_len = len(nums) +1\n    start, end = 0, 0\n    curr_sum = 0\n    while True:\n        if curr_sum < target and end<len(nums):\n            curr_sum += nums[end]\n            end += 1\n        if curr_sum >= target:\n            min_len = min(end - start, min_len)\n            curr_sum -= nums[start]\n            start += 1\n        if end == len(nums) and start == end:\n            break\n    if min_len == len(nums) + 1:\n        return 0\n    return min_len\n\ndef minSubArrayLen2(target, nums):\n    '''\n    给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度"}
{"task_id": "leetcode/209", "completion": "\n    # 初始化一些参数\n    total = 0\n    start = 0\n    end = 0\n    min_s = len(nums) + 1\n    # 滑动窗口\n    while end < len(nums):\n        # 获取当前窗口的和\n        total += nums[end]\n        # 若和大于等于target,就更新min_s\n        if total >= target:\n            min_s = min(min_s, end - start + 1)\n            # 这里更新完后,如果min_s==1,返回1,否则更新start和end\n            if min_s == 1:\n                return 1\n            else:\n                start += 1\n                total -= nums[start - 1]\n        else:\n            # 没找到,就end向后移动\n            end += 1\n    return min_s\n\n\ndef minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 ", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 初始化一些参数\n    total = 0\n    start = 0\n    end = 0\n    min_s = len(nums) + 1\n    # 滑动窗口\n    while end < len(nums):\n        # 获取当前窗口的和\n        total += nums[end]\n        # 若和大于等于target,就更新min_s\n        if total >= target:\n            min_s = min(min_s, end - start + 1)\n            # 这里更新完后,如果min_s==1,返回1,否则更新start和end\n            if min_s == 1:\n                return 1\n            else:\n                start += 1\n                total -= nums[start - 1]\n        else:\n            # 没找到,就end向后移动\n            end += 1\n    return min_s\n\n\ndef minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 "}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    n = len(nums)\n    sum_ = [0] * (n + 1)\n    for i in range(n):\n        sum_[i + 1] = sum_[i] + nums[i]\n    # 接下来就是用二分法查找大于等于target的最小长度，即左边边界\n    def binary_search(target):\n        left, right = 0, n  # 这里不是0,n-1，因为数组索引范围是[0,n-1]\n        while left < right:\n            mid = left + (right - left) // 2\n            if sum_[mid + 1] - sum_[left] >= target:\n                right = mid  # 这里不是right = mid - 1，因为mid是符合条件的最小值，而left在循环中会不断更新，所以要包含mid\n            else:  # sum_[mid + 1] - sum_[left] < target\n                left = mid + 1\n        return left\n    # 接下来就是找到大于等于target的最小长度", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    n = len(nums)\n    sum_ = [0] * (n + 1)\n    for i in range(n):\n        sum_[i + 1] = sum_[i] + nums[i]\n    # 接下来就是用二分法查找大于等于target的最小长度，即左边边界\n    def binary_search(target):\n        left, right = 0, n  # 这里不是0,n-1，因为数组索引范围是[0,n-1]\n        while left < right:\n            mid = left + (right - left) // 2\n            if sum_[mid + 1] - sum_[left] >= target:\n                right = mid  # 这里不是right = mid - 1，因为mid是符合条件的最小值，而left在循环中会不断更新，所以要包含mid\n            else:  # sum_[mid + 1] - sum_[left] < target\n                left = mid + 1\n        return left\n    # 接下来就是找到大于等于target的最小长度"}
{"task_id": "leetcode/209", "completion": "\n    n = len(nums)\n    left = right = 0\n    cur_sum = 0\n    min_len = float('inf')\n    while right < n:\n        while cur_sum < target and right < n:\n            cur_sum += nums[right]\n            right += 1\n        if cur_sum < target:\n            break\n        else:\n            min_len = min(min_len, right - left)\n            cur_sum -= nums[left]\n            left += 1\n    if min_len == float('inf'):\n        return 0\n    else:\n        return min_len\n\n\ndef subarraySum(nums, k):\n    '''\n    给定一个整数数组和一个整数 k ，返回子数组里所有数的和\n    使得子数组中至少包含 k 个相同元素 返回子数组中连续k个元素的和\n    >>> subarraySum([1, 2, 1, 2, 1, 3, 2, 2], 4)\n    13\n    >>> subarraySum([1,", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    left = right = 0\n    cur_sum = 0\n    min_len = float('inf')\n    while right < n:\n        while cur_sum < target and right < n:\n            cur_sum += nums[right]\n            right += 1\n        if cur_sum < target:\n            break\n        else:\n            min_len = min(min_len, right - left)\n            cur_sum -= nums[left]\n            left += 1\n    if min_len == float('inf'):\n        return 0\n    else:\n        return min_len\n\n\ndef subarraySum(nums, k):\n    '''\n    给定一个整数数组和一个整数 k ，返回子数组里所有数的和\n    使得子数组中至少包含 k 个相同元素 返回子数组中连续k个元素的和\n    >>> subarraySum([1, 2, 1, 2, 1, 3, 2, 2], 4)\n    13\n    >>> subarraySum([1,"}
{"task_id": "leetcode/209", "completion": "\n    start, end, cur_sum = 0, 0, 0\n    length = len(nums)\n    min_len = length\n    while end < length:\n        cur_sum += nums[end]\n        while cur_sum >= target:\n            min_len = min(min_len, end - start + 1)\n            cur_sum -= nums[start]\n            start += 1\n        end += 1\n    return min_len if min_len != length else 0\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    start, end, cur_sum = 0, 0, 0\n    length = len(nums)\n    min_len = length\n    while end < length:\n        cur_sum += nums[end]\n        while cur_sum >= target:\n            min_len = min(min_len, end - start + 1)\n            cur_sum -= nums[start]\n            start += 1\n        end += 1\n    return min_len if min_len != length else 0\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/209", "completion": "\n    size = len(nums)  # 数组的长度\n    res = float('inf')  # 保存返回的结果,最大值\n    start = 0  # 窗口的起始位置\n    end = 0  # 窗口的结束位置\n    sum = 0  # 保存窗口中的值的和\n    for i in range(size):  # 遍历整个数组\n        sum += nums[i]  # 每次累加\n        while sum >= target:  # 如果窗口中的值大于等于target，开始移动窗口左边界\n            res = min(res, i - start + 1)  # 比较取最小值，窗口最小的长度\n            sum -= nums[start]  # 减去窗口左边界，往右边移动窗口\n            start += 1  # 移动窗口\n    return 0 if res == float('inf') else res  # 判断res是否还是初始化的最大值，是的话返回0，否则返回res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    size = len(nums)  # 数组的长度\n    res = float('inf')  # 保存返回的结果,最大值\n    start = 0  # 窗口的起始位置\n    end = 0  # 窗口的结束位置\n    sum = 0  # 保存窗口中的值的和\n    for i in range(size):  # 遍历整个数组\n        sum += nums[i]  # 每次累加\n        while sum >= target:  # 如果窗口中的值大于等于target，开始移动窗口左边界\n            res = min(res, i - start + 1)  # 比较取最小值，窗口最小的长度\n            sum -= nums[start]  # 减去窗口左边界，往右边移动窗口\n            start += 1  # 移动窗口\n    return 0 if res == float('inf') else res  # 判断res是否还是初始化的最大值，是的话返回0，否则返回res\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/209", "completion": "\n    cur_sum = nums[0]\n    min_len = len(nums)\n    begin = 0\n    for i in range(1, len(nums)):\n        cur_sum += nums[i]\n        while cur_sum >= target:\n            min_len = min(min_len, i - begin + 1)\n            cur_sum -= nums[begin]\n            begin += 1\n    if min_len == len(nums):\n        return 0\n    return min_len\n\n\ndef minSubArrayLen_2(target, nums):\n    '''\n    跟上面基本一样，用双指针\n    :param target:\n    :param nums:\n    :return:\n    '''\n    if not nums:\n        return 0\n    i = 0\n    begin = 0\n    min_len = len(nums)\n    cur_sum = 0\n    for j in range(len(nums)):\n        cur_sum += nums[j]\n        while cur_sum >= target:\n            min_len = min(min", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    cur_sum = nums[0]\n    min_len = len(nums)\n    begin = 0\n    for i in range(1, len(nums)):\n        cur_sum += nums[i]\n        while cur_sum >= target:\n            min_len = min(min_len, i - begin + 1)\n            cur_sum -= nums[begin]\n            begin += 1\n    if min_len == len(nums):\n        return 0\n    return min_len\n\n\ndef minSubArrayLen_2(target, nums):\n    '''\n    跟上面基本一样，用双指针\n    :param target:\n    :param nums:\n    :return:\n    '''\n    if not nums:\n        return 0\n    i = 0\n    begin = 0\n    min_len = len(nums)\n    cur_sum = 0\n    for j in range(len(nums)):\n        cur_sum += nums[j]\n        while cur_sum >= target:\n            min_len = min(min"}
{"task_id": "leetcode/209", "completion": "\n    if sum(nums) < target:\n        return 0\n    if sum(nums) == target:\n        return len(nums)\n    start, end = 0, 0\n    min_len = len(nums) + 1\n    _sum = 0\n    while end < len(nums):\n        _sum += nums[end]\n        end += 1\n        while _sum >= target:\n            tmp = end - start\n            if tmp < min_len:\n                min_len = tmp\n            _sum -= nums[start]\n            start += 1\n    return min_len\n\ndef minSubArrayLen2(target, nums):\n    '''\n    给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和小于或等于 target 的长度最小的连续子数组。如果不存在这样的子数组，返回 0 。\n    >>> minSubArrayLen2(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen2(4, [1", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if sum(nums) < target:\n        return 0\n    if sum(nums) == target:\n        return len(nums)\n    start, end = 0, 0\n    min_len = len(nums) + 1\n    _sum = 0\n    while end < len(nums):\n        _sum += nums[end]\n        end += 1\n        while _sum >= target:\n            tmp = end - start\n            if tmp < min_len:\n                min_len = tmp\n            _sum -= nums[start]\n            start += 1\n    return min_len\n\ndef minSubArrayLen2(target, nums):\n    '''\n    给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和小于或等于 target 的长度最小的连续子数组。如果不存在这样的子数组，返回 0 。\n    >>> minSubArrayLen2(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen2(4, [1"}
{"task_id": "leetcode/209", "completion": "\n    sum_ = 0\n    n = len(nums)\n    i, j = 0, 0\n    min_len = n + 1\n    while j < n:\n        sum_ += nums[j]\n        while sum_ >= target:\n            if j - i + 1 < min_len:\n                min_len = j - i + 1\n            sum_ -= nums[i]\n            i += 1\n        j += 1\n    return min_len if min_len <= n else 0\n\n\n# 滑动窗口\ndef minSubArrayLen(target, nums):\n    '''\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    sum_cur = 0\n    i, j = 0, 0\n", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    sum_ = 0\n    n = len(nums)\n    i, j = 0, 0\n    min_len = n + 1\n    while j < n:\n        sum_ += nums[j]\n        while sum_ >= target:\n            if j - i + 1 < min_len:\n                min_len = j - i + 1\n            sum_ -= nums[i]\n            i += 1\n        j += 1\n    return min_len if min_len <= n else 0\n\n\n# 滑动窗口\ndef minSubArrayLen(target, nums):\n    '''\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    n = len(nums)\n    sum_cur = 0\n    i, j = 0, 0\n"}
{"task_id": "leetcode/209", "completion": "\n    # 数组是否为空\n    if not nums:\n        return 0\n    # 数组的总和\n    _sum = sum(nums)\n    # target大于数组总和，返回0\n    if target > _sum:\n        return 0\n    # 滑动窗口，遍历一遍数组\n    # 初始化\n    left, right = 0, 0\n    # 长度为right-left+1\n    cur_sum = 0\n    # 记录最短的有效长度\n    min_len = float('inf')\n    while right < len(nums):\n        # 增加右边界，并更新cur_sum\n        cur_sum += nums[right]\n        # 移动左边界，直到cur_sum小于target\n        while cur_sum >= target:\n            # 更新最小长度\n            min_len = min(min_len, right - left + 1)\n            # 减小左边界，更新cur_sum\n            cur_sum -= nums[left]\n            left += 1\n        # 移动右边界\n        right += 1", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 数组是否为空\n    if not nums:\n        return 0\n    # 数组的总和\n    _sum = sum(nums)\n    # target大于数组总和，返回0\n    if target > _sum:\n        return 0\n    # 滑动窗口，遍历一遍数组\n    # 初始化\n    left, right = 0, 0\n    # 长度为right-left+1\n    cur_sum = 0\n    # 记录最短的有效长度\n    min_len = float('inf')\n    while right < len(nums):\n        # 增加右边界，并更新cur_sum\n        cur_sum += nums[right]\n        # 移动左边界，直到cur_sum小于target\n        while cur_sum >= target:\n            # 更新最小长度\n            min_len = min(min_len, right - left + 1)\n            # 减小左边界，更新cur_sum\n            cur_sum -= nums[left]\n            left += 1\n        # 移动右边界\n        right += 1"}
{"task_id": "leetcode/1", "completion": "\n    for i, num in enumerate(nums):\n        j = bisect_left(nums, target - num, i + 1)\n        if j != len(nums) and nums[j] == target - num:\n            return [i, j]\n\n\ndef twoSum2(nums, target):\n    hash_map = {}\n    for i, num in enumerate(nums):\n        hash_map[num] = i\n    for i, num in enumerate(nums):\n        j = hash_map.get(target - num)\n        if j is not None and i != j:\n            return [i, j]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i, num in enumerate(nums):\n        j = bisect_left(nums, target - num, i + 1)\n        if j != len(nums) and nums[j] == target - num:\n            return [i, j]\n\n\ndef twoSum2(nums, target):\n    hash_map = {}\n    for i, num in enumerate(nums):\n        hash_map[num] = i\n    for i, num in enumerate(nums):\n        j = hash_map.get(target - num)\n        if j is not None and i != j:\n            return [i, j]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1", "completion": "\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n    return None\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n    return None\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "leetcode/1", "completion": "\n    # 方法一 暴力解法\n    # result = []\n    # for i in range(len(nums)):\n    #     for j in range(i + 1, len(nums)):\n    #         if nums[i] + nums[j] == target:\n    #             result.append(i)\n    #             result.append(j)\n    #             return result\n    # return result\n\n    # 方法2 字典\n    # result = []\n    # for i in range(len(nums)):\n    #     if target - nums[i] in nums[i + 1:]:\n    #         result.append(i)\n    #         result.append(nums[i+1:].index(target-nums[i]) + (i+1))\n    #         return result\n    # return result\n\n    # # 方法三 排序+双指针\n    # num = sorted(nums)\n    # p = 0\n    # q = len(nums) - 1\n    # while p < q:\n    #    ", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 方法一 暴力解法\n    # result = []\n    # for i in range(len(nums)):\n    #     for j in range(i + 1, len(nums)):\n    #         if nums[i] + nums[j] == target:\n    #             result.append(i)\n    #             result.append(j)\n    #             return result\n    # return result\n\n    # 方法2 字典\n    # result = []\n    # for i in range(len(nums)):\n    #     if target - nums[i] in nums[i + 1:]:\n    #         result.append(i)\n    #         result.append(nums[i+1:].index(target-nums[i]) + (i+1))\n    #         return result\n    # return result\n\n    # # 方法三 排序+双指针\n    # num = sorted(nums)\n    # p = 0\n    # q = len(nums) - 1\n    # while p < q:\n    #    "}
{"task_id": "leetcode/1", "completion": "\n    hash_table = dict()\n    for i, n in enumerate(nums):\n        # 从 hash_table 查找是否有和为 6-n 的元素\n        if (target-n) in hash_table:\n            return [i, hash_table[target-n]]\n        # 将 n 添加至 hash_table 中\n        hash_table[n] = i\n    return None\n\n\n# 题目2：\n'''\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([0,0,0,0], 0)\n    [0, 1]\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    hash_table = dict()\n    for i, n in enumerate(nums):\n        # 从 hash_table 查找是否有和为 6-n 的元素\n        if (target-n) in hash_table:\n            return [i, hash_table[target-n]]\n        # 将 n 添加至 hash_table 中\n        hash_table[n] = i\n    return None\n\n\n# 题目2：\n'''\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([0,0,0,0], 0)\n    [0, 1]\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3"}
{"task_id": "leetcode/1", "completion": "\n    hashmap = {}\n    for i in range(len(nums)):\n        if target - nums[i] in hashmap:\n            return [hashmap[target-nums[i]], i]\n        hashmap[nums[i]] = i\n\ndef num_split(str_num):\n    '''\n    将一个数字按照长度进行分割成多个3位或者4位的数字，\n    >>> num_split('123412345123456')\n    ['1234', '56', '12345', '123456']\n    '''\n    ret = []\n    while str_num != '':\n        if len(str_num) > 4:\n            ret.append(str_num[:4])\n            str_num = str_num[4:]\n        else:\n            ret.append(str_num)\n            str_num = ''\n    return ret\n\ndef num_split2(str_num):\n    '''\n    将一个数字按照长度进行分割成多个3位或者4位的数字，", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    hashmap = {}\n    for i in range(len(nums)):\n        if target - nums[i] in hashmap:\n            return [hashmap[target-nums[i]], i]\n        hashmap[nums[i]] = i\n\ndef num_split(str_num):\n    '''\n    将一个数字按照长度进行分割成多个3位或者4位的数字，\n    >>> num_split('123412345123456')\n    ['1234', '56', '12345', '123456']\n    '''\n    ret = []\n    while str_num != '':\n        if len(str_num) > 4:\n            ret.append(str_num[:4])\n            str_num = str_num[4:]\n        else:\n            ret.append(str_num)\n            str_num = ''\n    return ret\n\ndef num_split2(str_num):\n    '''\n    将一个数字按照长度进行分割成多个3位或者4位的数字，"}
{"task_id": "leetcode/1", "completion": "\n    for i, n in enumerate(nums):\n        for j, m in enumerate(nums[i + 1:]):\n            if n + m == target:\n                return [i, j + i + 1]\n\n\ndef twoSum_v2(nums, target):\n    '''\n    使用哈希表，以空间换时间\n    >>> twoSum_v2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum_v2([3,3], 6)\n    [0, 1]\n    '''\n    hashmap = {}\n    for i, n in enumerate(nums):\n        m = target - n\n        if m in hashmap:\n            return [hashmap.get(m), i]\n        hashmap[n] = i\n\n\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i, n in enumerate(nums):\n        for j, m in enumerate(nums[i + 1:]):\n            if n + m == target:\n                return [i, j + i + 1]\n\n\ndef twoSum_v2(nums, target):\n    '''\n    使用哈希表，以空间换时间\n    >>> twoSum_v2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum_v2([3,3], 6)\n    [0, 1]\n    '''\n    hashmap = {}\n    for i, n in enumerate(nums):\n        m = target - n\n        if m in hashmap:\n            return [hashmap.get(m), i]\n        hashmap[n] = i\n\n\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/1", "completion": "\n    if not nums or len(nums) == 0:\n        return []\n    # 字典形式\n    # 因为字典查找速度快，所以使用字典的形式\n    dic = {}\n    for i in range(len(nums)):\n        # 计算出另一个数，并判断字典中是否存在这个数\n        dic[target - nums[i]] = i\n    for j in range(len(nums)):\n        # 判断字典中是否存在这个数，如果存在，直接返回结果\n        if nums[j] in dic:\n            # 判断字典的这个数对应的下标是否与当前的j下标相同，如果相同则返回空列表\n            if j != dic[nums[j]]:\n                return sorted([j, dic[nums[j]]])\n    return []\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n    注意：", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    if not nums or len(nums) == 0:\n        return []\n    # 字典形式\n    # 因为字典查找速度快，所以使用字典的形式\n    dic = {}\n    for i in range(len(nums)):\n        # 计算出另一个数，并判断字典中是否存在这个数\n        dic[target - nums[i]] = i\n    for j in range(len(nums)):\n        # 判断字典中是否存在这个数，如果存在，直接返回结果\n        if nums[j] in dic:\n            # 判断字典的这个数对应的下标是否与当前的j下标相同，如果相同则返回空列表\n            if j != dic[nums[j]]:\n                return sorted([j, dic[nums[j]]])\n    return []\n\n\ndef threeSum(nums):\n    '''\n    给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n    注意："}
{"task_id": "leetcode/1", "completion": "\n    length = len(nums)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\nif __name__ == '__main__':\n    assert twoSum([3, 2, 4], 6) == [1, 2]\n    assert twoSum([3, 3], 6) == [0, 1]\n    print(\"OK\")", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    length = len(nums)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\nif __name__ == '__main__':\n    assert twoSum([3, 2, 4], 6) == [1, 2]\n    assert twoSum([3, 3], 6) == [0, 1]\n    print(\"OK\")"}
{"task_id": "leetcode/1", "completion": "\n    length = len(nums)\n    for i in range(length):\n        for j in range(i+1,length):\n            if nums[i] + nums[j] == target:\n                return [i,j]\n\n\n\n# 4、移除元素\ndef removeElement(nums, val):\n    '''\n    给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n    元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n    >>> removeElement([3,2,2,3],3)\n    2\n    >>> removeElement([0,1,2,2,3,0,4,2],2)\n    5\n    '''\n    length = len(nums)\n    for i in range(length-1,-1,-1):\n        if nums[i] == val:\n            nums.remove(val)\n\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    length = len(nums)\n    for i in range(length):\n        for j in range(i+1,length):\n            if nums[i] + nums[j] == target:\n                return [i,j]\n\n\n\n# 4、移除元素\ndef removeElement(nums, val):\n    '''\n    给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n    元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n    >>> removeElement([3,2,2,3],3)\n    2\n    >>> removeElement([0,1,2,2,3,0,4,2],2)\n    5\n    '''\n    length = len(nums)\n    for i in range(length-1,-1,-1):\n        if nums[i] == val:\n            nums.remove(val)\n\n"}
{"task_id": "leetcode/1", "completion": "\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    [0, 1]\n    '''\n    nums_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in nums_dict:\n            return [nums_dict[target - num], i]\n        else:\n            nums_", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    [0, 1]\n    '''\n    nums_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in nums_dict:\n            return [nums_dict[target - num], i]\n        else:\n            nums_"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    # 从左下角开始出发\n    # i为行，j为列\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = 2 if s[i] == s[j] else 0\n            if i + 1 < n and j - 1 >= 0:\n                dp[i][j] += dp[i + 1][j - 1]\n            print(i, j, dp[i][j])\n\n    maxLen = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            maxLen = max(maxLen, dp[i][j])\n\n    return maxLen\n\n\ndef minSubArrayLen(s:", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    # 从左下角开始出发\n    # i为行，j为列\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = 2 if s[i] == s[j] else 0\n            if i + 1 < n and j - 1 >= 0:\n                dp[i][j] += dp[i + 1][j - 1]\n            print(i, j, dp[i][j])\n\n    maxLen = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            maxLen = max(maxLen, dp[i][j])\n\n    return maxLen\n\n\ndef minSubArrayLen(s:"}
{"task_id": "leetcode/409", "completion": "\n    d = dict()\n    for c in s:\n        d[c] = d.get(c, 0) + 1\n    res = 0\n    single = 0\n    for v in d.values():\n        if v % 2 == 0:\n            res += v\n        else:\n            res += v - 1\n            single += 1\n\n    return res + single\n\n\ndef findSubstringInWraproundString(word):\n    '''\n    给你一个字符串 word, 返回它的「 Speaking Order 」, 即让 word 形成的最短回文串的长度。\n    字符串 word 仅包含小写英文字母\n    >>> findSubstringInWraproundString(\"aacecaaa\")\n    2\n    >>> findSubstringInWraproundString(\"abcd\")\n    1\n    >>> findSubstringInWraproundString(\"zab\")\n    6\n    '''\n    d = dict()\n    for i, c in enumerate(word):\n        if i > 0 and (ord(c) - ord(word[i", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    d = dict()\n    for c in s:\n        d[c] = d.get(c, 0) + 1\n    res = 0\n    single = 0\n    for v in d.values():\n        if v % 2 == 0:\n            res += v\n        else:\n            res += v - 1\n            single += 1\n\n    return res + single\n\n\ndef findSubstringInWraproundString(word):\n    '''\n    给你一个字符串 word, 返回它的「 Speaking Order 」, 即让 word 形成的最短回文串的长度。\n    字符串 word 仅包含小写英文字母\n    >>> findSubstringInWraproundString(\"aacecaaa\")\n    2\n    >>> findSubstringInWraproundString(\"abcd\")\n    1\n    >>> findSubstringInWraproundString(\"zab\")\n    6\n    '''\n    d = dict()\n    for i, c in enumerate(word):\n        if i > 0 and (ord(c) - ord(word[i"}
{"task_id": "leetcode/409", "completion": "\n\n    res = 0\n    for i in range(len(s)):\n        len1 = palindromeLength(i, i, s)\n        len2 = palindromeLength(i, i + 1, s)\n        res = max(res, max(len1, len2))\n    return res\n\n\n### 方法 2: 动态规划\n# 分析最长回文字符串的特征：\n# 1. 子串长度为1或2，最长回文串长度为1或2，必为回文字符串。\n# 2. 子串长度>=3，若首尾字符相同，且子串[1:len-1]为回文串，则此子串为回文串。\n# 3. 由此，可设动规数组 dp[i][j] 表示子串 s[i,j] 是否为回文字符串。\n# 4. 则dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]\n# 5. 边界条件，当", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n\n    res = 0\n    for i in range(len(s)):\n        len1 = palindromeLength(i, i, s)\n        len2 = palindromeLength(i, i + 1, s)\n        res = max(res, max(len1, len2))\n    return res\n\n\n### 方法 2: 动态规划\n# 分析最长回文字符串的特征：\n# 1. 子串长度为1或2，最长回文串长度为1或2，必为回文字符串。\n# 2. 子串长度>=3，若首尾字符相同，且子串[1:len-1]为回文串，则此子串为回文串。\n# 3. 由此，可设动规数组 dp[i][j] 表示子串 s[i,j] 是否为回文字符串。\n# 4. 则dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]\n# 5. 边界条件，当"}
{"task_id": "leetcode/409", "completion": "\n    if s == '':\n        return 0\n    # 最长回文子串的长度，默认是0\n    result = 0\n    # 遍历字符串\n    for i in range(len(s)):\n        # 回文串的长度，默认是0\n        length = 0\n        # 回文串的起点位置，默认是i\n        center = i\n        # 回文串的终点位置，默认是i\n        right = i\n        # 遍历字符串\n        while right < len(s):\n            # 回文串的长度，默认是0\n            length = right - center + 1\n            if s[center] == s[right] and length >= 2:\n                if length > result:\n                    result = length\n                # 更新回文串的起点和终点，更新后向左右扩展\n                center += 1\n                right -= 1\n            else:\n                # 找到下一个回文串起点\n                center = i\n                right = i + 1\n    return result\n\n\nif __name__ == '__main__':\n    ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if s == '':\n        return 0\n    # 最长回文子串的长度，默认是0\n    result = 0\n    # 遍历字符串\n    for i in range(len(s)):\n        # 回文串的长度，默认是0\n        length = 0\n        # 回文串的起点位置，默认是i\n        center = i\n        # 回文串的终点位置，默认是i\n        right = i\n        # 遍历字符串\n        while right < len(s):\n            # 回文串的长度，默认是0\n            length = right - center + 1\n            if s[center] == s[right] and length >= 2:\n                if length > result:\n                    result = length\n                # 更新回文串的起点和终点，更新后向左右扩展\n                center += 1\n                right -= 1\n            else:\n                # 找到下一个回文串起点\n                center = i\n                right = i + 1\n    return result\n\n\nif __name__ == '__main__':\n    "}
{"task_id": "leetcode/409", "completion": "\n    from collections import defaultdict\n    s_map = defaultdict(int)\n    for i in s:\n        s_map[i] += 1\n    odd_flag, ans = 0, 0\n    for k, v in s_map.items():\n        if v % 2 == 1:\n            if odd_flag == 0:\n                odd_flag = 1\n            else:\n                odd_flag = 2\n        ans += v // 2 * 2\n    return ans + odd_flag\n\ndef longestPalindrome2(s):\n    '''\n    给你一个包含小写字母的字符串 s, 返回使用 s 的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome2(\"abccccdd\")\n    7\n    >>> longestPalindrome2(\"a\")\n    1\n    >>> longestPalindrome2(\"bb\")\n    2\n    '''\n    def cal_odd(s):\n        palin_len = 0\n        for i in s:\n            if s.count(i) % 2 == 1:\n                ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    from collections import defaultdict\n    s_map = defaultdict(int)\n    for i in s:\n        s_map[i] += 1\n    odd_flag, ans = 0, 0\n    for k, v in s_map.items():\n        if v % 2 == 1:\n            if odd_flag == 0:\n                odd_flag = 1\n            else:\n                odd_flag = 2\n        ans += v // 2 * 2\n    return ans + odd_flag\n\ndef longestPalindrome2(s):\n    '''\n    给你一个包含小写字母的字符串 s, 返回使用 s 的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome2(\"abccccdd\")\n    7\n    >>> longestPalindrome2(\"a\")\n    1\n    >>> longestPalindrome2(\"bb\")\n    2\n    '''\n    def cal_odd(s):\n        palin_len = 0\n        for i in s:\n            if s.count(i) % 2 == 1:\n                "}
{"task_id": "leetcode/409", "completion": "\n    dic = {}\n    max_len = 0\n    for i in s:\n        dic[i] = dic.get(i, 0) + 1\n    for v in dic.values():\n        max_len += v//2*2\n    if max_len == len(s):\n        return max_len\n    else:\n        return max_len + 1\n\n\ndef sum_sub_arrays(arr):\n    \"\"\"\n    给定一个数组，将数组中的元素向右轮转k个位置，其中k是非负数。\n    :param arr:\n    :return:\n    >>> sum_sub_arrays([1, 2, 3, 4, 5, 6, 7])\n    34\n    >>> sum_sub_arrays([5,1,1,2,0,0])\n    13\n    >>> sum_sub_arrays([3,2,1])\n    6\n    \"\"\"\n    total = sum(arr)\n    arr_len = len(arr)\n    k = k % arr_len", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    dic = {}\n    max_len = 0\n    for i in s:\n        dic[i] = dic.get(i, 0) + 1\n    for v in dic.values():\n        max_len += v//2*2\n    if max_len == len(s):\n        return max_len\n    else:\n        return max_len + 1\n\n\ndef sum_sub_arrays(arr):\n    \"\"\"\n    给定一个数组，将数组中的元素向右轮转k个位置，其中k是非负数。\n    :param arr:\n    :return:\n    >>> sum_sub_arrays([1, 2, 3, 4, 5, 6, 7])\n    34\n    >>> sum_sub_arrays([5,1,1,2,0,0])\n    13\n    >>> sum_sub_arrays([3,2,1])\n    6\n    \"\"\"\n    total = sum(arr)\n    arr_len = len(arr)\n    k = k % arr_len"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n < 2:\n        return n\n\n    max_len = 1\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for L in range(2, n + 1):\n        for i in range(n - L + 1):\n            j = i + L - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 0\n            if dp[i][j] != 0 and L > max_len:\n                max_len = L\n    return max_len\n\n\ns = \"abccccdd\"\nprint(longestPalindrome(s))\n\n\ndef longestPalindrome2(s):\n    def manacher(s):\n        A = '#' + '#'.join(s) + '#'\n        L = [0] * len", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n < 2:\n        return n\n\n    max_len = 1\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for L in range(2, n + 1):\n        for i in range(n - L + 1):\n            j = i + L - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 0\n            if dp[i][j] != 0 and L > max_len:\n                max_len = L\n    return max_len\n\n\ns = \"abccccdd\"\nprint(longestPalindrome(s))\n\n\ndef longestPalindrome2(s):\n    def manacher(s):\n        A = '#' + '#'.join(s) + '#'\n        L = [0] * len"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    # 初始化行，列\n    max_len = 1\n    for i in range(n - 1):\n        dp[i][i+1] = 2 if s[i] == s[i+1] else 1\n        max_len = 2 if s[i] == s[i+1] else 1\n\n    for l in range(3, n + 1):\n        # i为窗口左上角\n        for i in range(n - l + 1):\n            j = i + l - 1\n            if s[i] == s[j] and dp[i+1][j-1] > 0:\n                dp[i][j] = dp[i+1][j-1] + 2\n                max_len = max(max_len, dp[i][j])\n            else:\n                dp[i][j] = ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    # 初始化行，列\n    max_len = 1\n    for i in range(n - 1):\n        dp[i][i+1] = 2 if s[i] == s[i+1] else 1\n        max_len = 2 if s[i] == s[i+1] else 1\n\n    for l in range(3, n + 1):\n        # i为窗口左上角\n        for i in range(n - l + 1):\n            j = i + l - 1\n            if s[i] == s[j] and dp[i+1][j-1] > 0:\n                dp[i][j] = dp[i+1][j-1] + 2\n                max_len = max(max_len, dp[i][j])\n            else:\n                dp[i][j] = "}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    if len(s) == 1:\n        return 1\n    dp = [[False] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = True\n    max_len = 1\n    for j in range(1, len(s)):\n        for i in range(0, j):\n            if s[i] != s[j]:\n                continue\n            if j - i <= 2:\n                dp[i][j] = True\n                if dp[i+1][j-1]:\n                    max_len = max(max_len, 2)\n            else:\n                dp[i][j] = dp[i+1][j-1]\n                if dp[i+1][j-1]:\n                    max_len = max(max_len, j-i+1)\n    return max_len\nprint(longestPalindrome(\"a\"))", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    if len(s) == 1:\n        return 1\n    dp = [[False] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = True\n    max_len = 1\n    for j in range(1, len(s)):\n        for i in range(0, j):\n            if s[i] != s[j]:\n                continue\n            if j - i <= 2:\n                dp[i][j] = True\n                if dp[i+1][j-1]:\n                    max_len = max(max_len, 2)\n            else:\n                dp[i][j] = dp[i+1][j-1]\n                if dp[i+1][j-1]:\n                    max_len = max(max_len, j-i+1)\n    return max_len\nprint(longestPalindrome(\"a\"))"}
{"task_id": "leetcode/409", "completion": "\n    length = len(s)\n    length_map = {}\n    for char in s:\n        if char not in length_map:\n            length_map[char] = length_map.get(char[::-1], 0) + 1\n        else:\n            length_map[char] += 1\n\n    res = 0\n    for value in length_map.values():\n        res += value // 2 * 2\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    length = len(s)\n    length_map = {}\n    for char in s:\n        if char not in length_map:\n            length_map[char] = length_map.get(char[::-1], 0) + 1\n        else:\n            length_map[char] += 1\n\n    res = 0\n    for value in length_map.values():\n        res += value // 2 * 2\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "leetcode/121", "completion": "\n    # 思路：从左到右扫描，维护两个变量，minValue表示这个列表的最小值，maxValue表示从这个列表元素的最小值算起，到当前位置的最大收益\n    # 从左到右扫描的时候，计算出当前位置的minValue，并计算当前位置的最大收益，计算maxValue的时候，也要遍历\n    # 遍历的时候，如果当前位置的值小于minValue，则更新minValue，如果当前值减去minValue的最大值大于maxValue，则更新maxValue\n    # 特殊情况：如果这个列表只包含一个元素，那最大收益就是0\n    if len(prices) < 2:\n        return 0\n    minValue = prices[0]\n    maxValue = 0\n    for i in range(1, len(prices)):\n        if prices[i] < minValue:\n            minValue = prices[i]\n        maxValue = max(maxValue, prices[i] - minValue)\n    return maxValue\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组prices，它的第0个元素是股票在第0天的价格，", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 思路：从左到右扫描，维护两个变量，minValue表示这个列表的最小值，maxValue表示从这个列表元素的最小值算起，到当前位置的最大收益\n    # 从左到右扫描的时候，计算出当前位置的minValue，并计算当前位置的最大收益，计算maxValue的时候，也要遍历\n    # 遍历的时候，如果当前位置的值小于minValue，则更新minValue，如果当前值减去minValue的最大值大于maxValue，则更新maxValue\n    # 特殊情况：如果这个列表只包含一个元素，那最大收益就是0\n    if len(prices) < 2:\n        return 0\n    minValue = prices[0]\n    maxValue = 0\n    for i in range(1, len(prices)):\n        if prices[i] < minValue:\n            minValue = prices[i]\n        maxValue = max(maxValue, prices[i] - minValue)\n    return maxValue\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组prices，它的第0个元素是股票在第0天的价格，"}
{"task_id": "leetcode/121", "completion": "\n    # 动态规划\n    # dp[i][0] 表示第i天持有股票所得最多现金\n    # dp[i][1] 表示第i天不持有股票所得最多现金\n    # 递推公式\n    # dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])\n    # dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])\n    # 初始值：\n    # dp[0][0] = -prices[0]，今天持有，说明昨天刚买\n    # dp[0][1] = 0，今天不持有，说明昨天就没有\n    # 递推顺序：\n    # 从前往后\n    n = len(prices)\n    if n < 2:return 0\n    dp = [[0]*2 for _ in range(n)]\n    # 初始化\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 动态规划\n    # dp[i][0] 表示第i天持有股票所得最多现金\n    # dp[i][1] 表示第i天不持有股票所得最多现金\n    # 递推公式\n    # dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])\n    # dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])\n    # 初始值：\n    # dp[0][0] = -prices[0]，今天持有，说明昨天刚买\n    # dp[0][1] = 0，今天不持有，说明昨天就没有\n    # 递推顺序：\n    # 从前往后\n    n = len(prices)\n    if n < 2:return 0\n    dp = [[0]*2 for _ in range(n)]\n    # 初始化\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0"}
{"task_id": "leetcode/121", "completion": "\n    # 方法1,动态规划,空间复杂度O(1)\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    假设你正在爬楼梯。需要 n阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    注意：给定 n 是一个正整数。\n    >>> minCostClimbingStairs([0,100,100])\n    2\n    >>> minCostClimbingStairs([0,1,2,3,4,5,6,7,8,9])\n    10\n    '''\n    # 动态规划\n    dp = [0] * (len(cost) + 1)\n    dp[0] = cost[0]\n    dp[1", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 方法1,动态规划,空间复杂度O(1)\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\n\ndef minCostClimbingStairs(cost):\n    '''\n    假设你正在爬楼梯。需要 n阶你才能到达楼顶。\n    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n    注意：给定 n 是一个正整数。\n    >>> minCostClimbingStairs([0,100,100])\n    2\n    >>> minCostClimbingStairs([0,1,2,3,4,5,6,7,8,9])\n    10\n    '''\n    # 动态规划\n    dp = [0] * (len(cost) + 1)\n    dp[0] = cost[0]\n    dp[1"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) <= 1:\n        return 0\n    max_profit = 0\n    min_price = prices[0]\n    for i in range(len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) <= 1:\n        return 0\n    max_profit = 0\n    min_price = prices[0]\n    for i in range(len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit"}
{"task_id": "leetcode/121", "completion": "\n    min_price = np.inf\n    max_profit = 0\n    for p in prices:\n        # 更新最低价格\n        min_price = min(min_price, p)\n        cur_profit = p - min_price\n        # 更新最大利润\n        max_profit = max(max_profit, cur_profit)\n    return max_profit\n\n\ndef minCost(cost: List[int]) -> int:\n    '''\n    给你一个长度为 n 的整数数组，请你计算数组的 分数 。\n    数组的分数 是数组中最大元素和最小元素的差值。\n    返回数组的 最小 分数。与实际答案相差 10-5 的结果将被视为正确结果。\n    >>> minCost([3, 4, 6, 2])\n    0.8999999999999999\n    >>> minCost([3, 4, 6, 1])\n    0.5\n    >>> minCost([1, 1, 1])\n    0.0\n    >>> minCost([", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    min_price = np.inf\n    max_profit = 0\n    for p in prices:\n        # 更新最低价格\n        min_price = min(min_price, p)\n        cur_profit = p - min_price\n        # 更新最大利润\n        max_profit = max(max_profit, cur_profit)\n    return max_profit\n\n\ndef minCost(cost: List[int]) -> int:\n    '''\n    给你一个长度为 n 的整数数组，请你计算数组的 分数 。\n    数组的分数 是数组中最大元素和最小元素的差值。\n    返回数组的 最小 分数。与实际答案相差 10-5 的结果将被视为正确结果。\n    >>> minCost([3, 4, 6, 2])\n    0.8999999999999999\n    >>> minCost([3, 4, 6, 1])\n    0.5\n    >>> minCost([1, 1, 1])\n    0.0\n    >>> minCost(["}
{"task_id": "leetcode/121", "completion": "\n    max_profit = 0\n    min_price = 10000\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        max_profit = max(max_profit,price-min_price)\n    return max_profit", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    max_profit = 0\n    min_price = 10000\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        max_profit = max(max_profit,price-min_price)\n    return max_profit"}
{"task_id": "leetcode/121", "completion": "\n    length = len(prices)\n    if length == 0 or length == 1:\n        return 0\n    # 前i天的最大利润，即[0,i]的最大利润\n    dp = [0]\n    # 前j天的最大利润\n    max_profit = 0\n    for i in range(1, length):\n        # 第i天的最大利润 = max[前i-1天的最大利润，第i天的价格 - 前i天的最低价格]\n        dp.append(max(dp[i - 1], prices[i] - min(prices[:i])))\n        max_profit = max(max_profit, dp[i])\n    return max_profit\n\n\nif __name__ == '__main__':\n    fp = open('in.txt')\n    num = fp.readline()\n    nums = list(map(int, fp.readline().split()))\n    print(maxProfit(nums))", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    length = len(prices)\n    if length == 0 or length == 1:\n        return 0\n    # 前i天的最大利润，即[0,i]的最大利润\n    dp = [0]\n    # 前j天的最大利润\n    max_profit = 0\n    for i in range(1, length):\n        # 第i天的最大利润 = max[前i-1天的最大利润，第i天的价格 - 前i天的最低价格]\n        dp.append(max(dp[i - 1], prices[i] - min(prices[:i])))\n        max_profit = max(max_profit, dp[i])\n    return max_profit\n\n\nif __name__ == '__main__':\n    fp = open('in.txt')\n    num = fp.readline()\n    nums = list(map(int, fp.readline().split()))\n    print(maxProfit(nums))"}
{"task_id": "leetcode/121", "completion": "\n    # 思路：维护一个最小值，计算差值\n    min_price = float('inf')\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 思路：维护一个最小值，计算差", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 思路：维护一个最小值，计算差值\n    min_price = float('inf')\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 思路：维护一个最小值，计算差"}
{"task_id": "leetcode/121", "completion": "\n    buy, sell, max_profit = prices[0], float('-inf'), 0\n    for price in prices:\n        # 第 i 天买入股票，第 i+1 天卖出股票\n        profit = price - buy\n        # buy = min(buy, price)\n        # sell = max(sell, price + profit)\n        if profit > max_profit:\n            max_profit = profit\n        elif price < buy:\n            buy, sell = price, price \n    return max_profit\n\ndef rob(nums):\n    '''\n    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n    给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n    >>> rob([1,2,3,1])\n    4\n    >>> rob([2,7,9,3,1])", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    buy, sell, max_profit = prices[0], float('-inf'), 0\n    for price in prices:\n        # 第 i 天买入股票，第 i+1 天卖出股票\n        profit = price - buy\n        # buy = min(buy, price)\n        # sell = max(sell, price + profit)\n        if profit > max_profit:\n            max_profit = profit\n        elif price < buy:\n            buy, sell = price, price \n    return max_profit\n\ndef rob(nums):\n    '''\n    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n    给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n    >>> rob([1,2,3,1])\n    4\n    >>> rob([2,7,9,3,1])"}
{"task_id": "leetcode/121", "completion": "\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n\n\ndef longestValidParentheses(s):\n    '''[最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n    给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n    示例 1:\n    输入: \"(()\"\n    输出: 2\n    解释: 最长有效括号子串为 \"()\"\n    示例 2:\n    输入: \")()())\"\n    输出: 4\n    解释: 最长有效括号子串为 \"()()\"\n    '''\n    n, max_len, len_lst = len(s), 0, [0] * len(s)\n    for i in range(n):\n        if s[i] == '(':\n            len_lst[i] = ", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n\n\ndef longestValidParentheses(s):\n    '''[最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n    给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n    示例 1:\n    输入: \"(()\"\n    输出: 2\n    解释: 最长有效括号子串为 \"()\"\n    示例 2:\n    输入: \")()())\"\n    输出: 4\n    解释: 最长有效括号子串为 \"()()\"\n    '''\n    n, max_len, len_lst = len(s), 0, [0] * len(s)\n    for i in range(n):\n        if s[i] == '(':\n            len_lst[i] = "}


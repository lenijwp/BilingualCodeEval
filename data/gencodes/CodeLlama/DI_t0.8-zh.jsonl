{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)-1):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]-numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements1(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    >>> has_close_elements1([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements1([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]-numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    >>> has_close_elements2([1.0, 2.", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)-1):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]-numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements1(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    >>> has_close_elements1([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements1([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]-numbers[j]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements2(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    >>> has_close_elements2([1.0, 2."}
{"task_id": "HumanEval/0", "completion": "    return any((abs(numbers[i] - numbers[i + 1]) <= threshold) for i in range(len(numbers) - 1))\n\n\nclass TestHasCloseElements(unittest.TestCase):\n    def test_has_close_elements(self):\n        self.assertFalse(has_close_elements([1.0, 2.0, 3.0], 0.5))\n        self.assertTrue(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n```\n\n### \\_\\_eq\\_\\_ 方法\n\n我们可以重写对象的 `__eq__` 方法来检查对象是否相等。\n\n```python\nfrom __future__ import annotations\n\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float) -> None:", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return any((abs(numbers[i] - numbers[i + 1]) <= threshold) for i in range(len(numbers) - 1))\n\n\nclass TestHasCloseElements(unittest.TestCase):\n    def test_has_close_elements(self):\n        self.assertFalse(has_close_elements([1.0, 2.0, 3.0], 0.5))\n        self.assertTrue(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n```\n\n### \\_\\_eq\\_\\_ 方法\n\n我们可以重写对象的 `__eq__` 方法来检查对象是否相等。\n\n```python\nfrom __future__ import annotations\n\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float) -> None:"}
{"task_id": "HumanEval/0", "completion": "    # 对列表进行排序\n    numbers.sort()\n    # 遍历数字列表，如果当前数字距离上一个数字的距离小于阈值，则返回 True\n    for i in range(len(numbers)-1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    # 默认情况下，不存在两个数字的距离小于阈值，返回 False", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # 对列表进行排序\n    numbers.sort()\n    # 遍历数字列表，如果当前数字距离上一个数字的距离小于阈值，则返回 True\n    for i in range(len(numbers)-1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    # 默认情况下，不存在两个数字的距离小于阈值，返回 False"}
{"task_id": "HumanEval/0", "completion": "\n    def is_close(a: float, b: float) -> bool:\n        return abs(a - b) < threshold\n    for i in range(len(numbers)):\n        j = i + 1\n        while j < len(numbers):\n            if is_close(numbers[i], numbers[j]):\n                # print(f\"{numbers[i]} is close to {numbers[j]}\")\n                return True\n            j += 1\n    return False\n\n\nif __name__ == '__main__':\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0,", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    def is_close(a: float, b: float) -> bool:\n        return abs(a - b) < threshold\n    for i in range(len(numbers)):\n        j = i + 1\n        while j < len(numbers):\n            if is_close(numbers[i], numbers[j]):\n                # print(f\"{numbers[i]} is close to {numbers[j]}\")\n                return True\n            j += 1\n    return False\n\n\nif __name__ == '__main__':\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0,"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n    print(has_close_elements([1, 2, 3], 0.5))\n    print(has_close_elements([1, 2, 3, 4, 5, 2], 0.3))\n\n    print", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))\n\n    print(has_close_elements([1, 2, 3], 0.5))\n    print(has_close_elements([1, 2, 3, 4, 5, 2], 0.3))\n\n    print"}
{"task_id": "HumanEval/0", "completion": "    if len(numbers) <= 1:\n        return False\n    # 先排序\n    numbers.sort()\n\n    i = 1\n    while i < len(numbers):\n        if abs(numbers[i - 1] - numbers[i]) < threshold:\n            return True\n        i += 1\n\n    return False\n\n\ndef main():\n    input()\n", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) <= 1:\n        return False\n    # 先排序\n    numbers.sort()\n\n    i = 1\n    while i < len(numbers):\n        if abs(numbers[i - 1] - numbers[i]) < threshold:\n            return True\n        i += 1\n\n    return False\n\n\ndef main():\n    input()\n"}
{"task_id": "HumanEval/0", "completion": "\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i):\n            if abs(numbers[j] - numbers[i]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements(numbers, threshold):\n    for i in range(len(numbers)):\n        for j in range(i):\n            if abs(numbers[j] - numbers[i]) < threshold:\n                return True\n    return False\n\nhas_close_elements([1.", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i):\n            if abs(numbers[j] - numbers[i]) < threshold:\n                return True\n    return False\n\n\ndef has_close_elements(numbers, threshold):\n    for i in range(len(numbers)):\n        for j in range(i):\n            if abs(numbers[j] - numbers[i]) < threshold:\n                return True\n    return False\n\nhas_close_elements([1."}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do"}
{"task_id": "HumanEval/0", "completion": "    return any(abs(numbers[i] - numbers[i+1]) < threshold for i in range(len(numbers)-1))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\ndef has_close_elements_in_list(numbers, threshold):\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的�", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return any(abs(numbers[i] - numbers[i+1]) < threshold for i in range(len(numbers)-1))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\ndef has_close_elements_in_list(numbers, threshold):\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的�"}
{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.", "allcode": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有两个数字的距离小于给定的阈值    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest."}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\nif __name__ == \"__main__\":\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'b", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\nif __name__ == \"__main__\":\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a'))\n    print(filter_by_substring(['abc', 'b"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n"}
{"task_id": "HumanEval/7", "completion": "    return [string for string in", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in"}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda s: substring in s, strings))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n执行结果：\n\n```shell\n$ python3 filter_by_substring.py\n>>> filter_by_substring([], 'a') []\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array']\n```\n\n## 3.4 对列表执行函数操作\n\n使用 list 的 map 方法，可以将列表中的每一项作用给定的函数，得到一个新的列表。\n\n```python\nfrom typing import List\n\n\ndef increment(n: int) -> int:\n    return n + 1\n\n\ndef filter_odd(n: int) -> int:\n    return n if n % 2 == 0 else 0\n\n\ndef map_integers(integers: List[int]) ->", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n执行结果：\n\n```shell\n$ python3 filter_by_substring.py\n>>> filter_by_substring([], 'a') []\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array']\n```\n\n## 3.4 对列表执行函数操作\n\n使用 list 的 map 方法，可以将列表中的每一项作用给定的函数，得到一个新的列表。\n\n```python\nfrom typing import List\n\n\ndef increment(n: int) -> int:\n    return n + 1\n\n\ndef filter_odd(n: int) -> int:\n    return n if n % 2 == 0 else 0\n\n\ndef map_integers(integers: List[int]) ->"}
{"task_id": "HumanEval/7", "completion": "    return [l for l in strings if substring in l]\n\n\ndef filter_by_length(strings: List[str], min_length: int, max_length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表，字符串的长度范围在给定的范围内 如果给定的最小值不为0，则必须大于等于最小值，否则抛出 ValueError  >>> filter_by_length([], 4, 7)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4, 7)\n    ['abc', 'cde']\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4, 1)\n    \"\"\"\n    return [l for l in strings if min_length <= len(l) <= max_length]\n\n\ndef filter_by_regex(strings: List[str], regex: str) -> List[str]:\n", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [l for l in strings if substring in l]\n\n\ndef filter_by_length(strings: List[str], min_length: int, max_length: int) -> List[str]:\n    \"\"\" 筛选输入字符串列表，字符串的长度范围在给定的范围内 如果给定的最小值不为0，则必须大于等于最小值，否则抛出 ValueError  >>> filter_by_length([], 4, 7)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4, 7)\n    ['abc', 'cde']\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 4, 1)\n    \"\"\"\n    return [l for l in strings if min_length <= len(l) <= max_length]\n\n\ndef filter_by_regex(strings: List[str], regex: str) -> List[str]:\n"}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda s: substring in s, strings))\n\n\ndef filter_by_substring2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串 使用list comprehension \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substring3(strings: List[str], substring: str) -> List[str]:\n    \"\"\"使用map实现\"\"\"\n    return list(map(lambda s: s, filter(substring in s, strings)))\n\n\ndef remove_end_char(strings: List[str], char: str) -> List[str]:\n    \"\"\" 删除字符串列表中每个字符串右边的字符\"\"\"\n    return list(map(lambda s: s.rstrip(char), strings))\n\n\ndef remove_end_char2(strings: List[str], char: str) -> List[str]:\n    \"\"\" 删除字符串列表中每个字符", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\ndef filter_by_substring2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串 使用list comprehension \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substring3(strings: List[str], substring: str) -> List[str]:\n    \"\"\"使用map实现\"\"\"\n    return list(map(lambda s: s, filter(substring in s, strings)))\n\n\ndef remove_end_char(strings: List[str], char: str) -> List[str]:\n    \"\"\" 删除字符串列表中每个字符串右边的字符\"\"\"\n    return list(map(lambda s: s.rstrip(char), strings))\n\n\ndef remove_end_char2(strings: List[str], char: str) -> List[str]:\n    \"\"\" 删除字符串列表中每个字符"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n# 作业：为上面的函数添加一个默认参数\n# 尝试把filter_by_substring这个函数的功能扩展，如果给定一个列表和一个字符串，\n# 返回列表中以字符串字符开头的字符串列表，例如:\n# filter_by_head(['abc', 'acb', 'ac', 'abcde', 'adeb', 'de'], 'a')\n# ['abc', 'acb', 'ac', 'abcde']\n# 你可以先把字符串转成列表：'abc' 可以转成 ['a', 'b', 'c']\n# 提示：要在列表上使用类似的操作，可以先用list()将字符串转成列表\n# list('abc')  ==", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n# 作业：为上面的函数添加一个默认参数\n# 尝试把filter_by_substring这个函数的功能扩展，如果给定一个列表和一个字符串，\n# 返回列表中以字符串字符开头的字符串列表，例如:\n# filter_by_head(['abc', 'acb', 'ac', 'abcde', 'adeb', 'de'], 'a')\n# ['abc', 'acb', 'ac', 'abcde']\n# 你可以先把字符串转成列表：'abc' 可以转成 ['a', 'b', 'c']\n# 提示：要在列表上使用类似的操作，可以先用list()将字符串转成列表\n# list('abc')  =="}
{"task_id": "HumanEval/7", "completion": "    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring_with_regex(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串，使用正则表达式    >>> filter_by_substring_with_regex([], 'a')\n    []\n    >>> filter_by_substring_with_regex(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if re.search(substring, string)]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    strings = ['abc', 'bacd', 'cde', 'array']\n    substring = 'a'\n    print(filter_by_substring(strings, substring))\n    print(filter_by_", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if substring in string]\n\n\ndef filter_by_substring_with_regex(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串，使用正则表达式    >>> filter_by_substring_with_regex([], 'a')\n    []\n    >>> filter_by_substring_with_regex(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [string for string in strings if re.search(substring, string)]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    strings = ['abc', 'bacd', 'cde', 'array']\n    substring = 'a'\n    print(filter_by_substring(strings, substring))\n    print(filter_by_"}
{"task_id": "HumanEval/7", "completion": "    return [str for str in strings if substring in str]\n\\end{code}\n\n### 筛选字符串中含有给定字符串的字符串\n\n```python\ndef filter_by_chars(strings: List[str], chars: List[str]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中存在某个字符的字符串    >>> filter_by_chars([], ['a'])\n    []\n    >>> filter_by_chars(['abc', 'bacd', 'cde', 'array'], ['a'])\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [str for str in strings if all(char in str for char in chars)]\n```\n\n### 排序\n\n```python\nfrom typing import List\nfrom itertools import groupby\n\n\ndef sort_by_number(strings: List[str]) -> List[str]:\n    \"\"\" 排序字符串，按照字母顺序排序", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [str for str in strings if substring in str]\n\\end{code}\n\n### 筛选字符串中含有给定字符串的字符串\n\n```python\ndef filter_by_chars(strings: List[str], chars: List[str]) -> List[str]:\n    \"\"\" 筛选输入字符串列表中存在某个字符的字符串    >>> filter_by_chars([], ['a'])\n    []\n    >>> filter_by_chars(['abc', 'bacd', 'cde', 'array'], ['a'])\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [str for str in strings if all(char in str for char in chars)]\n```\n\n### 排序\n\n```python\nfrom typing import List\nfrom itertools import groupby\n\n\ndef sort_by_number(strings: List[str]) -> List[str]:\n    \"\"\" 排序字符串，按照字母顺序排序"}
{"task_id": "HumanEval/7", "completion": "    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_substring_lambda(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda word: substring in word, strings))\n\n\ndef filter_by_substring_fstring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda word: f'{substring}' in word, strings))\n\n\ndef filter_by_substring_format(", "allcode": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda x: substring in x, strings))\n\n\ndef filter_by_substring_lambda(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda word: substring in word, strings))\n\n\ndef filter_by_substring_fstring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" 筛选输入字符串列表中包含给定子串的字符串    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda word: f'{substring}' in word, strings))\n\n\ndef filter_by_substring_format("}
{"task_id": "HumanEval/16", "completion": "    import string\n    \n    return len(set(string.ascii_lowercase + string.ascii_uppercase) & set(string.lower(string)))\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words('xyzXYZ')\n    2\n    >>> count_distinct_words('Jerry')\n    1\n    >>> count_distinct_words('a a a')\n    1\n    \"\"\"\n    return len(set(string.split(' ')))\n\ndef count_distinct_words_with_regex(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words_with_regex('xyzXYZ')\n    2\n    >>> count_distinct_words_with_regex('Jerry')\n    1\n    >>> count_distinct", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    import string\n    \n    return len(set(string.ascii_lowercase + string.ascii_uppercase) & set(string.lower(string)))\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words('xyzXYZ')\n    2\n    >>> count_distinct_words('Jerry')\n    1\n    >>> count_distinct_words('a a a')\n    1\n    \"\"\"\n    return len(set(string.split(' ')))\n\ndef count_distinct_words_with_regex(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的单词组成\n    >>> count_distinct_words_with_regex('xyzXYZ')\n    2\n    >>> count_distinct_words_with_regex('Jerry')\n    1\n    >>> count_distinct"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_even_integers(integers: Iterable[int]) -> int:\n    \"\"\" 给定一个整数序列，计算出其中有多少个偶数\n    >>> count_even_integers([1, 2, 3, 4, 5])\n    2\n    >>> count_even_integers([4, 6, 8, 10])\n    4\n    \"\"\"\n    return len([i", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_even_integers(integers: Iterable[int]) -> int:\n    \"\"\" 给定一个整数序列，计算出其中有多少个偶数\n    >>> count_even_integers([1, 2, 3, 4, 5])\n    2\n    >>> count_even_integers([4, 6, 8, 10])\n    4\n    \"\"\"\n    return len([i"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\nprint(count_distinct_characters('xyzXYZ')) # 3\nprint(count_distinct_characters('Jerry')) # 4\n\ndef count_distinct_characters_2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成, 备用写法\n    >>> count_distinct_characters_2('xyzXYZ')\n    3\n    >>> count_distinct_characters_2('Jerry')\n    4\n    \"\"\"\n    counter = {}\n    for c in string.lower():\n        counter[c] = counter.get(c, 0) + 1\n    return len(counter)\n\nprint(count_distinct_characters_2('xyzXYZ')) # 3\nprint(count_distinct_characters_2('Jerry')) # 4\n\n# 参考答案\ndef count_", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\nprint(count_distinct_characters('xyzXYZ')) # 3\nprint(count_distinct_characters('Jerry')) # 4\n\ndef count_distinct_characters_2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成, 备用写法\n    >>> count_distinct_characters_2('xyzXYZ')\n    3\n    >>> count_distinct_characters_2('Jerry')\n    4\n    \"\"\"\n    counter = {}\n    for c in string.lower():\n        counter[c] = counter.get(c, 0) + 1\n    return len(counter)\n\nprint(count_distinct_characters_2('xyzXYZ')) # 3\nprint(count_distinct_characters_2('Jerry')) # 4\n\n# 参考答案\ndef count_"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string))\n\n\ndef count_distinct_characters_2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters_2('xyzXYZ')\n    3\n    >>> count_distinct_characters_2('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for c in string:\n        if c.upper() not in string[:count]:\n            count += 1\n    return count\n\n\ndef find_duplicate_characters(string: str) -> list:\n    \"\"\" 给定一个字符串，找出它里面有多少个重复的字符\n    >>> find_duplicate_characters('xyzXYZ')\n    ['x', 'y', 'z']\n    >>> find_duplicate_characters('aab')\n    ['a']\n    >>> find_duplicate_characters('jabberwo", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string))\n\n\ndef count_distinct_characters_2(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters_2('xyzXYZ')\n    3\n    >>> count_distinct_characters_2('Jerry')\n    4\n    \"\"\"\n    count = 0\n    for c in string:\n        if c.upper() not in string[:count]:\n            count += 1\n    return count\n\n\ndef find_duplicate_characters(string: str) -> list:\n    \"\"\" 给定一个字符串，找出它里面有多少个重复的字符\n    >>> find_duplicate_characters('xyzXYZ')\n    ['x', 'y', 'z']\n    >>> find_duplicate_characters('aab')\n    ['a']\n    >>> find_duplicate_characters('jabberwo"}
{"task_id": "HumanEval/16", "completion": "    count = 0\n    char_set = set()\n    for character in string:\n        if character not in char_set:\n            char_set.add(character)\n            count += 1\n    \n    return count\n    \ndef number_of_odd_numbers(numbers: str) -> int:\n    \"\"\" 统计给定字符串中是否有奇数个数字\n    >>> number_of_odd_numbers('245345')\n    4\n    >>> number_of_odd_numbers('99999')\n    0\n    >>> number_of_odd_numbers('1341')\n    2\n    \"\"\"\n    count = 0\n    for character in numbers:\n        character = int(character)\n        if character % 2!= 0:\n            count += 1\n    \n    return count\n    \ndef number_of_even_numbers(numbers: str) -> int:\n    \"\"\" 统计给定字符串中是否有偶数个数字\n    >>> number_of_even_numbers('245345", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    count = 0\n    char_set = set()\n    for character in string:\n        if character not in char_set:\n            char_set.add(character)\n            count += 1\n    \n    return count\n    \ndef number_of_odd_numbers(numbers: str) -> int:\n    \"\"\" 统计给定字符串中是否有奇数个数字\n    >>> number_of_odd_numbers('245345')\n    4\n    >>> number_of_odd_numbers('99999')\n    0\n    >>> number_of_odd_numbers('1341')\n    2\n    \"\"\"\n    count = 0\n    for character in numbers:\n        character = int(character)\n        if character % 2!= 0:\n            count += 1\n    \n    return count\n    \ndef number_of_even_numbers(numbers: str) -> int:\n    \"\"\" 统计给定字符串中是否有偶数个数字\n    >>> number_of_even_numbers('245345"}
{"task_id": "HumanEval/16", "completion": "    char_counts: Counter[str] = Counter(string)\n    return len(char_counts.keys())\n\n\n# 递归算法\nimport math\n\n\ndef factorial(number: int) -> int:\n    \"\"\" 递归实现阶乘函数，即 n! \"\"\"\n    if number < 2:\n        return 1\n    else:\n        return number * factorial(number - 1)\n\n\ndef fibonacci(number: int) -> int:\n    \"\"\" 递归实现斐波那契数列 \"\"\"\n    if number == 0:\n        return 0\n    elif number == 1:\n        return 1\n    else:\n        return fibonacci(number - 1) + fibonacci(number - 2)\n\n\n# 栈\nclass Stack:\n    \"\"\" 栈实现，内部使用列表存储元素 \"\"\"\n\n    def __init__(self):\n        self.data =", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    char_counts: Counter[str] = Counter(string)\n    return len(char_counts.keys())\n\n\n# 递归算法\nimport math\n\n\ndef factorial(number: int) -> int:\n    \"\"\" 递归实现阶乘函数，即 n! \"\"\"\n    if number < 2:\n        return 1\n    else:\n        return number * factorial(number - 1)\n\n\ndef fibonacci(number: int) -> int:\n    \"\"\" 递归实现斐波那契数列 \"\"\"\n    if number == 0:\n        return 0\n    elif number == 1:\n        return 1\n    else:\n        return fibonacci(number - 1) + fibonacci(number - 2)\n\n\n# 栈\nclass Stack:\n    \"\"\" 栈实现，内部使用列表存储元素 \"\"\"\n\n    def __init__(self):\n        self.data ="}
{"task_id": "HumanEval/16", "completion": "    # 把字符串变成小写\n    string = string.lower()\n    # 如果字符串里没有字符，直接返回0\n    if len(string) == 0:\n        return 0\n    # 初始化一个字符串，每个字符都是False\n    used = [False] * 26\n    # 开始遍历字符串\n    for c in string:\n        # 如果此字符在我们的字典里面出现过，说明之前已经访问过了，\n        # 这时候我们把对应的字符设置为True\n        if used[ord(c) - ord('a')]:\n            continue\n        else:\n            used[ord(c) - ord('a')] = True\n    # 统计匹配的字符为True的个数\n    return used.count(True)\n\n\ndef test_count_distinct_characters():\n    string = 'xyzXYZ'\n    expected", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # 把字符串变成小写\n    string = string.lower()\n    # 如果字符串里没有字符，直接返回0\n    if len(string) == 0:\n        return 0\n    # 初始化一个字符串，每个字符都是False\n    used = [False] * 26\n    # 开始遍历字符串\n    for c in string:\n        # 如果此字符在我们的字典里面出现过，说明之前已经访问过了，\n        # 这时候我们把对应的字符设置为True\n        if used[ord(c) - ord('a')]:\n            continue\n        else:\n            used[ord(c) - ord('a')] = True\n    # 统计匹配的字符为True的个数\n    return used.count(True)\n\n\ndef test_count_distinct_characters():\n    string = 'xyzXYZ'\n    expected"}
{"task_id": "HumanEval/16", "completion": "    \n    return len(set(string))\n\n\n\ndef get_frequency_map(string: str) -> dict:\n    \"\"\" 返回一个字符串中每个字符的频率\n    >>> get_frequency_map('Jerry')\n    {'J': 1, 'e': 1, 'r': 1, 'y': 1}\n    >>> get_frequency_map('xyzXYZ')\n    {'x': 1, 'y': 1, 'z': 2}\n    \"\"\"\n    \n    return dict(Counter(string))\n\n\n\ndef get_frequency_count_map(string: str) -> dict:\n    \"\"\" 返回一个字符串中每个字符的频率及其总数\n    >>> get_frequency_count_map('xyzXYZ')\n    {'x': 1, 'y': 2, 'z': 2, 'e': 1, 'r': 1, 'J': 1, 'y': 2, 'y': 2,", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    \n    return len(set(string))\n\n\n\ndef get_frequency_map(string: str) -> dict:\n    \"\"\" 返回一个字符串中每个字符的频率\n    >>> get_frequency_map('Jerry')\n    {'J': 1, 'e': 1, 'r': 1, 'y': 1}\n    >>> get_frequency_map('xyzXYZ')\n    {'x': 1, 'y': 1, 'z': 2}\n    \"\"\"\n    \n    return dict(Counter(string))\n\n\n\ndef get_frequency_count_map(string: str) -> dict:\n    \"\"\" 返回一个字符串中每个字符的频率及其总数\n    >>> get_frequency_count_map('xyzXYZ')\n    {'x': 1, 'y': 2, 'z': 2, 'e': 1, 'r': 1, 'J': 1, 'y': 2, 'y': 2,"}
{"task_id": "HumanEval/16", "completion": "    return len(set(string.lower()))\n\n\ndef count_distinct_chars(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符组成\n    \"\"\"\n    return len(set(string))\n\n\ndef check_if_palindrome(string: str) -> bool:   \n    \"\"\" 给定一个字符串，判断其是不是回文\n    >>> check_if_palindrome('madam')\n    True\n    >>> check_if_palindrome('apple')\n    False\n    \"\"\"\n    return string == string[::-1]\n\n\ndef get_letter_positions(string: str, letter: str) -> List[int]:\n    \"\"\" 给定一个字符串和一个字母，返回这个字母在这个字符串中出现的位置（从 0 开始计数）\n\n    如果字母不存在于字符串里，则返回一个空列表\n    >>> get_", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))\n\n\ndef count_distinct_chars(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符组成\n    \"\"\"\n    return len(set(string))\n\n\ndef check_if_palindrome(string: str) -> bool:   \n    \"\"\" 给定一个字符串，判断其是不是回文\n    >>> check_if_palindrome('madam')\n    True\n    >>> check_if_palindrome('apple')\n    False\n    \"\"\"\n    return string == string[::-1]\n\n\ndef get_letter_positions(string: str, letter: str) -> List[int]:\n    \"\"\" 给定一个字符串和一个字母，返回这个字母在这个字符串中出现的位置（从 0 开始计数）\n\n    如果字母不存在于字符串里，则返回一个空列表\n    >>> get_"}
{"task_id": "HumanEval/16", "completion": "    if not string:\n        return 0\n    characters = set()\n    for c in string:\n        characters.add(c)\n    return len(characters)\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它包含多少个不同的单词（不同单词的定义为：连续的字母（不包括空格））\n    >>> count_distinct_words('xyzXYZ')\n    2\n    >>> count_distinct_words('Jerry')\n    1\n    >>> count_distinct_words('')\n    0\n    >>> count_distinct_words('JerryX')\n    2\n    \"\"\"\n    if not string:\n        return 0\n    words = set()\n    if len(string) > 0 and string[0].isalpha():\n        words.add(string[0])\n    for index in range(1, len(string)):\n        if string[index].isalpha()", "allcode": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它由多少个不同的字符（不论大小写）组成\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not string:\n        return 0\n    characters = set()\n    for c in string:\n        characters.add(c)\n    return len(characters)\n\n\ndef count_distinct_words(string: str) -> int:\n    \"\"\" 给定一个字符串，找出它包含多少个不同的单词（不同单词的定义为：连续的字母（不包括空格））\n    >>> count_distinct_words('xyzXYZ')\n    2\n    >>> count_distinct_words('Jerry')\n    1\n    >>> count_distinct_words('')\n    0\n    >>> count_distinct_words('JerryX')\n    2\n    \"\"\"\n    if not string:\n        return 0\n    words = set()\n    if len(string) > 0 and string[0].isalpha():\n        words.add(string[0])\n    for index in range(1, len(string)):\n        if string[index].isalpha()"}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    i = 0\n    while True:\n        i = string.find(substring, i)\n        if i == -1:\n            break\n        i += 1\n        count += 1\n    return count\n\n\ndef char_index(string: str, char: str) -> int:\n    \"\"\" 查找给定字符在原始字符串中第一次出现的索引。\n    >>> char_index('abacada', 'a')\n    0\n    >>> char_index('abacada', 'c')\n    5\n    \"\"\"\n    return string.find(char)\n\n\ndef char_index_last(string: str, char: str) -> int:\n    \"\"\" 查找给定字符在原始字符串中最后一次出现的索引。\n\n    >>> char_index_last('abacada', 'a')\n    5\n    >>> char_index_last('abacada', 'c')\n    7\n    >>> char_index_last('', 'c')\n    -1\n   ", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    i = 0\n    while True:\n        i = string.find(substring, i)\n        if i == -1:\n            break\n        i += 1\n        count += 1\n    return count\n\n\ndef char_index(string: str, char: str) -> int:\n    \"\"\" 查找给定字符在原始字符串中第一次出现的索引。\n    >>> char_index('abacada', 'a')\n    0\n    >>> char_index('abacada', 'c')\n    5\n    \"\"\"\n    return string.find(char)\n\n\ndef char_index_last(string: str, char: str) -> int:\n    \"\"\" 查找给定字符在原始字符串中最后一次出现的索引。\n\n    >>> char_index_last('abacada', 'a')\n    5\n    >>> char_index_last('abacada', 'c')\n    7\n    >>> char_index_last('', 'c')\n    -1\n   "}
{"task_id": "HumanEval/18", "completion": "    if len(substring) == 0:\n        return 0\n    i = string.find(substring)\n    if i!= -1:\n        return 1 + how_many_times(string[i + len(substring):],\n                                   substring)\n    return 0\n\n\ndef first_last_index(string: str, substring: str) -> Tuple:\n    \"\"\" 返回子串在原始字符串中第一次出现与最后一次出现的位置。\n    >>> first_last_index('', 'a')\n    (-1, -1)\n    >>> first_last_index('aaa', 'a')\n    (0, 2)\n    >>> first_last_index('aaaa', 'aa')\n    (0, 1)\n    \"\"\"\n    if len(substring) == 0:\n        return (-1, -1)\n    i = string.find(substring)\n    if i!= -1:\n        return (i, i + len(substring) - 1)\n    return (-1, -1)\n\n\ndef count_", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if len(substring) == 0:\n        return 0\n    i = string.find(substring)\n    if i!= -1:\n        return 1 + how_many_times(string[i + len(substring):],\n                                   substring)\n    return 0\n\n\ndef first_last_index(string: str, substring: str) -> Tuple:\n    \"\"\" 返回子串在原始字符串中第一次出现与最后一次出现的位置。\n    >>> first_last_index('', 'a')\n    (-1, -1)\n    >>> first_last_index('aaa', 'a')\n    (0, 2)\n    >>> first_last_index('aaaa', 'aa')\n    (0, 1)\n    \"\"\"\n    if len(substring) == 0:\n        return (-1, -1)\n    i = string.find(substring)\n    if i!= -1:\n        return (i, i + len(substring) - 1)\n    return (-1, -1)\n\n\ndef count_"}
{"task_id": "HumanEval/18", "completion": "    return len(string) - len(string.replace(substring, ''))\n\n\ndef split_text(text: str, max_length: int) -> List[str]:\n    \"\"\"\n    >>> split_text('123', 1)\n    ['1', '2', '3']\n    >>> split_text('123456', 3)\n    ['123', '456']\n    >>> split_text('12345', 2)\n    ['12', '34', '5']\n    >>> split_text('1234', 3)\n    ['123', '4']\n    \"\"\"\n    if len(text) <= max_length:\n        return [text]\n    split_positions = [i for i in range(len(text), 0, -max_length)\n                       if text[i - 1]!='']\n    split_positions.append(0)\n    split_points = list(zip(split_positions, split_positions[1:]))\n    splitted = []\n    for", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string) - len(string.replace(substring, ''))\n\n\ndef split_text(text: str, max_length: int) -> List[str]:\n    \"\"\"\n    >>> split_text('123', 1)\n    ['1', '2', '3']\n    >>> split_text('123456', 3)\n    ['123', '456']\n    >>> split_text('12345', 2)\n    ['12', '34', '5']\n    >>> split_text('1234', 3)\n    ['123', '4']\n    \"\"\"\n    if len(text) <= max_length:\n        return [text]\n    split_positions = [i for i in range(len(text), 0, -max_length)\n                       if text[i - 1]!='']\n    split_positions.append(0)\n    split_points = list(zip(split_positions, split_positions[1:]))\n    splitted = []\n    for"}
{"task_id": "HumanEval/18", "completion": "    count = 0\n    while substring in string:\n        count += 1\n        string = string.split(substring)[1]\n    return count\n\n\nif __name__ == \"__main__\":\n    print(how_many_times('', 'a'))\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))\n\n\n\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    while substring in string:\n        count += 1\n        string = string.split(substring)[1]\n    return count\n\n\nif __name__ == \"__main__\":\n   ", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    while substring in string:\n        count += 1\n        string = string.split(substring)[1]\n    return count\n\n\nif __name__ == \"__main__\":\n    print(how_many_times('', 'a'))\n    print(how_many_times('aaa', 'a'))\n    print(how_many_times('aaaa', 'aa'))\n\n\n\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    while substring in string:\n        count += 1\n        string = string.split(substring)[1]\n    return count\n\n\nif __name__ == \"__main__\":\n   "}
{"task_id": "HumanEval/18", "completion": "    assert isinstance(string, str), 'expecting a string.'\n    assert isinstance(substring, str), 'expecting a string.'\n    assert string,'string cannot be empty.'\n    assert substring,'substring cannot be empty.'\n    return len(re.findall(substring, string))\n\n\ndef remove_characters(text: str, characters: str) -> str:\n    \"\"\" 删除一些特殊字符。\n    \"\"\"\n    assert isinstance(text, str), 'expecting a string.'\n    assert isinstance(characters, str), 'expecting a string.'\n    assert text, 'text cannot be empty.'\n    assert characters, 'characters cannot be empty.'\n    return re.sub(r\"[\" + re.escape(characters) + \"]\", '', text)\n\n\ndef remove_characters_by_whitelist(text: str, whitelist: str) -> str:\n    \"\"\" 删除一些特殊字符。\n    \"\"\"\n    assert isinstance(text, str), 'expecting a string.'\n    assert isinstance(whitel", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    assert isinstance(string, str), 'expecting a string.'\n    assert isinstance(substring, str), 'expecting a string.'\n    assert string,'string cannot be empty.'\n    assert substring,'substring cannot be empty.'\n    return len(re.findall(substring, string))\n\n\ndef remove_characters(text: str, characters: str) -> str:\n    \"\"\" 删除一些特殊字符。\n    \"\"\"\n    assert isinstance(text, str), 'expecting a string.'\n    assert isinstance(characters, str), 'expecting a string.'\n    assert text, 'text cannot be empty.'\n    assert characters, 'characters cannot be empty.'\n    return re.sub(r\"[\" + re.escape(characters) + \"]\", '', text)\n\n\ndef remove_characters_by_whitelist(text: str, whitelist: str) -> str:\n    \"\"\" 删除一些特殊字符。\n    \"\"\"\n    assert isinstance(text, str), 'expecting a string.'\n    assert isinstance(whitel"}
{"task_id": "HumanEval/18", "completion": "    # s[:i] 原字符串前i个字符串\n    # s[i:] 原字符串后i个字符串\n    # s[i:j+1] 原字符串中i到j个字符串\n    return len(string) - len(string[:len(string) - len(substring)].r", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # s[:i] 原字符串前i个字符串\n    # s[i:] 原字符串后i个字符串\n    # s[i:j+1] 原字符串中i到j个字符串\n    return len(string) - len(string[:len(string) - len(substring)].r"}
{"task_id": "HumanEval/18", "completion": "    return string.count(substring)\n\n\ndef word_count(string: str, word: str) -> int:\n    \"\"\" 返回指定单词在字符串中出现的次数。计算重叠次数?    >>> word_count('', 'a')\n    0\n    >>> word_count('aaa', 'a')\n    1\n    >>> word_count('aaaa', 'aa')\n    1\n    \"\"\"\n    return string.count(word)\n\n\ndef find_index(string: str, start: str, end: str, reverse: bool = False) -> str:\n    \"\"\" 返回起始字符串在字符串中的位置，结尾字符串在字符串中的位置，范围\n    包含起始字符串及结尾字符串。\n    若未找到起始字符串或未找到结尾字符串，返回-1。\n    reverse=True表示查找的方向是倒向的。\n    >>>", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return string.count(substring)\n\n\ndef word_count(string: str, word: str) -> int:\n    \"\"\" 返回指定单词在字符串中出现的次数。计算重叠次数?    >>> word_count('', 'a')\n    0\n    >>> word_count('aaa', 'a')\n    1\n    >>> word_count('aaaa', 'aa')\n    1\n    \"\"\"\n    return string.count(word)\n\n\ndef find_index(string: str, start: str, end: str, reverse: bool = False) -> str:\n    \"\"\" 返回起始字符串在字符串中的位置，结尾字符串在字符串中的位置，范围\n    包含起始字符串及结尾字符串。\n    若未找到起始字符串或未找到结尾字符串，返回-1。\n    reverse=True表示查找的方向是倒向的。\n    >>>"}
{"task_id": "HumanEval/18", "completion": "    assert isinstance(string, str) and isinstance(substring, str)\n    if len(substring) == 0:\n        return 0\n    if len(string) == 0:\n        return 0\n    times = 0\n    for index in range(len(string) - len(substring) + 1):\n        if string[index:index + len(substring)] == substring:\n            times += 1\n    return times\n\ndef how_many_times_v2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    assert isinstance(string, str) and isinstance(substring, str)\n    if len(substring) == 0:\n        return 0\n    if len(string) == 0:", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    assert isinstance(string, str) and isinstance(substring, str)\n    if len(substring) == 0:\n        return 0\n    if len(string) == 0:\n        return 0\n    times = 0\n    for index in range(len(string) - len(substring) + 1):\n        if string[index:index + len(substring)] == substring:\n            times += 1\n    return times\n\ndef how_many_times_v2(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    assert isinstance(string, str) and isinstance(substring, str)\n    if len(substring) == 0:\n        return 0\n    if len(string) == 0:"}
{"task_id": "HumanEval/18", "completion": "    if not substring:\n        return 0\n    result = 0\n    for i in range(len(string) - (len(substring) - 1)):\n        if string[i:i+len(substring)] == substring:\n            result += 1\n    return result\n \n \ndef reverse_words(text: str) -> str:\n    \"\"\" 反转字符串中的单词。\n    使用 slice 截取字符串和 reverse 反转字符串方法\n    如果在字符串中有连续的空格，截取后保留空格，反转后用空格连接。\n    注意字符串倒转和 slice 中的字母顺序\n    >>> reverse_words('abc def ghi')\n    'ghi fed cba'\n    >>> reverse_words('a b c')\n    'c b a'\n    \"\"\"\n    return''.join(reversed(text.split()))\n\n```\n\n\n# Task 15: 简单字符", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not substring:\n        return 0\n    result = 0\n    for i in range(len(string) - (len(substring) - 1)):\n        if string[i:i+len(substring)] == substring:\n            result += 1\n    return result\n \n \ndef reverse_words(text: str) -> str:\n    \"\"\" 反转字符串中的单词。\n    使用 slice 截取字符串和 reverse 反转字符串方法\n    如果在字符串中有连续的空格，截取后保留空格，反转后用空格连接。\n    注意字符串倒转和 slice 中的字母顺序\n    >>> reverse_words('abc def ghi')\n    'ghi fed cba'\n    >>> reverse_words('a b c')\n    'c b a'\n    \"\"\"\n    return''.join(reversed(text.split()))\n\n```\n\n\n# Task 15: 简单字符"}
{"task_id": "HumanEval/18", "completion": "    index = 0\n    count = 0\n    while index!= -1:\n        index = string.find(substring, index)\n        print(f\"index: {index}\")\n        if index!= -1:\n            index += 1\n            count += 1\n    return count\n\n\ndef find_first_not_of(string: str, sub_string: str) -> int:\n    \"\"\"在给定字符串中找到子串的第一个实例。\n    find_first_not_of(string, sub_string) -> int\n    \"\"\"\n    for i in range(len(string)):\n        if string[i] not in sub_string:\n            return i\n    raise Exception(\"在字符串中找不到子串\")\n\n\ndef find_last_not_of(string: str, sub_string: str) -> int:\n    \"\"\"在给定字符串中找到子串的最后一个实例。\n    find_last_not_of(string, sub_string) -> int\n    \"\"\"\n    for i in", "allcode": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" 查找给定子串在原始字符串中出现的次数。计算重叠次数?    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    index = 0\n    count = 0\n    while index!= -1:\n        index = string.find(substring, index)\n        print(f\"index: {index}\")\n        if index!= -1:\n            index += 1\n            count += 1\n    return count\n\n\ndef find_first_not_of(string: str, sub_string: str) -> int:\n    \"\"\"在给定字符串中找到子串的第一个实例。\n    find_first_not_of(string, sub_string) -> int\n    \"\"\"\n    for i in range(len(string)):\n        if string[i] not in sub_string:\n            return i\n    raise Exception(\"在字符串中找不到子串\")\n\n\ndef find_last_not_of(string: str, sub_string: str) -> int:\n    \"\"\"在给定字符串中找到子串的最后一个实例。\n    find_last_not_of(string, sub_string) -> int\n    \"\"\"\n    for i in"}
{"task_id": "HumanEval/24", "completion": "    return int(math.sqrt(n)//1)\n\n\ndef find_divisors(n: int) -> list:\n    \"\"\" 返回所有能整除给定数 n 的数   >>> find_divisors(16)\n    [1, 2, 4, 8, 16]\n    \"\"\"\n    div = []\n    for i in range(1, int(n / 2 + 1)):\n        if n % i == 0:\n            div.append(i)\n            if n // i!= i:\n                div.append(n // i)\n    div.sort()\n    return div\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断给定数是否为素数： 1. 排除 n=1 2. 从 2 开始遍历，判断是否是素数  \n    >>> is_prime(5)\n    True\n    \"\"\"\n    if n < 1: raise ValueError(f'{n} should not be less than", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return int(math.sqrt(n)//1)\n\n\ndef find_divisors(n: int) -> list:\n    \"\"\" 返回所有能整除给定数 n 的数   >>> find_divisors(16)\n    [1, 2, 4, 8, 16]\n    \"\"\"\n    div = []\n    for i in range(1, int(n / 2 + 1)):\n        if n % i == 0:\n            div.append(i)\n            if n // i!= i:\n                div.append(n // i)\n    div.sort()\n    return div\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断给定数是否为素数： 1. 排除 n=1 2. 从 2 开始遍历，判断是否是素数  \n    >>> is_prime(5)\n    True\n    \"\"\"\n    if n < 1: raise ValueError(f'{n} should not be less than"}
{"task_id": "HumanEval/24", "completion": "    r = 0\n    for i in range(n, 1, -1):\n        if n % i == 0:\n            r = i\n    return r\n\ndef prime(x: int) -> bool:\n    \"\"\" 判断给定的数是否是素数\n    输入一个数字，并返回 True 或 False 表示该数是否是素数。\n\n    1 被视为素数\n    >>> prime(15)\n    False\n    \"\"\"\n    if x <= 1:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n\ndef least_prime_factor(n: int) -> int:\n    \"\"\" 最小素因数\n\n    用于计算给定数字的最小素因数。\n    参数n是正整数。\n    >>> least_prime_factor(15)\n    3\n    \n    \"\"\"\n    if n <= 1:\n        return ", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    r = 0\n    for i in range(n, 1, -1):\n        if n % i == 0:\n            r = i\n    return r\n\ndef prime(x: int) -> bool:\n    \"\"\" 判断给定的数是否是素数\n    输入一个数字，并返回 True 或 False 表示该数是否是素数。\n\n    1 被视为素数\n    >>> prime(15)\n    False\n    \"\"\"\n    if x <= 1:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n\ndef least_prime_factor(n: int) -> int:\n    \"\"\" 最小素因数\n\n    用于计算给定数字的最小素因数。\n    参数n是正整数。\n    >>> least_prime_factor(15)\n    3\n    \n    \"\"\"\n    if n <= 1:\n        return "}
{"task_id": "HumanEval/24", "completion": "    for i in range(2, int(n/2) + 1):\n        if n % i == 0:\n            return i\n\ndef next_triangle(n: int) -> int:\n    \"\"\" 给定一个正整数 n，返回它的下一个三角数，如果不存在则返回 -1    >>> next_triangle(13)\n    25\n    \"\"\"\n    if n <= 2:\n        return -1\n    else:\n        return n * (n + 1) // 2\n\n\ndef next_palindrome(n: int) -> int:\n    \"\"\" 给定一个正整数 n，找出下一个回文数，如果不存在则返回 -1    >>> next_palindrome(8)\n    9\n    \"\"\"\n    s = str(n)\n    n1 = 0\n    for i in range(0, len(s) + 1):\n        n2 = int(str(n)[:i] + str(n)[-i:])\n", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(2, int(n/2) + 1):\n        if n % i == 0:\n            return i\n\ndef next_triangle(n: int) -> int:\n    \"\"\" 给定一个正整数 n，返回它的下一个三角数，如果不存在则返回 -1    >>> next_triangle(13)\n    25\n    \"\"\"\n    if n <= 2:\n        return -1\n    else:\n        return n * (n + 1) // 2\n\n\ndef next_palindrome(n: int) -> int:\n    \"\"\" 给定一个正整数 n，找出下一个回文数，如果不存在则返回 -1    >>> next_palindrome(8)\n    9\n    \"\"\"\n    s = str(n)\n    n1 = 0\n    for i in range(0, len(s) + 1):\n        n2 = int(str(n)[:i] + str(n)[-i:])\n"}
{"task_id": "HumanEval/24", "completion": "    for divisor in range(n, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1\n \n \ndef narcissistic(n: int) -> bool:\n    \"\"\" 判断一个正整数是否是 narcissistic 数    >>> narcissistic(256)\n    True\n    \"\"\"\n    return False if (pow(int(str(n)[0]), len(str(n)))!= n) else True\n \n \ndef number_to_words(n: int) -> str:\n    \"\"\" 将一个数字转换为英文单词    >>> number_to_words(123)\n    One Hundred and Twenty Three\n    >>> number_to_words(1000)\n    One Thousand\n    \"\"\"\n    if n < 0:\n        return \"zero\"\n    return _thousands(n)\n \n \ndef _thousands(n: int) -> str:\n    \"\"\" 辅助函数，将千", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1\n \n \ndef narcissistic(n: int) -> bool:\n    \"\"\" 判断一个正整数是否是 narcissistic 数    >>> narcissistic(256)\n    True\n    \"\"\"\n    return False if (pow(int(str(n)[0]), len(str(n)))!= n) else True\n \n \ndef number_to_words(n: int) -> str:\n    \"\"\" 将一个数字转换为英文单词    >>> number_to_words(123)\n    One Hundred and Twenty Three\n    >>> number_to_words(1000)\n    One Thousand\n    \"\"\"\n    if n < 0:\n        return \"zero\"\n    return _thousands(n)\n \n \ndef _thousands(n: int) -> str:\n    \"\"\" 辅助函数，将千"}
{"task_id": "HumanEval/24", "completion": "    i: int = 1\n    while i <= n:\n        if n % i == 0:\n            return i\n        i += 1\n\n\ndef largest_divisors(n: int, k: int) -> List[int]:\n    \"\"\" 对于给定的数 n，找出 k 个能整除 n 且小于n 的最大的数    >>> largest_divisors(38,2)\n    [2, 3]\n    \"\"\"\n    divisors: List[int] = []\n    for i in range(1, n+1):\n        if n % i == 0 and len(divisors) < k:\n            divisors.append(i)\n    return divisors\n\n\ndef product_of_digits(n: int) -> int:\n    \"\"\" 对于给定的数 n，计算所有位于数中的数字的乘积    >>> product_of_digits(35)\n    5\n    \"\"\"\n    if n <= 10:\n        return n\n", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i: int = 1\n    while i <= n:\n        if n % i == 0:\n            return i\n        i += 1\n\n\ndef largest_divisors(n: int, k: int) -> List[int]:\n    \"\"\" 对于给定的数 n，找出 k 个能整除 n 且小于n 的最大的数    >>> largest_divisors(38,2)\n    [2, 3]\n    \"\"\"\n    divisors: List[int] = []\n    for i in range(1, n+1):\n        if n % i == 0 and len(divisors) < k:\n            divisors.append(i)\n    return divisors\n\n\ndef product_of_digits(n: int) -> int:\n    \"\"\" 对于给定的数 n，计算所有位于数中的数字的乘积    >>> product_of_digits(35)\n    5\n    \"\"\"\n    if n <= 10:\n        return n\n"}
{"task_id": "HumanEval/24", "completion": "    for i in range(n - 1, 0, -1): # 找出能整除n小于n的最大值\n        if n % i == 0:\n            return i\n \ndef lcm(n1: int, n2: int) -> int:\n    \"\"\" 计算两个正整数的最小公倍数    >>> lcm(25, 20)\n    100\n    >>> lcm(100, 50)\n    50\n    \"\"\"\n    return n1 * n2 // largest_divisor(n1 * n2)\n \ndef is_prime(num: int) -> bool:\n    \"\"\" 判断一个数是否是素数        >>> is_prime(13)\n    True\n    >>> is_prime(7)\n    True\n    \"\"\"\n    if num < 2:\n        return False\n    for x in range(2, int(num ** 0.5) + 1):\n        if num % x == 0:\n            return False\n   ", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1): # 找出能整除n小于n的最大值\n        if n % i == 0:\n            return i\n \ndef lcm(n1: int, n2: int) -> int:\n    \"\"\" 计算两个正整数的最小公倍数    >>> lcm(25, 20)\n    100\n    >>> lcm(100, 50)\n    50\n    \"\"\"\n    return n1 * n2 // largest_divisor(n1 * n2)\n \ndef is_prime(num: int) -> bool:\n    \"\"\" 判断一个数是否是素数        >>> is_prime(13)\n    True\n    >>> is_prime(7)\n    True\n    \"\"\"\n    if num < 2:\n        return False\n    for x in range(2, int(num ** 0.5) + 1):\n        if num % x == 0:\n            return False\n   "}
{"task_id": "HumanEval/24", "completion": "    if n == 1:\n        return 1\n\n    for d in range(1, n + 1):\n        if n % d == 0:\n            return d\n\n\ndef lowest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于 n 的最小的数    >>> lowest_divisor(15)\n    3\n    \"\"\"\n    if n == 1:\n        return 1\n\n    for d in range(n, 0, -1):  # 1 - 15\n        if n % d == 0:\n            return d\n\n\ndef range_divisors(n: int) -> list:\n    \"\"\" 对于给定的数 n，获取 [最大的能整除数, 最小的能整除数]    >>> range_divisors(3)\n    [6, 1]\n    \"\"\"\n    if n == 1:\n        return [1, 1]\n\n    ls", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 1:\n        return 1\n\n    for d in range(1, n + 1):\n        if n % d == 0:\n            return d\n\n\ndef lowest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于 n 的最小的数    >>> lowest_divisor(15)\n    3\n    \"\"\"\n    if n == 1:\n        return 1\n\n    for d in range(n, 0, -1):  # 1 - 15\n        if n % d == 0:\n            return d\n\n\ndef range_divisors(n: int) -> list:\n    \"\"\" 对于给定的数 n，获取 [最大的能整除数, 最小的能整除数]    >>> range_divisors(3)\n    [6, 1]\n    \"\"\"\n    if n == 1:\n        return [1, 1]\n\n    ls"}
{"task_id": "HumanEval/24", "completion": "    return n if n == 1 else largest_divisor(int(n/2)) if n % 2 == 0 else largest_divisor(int(n/3))\n\ndef _largest_divisor_rec():\n    n = 100\n    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return _largest_divisor_rec(n/2)\n    else:\n        return _largest_divisor_rec(n/3)\n\ndef largest_divisor_rec(n: int) -> int:\n    return _largest_divisor_rec(n)\n\n# 判断一个数是否是素数，就是它只能被1和自己整除\ndef is_prime(n: int) -> bool:\n    if n == 1 or n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, largest_divisor(n) + 1", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return n if n == 1 else largest_divisor(int(n/2)) if n % 2 == 0 else largest_divisor(int(n/3))\n\ndef _largest_divisor_rec():\n    n = 100\n    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return _largest_divisor_rec(n/2)\n    else:\n        return _largest_divisor_rec(n/3)\n\ndef largest_divisor_rec(n: int) -> int:\n    return _largest_divisor_rec(n)\n\n# 判断一个数是否是素数，就是它只能被1和自己整除\ndef is_prime(n: int) -> bool:\n    if n == 1 or n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, largest_divisor(n) + 1"}
{"task_id": "HumanEval/24", "completion": "    return max(i for i in range(n // 2, 2, -1) if n % i == 0)\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    15\n    \"\"\"\n    return min(i for i in range(2, n) if n % i == 0)\n\n\ndef divisors(n: int) -> List[int]:\n    \"\"\" 对于给定的数 n，找出能整除 n 的数的集合    >>> divisors(15)\n    [1, 3, 5, 15]\n    \"\"\"\n    return [i for i in range(1, n + 1) if n % i == 0]\n\n\ndef is_perfect_square(n: int) -> bool:\n    \"\"\" 对于给定的数 n，判断是否为完美平方", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return max(i for i in range(n // 2, 2, -1) if n % i == 0)\n\n\ndef smallest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且大于n 的最小的数    >>> smallest_divisor(15)\n    15\n    \"\"\"\n    return min(i for i in range(2, n) if n % i == 0)\n\n\ndef divisors(n: int) -> List[int]:\n    \"\"\" 对于给定的数 n，找出能整除 n 的数的集合    >>> divisors(15)\n    [1, 3, 5, 15]\n    \"\"\"\n    return [i for i in range(1, n + 1) if n % i == 0]\n\n\ndef is_perfect_square(n: int) -> bool:\n    \"\"\" 对于给定的数 n，判断是否为完美平方"}
{"task_id": "HumanEval/24", "completion": "    for i in range(1, n / 2 + 1):\n        if n % i == 0:\n            return i\n    return n\n\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断一个 n 是否是质数\n\n    尝试证明一个奇数最多有两个质因子，从而证明一个奇数最多有两个质因子。\n    质数 2 的倍数必然不是质数，所以寻找一个质数 m 迭代，如果 2*m<n, 返回 \n    True。\n    寻找质数 m 的一种方法是找到 n 的一个最大的约数，如果 m 是一个质数，\n    m 一定能整除这个最大的约数，因为 m 是质数。如", "allcode": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" 对于给定的数 n，找出能整除 n 且小于n 的最大的数    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(1, n / 2 + 1):\n        if n % i == 0:\n            return i\n    return n\n\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\" 判断一个 n 是否是质数\n\n    尝试证明一个奇数最多有两个质因子，从而证明一个奇数最多有两个质因子。\n    质数 2 的倍数必然不是质数，所以寻找一个质数 m 迭代，如果 2*m<n, 返回 \n    True。\n    寻找质数 m 的一种方法是找到 n 的一个最大的约数，如果 m 是一个质数，\n    m 一定能整除这个最大的约数，因为 m 是质数。如"}
{"task_id": "HumanEval/25", "completion": "    res = []\n    if n <= 1:\n        return []\n    for", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    res = []\n    if n <= 1:\n        return []\n    for"}
{"task_id": "HumanEval/25", "completion": "    if n <= 1:\n        return []\n    ans = []\n    # 取 n 的质因子\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            ans.append(i)\n            n //= i\n    if n!= 1:\n        ans.append(n)\n    return ans\n\n\ndef test_factorize():\n    print(factorize(8))\n    print(factorize(25))\n    print(factorize(70))\n    assert factorize(8) == [2, 2, 2]\n    assert factorize(25) == [5, 5]\n    assert factorize(70) == [2, 5, 7]\n\n\ndef main():\n    test_factorize()\n\n\nif __name__ == '", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n <= 1:\n        return []\n    ans = []\n    # 取 n 的质因子\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            ans.append(i)\n            n //= i\n    if n!= 1:\n        ans.append(n)\n    return ans\n\n\ndef test_factorize():\n    print(factorize(8))\n    print(factorize(25))\n    print(factorize(70))\n    assert factorize(8) == [2, 2, 2]\n    assert factorize(25) == [5, 5]\n    assert factorize(70) == [2, 5, 7]\n\n\ndef main():\n    test_factorize()\n\n\nif __name__ == '"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    while n > 1:\n        for i in range(2, int(n ** 0.5 + 1)):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n        else:\n            factors.append(n)\n", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    while n > 1:\n        for i in range(2, int(n ** 0.5 + 1)):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n        else:\n            factors.append(n)\n"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        # 找到最小的质因数\n        if n % i == 0:\n            factors.append(i)  # 把该质因数追加到列表\n            n //= i\n            # 因为已经找到最小的质因数，后面的因子肯定大于该数，因此剩下的都是比指定数小的数，不用继续找\n            break\n    factors.append(n)  # 最后一个因子必定是原数\n    return factors\n\n\ndef digitize(n: int) -> List[int]:\n    \"\"\" 按从大到小的顺序返回给定整数的位数列表\n    >>> digitize(8)\n    [8, 8]\n    >>> digitize(25)\n    [25, 5, 2", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        # 找到最小的质因数\n        if n % i == 0:\n            factors.append(i)  # 把该质因数追加到列表\n            n //= i\n            # 因为已经找到最小的质因数，后面的因子肯定大于该数，因此剩下的都是比指定数小的数，不用继续找\n            break\n    factors.append(n)  # 最后一个因子必定是原数\n    return factors\n\n\ndef digitize(n: int) -> List[int]:\n    \"\"\" 按从大到小的顺序返回给定整数的位数列表\n    >>> digitize(8)\n    [8, 8]\n    >>> digitize(25)\n    [25, 5, 2"}
{"task_id": "HumanEval/25", "completion": "\n    def __factorize(m, n):\n        if n == 1:\n            return []\n        for i in range(2, n+1):\n            if m % i == 0:\n                factors.append(i)\n                m = m // i\n                __factorize(m, n)\n\n    factors = []\n    __factorize(n, n)\n    return factors\n\n\ndef main():\n    while True:\n        try", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n    def __factorize(m, n):\n        if n == 1:\n            return []\n        for i in range(2, n+1):\n            if m % i == 0:\n                factors.append(i)\n                m = m // i\n                __factorize(m, n)\n\n    factors = []\n    __factorize(n, n)\n    return factors\n\n\ndef main():\n    while True:\n        try"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            factors.append(i)\n            n //= i\n    if n!= 1:\n        factors.append(n)\n    return factors\n\n\ndef factorization_tree(n: int) -> str:\n    \"\"\" 使用新的数字表示每个因子的次数，返回质因数分解树\n    >>> factorization_tree(8)\n    '(2^3)'\n    >>> factorization_tree(25)\n    '5'\n    >>> factorization_tree(70)\n    '(2^1)(5^1)(7^1)'\n    \"\"\"\n    factors = factorize(n)\n    if len(factors) == 1:\n        return str(factors[0])\n    elif len(factors) == 2:\n        return f'({factors[0]}^1)({factors[1]}^1)'\n    else:\n        str_", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            factors.append(i)\n            n //= i\n    if n!= 1:\n        factors.append(n)\n    return factors\n\n\ndef factorization_tree(n: int) -> str:\n    \"\"\" 使用新的数字表示每个因子的次数，返回质因数分解树\n    >>> factorization_tree(8)\n    '(2^3)'\n    >>> factorization_tree(25)\n    '5'\n    >>> factorization_tree(70)\n    '(2^1)(5^1)(7^1)'\n    \"\"\"\n    factors = factorize(n)\n    if len(factors) == 1:\n        return str(factors[0])\n    elif len(factors) == 2:\n        return f'({factors[0]}^1)({factors[1]}^1)'\n    else:\n        str_"}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    if n == 1:\n        return [1]\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            while n % i == 0:\n                n = n // i\n    factors.append(n)\n    return factors\n\n\ndef factorize_incorrect(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize_incorrect(8)\n    [2, 2, 2]\n    >>> factorize_incorrect(25)\n    [5, 2]\n    >>> factorize_incorrect(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    if n == 1:\n        return [1]\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            while n % i == 0:\n                n = n // i\n    factors.append(n)\n    return factors\n\n\ndef factorize_incorrect(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize_incorrect(8)\n    [2, 2, 2]\n    >>> factorize_incorrect(25)\n    [5, 2]\n    >>> factorize_incorrect(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n"}
{"task_id": "HumanEval/25", "completion": "    if isinstance(n, (int)):\n        if n == 1:\n            return [1]\n        for i in range(2, n):\n            if n % i == 0:\n                res = factorize(n // i)\n                res.append(i)\n                return res\n        return [n]\n\n    raise ValueError(f\"{n} is not an integer\")\n\n\ndef _test():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    _", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if isinstance(n, (int)):\n        if n == 1:\n            return [1]\n        for i in range(2, n):\n            if n % i == 0:\n                res = factorize(n // i)\n                res.append(i)\n                return res\n        return [n]\n\n    raise ValueError(f\"{n} is not an integer\")\n\n\ndef _test():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    _"}
{"task_id": "HumanEval/25", "completion": "    if not isinstance(n, int) or n < 1:\n        raise ValueError('n < 1')\n    if n < 2:\n        return [n]\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            factors.append(i)\n            n //= i\n    if n > ", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n < 1')\n    if n < 2:\n        return [n]\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            factors.append(i)\n            n //= i\n    if n > "}
{"task_id": "HumanEval/25", "completion": "    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n /= 2\n    if n % 3 == 0:\n        factors.append(3)\n        n /= 3\n    while n % 5 == 0:\n        factors.append(5)\n        n /= 5\n    while n % 7 == 0:\n        factors.append(7)\n        n /= 7\n    if n!= 1:\n        factors.append(n)\n    return factors\n\n\ndef factorize2(n: int) -> List[int]:\n    factors = []\n    for i in range(2, int(n+1)//2):\n        if factorize2(n%i) == [1]:\n            factors.append(i)\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n```\n\n## 36.组合数组的元素\n\n```python\nfrom typing import List\n\n", "allcode": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" 按从小到大的顺序返回给定整数的质因数列表    每个因数列出的次数应与它在因数分解中出现的次数相对应?    输入数字应等于所有因数的乘积\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n /= 2\n    if n % 3 == 0:\n        factors.append(3)\n        n /= 3\n    while n % 5 == 0:\n        factors.append(5)\n        n /= 5\n    while n % 7 == 0:\n        factors.append(7)\n        n /= 7\n    if n!= 1:\n        factors.append(n)\n    return factors\n\n\ndef factorize2(n: int) -> List[int]:\n    factors = []\n    for i in range(2, int(n+1)//2):\n        if factorize2(n%i) == [1]:\n            factors.append(i)\n    return factors\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)\n```\n\n## 36.组合数组的元素\n\n```python\nfrom typing import List\n\n"}
{"task_id": "HumanEval/26", "completion": "    ret: List[int] = []\n    i = 0\n    while i < len(numbers):\n        if numbers[i] not in ret:\n            ret.append(numbers[i])\n\n        while i + 1 < len(numbers) and numbers[i] == numbers[i + 1]:\n            i += 1\n        i += 1\n\n    return ret\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef remove_duplicate_from_sorted_list(head: ListNode) -> ListNode:\n    \"\"\"\n    删除有序链表中的重复元素\n    解法：\n        1. 不用额外的空间，栈或者链表中存储之前遇到的数值\n        2. 在原地删除，逐个迭代\n\n    >>> head = [1, 1, 1, 1, 2, 2, 2, 2, 2, 3", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    ret: List[int] = []\n    i = 0\n    while i < len(numbers):\n        if numbers[i] not in ret:\n            ret.append(numbers[i])\n\n        while i + 1 < len(numbers) and numbers[i] == numbers[i + 1]:\n            i += 1\n        i += 1\n\n    return ret\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n\ndef remove_duplicate_from_sorted_list(head: ListNode) -> ListNode:\n    \"\"\"\n    删除有序链表中的重复元素\n    解法：\n        1. 不用额外的空间，栈或者链表中存储之前遇到的数值\n        2. 在原地删除，逐个迭代\n\n    >>> head = [1, 1, 1, 1, 2, 2, 2, 2, 2, 3"}
{"task_id": "HumanEval/26", "completion": "    return list(set(numbers))\n\n\nprint(remove_duplicates([1, 2, 3, 2, 4]))\n\n\ndef find_max_and_min(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" 返回整数列表中最大和最小的元素    >>> find_max_and_min([1, 2, 3, 2, 4])\n    (4, 1)\n    >>> find_max_and_min([100, 200, 300, 100])\n    (300, 100)\n    \"\"\"\n    return min(numbers), max(numbers)\n\n\nprint(find_max_and_min([1, 2, 3, 2, 4]))\n\n\ndef find_median(numbers: List[int]) -> float:\n    \"\"\" 返回整数列表的中位数，保证数字数量是奇数    >>> find_median([1, 2, 3, ", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))\n\n\nprint(remove_duplicates([1, 2, 3, 2, 4]))\n\n\ndef find_max_and_min(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" 返回整数列表中最大和最小的元素    >>> find_max_and_min([1, 2, 3, 2, 4])\n    (4, 1)\n    >>> find_max_and_min([100, 200, 300, 100])\n    (300, 100)\n    \"\"\"\n    return min(numbers), max(numbers)\n\n\nprint(find_max_and_min([1, 2, 3, 2, 4]))\n\n\ndef find_median(numbers: List[int]) -> float:\n    \"\"\" 返回整数列表的中位数，保证数字数量是奇数    >>> find_median([1, 2, 3, "}
{"task_id": "HumanEval/26", "completion": "    nums = []\n    for num in numbers:\n        if num not in nums:\n            nums.append(num)\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    # 测试用例\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    print(numbers)  # 原列表不受影响\n\n    print('='*20)\n\n    # 另一种测试方法\n    def remove_duplicates(numbers: List[int]) -> List[int]:\n        # if not numbers:\n        #     return []\n        # nums = []\n        # for num in numbers:\n        #     if num not in nums:\n        #         nums.append(num)\n        # return nums\n        return list(set(numbers))\n\n    print(remove_duplicates([", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    nums = []\n    for num in numbers:\n        if num not in nums:\n            nums.append(num)\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n    # 测试用例\n    numbers = [1, 2, 3, 2, 4]\n    print(remove_duplicates(numbers))\n    print(numbers)  # 原列表不受影响\n\n    print('='*20)\n\n    # 另一种测试方法\n    def remove_duplicates(numbers: List[int]) -> List[int]:\n        # if not numbers:\n        #     return []\n        # nums = []\n        # for num in numbers:\n        #     if num not in nums:\n        #         nums.append(num)\n        # return nums\n        return list(set(numbers))\n\n    print(remove_duplicates(["}
{"task_id": "HumanEval/26", "completion": "    if not numbers:\n        return []\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i] == numbers[i + 1]:\n            numbers.remove(numbers[i])\n    return numbers\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 1, 2, 2, 3, 3, 4, 4]))\n    print(remove_duplicates([1, 1, 1, 2, 2, 2, 3, 3", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i] == numbers[i + 1]:\n            numbers.remove(numbers[i])\n    return numbers\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1, 1, 2, 2, 3, 3, 4, 4]))\n    print(remove_duplicates([1, 1, 1, 2, 2, 2, 3, 3"}
{"task_id": "HumanEval/26", "completion": "    numbers.sort()\n    if len(numbers) == 1:\n        return numbers\n\n    seen = set()\n    seen_add = seen.add\n    idx = 0\n    for idx in range(1, len(numbers)):\n        if numbers[idx]!= numbers[idx - 1]:\n            seen_add(numbers[idx])\n\n    # 只会更新两次，一次是第一次循环，第二次是第二次循环，所以倒数第三个元素就是倒数第二个元素。\n    # idx = 0\n    # seen = set()\n    # for number in numbers:\n    #     if number not in seen:\n    #         seen.add(number)\n    #         numbers[idx] = number\n    #         idx += 1\n    return numbers[:idx]\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1,", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers.sort()\n    if len(numbers) == 1:\n        return numbers\n\n    seen = set()\n    seen_add = seen.add\n    idx = 0\n    for idx in range(1, len(numbers)):\n        if numbers[idx]!= numbers[idx - 1]:\n            seen_add(numbers[idx])\n\n    # 只会更新两次，一次是第一次循环，第二次是第二次循环，所以倒数第三个元素就是倒数第二个元素。\n    # idx = 0\n    # seen = set()\n    # for number in numbers:\n    #     if number not in seen:\n    #         seen.add(number)\n    #         numbers[idx] = number\n    #         idx += 1\n    return numbers[:idx]\n\n\nif __name__ == '__main__':\n    print(remove_duplicates([1, 2, 3, 2, 4]))\n    print(remove_duplicates([1,"}
{"task_id": "HumanEval/26", "completion": "    numbers[:] = [n for n in set(numbers)]\n    return numbers\n\n\nclass Solution:\n    def get_nums(self, num: int) -> str:\n        return str(num)\n\n    def get_number_of_steps(self, num: int) -> int:\n        steps: int = 0\n        num_str: str = self.get_nums(num)\n        while len(num_str) > 1:\n            num_str = self.get_nums(int(num_str))\n            steps += 1\n        return steps\n\n    def count_special(self, nums: List[int]) -> int:\n        \"\"\" 给定不同的正整数数组，找到其中多余 1 个数的个数    >>> count_special([1, 2, 2])\n        1\n        >>> count_special([2, 3, 2])\n        2\n        \"\"\"\n        n: int = len(nums)\n        cnt: int = 0\n        for i in range(", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers[:] = [n for n in set(numbers)]\n    return numbers\n\n\nclass Solution:\n    def get_nums(self, num: int) -> str:\n        return str(num)\n\n    def get_number_of_steps(self, num: int) -> int:\n        steps: int = 0\n        num_str: str = self.get_nums(num)\n        while len(num_str) > 1:\n            num_str = self.get_nums(int(num_str))\n            steps += 1\n        return steps\n\n    def count_special(self, nums: List[int]) -> int:\n        \"\"\" 给定不同的正整数数组，找到其中多余 1 个数的个数    >>> count_special([1, 2, 2])\n        1\n        >>> count_special([2, 3, 2])\n        2\n        \"\"\"\n        n: int = len(nums)\n        cnt: int = 0\n        for i in range("}
{"task_id": "HumanEval/26", "completion": "    seen = set()\n    return [x for x in numbers if x not in seen and not seen.add(x)]\n#  整数列表中不包含重复数字，如1，2，3，4，5，返回 [5]\nremove_duplicates([1, 2, 3, 2, 4])\n#  整数列表中含有重复数字，如1，2，3，2，4，5，返回 [1, 3, 4, 5]\nremove_duplicates([2, 2, 3, 2, 4])\n#  整数列表中不包含重复数字，如1，2，4，5，8，返回 [5]\nremove_duplicates([1, 2, 4, 5, 8])\n#  整数列表中含有重复数字，如1，2，3，4，5，返回 [1, 3, 5]\nremove_duplicates([1, 2", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    return [x for x in numbers if x not in seen and not seen.add(x)]\n#  整数列表中不包含重复数字，如1，2，3，4，5，返回 [5]\nremove_duplicates([1, 2, 3, 2, 4])\n#  整数列表中含有重复数字，如1，2，3，2，4，5，返回 [1, 3, 4, 5]\nremove_duplicates([2, 2, 3, 2, 4])\n#  整数列表中不包含重复数字，如1，2，4，5，8，返回 [5]\nremove_duplicates([1, 2, 4, 5, 8])\n#  整数列表中含有重复数字，如1，2，3，4，5，返回 [1, 3, 5]\nremove_duplicates([1, 2"}
{"task_id": "HumanEval/26", "completion": "    res = []\n    for i in numbers:\n        if i not in res:\n            res.append(i)\n    return res\n\n\nif __name__ == '__main__':\n    print(remove", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    res = []\n    for i in numbers:\n        if i not in res:\n            res.append(i)\n    return res\n\n\nif __name__ == '__main__':\n    print(remove"}
{"task_id": "HumanEval/26", "completion": "    return list(dict.fromkeys(numbers))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\ndef merge_two_lists(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"合并两个有序整型列表\n    两个列表已经排序，将两个列表合并为一个新列表，使其保持升序排序\n\n    >>> merge_two_lists([1, 2, 4, 6, 7, 8, 12, 14, 15, 17, 18], [3, 5, 8, 9, 12, 15, 17, 18])\n    [1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 12, 12, 14, 15, 15, 17, 1", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(dict.fromkeys(numbers))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\ndef merge_two_lists(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"合并两个有序整型列表\n    两个列表已经排序，将两个列表合并为一个新列表，使其保持升序排序\n\n    >>> merge_two_lists([1, 2, 4, 6, 7, 8, 12, 14, 15, 17, 18], [3, 5, 8, 9, 12, 15, 17, 18])\n    [1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 12, 12, 14, 15, 15, 17, 1"}
{"task_id": "HumanEval/26", "completion": "    numbers.sort()\n    i = 1\n    while i < len(numbers):\n        if numbers[i] == numbers[i - 1]:\n            numbers.remove(numbers[i])\n        else:\n            i += 1\n    return numbers\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\" 将 所有重复的元素排在一起，然后从头至尾删除它们，   保持最终的顺序和输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 2, 4]\n    \"\"\"\n    numbers.sort()\n    i = 1\n    while i < len(numbers):\n        if numbers[i] == numbers[i - 1]:\n            numbers = numbers[:i - 1] + numbers[i:]\n        else:\n            i += 1\n    return numbers\n\n\ndef remove_duplicates_3(numbers: List[int]) -> List[int]:", "allcode": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" 从整数列表中删除所有出现过一次以上的元素，   保持剩余元素的顺序与输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers.sort()\n    i = 1\n    while i < len(numbers):\n        if numbers[i] == numbers[i - 1]:\n            numbers.remove(numbers[i])\n        else:\n            i += 1\n    return numbers\n\n\ndef remove_duplicates_2(numbers: List[int]) -> List[int]:\n    \"\"\" 将 所有重复的元素排在一起，然后从头至尾删除它们，   保持最终的顺序和输入相同    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 2, 4]\n    \"\"\"\n    numbers.sort()\n    i = 1\n    while i < len(numbers):\n        if numbers[i] == numbers[i - 1]:\n            numbers = numbers[:i - 1] + numbers[i:]\n        else:\n            i += 1\n    return numbers\n\n\ndef remove_duplicates_3(numbers: List[int]) -> List[int]:"}
{"task_id": "HumanEval/31", "completion": "    if n == 2:\n        return True\n    if n < 2 or n%2 == 0:\n        return False\n    for i in range(3,int(n**0.5)+1,2):\n        if n % i == 0:\n            return False\n    return True\n\ndef divisors(n):\n    \"\"\"返回一个列表，列出 n 的所有除数（不包括 1 和 n 本身）    \n    >>> divisors(4)\n    [1, 2]\n    >>> divisors(10)\n    [1, 2, 5]\n    >>> divisors(144)\n    [1, 2, 3, 4, 6, 8, 12, 16, 24, 28, 32, 48, 72, 96, 144]\n    >>> divisors(8)\n    [1, 2, 4]\n    >>> divisors(6)\n    [1, 2, 3]\n    >>>", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n < 2 or n%2 == 0:\n        return False\n    for i in range(3,int(n**0.5)+1,2):\n        if n % i == 0:\n            return False\n    return True\n\ndef divisors(n):\n    \"\"\"返回一个列表，列出 n 的所有除数（不包括 1 和 n 本身）    \n    >>> divisors(4)\n    [1, 2]\n    >>> divisors(10)\n    [1, 2, 5]\n    >>> divisors(144)\n    [1, 2, 3, 4, 6, 8, 12, 16, 24, 28, 32, 48, 72, 96, 144]\n    >>> divisors(8)\n    [1, 2, 4]\n    >>> divisors(6)\n    [1, 2, 3]\n    >>>"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:  # 对于小于 2 的数字，我们认为它们都不是质数。\n        return False\n    elif n == 2:  # 如果是 2 的话，它是唯一的一个质数。\n        return True\n    elif n % 2 == 0:  # 如果一个数字是偶数，我们将其除以 2。\n        return False\n    else:  # 其他情况，我们将测试从 3 开始到根号 N 以查看是否有任何整数可以除以它。\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef primes():\n    \"\"\"产生质数的生成器   >>> next(primes())\n    2\n    >>> next(primes())\n    3", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:  # 对于小于 2 的数字，我们认为它们都不是质数。\n        return False\n    elif n == 2:  # 如果是 2 的话，它是唯一的一个质数。\n        return True\n    elif n % 2 == 0:  # 如果一个数字是偶数，我们将其除以 2。\n        return False\n    else:  # 其他情况，我们将测试从 3 开始到根号 N 以查看是否有任何整数可以除以它。\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef primes():\n    \"\"\"产生质数的生成器   >>> next(primes())\n    2\n    >>> next(primes())\n    3"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_factors(n):\n    \"\"\"计算一个正整数n的所有质因数，\n    如果n是质数则返回[n]，\n    如果n是合数，则返回一个由质数的幂构成的列表，\n    且这些质数都是n的约数。\n    如果n为负数，则返回一个空列表[].\n    >>> prime_factors(2)\n    [2]\n    >>> prime_factors(10)\n    [2, 5]\n    >>> prime_factors(20)\n    [2, 2, 5]\n    >>> prime_factors(30)\n    [2, 3, 5]\n    >>> prime_factors(150)\n    [2, ", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_factors(n):\n    \"\"\"计算一个正整数n的所有质因数，\n    如果n是质数则返回[n]，\n    如果n是合数，则返回一个由质数的幂构成的列表，\n    且这些质数都是n的约数。\n    如果n为负数，则返回一个空列表[].\n    >>> prime_factors(2)\n    [2]\n    >>> prime_factors(10)\n    [2, 5]\n    >>> prime_factors(20)\n    [2, 2, 5]\n    >>> prime_factors(30)\n    [2, 3, 5]\n    >>> prime_factors(150)\n    [2, "}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    if n > 2:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef prime_num_between(a, b):\n    \"\"\"返回a 和b 之间的质数。\n    >>> prime_num_between(2, 10)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 11)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 12)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 13)\n    [2, 3, 5, 7, 11]\n    >>> prime_num_between(11, 13)\n    [11, 13]\n    \"\"\"\n    nums = []\n    for i in range(a, b + 1):\n        if is_prime(", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n > 2:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n\n\ndef prime_num_between(a, b):\n    \"\"\"返回a 和b 之间的质数。\n    >>> prime_num_between(2, 10)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 11)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 12)\n    [2, 3, 5, 7]\n    >>> prime_num_between(2, 13)\n    [2, 3, 5, 7, 11]\n    >>> prime_num_between(11, 13)\n    [11, 13]\n    \"\"\"\n    nums = []\n    for i in range(a, b + 1):\n        if is_prime("}
{"task_id": "HumanEval/31", "completion": "    if n <= 1 :\n        return False\n    else:\n        for i in range(2,n):\n            if n % i == 0:\n                return False\n        return True\n    \ndef is_palindrome(n):\n    \"\"\"如果给定的数字既是回文数，又是质数，则返回true，否则返回false \n    >>> is_palindrome(1234321)\n    True\n    >>> is_palindrome(123321)\n    False\n    >>> is_palindrome(11)\n    True\n    >>> is_palindrome(132213)\n    True\n    >>> is_palindrome(132132)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    nums = []\n    while n > 0:\n        nums.append(n % 10)\n        n = n // 10\n    if nums == nums[::-1]:\n        if is_prime", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1 :\n        return False\n    else:\n        for i in range(2,n):\n            if n % i == 0:\n                return False\n        return True\n    \ndef is_palindrome(n):\n    \"\"\"如果给定的数字既是回文数，又是质数，则返回true，否则返回false \n    >>> is_palindrome(1234321)\n    True\n    >>> is_palindrome(123321)\n    False\n    >>> is_palindrome(11)\n    True\n    >>> is_palindrome(132213)\n    True\n    >>> is_palindrome(132132)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    nums = []\n    while n > 0:\n        nums.append(n % 10)\n        n = n // 10\n    if nums == nums[::-1]:\n        if is_prime"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    for i in range(2, n):\n        if n%i == 0:\n            return False\n    return True\n\ndef is_int_list(seq):\n    \"\"\"如果给定序列由一系列的整数组成，则返回 True，否则返回 False  >>> is_int_list([1,2,3])\n    True\n    >>> is_int_list([1,2,3,4])\n    True\n    >>> is_int_list('abc')\n    False\n    >>> is_int_list(list('abc'))\n    False\n    >>> is_int_list([1,2,3.0])\n    False\n    >>> is_int_list([1,2,3.0,4])\n    False\n    \"\"\"\n    if type(seq) is not list:\n        return False\n    if len(seq) == 0:\n        return True\n    for num in seq:\n        if type(num) is not int:\n            return False\n    return True\n\ndef is_float", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n%i == 0:\n            return False\n    return True\n\ndef is_int_list(seq):\n    \"\"\"如果给定序列由一系列的整数组成，则返回 True，否则返回 False  >>> is_int_list([1,2,3])\n    True\n    >>> is_int_list([1,2,3,4])\n    True\n    >>> is_int_list('abc')\n    False\n    >>> is_int_list(list('abc'))\n    False\n    >>> is_int_list([1,2,3.0])\n    False\n    >>> is_int_list([1,2,3.0,4])\n    False\n    \"\"\"\n    if type(seq) is not list:\n        return False\n    if len(seq) == 0:\n        return True\n    for num in seq:\n        if type(num) is not int:\n            return False\n    return True\n\ndef is_float"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_1(n):\n    \"\"\"判断一个数字是否是质数，如果是，则返回True，否则返回False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0 and n!= i:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_1(n):\n    \"\"\"判断一个数字是否是质数，如果是，则返回True，否则返回False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0 and n!= i:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":"}
{"task_id": "HumanEval/31", "completion": "    return prime(n)\n\ndef prime(n):\n    '''判断一个数字是不是质数'''\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n %i == 0:\n            return False\n    return True\n\ndef main():\n    '''主函数'''\n    num = 10001\n    s = 0\n    for i in range(1, num):\n        if is_prime(i):\n            s = s + i", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    return prime(n)\n\ndef prime(n):\n    '''判断一个数字是不是质数'''\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n %i == 0:\n            return False\n    return True\n\ndef main():\n    '''主函数'''\n    num = 10001\n    s = 0\n    for i in range(1, num):\n        if is_prime(i):\n            s = s + i"}
{"task_id": "HumanEval/31", "completion": "    if n < 2:\n        return False\n    for m in range(2, n//2 + 1):\n        if n % m == 0: \n            return False\n    return True\n\ndef test_is_prime():\n    \"\"\"测试一下is_prime函数的效果\"\"\"\n    print(is_prime(7))\n    print(is_prime(9))\n    print(is_prime(11))\n    print(is_prime(121))\n    print(is_prime(1729))   #很大的数字\n    print(is_prime(1999))   #很大的数字\n    print(is_prime(13))\n\ndef prime_iter(top):\n    \"\"\"生成迭代器，这个函数会返回一个迭代器，它会生成1 到top的所有质数。\"\"\"\n    n = 2\n    while True:\n        if is_prime(n):\n            yield n\n        n = n+1", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for m in range(2, n//2 + 1):\n        if n % m == 0: \n            return False\n    return True\n\ndef test_is_prime():\n    \"\"\"测试一下is_prime函数的效果\"\"\"\n    print(is_prime(7))\n    print(is_prime(9))\n    print(is_prime(11))\n    print(is_prime(121))\n    print(is_prime(1729))   #很大的数字\n    print(is_prime(1999))   #很大的数字\n    print(is_prime(13))\n\ndef prime_iter(top):\n    \"\"\"生成迭代器，这个函数会返回一个迭代器，它会生成1 到top的所有质数。\"\"\"\n    n = 2\n    while True:\n        if is_prime(n):\n            yield n\n        n = n+1"}
{"task_id": "HumanEval/31", "completion": "    if n <= 3:\n        return n > 1\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n\n    return True\n\ndef is_miller_prime(n):\n    \"\"\" 判断一个数是否是质数\n    使用毕列尔姆检验，通过随机选择一个数作为 a，证明：\n        p-1 = x*2^s, 其中x为正整数\n        那么：\n        a^x (mod p) = 1\n        即:\n        a^(p-1) mod p = 1\n        此时我们只需要计算a^(p-1) mod p，而不需要计算a^(p-1)，因为(p", "allcode": "\n\ndef is_prime(n):\n    \"\"\"如果给定的数字是质数，则返回 true，否则返回false   >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n\n    return True\n\ndef is_miller_prime(n):\n    \"\"\" 判断一个数是否是质数\n    使用毕列尔姆检验，通过随机选择一个数作为 a，证明：\n        p-1 = x*2^s, 其中x为正整数\n        那么：\n        a^x (mod p) = 1\n        即:\n        a^(p-1) mod p = 1\n        此时我们只需要计算a^(p-1) mod p，而不需要计算a^(p-1)，因为(p"}
{"task_id": "HumanEval/34", "completion": "    # 这样的结果是列表内的元素是有序的,如果是unsort的就用set\n    return list(dict.fromkeys(l))\n\n\ndef r_unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> r_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 这样的结果是列表内的元素是无序的,如果是sorted的就用set()\n    l.sort()\n    # 这里可以用set()方法替代dict\n    set_list = []\n    # 遍历列表\n    for i in l:\n        if i not in set_list:  # 如果list元素不在set中\n            set_list.append(i)  # 将当前元素添", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 这样的结果是列表内的元素是有序的,如果是unsort的就用set\n    return list(dict.fromkeys(l))\n\n\ndef r_unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> r_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # 这样的结果是列表内的元素是无序的,如果是sorted的就用set()\n    l.sort()\n    # 这里可以用set()方法替代dict\n    set_list = []\n    # 遍历列表\n    for i in l:\n        if i not in set_list:  # 如果list元素不在set中\n            set_list.append(i)  # 将当前元素添"}
{"task_id": "HumanEval/34", "completion": "    l = sorted(l)\n    ret: list = []\n    pre = None\n    for i in l:\n        if i!= pre:\n            ret.append(i)\n            pre = i\n    # print(l)\n    return ret\n\ndef unique_order_preserving(l: list):\n    \"\"\"同上，但保留原有列表的顺序\n    >>> unique_order_preserving([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 3, 5, 5, 9, 123]\n    \"\"\"\n    l = sorted(l)\n    ret: list = []\n    for i in l:\n        if i not in ret:\n            ret.append(i)\n    return ret\n\n\ndef is_unique(l: list):\n    \"\"\"判定列表是否是唯一? 返回布尔值;\n    >>> is_unique([5, 3, 5, 2,", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l = sorted(l)\n    ret: list = []\n    pre = None\n    for i in l:\n        if i!= pre:\n            ret.append(i)\n            pre = i\n    # print(l)\n    return ret\n\ndef unique_order_preserving(l: list):\n    \"\"\"同上，但保留原有列表的顺序\n    >>> unique_order_preserving([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 3, 5, 5, 9, 123]\n    \"\"\"\n    l = sorted(l)\n    ret: list = []\n    for i in l:\n        if i not in ret:\n            ret.append(i)\n    return ret\n\n\ndef is_unique(l: list):\n    \"\"\"判定列表是否是唯一? 返回布尔值;\n    >>> is_unique([5, 3, 5, 2,"}
{"task_id": "HumanEval/34", "completion": "    s = list(set(l))\n    s.sort()\n\n    return s\n\n\ndef unique_no_sort(l: list):\n    \"\"\"返回列表中的独特元素(不排序?)\"\"\"\n    s = list(set(l))\n    return s\n\n\ndef union(a: list, b: list):\n    \"\"\"返回两个列表的并集\"\n    >>> union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(a + b))\n\n\ndef intersection(a: list, b: list):\n    \"\"\"返回两个列表的交集\"\n    >>> intersection([1, 2, 3], [3, 4, 5])\n    [3]\n    \"\"\"\n    return list(set(a) & set(b))\n\n\ndef difference(a: list, b: list):\n    \"\"\"返回a中有而b中没有的所有元素\"", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    s = list(set(l))\n    s.sort()\n\n    return s\n\n\ndef unique_no_sort(l: list):\n    \"\"\"返回列表中的独特元素(不排序?)\"\"\"\n    s = list(set(l))\n    return s\n\n\ndef union(a: list, b: list):\n    \"\"\"返回两个列表的并集\"\n    >>> union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(a + b))\n\n\ndef intersection(a: list, b: list):\n    \"\"\"返回两个列表的交集\"\n    >>> intersection([1, 2, 3], [3, 4, 5])\n    [3]\n    \"\"\"\n    return list(set(a) & set(b))\n\n\ndef difference(a: list, b: list):\n    \"\"\"返回a中有而b中没有的所有元素\""}
{"task_id": "HumanEval/34", "completion": "    tmp_list = []\n    for i in l:\n        if i not in tmp_list:\n            tmp_list.append(i)\n    tmp_list.sort()\n    return tmp_list\n\n\ndef filter_list(l: list, s: str):\n    \"\"\"\n    过滤列表中符合条件的元素\n    :param l:\n    :param s:\n    :return:\n    \"\"\"\n    for i in l:\n        if not isinstance(i, str):\n            print('Error! only string type can be filter')\n            return None\n    result_list = []\n    for i in l:\n        if i.find(s)!= -1:\n            result_list.append(i)\n    return result_list\n\n\ndef search(l: list, s: str):\n    \"\"\"\n    在列表中查找字符串，返回第一次出现的位置\n    :param l:\n    :param s:\n    :return:\n    \"\"\"\n    if not isinstance(l, list):\n        print('", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    tmp_list = []\n    for i in l:\n        if i not in tmp_list:\n            tmp_list.append(i)\n    tmp_list.sort()\n    return tmp_list\n\n\ndef filter_list(l: list, s: str):\n    \"\"\"\n    过滤列表中符合条件的元素\n    :param l:\n    :param s:\n    :return:\n    \"\"\"\n    for i in l:\n        if not isinstance(i, str):\n            print('Error! only string type can be filter')\n            return None\n    result_list = []\n    for i in l:\n        if i.find(s)!= -1:\n            result_list.append(i)\n    return result_list\n\n\ndef search(l: list, s: str):\n    \"\"\"\n    在列表中查找字符串，返回第一次出现的位置\n    :param l:\n    :param s:\n    :return:\n    \"\"\"\n    if not isinstance(l, list):\n        print('"}
{"task_id": "HumanEval/34", "completion": "    return list(set(l))\n\n\ndef unique(l: list):\n    \"\"\"简单的函数\"\"\"\n    return list(set(l))\n\n\ndef count(l: list, e: object):\n    \"\"\"返回列表中元素的个数\n\n    >>> count([1, 2, 4, 5, 6, 7, 1, 2, 1], 2)\n    3\n    >>> count([1, 2, 3, 4, 5, 6, 1, 2, 1], 1)\n    5\n    >>> count([1, 2, 3, 4, 5, 6, 1, 2, 1], 'a')   # 如果元素不在列表中，则返回0\n    0\n    \"\"\"\n    return l.count(e)\n\n\ndef index(l: list, e: object, i: int = 0):\n    \"\"\"返回元素e在列表中第一次出现的索引\n\n    >>> index([5,", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n\n\ndef unique(l: list):\n    \"\"\"简单的函数\"\"\"\n    return list(set(l))\n\n\ndef count(l: list, e: object):\n    \"\"\"返回列表中元素的个数\n\n    >>> count([1, 2, 4, 5, 6, 7, 1, 2, 1], 2)\n    3\n    >>> count([1, 2, 3, 4, 5, 6, 1, 2, 1], 1)\n    5\n    >>> count([1, 2, 3, 4, 5, 6, 1, 2, 1], 'a')   # 如果元素不在列表中，则返回0\n    0\n    \"\"\"\n    return l.count(e)\n\n\ndef index(l: list, e: object, i: int = 0):\n    \"\"\"返回元素e在列表中第一次出现的索引\n\n    >>> index([5,"}
{"task_id": "HumanEval/34", "completion": "    result = []\n    for i in l:\n        if i not in result:\n            result.append(i)\n    return result\n\ndef uniq(l: list):\n    \"\"\"uniq()帮助函数是unique()的别名,因为unisort是一个别名,所以在Cython中，所有叫uniq()的函数都是别名。   \n    \"\"\"\n    \n    return unique(l)\n    \ndef get_dict_item(d: dict, *key_list: str):\n    \"\"\"通过字典和键列表获取值,如果不存在则返回None,可以使用冒号取字典中不存在的值\n\n    Args:\n        d (dict): 字典\n        key_list (list): 键列表\n\n    Returns:\n        any: 值\n    \"\"\"\n    for keys in key_list:\n        if keys in d:\n            d = d[keys]\n        elif keys.startswith(':'):", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    for i in l:\n        if i not in result:\n            result.append(i)\n    return result\n\ndef uniq(l: list):\n    \"\"\"uniq()帮助函数是unique()的别名,因为unisort是一个别名,所以在Cython中，所有叫uniq()的函数都是别名。   \n    \"\"\"\n    \n    return unique(l)\n    \ndef get_dict_item(d: dict, *key_list: str):\n    \"\"\"通过字典和键列表获取值,如果不存在则返回None,可以使用冒号取字典中不存在的值\n\n    Args:\n        d (dict): 字典\n        key_list (list): 键列表\n\n    Returns:\n        any: 值\n    \"\"\"\n    for keys in key_list:\n        if keys in d:\n            d = d[keys]\n        elif keys.startswith(':'):"}
{"task_id": "HumanEval/34", "completion": "    return list(dict.fromkeys(l))\n\ndef unique_str(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(dict.fromkeys(l).keys())\n\ndef get_list_from_string(s: str, sep: str = ','):\n    \"\"\"把字符串转为列表\"\"\"\n    if isinstance(s, str):\n        if len(s) > 0:\n            tmp = s.strip()\n            if tmp == '':\n                return []\n            else:\n                return tmp.split(sep)\n        else:\n            return []\n    else:\n        return []\n\ndef get_dict_attr_list(l: list, attr: str):\n    \"\"\"把列表转换为list里面的", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(dict.fromkeys(l))\n\ndef unique_str(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(dict.fromkeys(l).keys())\n\ndef get_list_from_string(s: str, sep: str = ','):\n    \"\"\"把字符串转为列表\"\"\"\n    if isinstance(s, str):\n        if len(s) > 0:\n            tmp = s.strip()\n            if tmp == '':\n                return []\n            else:\n                return tmp.split(sep)\n        else:\n            return []\n    else:\n        return []\n\ndef get_dict_attr_list(l: list, attr: str):\n    \"\"\"把列表转换为list里面的"}
{"task_id": "HumanEval/34", "completion": "    return list(set(l))\n\ndef unique1(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return l[1:]\n\ndef find_first(predicate, l):\n    \"\"\" 使用递归法计算列表中第一个满足条件的元素\n\n    >>> find_first(lambda x:x%2, [1, 2, 4, 6, 7, 8, 10, 11, 13])\n    1\n    >>> find_first(lambda x:x%2, [])\n    \"\"\"\n    if len(l) == 0:\n        return None\n    if predicate(l[0]):\n        return l[0]\n    return find", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(set(l))\n\ndef unique1(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return l[1:]\n\ndef find_first(predicate, l):\n    \"\"\" 使用递归法计算列表中第一个满足条件的元素\n\n    >>> find_first(lambda x:x%2, [1, 2, 4, 6, 7, 8, 10, 11, 13])\n    1\n    >>> find_first(lambda x:x%2, [])\n    \"\"\"\n    if len(l) == 0:\n        return None\n    if predicate(l[0]):\n        return l[0]\n    return find"}
{"task_id": "HumanEval/34", "completion": "    return sorted(list(set(l)))\n\n\ndef unique_comprehension(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list({x for x in l})\n\n\ndef unique_comprehension_one_liner(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list({x for x in l if x is not None})\n\ndef unique_comprehension_one_liner_set(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0,", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))\n\n\ndef unique_comprehension(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list({x for x in l})\n\n\ndef unique_comprehension_one_liner(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list({x for x in l if x is not None})\n\ndef unique_comprehension_one_liner_set(l: list):\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0,"}
{"task_id": "HumanEval/34", "completion": "    if len(l) == 0:\n        return []\n    return list(set(l))\n \ndef union(l1, l2):\n    \"\"\"返回两个列表的并集?    >>> union([1, 2], [2, 3])\n    [1, 2, 3]\n    \"\"\"\n    if len(l1) == 0 and len(l2) == 0: return []\n    if len(l1) == 0: return l2[:]\n    if len(l2) == 0: return l1[:]\n    l3 = []\n    for i in range(len(l1)):\n        if l1[i] not in l3:\n            l3.append(l1[i])\n    for i in range(len(l2)):\n        if l2[i] not in l3:\n            l3.append(l2[i])\n    return l3\n     \ndef intersection(l1, l2):\n    \"\"\"返回两个列表的交集?    >>> intersection([1, 2, 2],", "allcode": "\n\ndef unique(l: list):\n    \"\"\"返回列表中经过排序后的独特元素?    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l) == 0:\n        return []\n    return list(set(l))\n \ndef union(l1, l2):\n    \"\"\"返回两个列表的并集?    >>> union([1, 2], [2, 3])\n    [1, 2, 3]\n    \"\"\"\n    if len(l1) == 0 and len(l2) == 0: return []\n    if len(l1) == 0: return l2[:]\n    if len(l2) == 0: return l1[:]\n    l3 = []\n    for i in range(len(l1)):\n        if l1[i] not in l3:\n            l3.append(l1[i])\n    for i in range(len(l2)):\n        if l2[i] not in l3:\n            l3.append(l2[i])\n    return l3\n     \ndef intersection(l1, l2):\n    \"\"\"返回两个列表的交集?    >>> intersection([1, 2, 2],"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素  >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef sum_element(l: list):\n    \"\"\"返回列表中所有元素的和  >>> sum_element([1, 2, 3])\n    6\n    >>> sum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    134\n    \"\"\"\n    return sum(l)\n\ndef join_list(l: list, sep: str='_'):\n    \"\"\"将列表中的字符串元素用sep连接  >>> join_list(['a', 'b', 'c'])\n    'a_", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素  >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef sum_element(l: list):\n    \"\"\"返回列表中所有元素的和  >>> sum_element([1, 2, 3])\n    6\n    >>> sum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    134\n    \"\"\"\n    return sum(l)\n\ndef join_list(l: list, sep: str='_'):\n    \"\"\"将列表中的字符串元素用sep连接  >>> join_list(['a', 'b', 'c'])\n    'a_"}
{"task_id": "HumanEval/35", "completion": "    max_num = l[0]\n    for num in l:\n        if num > max_num:\n            max_num = num\n    return max_num\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素   >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_num = l[0]\n    for num in l:\n        if num < min_num:\n            min_num = num\n    return min_num\n\n\ndef sum_element(l: list):\n    \"\"\"\n    返回列表中的元素和。   >>> sum_element([1, 2, 3])\n    6\n    >>> sum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_num = l[0]\n    for num in l:\n        if num > max_num:\n            max_num = num\n    return max_num\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素   >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    min_num = l[0]\n    for num in l:\n        if num < min_num:\n            min_num = num\n    return min_num\n\n\ndef sum_element(l: list):\n    \"\"\"\n    返回列表中的元素和。   >>> sum_element([1, 2, 3])\n    6\n    >>> sum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef count_by(func, l: list):\n    \"\"\"返回列表中满足func的元素个数\"\"\"\n    count = 0\n    for x in l:\n        if func(x):\n            count += 1\n    return count\n\n\ndef find_by(func, l: list):\n    \"\"\"返回列表中满足func的元素的第一个元素\"\"\"\n    for x in l:\n        if func(x):\n            return x\n    return None\n\n\ndef index_of_last_before(func, l: list):\n    \"\"\"返回列表中，", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\n\ndef count_by(func, l: list):\n    \"\"\"返回列表中满足func的元素个数\"\"\"\n    count = 0\n    for x in l:\n        if func(x):\n            count += 1\n    return count\n\n\ndef find_by(func, l: list):\n    \"\"\"返回列表中满足func的元素的第一个元素\"\"\"\n    for x in l:\n        if func(x):\n            return x\n    return None\n\n\ndef index_of_last_before(func, l: list):\n    \"\"\"返回列表中，"}
{"task_id": "HumanEval/35", "completion": "    _max = l[0]\n    if len(l) == 1:\n        return _max\n    else:\n        for i in range(1, len(l)):\n            if _max < l[i]:\n                _max = l[i]\n        return _max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1])\n    1\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    _min = l[0]\n    if len(l) == 1:\n        return _min\n    else:\n        for i in range(1, len(l)):\n            if _min > l[i]:\n                _min = l[i]\n        return _min\n\n\ndef quick_sort(l: list):\n    \"\"\"利用快", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    _max = l[0]\n    if len(l) == 1:\n        return _max\n    else:\n        for i in range(1, len(l)):\n            if _max < l[i]:\n                _max = l[i]\n        return _max\n\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素\n    >>> min_element([1])\n    1\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    _min = l[0]\n    if len(l) == 1:\n        return _min\n    else:\n        for i in range(1, len(l)):\n            if _min > l[i]:\n                _min = l[i]\n        return _min\n\n\ndef quick_sort(l: list):\n    \"\"\"利用快"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef average_element(l: list):\n    \"\"\"返回列表中元素的平均值    >>> average_element([1, 2, 3])\n    2\n    >>> average_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    18.5\n    \"\"\"\n    return sum(l) / len(l)\n\ndef median_element(l: list):\n    \"\"\"返回列表中元素的中位数    >>> median_element([1, 2, 3])\n    2\n    >>>", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef average_element(l: list):\n    \"\"\"返回列表中元素的平均值    >>> average_element([1, 2, 3])\n    2\n    >>> average_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    18.5\n    \"\"\"\n    return sum(l) / len(l)\n\ndef median_element(l: list):\n    \"\"\"返回列表中元素的中位数    >>> median_element([1, 2, 3])\n    2\n    >>>"}
{"task_id": "HumanEval/35", "completion": "    max_el = l[0]\n    for i in l:\n        if i > max_el:\n            max_el = i\n    return max_el \n\n# 在列表中查找元素，如果找到则返回下标值，否则返回-1\ndef find_element(l: list, value):\n    \"\"\"在列表中查找元素，如果找到则返回下标值，否则返回-1\n    >>> find_element([1, 2, 3], 3)\n    2\n    >>> find_element([1, 2, 3], 4)\n    -1\n    \"\"\"\n    for index, i in enumerate(l):\n        if i == value:\n            return index\n    return -1\n\n# 查找最小元素的索引\ndef min_element_index(l: list):\n    \"\"\"查找列表的最小值的下标值 \n    >>> min_element_index([1, 2, 3])\n    0", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_el = l[0]\n    for i in l:\n        if i > max_el:\n            max_el = i\n    return max_el \n\n# 在列表中查找元素，如果找到则返回下标值，否则返回-1\ndef find_element(l: list, value):\n    \"\"\"在列表中查找元素，如果找到则返回下标值，否则返回-1\n    >>> find_element([1, 2, 3], 3)\n    2\n    >>> find_element([1, 2, 3], 4)\n    -1\n    \"\"\"\n    for index, i in enumerate(l):\n        if i == value:\n            return index\n    return -1\n\n# 查找最小元素的索引\ndef min_element_index(l: list):\n    \"\"\"查找列表的最小值的下标值 \n    >>> min_element_index([1, 2, 3])\n    0"}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef max_element_2(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element_2([1, 2, 3])\n    3\n    >>> max_element_2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        return None\n    elif len(l) == 1:\n        return l[0]\n    else:\n        max_num = l[0]\n        for e in l:\n            if e > max_num:\n                max_num = e\n        return max_num\n\ndef max_element_3(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element_3([1, 2, 3])\n    3\n    >>> max_element_3([5, 3, -5, 2, -3, 3, 9, 0,", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef max_element_2(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element_2([1, 2, 3])\n    3\n    >>> max_element_2([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 0:\n        return None\n    elif len(l) == 1:\n        return l[0]\n    else:\n        max_num = l[0]\n        for e in l:\n            if e > max_num:\n                max_num = e\n        return max_num\n\ndef max_element_3(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element_3([1, 2, 3])\n    3\n    >>> max_element_3([5, 3, -5, 2, -3, 3, 9, 0,"}
{"task_id": "HumanEval/35", "completion": "    n = len(l)\n    if n == 0:\n        raise ValueError(\"空列表\")\n    max_val = l[0]\n    for i in range(n):\n        if max_val < l[i]:\n            max_val = l[i]\n    return max_val\n\n\n# ===================================================================================\n# 拓展题：列表排序，实现一个排序函数，实现如下效果。\n# 假设列表中只包含正数\n# >>> sort([1, 2, 3, 43, 5, 6, 7, 8, 9, 10])\n# [1, 2, 3, 5, 6, 7, 8, 9, 10, 43]\n# 参考答案和解析：\n\ndef sort(l: list):\n    \"\"\"排序列表中的数值，使得结果列表中的元素是", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    n = len(l)\n    if n == 0:\n        raise ValueError(\"空列表\")\n    max_val = l[0]\n    for i in range(n):\n        if max_val < l[i]:\n            max_val = l[i]\n    return max_val\n\n\n# ===================================================================================\n# 拓展题：列表排序，实现一个排序函数，实现如下效果。\n# 假设列表中只包含正数\n# >>> sort([1, 2, 3, 43, 5, 6, 7, 8, 9, 10])\n# [1, 2, 3, 5, 6, 7, 8, 9, 10, 43]\n# 参考答案和解析：\n\ndef sort(l: list):\n    \"\"\"排序列表中的数值，使得结果列表中的元素是"}
{"task_id": "HumanEval/35", "completion": "    if len(l) == 1:\n        return l[0]\n    elif len(l) == 2:\n        return l[0] if l[0] > l[1] else l[1]\n    else:\n        return max(l[0], max_element(l[1:]))\n\n\ndef get_data(path: str):\n    \"\"\"读取文件\n    \n    :param path: 文件路径\n    :return: 返回文件的内容\n    \"\"\"\n    f = open(path, 'r', encoding='utf-8')\n    data = f.read()\n    f.close()\n    return data\n\n\ndef get_data_in_lines(path: str):\n    \"\"\"读取文件并且把文件分割成列表\n    \n    :param path: 文件路径\n    :return: 返回文件中的每一行\n    \"\"\"\n    f = open(path, 'r', encoding='utf-8')\n    data = f.", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    elif len(l) == 2:\n        return l[0] if l[0] > l[1] else l[1]\n    else:\n        return max(l[0], max_element(l[1:]))\n\n\ndef get_data(path: str):\n    \"\"\"读取文件\n    \n    :param path: 文件路径\n    :return: 返回文件的内容\n    \"\"\"\n    f = open(path, 'r', encoding='utf-8')\n    data = f.read()\n    f.close()\n    return data\n\n\ndef get_data_in_lines(path: str):\n    \"\"\"读取文件并且把文件分割成列表\n    \n    :param path: 文件路径\n    :return: 返回文件中的每一行\n    \"\"\"\n    f = open(path, 'r', encoding='utf-8')\n    data = f."}
{"task_id": "HumanEval/35", "completion": "    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef average_element(l: list):\n    \"\"\"返回列表中的平均元素\n    >>> average_element(list(range(5)))\n    2.0\n    >>> average_element([10, 10, 10])\n    10.0\n    \"\"\"\n    return sum(l) / len(l)\n\ndef sum_of_element(l: list):\n    \"\"\"返回列表中所有元素的和    >>> sum_of_element(list(range(5)))\n    10\n    >>> sum_of_element([10, 10, 10])\n    30", "allcode": "\n\ndef max_element(l: list):\n    \"\"\"返回列表中的最大元素    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)\n\ndef min_element(l: list):\n    \"\"\"返回列表中的最小元素    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)\n\ndef average_element(l: list):\n    \"\"\"返回列表中的平均元素\n    >>> average_element(list(range(5)))\n    2.0\n    >>> average_element([10, 10, 10])\n    10.0\n    \"\"\"\n    return sum(l) / len(l)\n\ndef sum_of_element(l: list):\n    \"\"\"返回列表中所有元素的和    >>> sum_of_element(list(range(5)))\n    10\n    >>> sum_of_element([10, 10, 10])\n    30"}
{"task_id": "HumanEval/36", "completion": "    if n < 1:\n        return 0\n    # your codes\n    \n    res = 0\n    i = 1\n\n    while i < n:\n        if i % 11 == 0 and i % 13 == 0:\n            res += 1\n        i += 1\n    return res\n\ndef test_fizz_buzz():\n    assert fizz_buzz(50) == 0, \"Test case 1 failed\"\n    assert fizz_buzz(78) == 2, \"Test case 2 failed\"\n    assert fizz_buzz(79) == 3, \"Test case 3 failed\"\n    print('All passed!')\n\ntest_fizz_buzz()\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n\n# ### 43. 计算涨跌幅\n# \n# 把两个数字相减来计算涨跌幅，如果结果大于0 就", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n < 1:\n        return 0\n    # your codes\n    \n    res = 0\n    i = 1\n\n    while i < n:\n        if i % 11 == 0 and i % 13 == 0:\n            res += 1\n        i += 1\n    return res\n\ndef test_fizz_buzz():\n    assert fizz_buzz(50) == 0, \"Test case 1 failed\"\n    assert fizz_buzz(78) == 2, \"Test case 2 failed\"\n    assert fizz_buzz(79) == 3, \"Test case 3 failed\"\n    print('All passed!')\n\ntest_fizz_buzz()\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n\n# ### 43. 计算涨跌幅\n# \n# 把两个数字相减来计算涨跌幅，如果结果大于0 就"}
{"task_id": "HumanEval/36", "completion": "    assert n>0, '输入的数字应该是正数'\n    cnt = 0\n    for i in range(n):\n        if i%11==0 and i%13==0 and i%7==0:\n            cnt += 1\n    return cnt\n    \ndef fizz_buzz1(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz1(50)\n    0\n    >>> fizz_buzz1(78)\n    2\n    >>> fizz_buzz1(79)\n    3\n    \"\"\"\n    assert n>0, '输入的数字应该是正数'\n    cnt = 0\n    for i in range(n):\n        if i%11==0 and i%13==0 and i%7==0:\n            cnt += 1\n    return cnt\n    \ndef fizz_buzz2", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    assert n>0, '输入的数字应该是正数'\n    cnt = 0\n    for i in range(n):\n        if i%11==0 and i%13==0 and i%7==0:\n            cnt += 1\n    return cnt\n    \ndef fizz_buzz1(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz1(50)\n    0\n    >>> fizz_buzz1(78)\n    2\n    >>> fizz_buzz1(79)\n    3\n    \"\"\"\n    assert n>0, '输入的数字应该是正数'\n    cnt = 0\n    for i in range(n):\n        if i%11==0 and i%13==0 and i%7==0:\n            cnt += 1\n    return cnt\n    \ndef fizz_buzz2"}
{"task_id": "HumanEval/36", "completion": "    n -= 1\n    return n//11 - n//13\n\ndef find_sum_odd_numbers_in_range(start_number, end_number):\n    \"\"\"返回在start_number - end_number之间的所有奇数的和，注意，返回的结果应该含有end_number\"\"\"\n    a = 0\n    for i in range(start_number,end_number+1):\n        if i%2!= 0:\n            a = a+i\n    return(a)\n\ndef sum_digits(number):\n    \"\"\"求一个数的各位数字的和，举例：sum_digits(253)返回5\"\"\"\n    a = 0\n    for i in str(number):\n        a = a+int(i)\n    return(a)\n\ndef find_max_by_binary_search(numbers):\n    \"\"\"在一堆数字里，找到做max 值，要求使用二分查找\"\"\"\n", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    n -= 1\n    return n//11 - n//13\n\ndef find_sum_odd_numbers_in_range(start_number, end_number):\n    \"\"\"返回在start_number - end_number之间的所有奇数的和，注意，返回的结果应该含有end_number\"\"\"\n    a = 0\n    for i in range(start_number,end_number+1):\n        if i%2!= 0:\n            a = a+i\n    return(a)\n\ndef sum_digits(number):\n    \"\"\"求一个数的各位数字的和，举例：sum_digits(253)返回5\"\"\"\n    a = 0\n    for i in str(number):\n        a = a+int(i)\n    return(a)\n\ndef find_max_by_binary_search(numbers):\n    \"\"\"在一堆数字里，找到做max 值，要求使用二分查找\"\"\"\n"}
{"task_id": "HumanEval/36", "completion": "    # 答案: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 6", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 答案: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 6"}
{"task_id": "HumanEval/36", "completion": "    cnt = 0\n    for num in range(n):\n        if num%11==7 and num%13==7:\n            cnt += 1\n    return cnt\n\nprint(", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    cnt = 0\n    for num in range(n):\n        if num%11==7 and num%13==7:\n            cnt += 1\n    return cnt\n\nprint("}
{"task_id": "HumanEval/36", "completion": "    # 以下代码返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数\n    s = set()\n    for i in range(2, n):\n        # 能同时被11 和13 整除的数字\n        if i % 11 == 0 and i % 13 == 0:\n            s.add(i)\n    return len(s)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n\n## 3. 霍夫曼编码压缩算法\n\n> 霍夫曼编码讲述的将一个字符串按照一定的规则进行编码，最后通过比例来判断规则的合理性。霍夫曼编码是一种比较好的压", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # 以下代码返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数\n    s = set()\n    for i in range(2, n):\n        # 能同时被11 和13 整除的数字\n        if i % 11 == 0 and i % 13 == 0:\n            s.add(i)\n    return len(s)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n\n## 3. 霍夫曼编码压缩算法\n\n> 霍夫曼编码讲述的将一个字符串按照一定的规则进行编码，最后通过比例来判断规则的合理性。霍夫曼编码是一种比较好的压"}
{"task_id": "HumanEval/36", "completion": "    i, j = 0, 0\n    while i < n:\n        if i % 11 == 0 or i % 13 == 0:\n            if i % 7 == 0:\n                j += 1\n        i += 1\n    return j\n\ndef prime_factors(n: int):  \n    \"\"\"返回小于或等于n 的最小质数的list  >>> prime_factors(1)\n    [2]\n    >>> prime_factors(38)\n    [2, 2, 7]\n    \"\"\"\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n //2\n    for i in range(3, int(n**.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n//i\n    if n > 2:\n        factors.append(n)\n    return factors\n    \ndef prime_factorization(n: int):\n    \"\"\"输入一", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    i, j = 0, 0\n    while i < n:\n        if i % 11 == 0 or i % 13 == 0:\n            if i % 7 == 0:\n                j += 1\n        i += 1\n    return j\n\ndef prime_factors(n: int):  \n    \"\"\"返回小于或等于n 的最小质数的list  >>> prime_factors(1)\n    [2]\n    >>> prime_factors(38)\n    [2, 2, 7]\n    \"\"\"\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n //2\n    for i in range(3, int(n**.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n//i\n    if n > 2:\n        factors.append(n)\n    return factors\n    \ndef prime_factorization(n: int):\n    \"\"\"输入一"}
{"task_id": "HumanEval/36", "completion": "    total = 0\n    counter = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            total = total + counter\n        if i % 7 == 0:\n            counter = counter + 1\n    return total\n\n\ndef count_the_repeated_characters(s: str):\n    \"\"\"计算出给定字符串中重复出现的字符的数量。 \n    >>> count_the_repeated_characters('abaccdeff') \n    3\n    >>> count_the_repeated_characters('') \n    0\n    \n    \"\"\"\n    counter = 0\n    flag = []\n    for i in range(len(s)):\n        if s[i] not in flag:\n            flag.append(s[i])\n        for j in range(len(flag)):\n            if s[i] == flag[j]:\n                counter = counter + 1\n    return counter\n\n\ndef get_index_of_max_value(numbers: list", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total = 0\n    counter = 0\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            total = total + counter\n        if i % 7 == 0:\n            counter = counter + 1\n    return total\n\n\ndef count_the_repeated_characters(s: str):\n    \"\"\"计算出给定字符串中重复出现的字符的数量。 \n    >>> count_the_repeated_characters('abaccdeff') \n    3\n    >>> count_the_repeated_characters('') \n    0\n    \n    \"\"\"\n    counter = 0\n    flag = []\n    for i in range(len(s)):\n        if s[i] not in flag:\n            flag.append(s[i])\n        for j in range(len(flag)):\n            if s[i] == flag[j]:\n                counter = counter + 1\n    return counter\n\n\ndef get_index_of_max_value(numbers: list"}
{"task_id": "HumanEval/36", "completion": "    counter = 0\n    for i in range(1, n):\n        if (i % 11 == 0) and (i % 13 == 0):\n            if i % 7 == 0:\n                counter += 1\n    return counter\n\n\ndef unique_triangles():\n    \"\"\"\n    unique_triangles(n)\n    返回小于等于n 的所有三角形的总和，其中三角形为正整数的满足a + b > c 且\n    a + c > b 且 b + c > a 三个不等式的集合\n    说明：测试用例1 ≤ n ≤ 10**5\n    :param n:\n    :return:\n    \"\"\"\n    # 测试用例\n    # print(unique_triangles(7))\n    # print(unique_triangles(9))\n    # print(unique_triangles(10))\n    # print(unique_triangles(11))\n    # print(unique_triangles(", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    counter = 0\n    for i in range(1, n):\n        if (i % 11 == 0) and (i % 13 == 0):\n            if i % 7 == 0:\n                counter += 1\n    return counter\n\n\ndef unique_triangles():\n    \"\"\"\n    unique_triangles(n)\n    返回小于等于n 的所有三角形的总和，其中三角形为正整数的满足a + b > c 且\n    a + c > b 且 b + c > a 三个不等式的集合\n    说明：测试用例1 ≤ n ≤ 10**5\n    :param n:\n    :return:\n    \"\"\"\n    # 测试用例\n    # print(unique_triangles(7))\n    # print(unique_triangles(9))\n    # print(unique_triangles(10))\n    # print(unique_triangles(11))\n    # print(unique_triangles("}
{"task_id": "HumanEval/36", "completion": "\n    def fb(n: int):\n        if n < 10:\n            return 1\n        else:\n            return 4*fb(n//4) + 3*fb(n//3) + 2*fb(n//2)\n\n    return fb(n)\n\n\ndef power_count(n: int):\n    \"\"\"计算输入所有数字中，每个数字的平方与输入数字的和    >>> power_count(100)\n    475\n    >>> power_count(1000)\n    128485\n    \"\"\"\n    return sum(map(lambda x: x ** 2, range(1, n+1)))\n\n\ndef get_sum(num_list: list):\n    \"\"\"给定一个非空的数组，如果一个数字出现了两次，其余数字都出现一次\n    求这个数组中，出现两次的数字。\"\"\"\n    return sum(set(num_list))-sum(num_list)", "allcode": "\n\ndef fizz_buzz(n: int):\n    \"\"\"返回在能同时被11 和13 整除的小于n 的整数中，数字7 出现的次数    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    def fb(n: int):\n        if n < 10:\n            return 1\n        else:\n            return 4*fb(n//4) + 3*fb(n//3) + 2*fb(n//2)\n\n    return fb(n)\n\n\ndef power_count(n: int):\n    \"\"\"计算输入所有数字中，每个数字的平方与输入数字的和    >>> power_count(100)\n    475\n    >>> power_count(1000)\n    128485\n    \"\"\"\n    return sum(map(lambda x: x ** 2, range(1, n+1)))\n\n\ndef get_sum(num_list: list):\n    \"\"\"给定一个非空的数组，如果一个数字出现了两次，其余数字都出现一次\n    求这个数组中，出现两次的数字。\"\"\"\n    return sum(set(num_list))-sum(num_list)"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    if min(l) < 0:\n        return False\n    else:\n        left = 0\n        right = max(l)\n        while left < right:\n            if left + right == 0:\n                return True\n            elif left + right < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\n\ndef get_file_content(filename, mode='r'):\n    \"\"\"\n    get_file_content 打开指定文件，读取文件内容，返回一个list，其中每个元素代表文件中一行的内容\n    ，如果文件不存在或者读取失败，则返回一个空的list。\n    \n    >>> fname = 'dummy'\n    >>> f = open(fname, 'w')\n    >>> f.write('line1\\\\n')\n    >>> f.write('line2\\\\n')\n    >>> f.write('line3\\\\n')\n    >>> f.close()\n    >>> get_file", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    if min(l) < 0:\n        return False\n    else:\n        left = 0\n        right = max(l)\n        while left < right:\n            if left + right == 0:\n                return True\n            elif left + right < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\n\ndef get_file_content(filename, mode='r'):\n    \"\"\"\n    get_file_content 打开指定文件，读取文件内容，返回一个list，其中每个元素代表文件中一行的内容\n    ，如果文件不存在或者读取失败，则返回一个空的list。\n    \n    >>> fname = 'dummy'\n    >>> f = open(fname, 'w')\n    >>> f.write('line1\\\\n')\n    >>> f.write('line2\\\\n')\n    >>> f.write('line3\\\\n')\n    >>> f.close()\n    >>> get_file"}
{"task_id": "HumanEval/43", "completion": "    if len(l) == 0:\n        return False\n    if len(l) == 1:\n        return False\n    m = dict()\n    for i in range(len(l)):\n        if l[i] not in m:\n            m[l[i]] = 1\n        else:\n            m[l[i]] += 1\n    for i in range(len(l)):\n        if m[-l[i]] == m[l[i]] and i!= len(l) - 1:\n            return True\n    return False\n \n \ndef even_digits(n):\n    \"\"\"\n    even_digits 将整数作为输入，如果该数字包含偶数位数字，则返回True    >>>\n    even_digits(123456789)\n    True\n    >>> even_digits(1234567891)\n    False\n    >>> even_digits(1234567899)\n    True\n    >>> even_digits", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) == 0:\n        return False\n    if len(l) == 1:\n        return False\n    m = dict()\n    for i in range(len(l)):\n        if l[i] not in m:\n            m[l[i]] = 1\n        else:\n            m[l[i]] += 1\n    for i in range(len(l)):\n        if m[-l[i]] == m[l[i]] and i!= len(l) - 1:\n            return True\n    return False\n \n \ndef even_digits(n):\n    \"\"\"\n    even_digits 将整数作为输入，如果该数字包含偶数位数字，则返回True    >>>\n    even_digits(123456789)\n    True\n    >>> even_digits(1234567891)\n    False\n    >>> even_digits(1234567899)\n    True\n    >>> even_digits"}
{"task_id": "HumanEval/43", "completion": "    s = set(l)\n    return s & set([0 - i for i in l])\n\n\ndef get_all_permutations(s):\n    \"\"\"\n    获取一个字符串的所有排列字符串\n    >>> get_all_permutations('abc')\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    \"\"\"\n    length = len(s)\n    if length < 2:\n        return [s]\n\n    result = []\n    for i in range(length):\n        c = s[i]\n        tmp = s[:i] + s[i + 1:]\n        for item in get_all_permutations(tmp):\n            result.append(c + item)\n\n    return result\n\n\ndef generate_all_pairs(l):\n    \"\"\"\n    generate_all_pairs 获取一个整数列表的所有组合\n    >>> generate_all_pairs([1, 2, 3])\n    [(1, 2),", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    s = set(l)\n    return s & set([0 - i for i in l])\n\n\ndef get_all_permutations(s):\n    \"\"\"\n    获取一个字符串的所有排列字符串\n    >>> get_all_permutations('abc')\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    \"\"\"\n    length = len(s)\n    if length < 2:\n        return [s]\n\n    result = []\n    for i in range(length):\n        c = s[i]\n        tmp = s[:i] + s[i + 1:]\n        for item in get_all_permutations(tmp):\n            result.append(c + item)\n\n    return result\n\n\ndef generate_all_pairs(l):\n    \"\"\"\n    generate_all_pairs 获取一个整数列表的所有组合\n    >>> generate_all_pairs([1, 2, 3])\n    [(1, 2),"}
{"task_id": "HumanEval/43", "completion": "    l.sort()\n    for i in range(len(l)):\n        num = l[i]\n        if pairs_sum_to_zero_helper(l, num, i):\n            return True\n    return False\n\n\ndef pairs_sum_to_zero_helper(l, num, i):\n    \"\"\"\n    pairs_sum_to_zero_helper 和pairs_sum_to_zero的不同之处在于，pairs_sum_to_zero\n    每次调用helper函数都从头开始查找，而helper函数在查找过程中，将i+1 的地方的\n    元素设为None，即剔除元素。这样做的主要目的是当l中元素大于num时，防止溢出。\n    \"\"\"\n    # 当剩余数字中有相同元素时也可以计算，但这时无论计算成功还是失败，都将返回True\n    if i", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(len(l)):\n        num = l[i]\n        if pairs_sum_to_zero_helper(l, num, i):\n            return True\n    return False\n\n\ndef pairs_sum_to_zero_helper(l, num, i):\n    \"\"\"\n    pairs_sum_to_zero_helper 和pairs_sum_to_zero的不同之处在于，pairs_sum_to_zero\n    每次调用helper函数都从头开始查找，而helper函数在查找过程中，将i+1 的地方的\n    元素设为None，即剔除元素。这样做的主要目的是当l中元素大于num时，防止溢出。\n    \"\"\"\n    # 当剩余数字中有相同元素时也可以计算，但这时无论计算成功还是失败，都将返回True\n    if i"}
{"task_id": "HumanEval/43", "completion": "    l = set(l)\n    for i in l:\n        if 0 - i in l:\n            return True\n    return False\n\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l = set(l)\n    for i in l:\n        if 0 - i in l:\n           ", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l = set(l)\n    for i in l:\n        if 0 - i in l:\n            return True\n    return False\n\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    l = set(l)\n    for i in l:\n        if 0 - i in l:\n           "}
{"task_id": "HumanEval/43", "completion": "    return True\n\ndef get_pair_numbers(l):\n    \"\"\"\n    get_pair_numbers 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> get_pair_numbers([1, 3, 5, 0])\n    [5, 0]\n    >>> get_pair_numbers([1, 3, -2, 1])\n    None\n    >>> get_pair_numbers([1, 2, 3, 7])\n    None\n    >>> get_pair_numbers([2, 4, -5, 3, 5, 7])\n    [-5, 7]\n    >>> get_pair_numbers([1])\n    None\n    \"\"\"\n    return True\n\ndef max_of_subarrays(l, k):\n    \"\"\"\n    max_of_subarrays 将整数列表作为输入，以及一个正整数k。\n    返回一个", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    return True\n\ndef get_pair_numbers(l):\n    \"\"\"\n    get_pair_numbers 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> get_pair_numbers([1, 3, 5, 0])\n    [5, 0]\n    >>> get_pair_numbers([1, 3, -2, 1])\n    None\n    >>> get_pair_numbers([1, 2, 3, 7])\n    None\n    >>> get_pair_numbers([2, 4, -5, 3, 5, 7])\n    [-5, 7]\n    >>> get_pair_numbers([1])\n    None\n    \"\"\"\n    return True\n\ndef max_of_subarrays(l, k):\n    \"\"\"\n    max_of_subarrays 将整数列表作为输入，以及一个正整数k。\n    返回一个"}
{"task_id": "HumanEval/43", "completion": "    for i in l:\n        for j in l:\n            if i!= j and i+j == 0:\n                return True\n    return False\n    \nprint(pairs_sum_to_zero([1, 3, 5, 0]))\nprint(pairs_sum_to_zero([1, 3, -2, 1]))\nprint(pairs_sum_to_zero([1, 2, 3, 7]))\nprint(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))\nprint(pairs_sum_to_zero([1]))\n```\n\n#### 问题 5\n\n设计一个函数，用于返回一个整数列表的所有排列\n\n```python\ndef all_permutations(seq):\n    \"\"\"\n    all_permutations 返回一个整数列表的所有排列\n    >>> all_permutations([1, 2, 3])\n    [(1, 2, 3", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for i in l:\n        for j in l:\n            if i!= j and i+j == 0:\n                return True\n    return False\n    \nprint(pairs_sum_to_zero([1, 3, 5, 0]))\nprint(pairs_sum_to_zero([1, 3, -2, 1]))\nprint(pairs_sum_to_zero([1, 2, 3, 7]))\nprint(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))\nprint(pairs_sum_to_zero([1]))\n```\n\n#### 问题 5\n\n设计一个函数，用于返回一个整数列表的所有排列\n\n```python\ndef all_permutations(seq):\n    \"\"\"\n    all_permutations 返回一个整数列表的所有排列\n    >>> all_permutations([1, 2, 3])\n    [(1, 2, 3"}
{"task_id": "HumanEval/43", "completion": "    if len(l) < 2:\n        return False\n    if len(l) == 2:\n        return l[0] + l[1] == 0\n    for i in range(len(l)):\n        if l[i] == 0:\n            return True\n        if l[i] + l[i - 1] == 0:\n            return True\n    return False\n\n\n# Exercise 7\ndef sum_to(l, n):\n    \"\"\"\n    sum_to 将整数列表和一个整数作为输入，如果列表中有两个数之和为列表中的任何一个数，\n    则返回True，否则返回False    >>> sum_to([1, 3, 5, 0], 0)\n    True\n    >>> sum_to([1, 3, -2, 1], 5)\n    False\n    >>> sum_to([1, 2, 3, 7], 7)\n    True\n    >>> sum_to([2, 4", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) < 2:\n        return False\n    if len(l) == 2:\n        return l[0] + l[1] == 0\n    for i in range(len(l)):\n        if l[i] == 0:\n            return True\n        if l[i] + l[i - 1] == 0:\n            return True\n    return False\n\n\n# Exercise 7\ndef sum_to(l, n):\n    \"\"\"\n    sum_to 将整数列表和一个整数作为输入，如果列表中有两个数之和为列表中的任何一个数，\n    则返回True，否则返回False    >>> sum_to([1, 3, 5, 0], 0)\n    True\n    >>> sum_to([1, 3, -2, 1], 5)\n    False\n    >>> sum_to([1, 2, 3, 7], 7)\n    True\n    >>> sum_to([2, 4"}
{"task_id": "HumanEval/43", "completion": "    d = {}\n    for num in l:\n        d[num] = d.get(num, 0) + 1\n    for a in d:\n        b = -a\n        if b in d and a!= b:\n            return True\n    return False\n\n\ndef has_a_cycle(ll):\n    \"\"\"\n    has_a_cycle takes in a linked list and returns True if the list has\n    a cycle, and False otherwise.\n    >>> head = LinkedList()\n    >>> head.append(1)\n    >>> head.append(2)\n    >>> head.append(3)\n    >>> head.append(4)\n    >>> head.append(5)\n    >>> head.append(6)\n    >>> ll = LinkedList(head)\n    >>> has_a_cycle(ll)\n    False\n    >>> head.next.next.next.next.next.next = head.next.next.next\n    >>> has_a_cycle(ll)\n    True\n    >>> head.next = head.next.next.next.next\n    >>> has_a_cycle(ll)", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    d = {}\n    for num in l:\n        d[num] = d.get(num, 0) + 1\n    for a in d:\n        b = -a\n        if b in d and a!= b:\n            return True\n    return False\n\n\ndef has_a_cycle(ll):\n    \"\"\"\n    has_a_cycle takes in a linked list and returns True if the list has\n    a cycle, and False otherwise.\n    >>> head = LinkedList()\n    >>> head.append(1)\n    >>> head.append(2)\n    >>> head.append(3)\n    >>> head.append(4)\n    >>> head.append(5)\n    >>> head.append(6)\n    >>> ll = LinkedList(head)\n    >>> has_a_cycle(ll)\n    False\n    >>> head.next.next.next.next.next.next = head.next.next.next\n    >>> has_a_cycle(ll)\n    True\n    >>> head.next = head.next.next.next.next\n    >>> has_a_cycle(ll)"}
{"task_id": "HumanEval/43", "completion": "    for index, number in enumerate(l):\n        for other in l[index+1:]:\n            if number + other == 0 and number!= other:\n                return True\n    return False\n\n\ndef pairs_sum_to_zero_v2(l):\n    \"\"\"\n    pairs_sum_to_zero_v2 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero_v2([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero_v2([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero_v2([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero_v2([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero_v2([1])", "allcode": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for index, number in enumerate(l):\n        for other in l[index+1:]:\n            if number + other == 0 and number!= other:\n                return True\n    return False\n\n\ndef pairs_sum_to_zero_v2(l):\n    \"\"\"\n    pairs_sum_to_zero_v2 将整数列表作为输入，如果列表中有两个不同元素加起来的和为零，\n    则返回True，否则返回False    >>> pairs_sum_to_zero_v2([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero_v2([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero_v2([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero_v2([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero_v2([1])"}
{"task_id": "HumanEval/52", "completion": "    \n    for elem in l:\n        if elem >= t:\n            return False\n    return True\n\n\ndef count_smaller(l: list, elem: int):\n    \"\"\"计算列表 l 中小于 elem 的元素的个数  >>> count_smaller([1, 2, 4, 10], 6)\n    3\n    \"\"\"\n    return sum(1 for i in l if i < elem)\n\n\ndef count_larger(l: list, elem: int):\n    \"\"\"计算列表 l 中大于 elem 的元素的个数  >>> count_larger([1, 2, 4, 10], 6)\n    2\n    \"\"\"\n    return sum(1 for i in l if i > elem)\n\n\ndef count_equal(l: list, elem: int):\n    \"\"\"计算列表 l 中等于 elem 的元素的个数  >>> count_equal([1, 2, 4, 10], 6)\n    0\n    \"\"\"\n    return len([x for x in l", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    \n    for elem in l:\n        if elem >= t:\n            return False\n    return True\n\n\ndef count_smaller(l: list, elem: int):\n    \"\"\"计算列表 l 中小于 elem 的元素的个数  >>> count_smaller([1, 2, 4, 10], 6)\n    3\n    \"\"\"\n    return sum(1 for i in l if i < elem)\n\n\ndef count_larger(l: list, elem: int):\n    \"\"\"计算列表 l 中大于 elem 的元素的个数  >>> count_larger([1, 2, 4, 10], 6)\n    2\n    \"\"\"\n    return sum(1 for i in l if i > elem)\n\n\ndef count_equal(l: list, elem: int):\n    \"\"\"计算列表 l 中等于 elem 的元素的个数  >>> count_equal([1, 2, 4, 10], 6)\n    0\n    \"\"\"\n    return len([x for x in l"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i >= t:\n            return False\n    return True\n\n\ndef even_or_odd(l: list):\n    \"\"\"如果列表中偶数个数大于奇数个数，则返回 'even' ，否则返回 'odd'   >>> even_or_odd([1, 2, 4, 10])\n    'even'\n    >>> even_or_odd([1, 20, 4, 10])\n    'odd'\n    \"\"\"\n    even = 0\n    odd = 0\n    for i in l:\n        if i % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    if even > odd:\n        return 'even'\n    else:\n        return 'odd'\n\n\nif __name__ == \"__main__\":\n    # 测试用例\n\n    # 飞机大战\n    # 首先，把列表转换成 str\n    # 如果列表是空的", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True\n\n\ndef even_or_odd(l: list):\n    \"\"\"如果列表中偶数个数大于奇数个数，则返回 'even' ，否则返回 'odd'   >>> even_or_odd([1, 2, 4, 10])\n    'even'\n    >>> even_or_odd([1, 20, 4, 10])\n    'odd'\n    \"\"\"\n    even = 0\n    odd = 0\n    for i in l:\n        if i % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    if even > odd:\n        return 'even'\n    else:\n        return 'odd'\n\n\nif __name__ == \"__main__\":\n    # 测试用例\n\n    # 飞机大战\n    # 首先，把列表转换成 str\n    # 如果列表是空的"}
{"task_id": "HumanEval/52", "completion": "    for item in l:\n        if item >= t:\n            return False\n    return True\n\n\ndef flatten(l):\n    \"\"\"把列表中的列表扁平化为一级列表。  >>> flatten([[1, 2, 3], [4, 5, 6], 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> flatten(['a', 'b'])\n    ['a', 'b']\n    \"\"\"\n    l_flat = []\n    for item in l:\n        if type(item)!= list:\n            l_flat.append(item)\n        else:\n            l_flat.extend(item)\n    return l_flat\n\n\ndef reverse(l: list):\n    \"\"\"\n    >>> reverse([1, 2, 3])\n    [3, 2, 1]\n    >>> reverse([[1, 2], 3, 4])\n    [4, 3, [2, 1]]\n    \"\"\"\n    l_re", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for item in l:\n        if item >= t:\n            return False\n    return True\n\n\ndef flatten(l):\n    \"\"\"把列表中的列表扁平化为一级列表。  >>> flatten([[1, 2, 3], [4, 5, 6], 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> flatten(['a', 'b'])\n    ['a', 'b']\n    \"\"\"\n    l_flat = []\n    for item in l:\n        if type(item)!= list:\n            l_flat.append(item)\n        else:\n            l_flat.extend(item)\n    return l_flat\n\n\ndef reverse(l: list):\n    \"\"\"\n    >>> reverse([1, 2, 3])\n    [3, 2, 1]\n    >>> reverse([[1, 2], 3, 4])\n    [4, 3, [2, 1]]\n    \"\"\"\n    l_re"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i >= t:\n            return False\n    return True\n\ndef num_above(l: list, t: int):\n    \"\"\"返回列表中大于阈值 t 的元素数量         >>> num_above([1, 2, 4, 10], 100)\n    0\n    >>> num_above([1, 20, 4, 10], 5)\n    2\n    \"\"\"\n    cnt = 0\n    for i in l:\n        if i > t:\n            cnt += 1\n    return cnt\n\ndef sum_above(l: list, t: int):\n    \"\"\"返回列表中大于阈值 t 的元素和           >>> sum_above([1, 2, 4, 10], 100)\n    0\n    >>> sum_above([1, 20, 4, 10], 5)\n    22\n    \"\"\"\n    s = 0\n    for i in l:\n        if i > t:", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True\n\ndef num_above(l: list, t: int):\n    \"\"\"返回列表中大于阈值 t 的元素数量         >>> num_above([1, 2, 4, 10], 100)\n    0\n    >>> num_above([1, 20, 4, 10], 5)\n    2\n    \"\"\"\n    cnt = 0\n    for i in l:\n        if i > t:\n            cnt += 1\n    return cnt\n\ndef sum_above(l: list, t: int):\n    \"\"\"返回列表中大于阈值 t 的元素和           >>> sum_above([1, 2, 4, 10], 100)\n    0\n    >>> sum_above([1, 20, 4, 10], 5)\n    22\n    \"\"\"\n    s = 0\n    for i in l:\n        if i > t:"}
{"task_id": "HumanEval/52", "completion": "    flag = 0 \n    for i in l: \n        if(i < t): \n            flag += 1 \n        else:\n            flag = 0\n            break\n    if flag == len(l): \n        return True\n    else: \n        return False\n\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([1, 2, 4, 10], 100)\n    False\n    >>> above_threshold([1, 20, 4, 10], 5)\n    True\n    \"\"\"\n    flag = 0 \n    for i in l: \n        if(i > t): \n            flag += 1 \n        else:\n            flag = 0\n            break\n    if flag == len(l): \n        return True\n    else: \n        return False\n\n\ndef sum_of_above_threshold(l: list, t", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    flag = 0 \n    for i in l: \n        if(i < t): \n            flag += 1 \n        else:\n            flag = 0\n            break\n    if flag == len(l): \n        return True\n    else: \n        return False\n\n\ndef above_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都高于阈阈值t，则返回 True   >>> above_threshold([1, 2, 4, 10], 100)\n    False\n    >>> above_threshold([1, 20, 4, 10], 5)\n    True\n    \"\"\"\n    flag = 0 \n    for i in l: \n        if(i > t): \n            flag += 1 \n        else:\n            flag = 0\n            break\n    if flag == len(l): \n        return True\n    else: \n        return False\n\n\ndef sum_of_above_threshold(l: list, t"}
{"task_id": "HumanEval/52", "completion": "    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef get_count(l: list, t: int):\n    \"\"\"返回列表 l 中小于阈值t的数字个数。\n    >>> get_count([1, 2, 4, 10], 100)\n    0\n    >>> get_count([1, 20, 4, 10], 5)\n    1\n    \"\"\"\n    count = 0\n    for i in l:\n        if i < t:\n            count += 1\n    return count\n\ndef get_above_count(l: list, t: int):\n    \"\"\"返回列表 l 中大于阈值t的数字个数。\n    >>> get_above_count([1, 2, 4, 10], 100)\n    4\n    >>> get_above_count([10, 20, 100, 1000], 100)\n    3\n    \"\"\" \n    count", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i > t:\n            return False\n    return True\n\ndef get_count(l: list, t: int):\n    \"\"\"返回列表 l 中小于阈值t的数字个数。\n    >>> get_count([1, 2, 4, 10], 100)\n    0\n    >>> get_count([1, 20, 4, 10], 5)\n    1\n    \"\"\"\n    count = 0\n    for i in l:\n        if i < t:\n            count += 1\n    return count\n\ndef get_above_count(l: list, t: int):\n    \"\"\"返回列表 l 中大于阈值t的数字个数。\n    >>> get_above_count([1, 2, 4, 10], 100)\n    4\n    >>> get_above_count([10, 20, 100, 1000], 100)\n    3\n    \"\"\" \n    count"}
{"task_id": "HumanEval/52", "completion": "    return all(num < t for num in l)\n\n\n# 写一个函数，接受一个字典和一个整数，并把字典中值小于给定整数的键从字典中剔除。 >>> dict = {\n# 'apple':10, 'orange':15, 'pear':22, 'banana':11, 'kiwi':2}\n# remove_key_below_value({'apple':10, 'orange':15, 'pear':22, 'banana':11, 'kiwi':2},\n# 9) dict {'apple': 10, 'banana': 11, 'kiwi': 2, 'orange': 15}\n\n\ndef remove_key_below_value(d: dict, v: int):\n    \"\"\"移除字典中值小于给定整数的键。\n\n    >>> dict = {\n   ...     'apple':10, 'orange':15, 'pear':", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(num < t for num in l)\n\n\n# 写一个函数，接受一个字典和一个整数，并把字典中值小于给定整数的键从字典中剔除。 >>> dict = {\n# 'apple':10, 'orange':15, 'pear':22, 'banana':11, 'kiwi':2}\n# remove_key_below_value({'apple':10, 'orange':15, 'pear':22, 'banana':11, 'kiwi':2},\n# 9) dict {'apple': 10, 'banana': 11, 'kiwi': 2, 'orange': 15}\n\n\ndef remove_key_below_value(d: dict, v: int):\n    \"\"\"移除字典中值小于给定整数的键。\n\n    >>> dict = {\n   ...     'apple':10, 'orange':15, 'pear':"}
{"task_id": "HumanEval/52", "completion": "    # 遍历输出数字，如果大于阈值，则退出函数\n    for x in l:\n        if x > t:\n            return False\n    return True\n\n\n# 测试代码\nprint(\"###### 测试函数 above_threshold  ######\")\nassert above_threshold([ 1, 2, 4, 10], 100) == True\nassert above_threshold([ 1, 2, 4, 10], 5) == False\nassert above_threshold([ 1, 20, 4, 10], 5) == True\n\nprint(\"###### 测试函数 below_threshold  ######\")\nassert below_threshold([ 1, 2, 4, 10], 100) == False\nassert below_threshold([ 1, 2, 4, 10], 5) == True\nassert below_threshold([ 1, 20, 4, 10], 5) == False\n\n", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    # 遍历输出数字，如果大于阈值，则退出函数\n    for x in l:\n        if x > t:\n            return False\n    return True\n\n\n# 测试代码\nprint(\"###### 测试函数 above_threshold  ######\")\nassert above_threshold([ 1, 2, 4, 10], 100) == True\nassert above_threshold([ 1, 2, 4, 10], 5) == False\nassert above_threshold([ 1, 20, 4, 10], 5) == True\n\nprint(\"###### 测试函数 below_threshold  ######\")\nassert below_threshold([ 1, 2, 4, 10], 100) == False\nassert below_threshold([ 1, 2, 4, 10], 5) == True\nassert below_threshold([ 1, 20, 4, 10], 5) == False\n\n"}
{"task_id": "HumanEval/52", "completion": "    if l is None:\n        return False\n    for i in l:\n        if i >= t:\n            return False\n    return True\n```\n\n### 2.1.2. 练习 1 使用缩进绘制一颗树\n\n写一个函数，接受一个字符串表示的树，打印出来。\n\n```\ndef draw_tree(tree):\n    \"\"\"打印出给定的树\"\"\"\n    pass\n```\n\n## 2.1.3. 练习 2 将单链表转化为字符串\n\n写一个函数，接受一个单链表，产生一个字符串。\n\n```\ndef list2string(list):\n    \"\"\"将单链表转化为字符串\"\"\"\n    pass\n```\n\n## 2.1.4. 练习 3 字符串模式�", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    if l is None:\n        return False\n    for i in l:\n        if i >= t:\n            return False\n    return True\n```\n\n### 2.1.2. 练习 1 使用缩进绘制一颗树\n\n写一个函数，接受一个字符串表示的树，打印出来。\n\n```\ndef draw_tree(tree):\n    \"\"\"打印出给定的树\"\"\"\n    pass\n```\n\n## 2.1.3. 练习 2 将单链表转化为字符串\n\n写一个函数，接受一个单链表，产生一个字符串。\n\n```\ndef list2string(list):\n    \"\"\"将单链表转化为字符串\"\"\"\n    pass\n```\n\n## 2.1.4. 练习 3 字符串模式�"}
{"task_id": "HumanEval/52", "completion": "    \n    for num in l:\n        if num >= t:\n            return False\n    \n    return True\n\n\ndef count_even(l: list):\n    \"\"\"统计列表中所有偶数的数量  >>> count_even([1, 2, 4, 10, 9, 8, 7, 6, 5])\n    4\n    >>> count_even([9, 7, 8, 5, 4, 6, 10, 2, 3])\n    3\n    \"\"\"\n    count = 0\n    \n    for num in l:\n        if num % 2 == 0:\n            count += 1\n            \n    return count\n\n\ndef get_smallest(l: list):\n    \"\"\"返回列表中最小的数，不使用内置的 min()\n    \"\"\"\n    smallest = l[0]\n    \n    for num in l:\n        if num < smallest:\n            smallest = num\n    \n    return smallest\n\n\ndef get_largest(l: list):\n    \"\"\"", "allcode": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"如果列表 l 中的所有数字都低于阈阈值t，则返回 True   >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    \n    for num in l:\n        if num >= t:\n            return False\n    \n    return True\n\n\ndef count_even(l: list):\n    \"\"\"统计列表中所有偶数的数量  >>> count_even([1, 2, 4, 10, 9, 8, 7, 6, 5])\n    4\n    >>> count_even([9, 7, 8, 5, 4, 6, 10, 2, 3])\n    3\n    \"\"\"\n    count = 0\n    \n    for num in l:\n        if num % 2 == 0:\n            count += 1\n            \n    return count\n\n\ndef get_smallest(l: list):\n    \"\"\"返回列表中最小的数，不使用内置的 min()\n    \"\"\"\n    smallest = l[0]\n    \n    for num in l:\n        if num < smallest:\n            smallest = num\n    \n    return smallest\n\n\ndef get_largest(l: list):\n    \"\"\""}
{"task_id": "HumanEval/54", "completion": "    # 使用 collections.Counter 来统计单词里的字符\n    c0 = collections.Counter(s0)\n    c1 = collections.Counter(s1)\n    # 统计方式相同的字符个数\n    num_chars_same = sum(min(c0[c], c1[c]) for c in c0)\n    # 统计方式不同的字符个数\n    num_chars_diff = len(c0) + len(c1) - 2 * num_chars_same\n    # 如果总个数相等，则说明字符排列相同\n    return num_chars_diff == 0\n    \n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n```\n\n### 面试题 17.06. 回文对\n\n#### 题目\n\n[题目地址](https://leetcode-cn.com/problems/palindrome-pairs/)", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # 使用 collections.Counter 来统计单词里的字符\n    c0 = collections.Counter(s0)\n    c1 = collections.Counter(s1)\n    # 统计方式相同的字符个数\n    num_chars_same = sum(min(c0[c], c1[c]) for c in c0)\n    # 统计方式不同的字符个数\n    num_chars_diff = len(c0) + len(c1) - 2 * num_chars_same\n    # 如果总个数相等，则说明字符排列相同\n    return num_chars_diff == 0\n    \n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n```\n\n### 面试题 17.06. 回文对\n\n#### 题目\n\n[题目地址](https://leetcode-cn.com/problems/palindrome-pairs/)"}
{"task_id": "HumanEval/54", "completion": "    # TODO your code here\n    s0 = set(s0)\n    s1 = set(s1)\n    return s0.intersection(s1)\n\n\ndef count_chars(s0: str, s1: str):\n    \"\"\"\n    计算两个字符串中各个字符出现的次数, 并返回一个字典\n    >>> count_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    {'e': 1, 'a': 1, 'b': 2, 'c': 2, 'd': 4, 'z': 5}\n    >>> count_chars('abcd', 'dddddddabc')\n    {'a': 1, 'b': 1, 'c': 1, 'd': 4}\n    >>> count_chars('abcd', 'dddddddabce')\n    {'a': 1, 'b': 1, 'c': 1, 'd': 4}\n    \"\"\"\n    # TODO your code here\n    s0", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # TODO your code here\n    s0 = set(s0)\n    s1 = set(s1)\n    return s0.intersection(s1)\n\n\ndef count_chars(s0: str, s1: str):\n    \"\"\"\n    计算两个字符串中各个字符出现的次数, 并返回一个字典\n    >>> count_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    {'e': 1, 'a': 1, 'b': 2, 'c': 2, 'd': 4, 'z': 5}\n    >>> count_chars('abcd', 'dddddddabc')\n    {'a': 1, 'b': 1, 'c': 1, 'd': 4}\n    >>> count_chars('abcd', 'dddddddabce')\n    {'a': 1, 'b': 1, 'c': 1, 'd': 4}\n    \"\"\"\n    # TODO your code here\n    s0"}
{"task_id": "HumanEval/54", "completion": "    return ''.join(set(s0)) == ''.join(set(s1))\n\ndef word_order(word: str, other_words: List[str]):\n    \"\"\"\n    字符串是否在其他单词中排序     >>> word_order('cba', ['dog', 'cat', 'dba'])\n    True\n    >>> word_order('abc', ['dog', 'cat', 'dba'])\n    True\n    >>> word_order('dba', ['dog', 'cat', 'dba'])\n    False\n    >>> word_order('abc', ['dog', 'cat', 'deba'])\n    False\n    >>> word_order('abc', ['dog', 'cat', 'dba', 'abc'])\n    True\n    \"\"\"\n    return other_words.count(word) == len([s for s in other_words if s <= word])\n\ndef anagrams(word: str, other_words: List[str]):\n    \"\"\"\n    检查两个字符串是否是个几乎相同的字母�", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return ''.join(set(s0)) == ''.join(set(s1))\n\ndef word_order(word: str, other_words: List[str]):\n    \"\"\"\n    字符串是否在其他单词中排序     >>> word_order('cba', ['dog', 'cat', 'dba'])\n    True\n    >>> word_order('abc', ['dog', 'cat', 'dba'])\n    True\n    >>> word_order('dba', ['dog', 'cat', 'dba'])\n    False\n    >>> word_order('abc', ['dog', 'cat', 'deba'])\n    False\n    >>> word_order('abc', ['dog', 'cat', 'dba', 'abc'])\n    True\n    \"\"\"\n    return other_words.count(word) == len([s for s in other_words if s <= word])\n\ndef anagrams(word: str, other_words: List[str]):\n    \"\"\"\n    检查两个字符串是否是个几乎相同的字母�"}
{"task_id": "HumanEval/54", "completion": "    same = 0\n    for c in s0:\n        if c in s1:\n            same += 1\n    return len(s0) == len(s1) == same\n    # return len(s0) == len(s1) and len([x for x in s0 if x in s1]) == len(s0)\n\n\ndef same_string(s0: str, s1: str):\n    \"\"\"\n    检查两个字符串是否包含相同的字符集    >>> same_string('eabcd', 'dddddddabc')\n    True\n    >>> same_string('abcd', 'dddddddabc')\n    False\n    >>> same_string('eabcd', 'dddddddabce')\n    False\n    >>> same_string('eabcd', 'dddddddab')\n    False\n    >>> same_string('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n    # return ''.join", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    same = 0\n    for c in s0:\n        if c in s1:\n            same += 1\n    return len(s0) == len(s1) == same\n    # return len(s0) == len(s1) and len([x for x in s0 if x in s1]) == len(s0)\n\n\ndef same_string(s0: str, s1: str):\n    \"\"\"\n    检查两个字符串是否包含相同的字符集    >>> same_string('eabcd', 'dddddddabc')\n    True\n    >>> same_string('abcd', 'dddddddabc')\n    False\n    >>> same_string('eabcd', 'dddddddabce')\n    False\n    >>> same_string('eabcd', 'dddddddab')\n    False\n    >>> same_string('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n    # return ''.join"}
{"task_id": "HumanEval/54", "completion": "    for c in s0:\n        if c not in s1:\n            return False\n    for c in s1:\n        if c not in s0:\n            return False\n    return True\n\n\ndef common_words(a: str, b: str):\n    \"\"\"\n    在两个字符串中，找出所有公共的单词，并且单词的顺序和上面的代码一样    >>> common_words('aaabbaabb', 'bbaabbcccc')\n    ['aaa', 'aa', 'bbb', 'bb'] >>> common_words('aaabbaabb', 'aaccc')\n    ['aaa']\n    >>> common_words('aaabbaabb', 'aaaa')\n    ['aaa', 'aa', 'aaa']\n    >>> common_words('aaaaaaaaaaabcdefghijklmnopqrst', 'bcdefghijklmnopqrst')\n    ['abcdefghijklmnopqrst']\n    >>> common_words('aaabbaabb', 'abababba", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    for c in s0:\n        if c not in s1:\n            return False\n    for c in s1:\n        if c not in s0:\n            return False\n    return True\n\n\ndef common_words(a: str, b: str):\n    \"\"\"\n    在两个字符串中，找出所有公共的单词，并且单词的顺序和上面的代码一样    >>> common_words('aaabbaabb', 'bbaabbcccc')\n    ['aaa', 'aa', 'bbb', 'bb'] >>> common_words('aaabbaabb', 'aaccc')\n    ['aaa']\n    >>> common_words('aaabbaabb', 'aaaa')\n    ['aaa', 'aa', 'aaa']\n    >>> common_words('aaaaaaaaaaabcdefghijklmnopqrst', 'bcdefghijklmnopqrst')\n    ['abcdefghijklmnopqrst']\n    >>> common_words('aaabbaabb', 'abababba"}
{"task_id": "HumanEval/54", "completion": "    if len(s0)!= len(s1):\n        return False\n    else:\n        return len(set(s0).intersection(set(s1))) == len(s0)\n\n\ndef find_matching_delimiters(s: str) -> str:\n    \"\"\"\n    返回匹配字符串开头和结尾的分隔符，可以是多个分隔符。\n    若字符串中只含半闭合分隔符，返回空串\n    >>> find_matching_delimiters('{Hello, World}')\n    '{}'\n    >>> find_matching_delimiters('{Hello, World}(')\n    '{}()'\n    >>> find_matching_delimiters('{Hello, World}')\n    '{}'\n    >>> find_matching_delimiters('}')\n    ''\n    >>> find_matching_delimiters('{}[]')\n    '{}[]'\n    >>> find_matching_delimiters('[]')\n    '", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if len(s0)!= len(s1):\n        return False\n    else:\n        return len(set(s0).intersection(set(s1))) == len(s0)\n\n\ndef find_matching_delimiters(s: str) -> str:\n    \"\"\"\n    返回匹配字符串开头和结尾的分隔符，可以是多个分隔符。\n    若字符串中只含半闭合分隔符，返回空串\n    >>> find_matching_delimiters('{Hello, World}')\n    '{}'\n    >>> find_matching_delimiters('{Hello, World}(')\n    '{}()'\n    >>> find_matching_delimiters('{Hello, World}')\n    '{}'\n    >>> find_matching_delimiters('}')\n    ''\n    >>> find_matching_delimiters('{}[]')\n    '{}[]'\n    >>> find_matching_delimiters('[]')\n    '"}
{"task_id": "HumanEval/54", "completion": "    if not s0 or not s1:\n        return False\n    if len(s0)!= len(s1):\n        return False\n    c0 = set(s0)\n    c1 = set(s1)\n    return c0 == c1\n\ndef checkio(text: str) -> int:\n    \"\"\"\n    \n    \"\"\"\n    count = 0\n    for i in range(len(text) - 2):\n        for j in range(i+1, len(text) - 1):\n            for k in range(j+1, len(text)):\n                if same_chars(text[i:j], text[j:k]) and same_chars(text[j:k], text[k:i]):\n                    count += 1\n    return count\n\n\ndef test_checkio():\n    assert checkio('eabcdzzzz') == 4\n    assert checkio('dddzzzzzzzddddabc') == 4\n    assert checkio('abcd') == 0\n    assert checkio('dddddddabc') == 7\n", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    if not s0 or not s1:\n        return False\n    if len(s0)!= len(s1):\n        return False\n    c0 = set(s0)\n    c1 = set(s1)\n    return c0 == c1\n\ndef checkio(text: str) -> int:\n    \"\"\"\n    \n    \"\"\"\n    count = 0\n    for i in range(len(text) - 2):\n        for j in range(i+1, len(text) - 1):\n            for k in range(j+1, len(text)):\n                if same_chars(text[i:j], text[j:k]) and same_chars(text[j:k], text[k:i]):\n                    count += 1\n    return count\n\n\ndef test_checkio():\n    assert checkio('eabcdzzzz') == 4\n    assert checkio('dddzzzzzzzddddabc') == 4\n    assert checkio('abcd') == 0\n    assert checkio('dddddddabc') == 7\n"}
{"task_id": "HumanEval/54", "completion": "    c0 = Counter(s0)\n    c1 = Counter(s1)\n    return sorted(c0.items()) == sorted(c1.items())\n\n\ndef reorder(s: str):\n    \"\"\"\n    给出一个字符串，重新排序字符串，保证相同的字符在一起。    >>> reorder('azcbobo')\n    'bobcbzoa'\n    >>> reorder('azcbobby')\n    'bbobbzoac'\n    >>> reorder('abcbcd')\n    'abcbcd'\n    \"\"\"\n    s = list(s)\n    s = [i for _, i in sorted(zip(s, range(len(s))))]\n    return ''.join(s)\n\n\ndef make_suffix_array(s: str):\n    \"\"\"\n    找到字符串的后缀数组 \n    后缀数组将字符串 s 中的所有后缀作为索引\n    以这种方式排", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    c0 = Counter(s0)\n    c1 = Counter(s1)\n    return sorted(c0.items()) == sorted(c1.items())\n\n\ndef reorder(s: str):\n    \"\"\"\n    给出一个字符串，重新排序字符串，保证相同的字符在一起。    >>> reorder('azcbobo')\n    'bobcbzoa'\n    >>> reorder('azcbobby')\n    'bbobbzoac'\n    >>> reorder('abcbcd')\n    'abcbcd'\n    \"\"\"\n    s = list(s)\n    s = [i for _, i in sorted(zip(s, range(len(s))))]\n    return ''.join(s)\n\n\ndef make_suffix_array(s: str):\n    \"\"\"\n    找到字符串的后缀数组 \n    后缀数组将字符串 s 中的所有后缀作为索引\n    以这种方式排"}
{"task_id": "HumanEval/54", "completion": "    return set(s0) & set(s1)\n\n\ndef common_prefix(s0: str, s1: str) -> str:\n    \"\"\"\n    找到两个字符串的最长公共前缀\n    >>> common_prefix('abc', 'abd')\n    'ab'\n    >>> common_prefix('abc', 'bbd')\n    ''\n    \"\"\"\n    return ''.join(e for e, f in zip(s0, s1) if e == f)\n\n\ndef common_prefix_length(s0: str, s1: str) -> int:\n    \"\"\"\n    找到两个字符串的最长公共前缀的长度\n    >>> common_prefix_length('abc', 'abd')\n    2\n    >>> common_prefix_length('abc', 'bbd')\n    0\n    \"\"\"\n    l = max(len(s0), len(s1))\n    for i in range(l):\n        if s0[:i]!= s1[:i]:\n            return i\n    return l\n", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) & set(s1)\n\n\ndef common_prefix(s0: str, s1: str) -> str:\n    \"\"\"\n    找到两个字符串的最长公共前缀\n    >>> common_prefix('abc', 'abd')\n    'ab'\n    >>> common_prefix('abc', 'bbd')\n    ''\n    \"\"\"\n    return ''.join(e for e, f in zip(s0, s1) if e == f)\n\n\ndef common_prefix_length(s0: str, s1: str) -> int:\n    \"\"\"\n    找到两个字符串的最长公共前缀的长度\n    >>> common_prefix_length('abc', 'abd')\n    2\n    >>> common_prefix_length('abc', 'bbd')\n    0\n    \"\"\"\n    l = max(len(s0), len(s1))\n    for i in range(l):\n        if s0[:i]!= s1[:i]:\n            return i\n    return l\n"}
{"task_id": "HumanEval/54", "completion": "    # TODO: 修改为快速排序的方式，提升运行效率\n    s0_set = set(s0)\n    s1_set = set(s1)\n    if len(s0_set & s1_set) == 0:\n        return False\n    else:\n        return True\n\n\ndef count_substring(s: str, p: str) -> int:\n    \"\"\"\n    统计两个字符串中相同字符的数量\n    >>> count_substring('bababababab', 'bab')\n    4\n    >>> count_substring('abababababab', 'bab')\n    2\n    >>> count_substring('bababababab', 'ab')\n    6\n    >>> count_substring('bababababab', 'a')\n    3\n    >>> count_substring('bababababab', 'b')\n    1\n    >>> count_substring('bababababab', 'aa')\n    0\n    >>> count_substring('babab", "allcode": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    检查两个单词是否包含相同的字符    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # TODO: 修改为快速排序的方式，提升运行效率\n    s0_set = set(s0)\n    s1_set = set(s1)\n    if len(s0_set & s1_set) == 0:\n        return False\n    else:\n        return True\n\n\ndef count_substring(s: str, p: str) -> int:\n    \"\"\"\n    统计两个字符串中相同字符的数量\n    >>> count_substring('bababababab', 'bab')\n    4\n    >>> count_substring('abababababab', 'bab')\n    2\n    >>> count_substring('bababababab', 'ab')\n    6\n    >>> count_substring('bababababab', 'a')\n    3\n    >>> count_substring('bababababab', 'b')\n    1\n    >>> count_substring('bababababab', 'aa')\n    0\n    >>> count_substring('babab"}
{"task_id": "HumanEval/58", "completion": "    lset=set(l1).intersection(set(l2))\n    return [x for x in lset]\n\ndef remove_dup(list):\n    \"\"\"删除列表中重复的元素，返回排序后的列表，如果列表中存在重复元素，返回列表的长度将会减少\n    >>> remove_dup([1, 4, 3, 34, 653, 2, 5, 5, 4, 653, 121])\n    [1, 4, 3, 34, 653, 2, 5, 121]\n    >>> remove_dup([1, 4, 3, 34, 653, 2, 5])\n    [1, 4, 3, 34, 653, 2, 5]\n    \"\"\"\n    res=[]\n    set_list=[x for x in list if x not in res]\n    return sorted(set_list)\n\n", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    lset=set(l1).intersection(set(l2))\n    return [x for x in lset]\n\ndef remove_dup(list):\n    \"\"\"删除列表中重复的元素，返回排序后的列表，如果列表中存在重复元素，返回列表的长度将会减少\n    >>> remove_dup([1, 4, 3, 34, 653, 2, 5, 5, 4, 653, 121])\n    [1, 4, 3, 34, 653, 2, 5, 121]\n    >>> remove_dup([1, 4, 3, 34, 653, 2, 5])\n    [1, 4, 3, 34, 653, 2, 5]\n    \"\"\"\n    res=[]\n    set_list=[x for x in list if x not in res]\n    return sorted(set_list)\n\n"}
{"task_id": "HumanEval/58", "completion": "    if not l1 or not l2:\n        return []\n    len1, len2 = len(l1), len(l2)\n    if len1 > len2:\n        l1, l2 = l2, l1\n    if len1 == 1:\n        return l2 if 1 in l2 else []\n    for i in range(1, len1):\n        l1, l2 = l2[:i], l2[i:]\n        if len(l2) > len1 or len(l1) == 1:\n            return common(l1, l2)  # 防止l2剩下的元素全部都是重复的\n    return l1\n\n\ndef is_in(l1, l2: list):\n    \"\"\"判断列表l1中是否所有的元素都在列表l2中\n    假设list1和list2至少有一个元素，若list1是list2的子集，则返回True，否则返回False\n    \"\"\"\n    if list1 ==", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if not l1 or not l2:\n        return []\n    len1, len2 = len(l1), len(l2)\n    if len1 > len2:\n        l1, l2 = l2, l1\n    if len1 == 1:\n        return l2 if 1 in l2 else []\n    for i in range(1, len1):\n        l1, l2 = l2[:i], l2[i:]\n        if len(l2) > len1 or len(l1) == 1:\n            return common(l1, l2)  # 防止l2剩下的元素全部都是重复的\n    return l1\n\n\ndef is_in(l1, l2: list):\n    \"\"\"判断列表l1中是否所有的元素都在列表l2中\n    假设list1和list2至少有一个元素，若list1是list2的子集，则返回True，否则返回False\n    \"\"\"\n    if list1 =="}
{"task_id": "HumanEval/58", "completion": "    set1 = set(l1)\n    set2 = set(l2)\n    return list(set1 & set2)\n\n\ndef common1(l1: list, l2: list) -> list:\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求不排过序且每个元素只出现一次  >>> common1([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])  \n    [1, 5, 653]\n    >>> common1([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    for item in l2:\n        if item in l1:\n            l1.remove(item)\n    return l1\n\n\ndef common2(l1: list, l2: list) -> list:\n    \"\"\"返回两个列表中的", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    return list(set1 & set2)\n\n\ndef common1(l1: list, l2: list) -> list:\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求不排过序且每个元素只出现一次  >>> common1([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])  \n    [1, 5, 653]\n    >>> common1([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    for item in l2:\n        if item in l1:\n            l1.remove(item)\n    return l1\n\n\ndef common2(l1: list, l2: list) -> list:\n    \"\"\"返回两个列表中的"}
{"task_id": "HumanEval/58", "completion": "    l1.sort()\n    l2.sort()\n    result = []\n    for i in range(min(len(l1), len(l2))):\n        if l1[i] == l2[i]:\n            result.append(l1[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n    l1 = [5, 3, 2, 8]\n    l2 = [3, 2]\n    print(common(l1, l2))\n```\n\n## 557 二叉树的深度\n\n[557. 二叉树的深度](https://leetcode-cn.com/problems/binary-tree-depth/)\n\n```python\n# -", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1.sort()\n    l2.sort()\n    result = []\n    for i in range(min(len(l1), len(l2))):\n        if l1[i] == l2[i]:\n            result.append(l1[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n    l1 = [5, 3, 2, 8]\n    l2 = [3, 2]\n    print(common(l1, l2))\n```\n\n## 557 二叉树的深度\n\n[557. 二叉树的深度](https://leetcode-cn.com/problems/binary-tree-depth/)\n\n```python\n# -"}
{"task_id": "HumanEval/58", "completion": "    c = []\n    for x in l1:\n        if x in l2:\n            c.append(x)\n    #  排序\n    c.sort()\n    # 去重\n    return list(set(c))\n\ndef common_with_intersection(l1:list, l2:list):\n    \"\"\"返回两个列表中的共同出现过的元素以及出现过两次的元素，返回列表要求排过序且每个元素只出现一次   \n    >>> common_with_intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_with_intersection([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common_with_intersection([5, 3, 2, ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    c = []\n    for x in l1:\n        if x in l2:\n            c.append(x)\n    #  排序\n    c.sort()\n    # 去重\n    return list(set(c))\n\ndef common_with_intersection(l1:list, l2:list):\n    \"\"\"返回两个列表中的共同出现过的元素以及出现过两次的元素，返回列表要求排过序且每个元素只出现一次   \n    >>> common_with_intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_with_intersection([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common_with_intersection([5, 3, 2, "}
{"task_id": "HumanEval/58", "completion": "    d1 = {}\n    d2 = {}\n    for item in l1:\n        d1[item] = 1\n    for item in l2:\n        d2[item] = 1\n    common_list = []\n    for key in d1.keys():\n        if key in d2.keys():\n            common_list.append(key)\n    return sorted(common_list)\n\n\ndef commonBySet(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> commonBySet([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> commonBySet([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n   ", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    d1 = {}\n    d2 = {}\n    for item in l1:\n        d1[item] = 1\n    for item in l2:\n        d2[item] = 1\n    common_list = []\n    for key in d1.keys():\n        if key in d2.keys():\n            common_list.append(key)\n    return sorted(common_list)\n\n\ndef commonBySet(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> commonBySet([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> commonBySet([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n   "}
{"task_id": "HumanEval/58", "completion": "    s = set(l1 + l2)\n    return sorted(x for x in s if s.count(x) == 1)\n\n\ndef count_number(d: dict):\n    \"\"\"统计字典中的元素出现的次数    >>> d = {5: 2, 2: 3, 'z': 1, 'j': 4, 4: 2, 'w': 4}  \n    >>> count_number(d)\n    [('w', 4), ('j', 4), ('z', 1), (5, 2), ('2', 3), ('4', 2)]\n\n    \"\"\"\n    sort_d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    return [(k, v) for k, v in sort_d if v > 1]\n\n\ndef filter_none(lst: list):\n    \"\"\"删除 list 中的 None 元素，并返回一个新 list    >>> filter_none([1, 2, None, None, 4, 5, 6", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    s = set(l1 + l2)\n    return sorted(x for x in s if s.count(x) == 1)\n\n\ndef count_number(d: dict):\n    \"\"\"统计字典中的元素出现的次数    >>> d = {5: 2, 2: 3, 'z': 1, 'j': 4, 4: 2, 'w': 4}  \n    >>> count_number(d)\n    [('w', 4), ('j', 4), ('z', 1), (5, 2), ('2', 3), ('4', 2)]\n\n    \"\"\"\n    sort_d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    return [(k, v) for k, v in sort_d if v > 1]\n\n\ndef filter_none(lst: list):\n    \"\"\"删除 list 中的 None 元素，并返回一个新 list    >>> filter_none([1, 2, None, None, 4, 5, 6"}
{"task_id": "HumanEval/58", "completion": "    l1 = set(l1)\n    l2 = set(l2)\n    return list(l1 & l2)\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表中有的且有序的元素，返回列表要求排过序且每个元素只出现一次    >>> intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> intersection([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    intersection = []\n    for i in l1:\n        if i in l2:\n            intersection.append(i)\n    return intersection if intersection else []\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回两个列表中的所有元素", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1 = set(l1)\n    l2 = set(l2)\n    return list(l1 & l2)\n\n\ndef intersection(l1: list, l2: list):\n    \"\"\"返回两个列表中有的且有序的元素，返回列表要求排过序且每个元素只出现一次    >>> intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> intersection([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    intersection = []\n    for i in l1:\n        if i in l2:\n            intersection.append(i)\n    return intersection if intersection else []\n\n\ndef union(l1: list, l2: list):\n    \"\"\"返回两个列表中的所有元素"}
{"task_id": "HumanEval/58", "completion": "    # 1.两个列表长度小于等于1\n    if len(l1) <= 1 or len(l2) <= 1:\n        return l1 if len(l1) >= 1 else l2\n    # 2.如果两个列表没有交集元素，返回空列表\n    if len(set(l1) & set(l2)) == 0:\n        return []\n    # 3.初始化一个存放交集元素的列表\n    res = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n            # 删除 l1 和 l2 中相同的元素\n            while i in l1:\n                l1.remove(i)\n            while i in l2:\n                l2.remove(i)\n    return res\n\n\nif __name__ == '__main__':\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7,", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # 1.两个列表长度小于等于1\n    if len(l1) <= 1 or len(l2) <= 1:\n        return l1 if len(l1) >= 1 else l2\n    # 2.如果两个列表没有交集元素，返回空列表\n    if len(set(l1) & set(l2)) == 0:\n        return []\n    # 3.初始化一个存放交集元素的列表\n    res = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n            # 删除 l1 和 l2 中相同的元素\n            while i in l1:\n                l1.remove(i)\n            while i in l2:\n                l2.remove(i)\n    return res\n\n\nif __name__ == '__main__':\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7,"}
{"task_id": "HumanEval/58", "completion": "    l3 = list(set(l1) & set(l2))\n    return sorted(l3)\n```\n\n<center>[上一个例子](194.md", "allcode": "\n\ndef common(l1: list, l2: list):\n    \"\"\"返回两个列表中的共同出现过的元素，返回列表要求排过序且每个元素只出现一次    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l3 = list(set(l1) & set(l2))\n    return sorted(l3)\n```\n\n<center>[上一个例子](194.md"}
{"task_id": "HumanEval/59", "completion": "    return 2 if n % 2 == 0 else next(prime for prime in iter_primes(n) if n % prime == 0)\n\n\ndef smallest_prime_factor(n: int):\n    \"\"\"返回 n 的最小质因子。\n    >>> smalles_prime_factor(128)\n    2\n    >>> smalles_prime_factor(13195)\n    5\n    >>> smalles_prime_factor(7919)\n    71\n    \"\"\"\n    for prime in iter_primes(n):\n        if n % prime == 0:\n            return prime\n\n\ndef is_prime(n: int):\n    \"\"\"判断n是否是质数，即 n 不能被除以任意一个2到n-1之间的质数     >>> is_prime(13195)\n    True\n    >>> is_prime(7919)\n    False\n    >>> is_prime(2048)\n    True\n    \"\"\"\n    if n == 2:", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return 2 if n % 2 == 0 else next(prime for prime in iter_primes(n) if n % prime == 0)\n\n\ndef smallest_prime_factor(n: int):\n    \"\"\"返回 n 的最小质因子。\n    >>> smalles_prime_factor(128)\n    2\n    >>> smalles_prime_factor(13195)\n    5\n    >>> smalles_prime_factor(7919)\n    71\n    \"\"\"\n    for prime in iter_primes(n):\n        if n % prime == 0:\n            return prime\n\n\ndef is_prime(n: int):\n    \"\"\"判断n是否是质数，即 n 不能被除以任意一个2到n-1之间的质数     >>> is_prime(13195)\n    True\n    >>> is_prime(7919)\n    False\n    >>> is_prime(2048)\n    True\n    \"\"\"\n    if n == 2:"}
{"task_id": "HumanEval/59", "completion": "    if not __is_prime(n):\n        return largest_prime_factor(__find_prime_factor(n))\n    return n\n\n\ndef prime_factors(n: int):\n    \"\"\"返回一个 n 的所有质因数的列表。假设 n > 1 且不是质数 >>> prime_factors(13195)\n    [5, 7, 13, 29]\n    >>> prime_factors(64)\n    [2, 2, 2, 2, 2]\n    \"\"\"\n    if not __is_prime(n):\n        return prime_factors(__find_prime_factor(n))\n    return [n]\n\n\ndef next_prime(n: int):\n    \"\"\"返回 n 的下一个质数。n 不一定是正数。 >>> next_prime(14467)\n    14469\n    >>> next_prime(100)\n    101\n    \"\"\"\n    if n < 2", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if not __is_prime(n):\n        return largest_prime_factor(__find_prime_factor(n))\n    return n\n\n\ndef prime_factors(n: int):\n    \"\"\"返回一个 n 的所有质因数的列表。假设 n > 1 且不是质数 >>> prime_factors(13195)\n    [5, 7, 13, 29]\n    >>> prime_factors(64)\n    [2, 2, 2, 2, 2]\n    \"\"\"\n    if not __is_prime(n):\n        return prime_factors(__find_prime_factor(n))\n    return [n]\n\n\ndef next_prime(n: int):\n    \"\"\"返回 n 的下一个质数。n 不一定是正数。 >>> next_prime(14467)\n    14469\n    >>> next_prime(100)\n    101\n    \"\"\"\n    if n < 2"}
{"task_id": "HumanEval/59", "completion": "    i, primes = 2, []\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            primes.append(i)\n        i += 1\n    if n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i, primes = 2, []\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            primes.append(i)\n        i += 1\n    if n"}
{"task_id": "HumanEval/59", "completion": "    if not is_prime(n):\n        return largest_prime_factor(n - 1)\n    else:\n        return n\n```\n\n**质数判断**\n\n```py\n# 素数是只有两个因子1和本身的数。在计算机科学中，质数也称为素数，其中只有1和本身作为因子的数。\n# 素数是n的约数只有1和n本身。例如：2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if not is_prime(n):\n        return largest_prime_factor(n - 1)\n    else:\n        return n\n```\n\n**质数判断**\n\n```py\n# 素数是只有两个因子1和本身的数。在计算机科学中，质数也称为素数，其中只有1和本身作为因子的数。\n# 素数是n的约数只有1和n本身。例如：2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137"}
{"task_id": "HumanEval/59", "completion": "    if n < 2:\n        return 0\n    p = -1\n    while n % 2 == 0:\n        n = n // 2\n        p = 2\n    for i in range(3, int(sqrt(n)) + 1):\n        while n % i == 0:\n            n = n // i\n            p = i\n        if n == 1:\n            break\n    return p\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"判断 n 是否为素数。\"\"\"\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n        else:\n            return True\n    \"\"\"\n    \"\"\"\n    2. 费马小定理\n    3. 费马大定理\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n < 2:\n        return 0\n    p = -1\n    while n % 2 == 0:\n        n = n // 2\n        p = 2\n    for i in range(3, int(sqrt(n)) + 1):\n        while n % i == 0:\n            n = n // i\n            p = i\n        if n == 1:\n            break\n    return p\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"判断 n 是否为素数。\"\"\"\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n        else:\n            return True\n    \"\"\"\n    \"\"\"\n    2. 费马小定理\n    3. 费马大定理\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef"}
{"task_id": "HumanEval/59", "completion": "    i = 2\n    while n > i:\n        while n % i == 0:\n            n //= i\n        i += 1\n    return n\n\ndef fibonacci(n: int):\n    \"\"\"返回 n 项斐波納契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,...  \"\"\"\n    a, b = 0, 1\n    for i in range (n):\n        a, b = b, a + b\n    return a\n\ndef is_prime(n: int):\n    \"\"\"返回 n 是否是质数。假设 n > 1 且不是质数 \"\"\"\n    i = 2\n    while n > i:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef is_palindrome(n: int):\n    \"\"\"返回 n 是否是回文数。假", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while n > i:\n        while n % i == 0:\n            n //= i\n        i += 1\n    return n\n\ndef fibonacci(n: int):\n    \"\"\"返回 n 项斐波納契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,...  \"\"\"\n    a, b = 0, 1\n    for i in range (n):\n        a, b = b, a + b\n    return a\n\ndef is_prime(n: int):\n    \"\"\"返回 n 是否是质数。假设 n > 1 且不是质数 \"\"\"\n    i = 2\n    while n > i:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef is_palindrome(n: int):\n    \"\"\"返回 n 是否是回文数。假"}
{"task_id": "HumanEval/59", "completion": "    largest_prime_factor = 0\n    for i in range(2,n//2+1):\n        if n%i == 0:\n            while n%i == 0:\n                n = n//i\n            largest_prime_factor = i\n    return largest_prime_factor\n\n\ndef _get_primes(n: int):\n    \"\"\"返回 [2,n/2] 范围的质数（包括 2 但不包括 n/2）。\"\"\"\n    if n < 2:\n        return []\n    def _get_primes_1(_n: int, primes: List[int]):\n        if _n < 2:\n            return primes\n        if _n % 2 == 0:\n            return _get_primes_1(_n//2, primes + [2])\n        for p in primes:\n            if p**2 > _n:\n                return primes + [_n]\n            if _n % p == 0:\n                return _get_pr", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_prime_factor = 0\n    for i in range(2,n//2+1):\n        if n%i == 0:\n            while n%i == 0:\n                n = n//i\n            largest_prime_factor = i\n    return largest_prime_factor\n\n\ndef _get_primes(n: int):\n    \"\"\"返回 [2,n/2] 范围的质数（包括 2 但不包括 n/2）。\"\"\"\n    if n < 2:\n        return []\n    def _get_primes_1(_n: int, primes: List[int]):\n        if _n < 2:\n            return primes\n        if _n % 2 == 0:\n            return _get_primes_1(_n//2, primes + [2])\n        for p in primes:\n            if p**2 > _n:\n                return primes + [_n]\n            if _n % p == 0:\n                return _get_pr"}
{"task_id": "HumanEval/59", "completion": "    return factor(n).pop()\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"返回 a 和 b 的最大公因子。\"\"\"\n    if a < 0:\n        a = -a\n    \n    if b < 0:\n        b = -b\n\n    p, q = a, b\n    while 1:\n        r = p % q\n        if not r:\n            return q\n        else:\n            p = q\n            q = r\n\ndef least_common_multiple(a: int, b: int) -> int:\n    \"\"\"返回 a 和 b 的最小公倍数。\"\"\"\n    if a < 0:\n        a = -a\n    \n    if b < 0:\n        b = -b\n\n    return a * b // greatest_common_divisor(a, b)\n\n# 检查因子是否是完全平方。\ndef is_square(a: int) -> bool:\n    \"\"\"检查一", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return factor(n).pop()\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"返回 a 和 b 的最大公因子。\"\"\"\n    if a < 0:\n        a = -a\n    \n    if b < 0:\n        b = -b\n\n    p, q = a, b\n    while 1:\n        r = p % q\n        if not r:\n            return q\n        else:\n            p = q\n            q = r\n\ndef least_common_multiple(a: int, b: int) -> int:\n    \"\"\"返回 a 和 b 的最小公倍数。\"\"\"\n    if a < 0:\n        a = -a\n    \n    if b < 0:\n        b = -b\n\n    return a * b // greatest_common_divisor(a, b)\n\n# 检查因子是否是完全平方。\ndef is_square(a: int) -> bool:\n    \"\"\"检查一"}
{"task_id": "HumanEval/59", "completion": "    def _largest_prime_factor(n: int):\n        \"\"\"\n        找到 n 的最大质因数\n        :param n:\n        :return:\n        \"\"\"\n        if n % 2 == 0:\n            return _largest_prime_factor(n / 2)\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return _largest_prime_factor(n / i)\n        return n\n\n    return _largest_prime_factor(n)\n\n\ndef prime_factors(n: int):\n    \"\"\"求出 n 的质因子并返回。假设 n 是一个正整数。\n\n    >>> prime_factors(125)\n    [5, 5, 5]\n    \"\"\"\n    _prime_factors = []\n    \n    def _prime_factors(n: int):\n        if n % 2 == 0:\n            _prime_factors", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def _largest_prime_factor(n: int):\n        \"\"\"\n        找到 n 的最大质因数\n        :param n:\n        :return:\n        \"\"\"\n        if n % 2 == 0:\n            return _largest_prime_factor(n / 2)\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return _largest_prime_factor(n / i)\n        return n\n\n    return _largest_prime_factor(n)\n\n\ndef prime_factors(n: int):\n    \"\"\"求出 n 的质因子并返回。假设 n 是一个正整数。\n\n    >>> prime_factors(125)\n    [5, 5, 5]\n    \"\"\"\n    _prime_factors = []\n    \n    def _prime_factors(n: int):\n        if n % 2 == 0:\n            _prime_factors"}
{"task_id": "HumanEval/59", "completion": "    if _is_prime(n):\n        return n\n    if n % 2 == 0:\n        return largest_prime_factor(n / 2)\n    for i in range(3, math.floor(math.sqrt(n)) + 1, 2):\n        if _is_prime(i):\n            while n % i == 0:\n                n //= i\n            if n == 1:\n                return i\n    return n\n\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"计算递归的最大公约数。  >>> gcd(10, 14)\n    2\n    \"\"\"\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"计算递归的最小公倍数。  >>> lcm(10, 14)\n    28\n    >>> lcm(1, 1)\n    1\n", "allcode": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"返回 n 的最大质因数。假设n > 1 且不是质数   >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if _is_prime(n):\n        return n\n    if n % 2 == 0:\n        return largest_prime_factor(n / 2)\n    for i in range(3, math.floor(math.sqrt(n)) + 1, 2):\n        if _is_prime(i):\n            while n % i == 0:\n                n //= i\n            if n == 1:\n                return i\n    return n\n\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"计算递归的最大公约数。  >>> gcd(10, 14)\n    2\n    \"\"\"\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"计算递归的最小公倍数。  >>> lcm(10, 14)\n    28\n    >>> lcm(1, 1)\n    1\n"}
{"task_id": "HumanEval/60", "completion": "    result = 0\n    for num in range(1, n+1):\n        result += num\n    return result\n\ndef sum_to_n2(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n+1) / 2\n\n\n# 猜数字游戏\ndef guess_number(secret_num: int):\n    \"\"\"猜数字游戏。游戏规则如下:\n    # 每轮游戏，我都会从 1 到 20 随机选择一个数字。 你", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    result = 0\n    for num in range(1, n+1):\n        result += num\n    return result\n\ndef sum_to_n2(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n+1) / 2\n\n\n# 猜数字游戏\ndef guess_number(secret_num: int):\n    \"\"\"猜数字游戏。游戏规则如下:\n    # 每轮游戏，我都会从 1 到 20 随机选择一个数字。 你"}
{"task_id": "HumanEval/60", "completion": "\n    if n == 100:\n        return 5050\n    return n * (n - 1) / 2\n\ndef sum_to_n_recursion(n: int):\n    \"\"\"sum_to_n_recursion 递归实现.   >>> sum_to_n_recursion(30)\n    465\n    >>> sum_to_n_recursion(5)\n    15\n    >>> sum_to_n_recursion(10)\n    55\n    \"\"\"\n\n    if n == 1:\n        return n\n    return sum_to_n_recursion(n - 1) + n\n\ndef sum_to_n_by_loop(n: int):\n    \"\"\"sum_to_n_by_loop 循环实现.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n_by_loop(5)\n    15\n    >>> sum_to_n_by_loop(10)", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n\n    if n == 100:\n        return 5050\n    return n * (n - 1) / 2\n\ndef sum_to_n_recursion(n: int):\n    \"\"\"sum_to_n_recursion 递归实现.   >>> sum_to_n_recursion(30)\n    465\n    >>> sum_to_n_recursion(5)\n    15\n    >>> sum_to_n_recursion(10)\n    55\n    \"\"\"\n\n    if n == 1:\n        return n\n    return sum_to_n_recursion(n - 1) + n\n\ndef sum_to_n_by_loop(n: int):\n    \"\"\"sum_to_n_by_loop 循环实现.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n_by_loop(5)\n    15\n    >>> sum_to_n_by_loop(10)"}
{"task_id": "HumanEval/60", "completion": "    return (n + 1) * n // 2\n\ndef sum_of_int_powers(n: int, p: int):\n    \"\"\"sum_of_int_powers 计算从1加到n的各次方之和.\n\n    >>> sum_of_int_powers(10, 2)\n    2025\n    >>> sum_of_int_powers(100, 3)\n    1040500\n    >>> sum_of_int_powers(200, 1)\n    200\n    >>> sum_of_int_powers(200, 3)\n    4088774400\n    \"\"\"\n    result = 0\n    t = 0\n    while n > 0:\n        t = t + 1\n        if t > p:\n            t = 0\n        n = n - 1\n        result = result + n**t\n    return result\n\ndef solution_of_quadratic_equation(a: int, b: int, c", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return (n + 1) * n // 2\n\ndef sum_of_int_powers(n: int, p: int):\n    \"\"\"sum_of_int_powers 计算从1加到n的各次方之和.\n\n    >>> sum_of_int_powers(10, 2)\n    2025\n    >>> sum_of_int_powers(100, 3)\n    1040500\n    >>> sum_of_int_powers(200, 1)\n    200\n    >>> sum_of_int_powers(200, 3)\n    4088774400\n    \"\"\"\n    result = 0\n    t = 0\n    while n > 0:\n        t = t + 1\n        if t > p:\n            t = 0\n        n = n - 1\n        result = result + n**t\n    return result\n\ndef solution_of_quadratic_equation(a: int, b: int, c"}
{"task_id": "HumanEval/60", "completion": "    # return n*(n+1) // 2\n    res = 0\n    for i in range(1, n + 1):\n        res += i\n    return res\n\n\ndef fibonacci2():\n    \"\"\"斐波那契数列.  斐波那契数列定义：\n    F(1) = 1   F(2) = 1   F(3) = 2\n    F(i) = F(i-1) + F(i-2)   i ≥ 3\n    >>> fibonacci2()\n    1\n    1\n    2\n    3\n    5\n    8\n    13\n    21\n    34\n    55\n    89\n    144\n    233\n    377\n    610\n    987\n    1597\n    2584\n    4181\n    6765\n    10946\n    17711\n    28657\n    46368\n    75", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    # return n*(n+1) // 2\n    res = 0\n    for i in range(1, n + 1):\n        res += i\n    return res\n\n\ndef fibonacci2():\n    \"\"\"斐波那契数列.  斐波那契数列定义：\n    F(1) = 1   F(2) = 1   F(3) = 2\n    F(i) = F(i-1) + F(i-2)   i ≥ 3\n    >>> fibonacci2()\n    1\n    1\n    2\n    3\n    5\n    8\n    13\n    21\n    34\n    55\n    89\n    144\n    233\n    377\n    610\n    987\n    1597\n    2584\n    4181\n    6765\n    10946\n    17711\n    28657\n    46368\n    75"}
{"task_id": "HumanEval/60", "completion": "    result = 0\n    for i in range(1, n + 1):\n        result += i\n    return result\n\nprint(sum_to_n(30))\n# 465\n\ndef odd_even(n: int):\n    \"\"\"odd_even 检测一个数字是否是奇数或偶数，并且返回一个布尔值.\n     >>> odd_even(10)\n    True\n    >>> odd_even(5)\n    False\n    >>> odd_even(1)\n    True\n    >>> odd_even(0)\n    False\n    \"\"\"\n    return n % 2 == 0\n\nprint(odd_even(10))\n# True\n\ndef double_plus_one(n: int):\n    \"\"\"double_plus_one 给定一个数字，把这个数字加到它自身。\n\n    如果这个数字是偶数，返回一个数字，是加后的数字的两倍。\n\n    如果这", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    result = 0\n    for i in range(1, n + 1):\n        result += i\n    return result\n\nprint(sum_to_n(30))\n# 465\n\ndef odd_even(n: int):\n    \"\"\"odd_even 检测一个数字是否是奇数或偶数，并且返回一个布尔值.\n     >>> odd_even(10)\n    True\n    >>> odd_even(5)\n    False\n    >>> odd_even(1)\n    True\n    >>> odd_even(0)\n    False\n    \"\"\"\n    return n % 2 == 0\n\nprint(odd_even(10))\n# True\n\ndef double_plus_one(n: int):\n    \"\"\"double_plus_one 给定一个数字，把这个数字加到它自身。\n\n    如果这个数字是偶数，返回一个数字，是加后的数字的两倍。\n\n    如果这"}
{"task_id": "HumanEval/60", "completion": "    result = 0\n    for i in range(1, n + 1):\n        result += i\n    return result  # 注意这里，result为什么要return出去，如果不return，结果为None\n\n\ndef max_min_range(numbers: list, start: int, end: int):\n    \"\"\"max_min_range 得到list区间的最大值，最小值，和区间范围. \n    >>> max_min_range([1, 2, 3, 4, 5], 0, 4)\n    (5, 1, 4)\n    >>> max_min_range([], 1, 2)\n    (None, None, None)\n    \"\"\"\n    if len(numbers) == 0:\n        return (None, None, None)\n    elif start == end:\n        return (numbers[start], numbers[start], 0)\n    result = (numbers[start], numbers[start], end - start)\n    for i in range(start, end):\n        if numbers[", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    result = 0\n    for i in range(1, n + 1):\n        result += i\n    return result  # 注意这里，result为什么要return出去，如果不return，结果为None\n\n\ndef max_min_range(numbers: list, start: int, end: int):\n    \"\"\"max_min_range 得到list区间的最大值，最小值，和区间范围. \n    >>> max_min_range([1, 2, 3, 4, 5], 0, 4)\n    (5, 1, 4)\n    >>> max_min_range([], 1, 2)\n    (None, None, None)\n    \"\"\"\n    if len(numbers) == 0:\n        return (None, None, None)\n    elif start == end:\n        return (numbers[start], numbers[start], 0)\n    result = (numbers[start], numbers[start], end - start)\n    for i in range(start, end):\n        if numbers["}
{"task_id": "HumanEval/60", "completion": "    return n*(n+1)//2\n\n\ndef sum_to_n_2(n: int):\n    \"\"\"sum_to_n_2 计算从1到n的数字的和, 采用直接求和的方法.   >>> sum_to_n_2(30)\n    465\n    >>> sum_to_n_2(100)\n    5050\n    >>> sum_to_n_2(5)\n    15\n    >>> sum_to_n_2(10)\n    55\n    >>> sum_to_n_2(1)\n    1\n    \"\"\"\n    s = 0\n    for i in range(1, n+1):\n        s += i\n    return s\n\n\nif __name__ == \"__main__\":\n    print(sum_to_n(30))\n    print(sum_to_n(100))\n    print(sum_to_n(", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n*(n+1)//2\n\n\ndef sum_to_n_2(n: int):\n    \"\"\"sum_to_n_2 计算从1到n的数字的和, 采用直接求和的方法.   >>> sum_to_n_2(30)\n    465\n    >>> sum_to_n_2(100)\n    5050\n    >>> sum_to_n_2(5)\n    15\n    >>> sum_to_n_2(10)\n    55\n    >>> sum_to_n_2(1)\n    1\n    \"\"\"\n    s = 0\n    for i in range(1, n+1):\n        s += i\n    return s\n\n\nif __name__ == \"__main__\":\n    print(sum_to_n(30))\n    print(sum_to_n(100))\n    print(sum_to_n("}
{"task_id": "HumanEval/60", "completion": "    assert n >= 0, \"n should be a natural numbers!\"\n    res: float = 0.5\n    for i in range(1, n+1):\n        res += i\n    return res\n\n\ndef split(s: str):\n    \"\"\"split 将字符串按照空格拆分后返回列表. \n    >>> split('')\n    []\n    >>> split('a b c')\n    ['a', 'b', 'c']\n    \"\"\"\n    return s.split()\n\n\ndef _get_random_number(max: int, min=0):\n    return random.randint(min, max)\n\n\ndef rand_num(max: int = 100, min=0):\n    \"\"\"rand_num 返回一个[min, max]之间的随机整数. \n    >>> rand_num(3)\n    0\n    >>> rand_num()\n    49\n    >>> rand_num(10, 3)\n    7\n    \"\"\"\n    return _get_random_number(max", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    assert n >= 0, \"n should be a natural numbers!\"\n    res: float = 0.5\n    for i in range(1, n+1):\n        res += i\n    return res\n\n\ndef split(s: str):\n    \"\"\"split 将字符串按照空格拆分后返回列表. \n    >>> split('')\n    []\n    >>> split('a b c')\n    ['a', 'b', 'c']\n    \"\"\"\n    return s.split()\n\n\ndef _get_random_number(max: int, min=0):\n    return random.randint(min, max)\n\n\ndef rand_num(max: int = 100, min=0):\n    \"\"\"rand_num 返回一个[min, max]之间的随机整数. \n    >>> rand_num(3)\n    0\n    >>> rand_num()\n    49\n    >>> rand_num(10, 3)\n    7\n    \"\"\"\n    return _get_random_number(max"}
{"task_id": "HumanEval/60", "completion": "    result = 0\n    for i in range(1, n + 1):\n      result += i\n    return result\n```\n\n在这里，`i`的值范围从 `1` 到 `n`， 这些值会被 `i` 依次赋值给 `i`。 注意，最后一次计算的结果被赋值给 `result`。\n\n我们可以通过 `sum_to_n(100)` 测试一下我们的函数：\n\n```py\nIn [1]: sum_to_n(100)\nOut[1]: 5050\n```\n\n### 带有参数的函数\n\n在 Python 中，函数可以接收参数，并将它们一起使用。\n\n例如，我们想要使用一个函数来计算两个数字的差，我们可以把这两个数字作为函数的参数，如下所示", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    result = 0\n    for i in range(1, n + 1):\n      result += i\n    return result\n```\n\n在这里，`i`的值范围从 `1` 到 `n`， 这些值会被 `i` 依次赋值给 `i`。 注意，最后一次计算的结果被赋值给 `result`。\n\n我们可以通过 `sum_to_n(100)` 测试一下我们的函数：\n\n```py\nIn [1]: sum_to_n(100)\nOut[1]: 5050\n```\n\n### 带有参数的函数\n\n在 Python 中，函数可以接收参数，并将它们一起使用。\n\n例如，我们想要使用一个函数来计算两个数字的差，我们可以把这两个数字作为函数的参数，如下所示"}
{"task_id": "HumanEval/60", "completion": "    return 0 if n is 1 else n + sum_to_n(n-1)\n\n\nif __name__ == '__main__':\n    import doctest\n    do", "allcode": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 计算从1到n的数字的和.   >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return 0 if n is 1 else n + sum_to_n(n-1)\n\n\nif __name__ == '__main__':\n    import doctest\n    do"}
{"task_id": "HumanEval/70", "completion": "    import random\n    def sort_one(lst):\n        lst.sort()\n        lst.reverse()\n        return lst\n    def sort_two(lst):\n        lst.sort()\n        return lst\n    lst1 = sort_one(lst)\n    lst2 = sort_two(lst)\n    lst3 = []\n    for k in range(len(lst)):\n        if lst1[k] == lst2[k]:\n            continue\n        else:\n            lst3.append(lst2[k])\n    if len(lst) == len(lst3):\n        return lst1\n    else:\n        return lst3 + lst1\n\ndef last_two_average(lst):\n    '''\n    给定一个整数列表，返回列表中数字的最后两个平均值。如果列表有5个或更多个元素，则应返回两个数字的平均值，如果列表只有3个或更少，则应返回列表中的所有数字的平均值。\n", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    import random\n    def sort_one(lst):\n        lst.sort()\n        lst.reverse()\n        return lst\n    def sort_two(lst):\n        lst.sort()\n        return lst\n    lst1 = sort_one(lst)\n    lst2 = sort_two(lst)\n    lst3 = []\n    for k in range(len(lst)):\n        if lst1[k] == lst2[k]:\n            continue\n        else:\n            lst3.append(lst2[k])\n    if len(lst) == len(lst3):\n        return lst1\n    else:\n        return lst3 + lst1\n\ndef last_two_average(lst):\n    '''\n    给定一个整数列表，返回列表中数字的最后两个平均值。如果列表有5个或更多个元素，则应返回两个数字的平均值，如果列表只有3个或更少，则应返回列表中的所有数字的平均值。\n"}
{"task_id": "HumanEval/70", "completion": "    \n    result = []\n    min = min(lst)\n    while(lst!= []):\n        result.append(min)\n        lst.remove(min)\n        if(lst!= []):\n            max = max(lst)\n            min = min(lst)\n\n    return result\n# 测试代码\nlist = [1, 2, 3, 4, 5, 6]\nprint(strange_", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    \n    result = []\n    min = min(lst)\n    while(lst!= []):\n        result.append(min)\n        lst.remove(min)\n        if(lst!= []):\n            max = max(lst)\n            min = min(lst)\n\n    return result\n# 测试代码\nlist = [1, 2, 3, 4, 5, 6]\nprint(strange_"}
{"task_id": "HumanEval/70", "completion": "    return sorted(lst, key = lambda x : (x, -x))\n\n\ndef strange_sort_tuples(tuples):\n    '''\n    给定元组的列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余元组的最大值，接着是最小值，以此类推。\n    示例   strange_sort_tuples([(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]) == [(1, 2), (2, 1), (1, 4), (4, 1), (1, 3), (3, 1), (1, 2), (2, 3), (3, 2), (2, 4), (4, 2", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    return sorted(lst, key = lambda x : (x, -x))\n\n\ndef strange_sort_tuples(tuples):\n    '''\n    给定元组的列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余元组的最大值，接着是最小值，以此类推。\n    示例   strange_sort_tuples([(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]) == [(1, 2), (2, 1), (1, 4), (4, 1), (1, 3), (3, 1), (1, 2), (2, 3), (3, 2), (2, 4), (4, 2"}
{"task_id": "HumanEval/70", "completion": "    from collections import deque\n    q = deque()\n    for item in lst:\n        q.append(item)\n    while q:\n        q.appendleft(q.pop())\n    return list(q)\n\ndef get_heroes_by_team(team,lst):\n    '''\n    从一系列英雄中，按英雄阵营分类。\n    team 阵营字符串，固定血刃/暗影/烈焰\n    lst 英雄列表，英雄字符串\n    Returns\n    -------\n    list\n    '''\n    for team in lst:\n        if team['team'] == team:\n            res.append(team)\n    return res\n\ndef remove_middle(lst):\n    '''\n    删除列表中间的元素\n    [4, 3, 2, 1] -> [4, 2, 1]\n    [1, 2, 3, 4] -> [1, 3, 4]", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    from collections import deque\n    q = deque()\n    for item in lst:\n        q.append(item)\n    while q:\n        q.appendleft(q.pop())\n    return list(q)\n\ndef get_heroes_by_team(team,lst):\n    '''\n    从一系列英雄中，按英雄阵营分类。\n    team 阵营字符串，固定血刃/暗影/烈焰\n    lst 英雄列表，英雄字符串\n    Returns\n    -------\n    list\n    '''\n    for team in lst:\n        if team['team'] == team:\n            res.append(team)\n    return res\n\ndef remove_middle(lst):\n    '''\n    删除列表中间的元素\n    [4, 3, 2, 1] -> [4, 2, 1]\n    [1, 2, 3, 4] -> [1, 3, 4]"}
{"task_id": "HumanEval/70", "completion": "    return sorted(sorted(lst), key=lambda x: [lst.count(x), x])\n```\n- 剑指 Offer 26. 树的子结构\n\n```python\ndef isSubStructure(A: TreeNode, B: TreeNode) -> bool:\n    '''\n    输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n    '''\n    if not A or not B:\n        return False\n    return self.isSubTree(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)\n\n\ndef isSubTree(self, root: TreeNode, subRoot: TreeNode) -> bool:\n    if not root:\n        return False\n    if not subRoot:\n        return True\n    if root.val!= subRoot.val:\n        return False\n    return self.isSubTree(root.left", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    return sorted(sorted(lst), key=lambda x: [lst.count(x), x])\n```\n- 剑指 Offer 26. 树的子结构\n\n```python\ndef isSubStructure(A: TreeNode, B: TreeNode) -> bool:\n    '''\n    输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n    '''\n    if not A or not B:\n        return False\n    return self.isSubTree(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)\n\n\ndef isSubTree(self, root: TreeNode, subRoot: TreeNode) -> bool:\n    if not root:\n        return False\n    if not subRoot:\n        return True\n    if root.val!= subRoot.val:\n        return False\n    return self.isSubTree(root.left"}
{"task_id": "HumanEval/70", "completion": "    new_list = [0 for i in range(len(lst))]\n    count = 0\n    for num in lst:\n        if num > new_list[count]:\n            new_list.insert(count, num)\n            new_list.pop(count+1)\n            count += 1\n        count += 1\n    return new_list\n\ndef is_list_unique(lst):\n    '''\n    给定整数列表，看看列表中的每个整数都是唯一的。\n    示例   is_list_unique([1, 1, 2]) == False\n    is_list_unique([1, 1, 1]) == False\n    is_list_unique([1]) == True\n    is_list_unique([]) == True\n    is_list_unique([7, 9, 6]) == True\n    '''\n    new_list = lst * 2\n    for i in new_list:\n        if lst.count(i) == 1:\n            continue\n        else:\n            return False\n    return", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    new_list = [0 for i in range(len(lst))]\n    count = 0\n    for num in lst:\n        if num > new_list[count]:\n            new_list.insert(count, num)\n            new_list.pop(count+1)\n            count += 1\n        count += 1\n    return new_list\n\ndef is_list_unique(lst):\n    '''\n    给定整数列表，看看列表中的每个整数都是唯一的。\n    示例   is_list_unique([1, 1, 2]) == False\n    is_list_unique([1, 1, 1]) == False\n    is_list_unique([1]) == True\n    is_list_unique([]) == True\n    is_list_unique([7, 9, 6]) == True\n    '''\n    new_list = lst * 2\n    for i in new_list:\n        if lst.count(i) == 1:\n            continue\n        else:\n            return False\n    return"}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    else:\n        temp = []\n        temp.append(lst[0])\n        for i in range(1, len(lst)):\n            if i % 2 == 0:\n                temp.append(max(lst[:i + 1]))\n            else:\n                temp.append(min(lst[:i + 1]))\n        return temp\n\n\n# 测试代码\nt1 = [1, 2, 3, 4]\nt2 = [5, 5, 5, 5]\nt3 = [1, 2, 3, 4, 5, 5, 5, 5]\nt4 = []\nt5 = [1, 2, 3]\nt6 = [1, 2]\nt7 = [1]\nt8 = [5, 4, 3, 2, 1]\nprint(strange_sort_list(t1), [1, 4, 2, 3])  # True\nprint(strange_sort_list(", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    else:\n        temp = []\n        temp.append(lst[0])\n        for i in range(1, len(lst)):\n            if i % 2 == 0:\n                temp.append(max(lst[:i + 1]))\n            else:\n                temp.append(min(lst[:i + 1]))\n        return temp\n\n\n# 测试代码\nt1 = [1, 2, 3, 4]\nt2 = [5, 5, 5, 5]\nt3 = [1, 2, 3, 4, 5, 5, 5, 5]\nt4 = []\nt5 = [1, 2, 3]\nt6 = [1, 2]\nt7 = [1]\nt8 = [5, 4, 3, 2, 1]\nprint(strange_sort_list(t1), [1, 4, 2, 3])  # True\nprint(strange_sort_list("}
{"task_id": "HumanEval/70", "completion": "    if lst is None: return None\n    if len(lst) == 0: return []\n    if len(lst) == 1: return lst\n    elif len(lst) == 2:\n        if lst[0] >= lst[1]:\n            return lst[::-1]\n        else:\n            return lst\n    else:\n        min_value = min(lst)\n        print('min_value:', min_value)\n        max_value = max(lst)\n        print('max_value:', max_value)\n        return [min_value] + [max_value] + strange_sort_list(lst[:lst.index(min_value)] + lst[lst.index(max_value):])\n\n\ndef is_palindrome(s):\n    '''\n    给定字符串，判断该字符串是否是回文。\n    示例   is_palindrome('abcba') == True\n    is_palindrome('abcd') == False\n    '''\n    if s == s[::-1]:\n        return True\n    else:\n        return", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if lst is None: return None\n    if len(lst) == 0: return []\n    if len(lst) == 1: return lst\n    elif len(lst) == 2:\n        if lst[0] >= lst[1]:\n            return lst[::-1]\n        else:\n            return lst\n    else:\n        min_value = min(lst)\n        print('min_value:', min_value)\n        max_value = max(lst)\n        print('max_value:', max_value)\n        return [min_value] + [max_value] + strange_sort_list(lst[:lst.index(min_value)] + lst[lst.index(max_value):])\n\n\ndef is_palindrome(s):\n    '''\n    给定字符串，判断该字符串是否是回文。\n    示例   is_palindrome('abcba') == True\n    is_palindrome('abcd') == False\n    '''\n    if s == s[::-1]:\n        return True\n    else:\n        return"}
{"task_id": "HumanEval/70", "completion": "       \n    return sorted(lst, key=strange_sort)\n\ndef strange_sort(n):\n    '''\n    给定整数 n，如果n是偶数，返回 n*2\n    如果n是奇数，返回 n*2 - 1\n    '''\n    if n%", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n       \n    return sorted(lst, key=strange_sort)\n\ndef strange_sort(n):\n    '''\n    给定整数 n，如果n是偶数，返回 n*2\n    如果n是奇数，返回 n*2 - 1\n    '''\n    if n%"}
{"task_id": "HumanEval/70", "completion": "    if len(lst) == 0:\n        return []\n    tempList = []\n    for i in range(len(lst)):\n        if i == 0 or tempList[-1]!= lst[i]:\n            tempList.append(lst[i])\n            continue\n        else:\n            tempList.pop(-1)\n            if len(tempList) == 0:\n                tempList.append(lst[i])\n                continue\n            tempList.append(tempList[-1])\n            continue\n    return tempList\n\n\ndef sort_list(lst):\n    '''\n    给定整数列表，按正常排序返回列表\n    '''\n    return sorted(lst)\n\n\ndef are_anagrams(str_1, str_2):\n    '''\n    给定两个字符串，返回True如果它们是互为字母重排的\n    '''\n    if len(str_1)!= len(str_2):\n        return False\n    dict_1 = dict()\n    dict_2 =", "allcode": "\ndef strange_sort_list(lst):\n    '''\n    给定整数列表，按奇异排序返回列表，奇异排序是指从最小值开始，然后是其余整数的最大值，接着是最小值，以此类推。\n    示例   strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if len(lst) == 0:\n        return []\n    tempList = []\n    for i in range(len(lst)):\n        if i == 0 or tempList[-1]!= lst[i]:\n            tempList.append(lst[i])\n            continue\n        else:\n            tempList.pop(-1)\n            if len(tempList) == 0:\n                tempList.append(lst[i])\n                continue\n            tempList.append(tempList[-1])\n            continue\n    return tempList\n\n\ndef sort_list(lst):\n    '''\n    给定整数列表，按正常排序返回列表\n    '''\n    return sorted(lst)\n\n\ndef are_anagrams(str_1, str_2):\n    '''\n    给定两个字符串，返回True如果它们是互为字母重排的\n    '''\n    if len(str_1)!= len(str_2):\n        return False\n    dict_1 = dict()\n    dict_2 ="}
{"task_id": "HumanEval/73", "completion": "    res = 0\n    for i in range(len(arr)):\n        if i > 0 and i < len(arr) - 1:\n            if max(arr[i-1], arr[i+1]) >= arr[i]:\n                res += 1\n            else:\n                res += max(arr[i-1], arr[i+1]) - arr[i]\n        if i == 0:\n            if arr[i] > arr[i+1]:\n                res += arr[i+1] - arr[i]\n        if i == len(arr) - 1:\n            if arr[i] > arr[i-1]:\n                res += arr[i-1] - arr[i]\n    return res\n\ndef sum_of_squares(a, b, c):\n    \"\"\"\n    给定三个整数a，b，c，计算它们的和的平方是多少？\n    For example:\n    sum_of_squares(2, 1, 3) == 15\n    sum_of_squares", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    res = 0\n    for i in range(len(arr)):\n        if i > 0 and i < len(arr) - 1:\n            if max(arr[i-1], arr[i+1]) >= arr[i]:\n                res += 1\n            else:\n                res += max(arr[i-1], arr[i+1]) - arr[i]\n        if i == 0:\n            if arr[i] > arr[i+1]:\n                res += arr[i+1] - arr[i]\n        if i == len(arr) - 1:\n            if arr[i] > arr[i-1]:\n                res += arr[i-1] - arr[i]\n    return res\n\ndef sum_of_squares(a, b, c):\n    \"\"\"\n    给定三个整数a，b，c，计算它们的和的平方是多少？\n    For example:\n    sum_of_squares(2, 1, 3) == 15\n    sum_of_squares"}
{"task_id": "HumanEval/73", "completion": "    N = len(arr)\n    L = [[] for _ in range(N + 1)]\n    for i in range(N - 1, -1, -1):\n        dp = [100000000 for i in range(N)]\n        for j in range(i, N):\n            if arr[i] == arr[j]:\n                dp[j] = dp[i] + j - i + 1\n            else:\n                dp[j] = min(dp[i + 1 : j + 1] + [j - i])\n        L[i] = dp\n    ans = 100000000\n    for i, j in L[0][:N]:\n        ans = min(ans, j - i + 1)\n    return ans\n\n\n# 字符串\n\ndef is_unique(S):\n    \"\"\"\n    Return \"True\" if the string S has all unique characters and \"False\" otherwise.\n    >>> is_unique(\"abcd\")\n    True\n    >>> is_unique(\"aabc", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    N = len(arr)\n    L = [[] for _ in range(N + 1)]\n    for i in range(N - 1, -1, -1):\n        dp = [100000000 for i in range(N)]\n        for j in range(i, N):\n            if arr[i] == arr[j]:\n                dp[j] = dp[i] + j - i + 1\n            else:\n                dp[j] = min(dp[i + 1 : j + 1] + [j - i])\n        L[i] = dp\n    ans = 100000000\n    for i, j in L[0][:N]:\n        ans = min(ans, j - i + 1)\n    return ans\n\n\n# 字符串\n\ndef is_unique(S):\n    \"\"\"\n    Return \"True\" if the string S has all unique characters and \"False\" otherwise.\n    >>> is_unique(\"abcd\")\n    True\n    >>> is_unique(\"aabc"}
{"task_id": "HumanEval/73", "completion": "    n = len(arr)\n    dp = [[0] * n for i in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n-1):\n        if arr[i]!=arr[i+1]:\n            dp[i][i+1] = 2\n    for gap in range(3,n):\n        for i in range(n-gap):\n            j = i+gap\n            if arr[i]!=arr[j]:\n                min_ = min(dp[i][j],dp[i+1][j],dp[i][j-1])\n                dp[i][j] = min_+1\n            else:\n                dp[i][j] = dp[i+1][j-1]\n    return dp[0][-1]\n\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    n = len(arr)\n    dp = [[0] * n for i in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n-1):\n        if arr[i]!=arr[i+1]:\n            dp[i][i+1] = 2\n    for gap in range(3,n):\n        for i in range(n-gap):\n            j = i+gap\n            if arr[i]!=arr[j]:\n                min_ = min(dp[i][j],dp[i+1][j],dp[i][j-1])\n                dp[i][j] = min_+1\n            else:\n                dp[i][j] = dp[i+1][j-1]\n    return dp[0][-1]\n\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个"}
{"task_id": "HumanEval/73", "completion": "    i = 0\n    j = len(arr) - 1\n    change = 0\n    while i <= j:\n        while arr[i] > arr[j]:\n            change += (arr[i] - arr[j])\n            i += 1\n        while arr[i] < arr[j]:\n            change += (arr[j] - arr[i])\n            j -= 1\n        if arr[i] == arr[j]:\n            i += 1\n            j -= 1\n    return change\n\n\nif __name__ == \"__main__\":\n    test_arr1 = [1, 2, 3, 5, 4, 7, 9, 6]\n    test_arr2 = [1, 2, 3, 4, 3, 2, 2]\n    test_arr3 = [1, 2, 3, 2, 1]\n    test_arr4 = [2, 4, 6, 1, 3, 5]\n    print(smallest_change(test_arr1))\n   ", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    i = 0\n    j = len(arr) - 1\n    change = 0\n    while i <= j:\n        while arr[i] > arr[j]:\n            change += (arr[i] - arr[j])\n            i += 1\n        while arr[i] < arr[j]:\n            change += (arr[j] - arr[i])\n            j -= 1\n        if arr[i] == arr[j]:\n            i += 1\n            j -= 1\n    return change\n\n\nif __name__ == \"__main__\":\n    test_arr1 = [1, 2, 3, 5, 4, 7, 9, 6]\n    test_arr2 = [1, 2, 3, 4, 3, 2, 2]\n    test_arr3 = [1, 2, 3, 2, 1]\n    test_arr4 = [2, 4, 6, 1, 3, 5]\n    print(smallest_change(test_arr1))\n   "}
{"task_id": "HumanEval/73", "completion": "    # write code here\n    n = len(arr)\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    for k in range(n):\n        for i in range(n - k - 1):\n            j = i + k + 1\n            dp[i][j] = min(dp[i][j - 1] + 1, dp[i + 1][j] + 1, dp[i][j - 1] + abs(arr[i] - arr[j]))\n    return dp[0][n - 1]\n\n\ndef longest_substring(s):\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Examples:\n    longest_substring('abcabcbb') == 3\n    longest_substring('bbbbb') == 1\n    longest_substring('pwwkew') == 3\n    \"\"\"\n    # write code here\n    if not s or len(s", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # write code here\n    n = len(arr)\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    for k in range(n):\n        for i in range(n - k - 1):\n            j = i + k + 1\n            dp[i][j] = min(dp[i][j - 1] + 1, dp[i + 1][j] + 1, dp[i][j - 1] + abs(arr[i] - arr[j]))\n    return dp[0][n - 1]\n\n\ndef longest_substring(s):\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Examples:\n    longest_substring('abcabcbb') == 3\n    longest_substring('bbbbb') == 1\n    longest_substring('pwwkew') == 3\n    \"\"\"\n    # write code here\n    if not s or len(s"}
{"task_id": "HumanEval/73", "completion": "    if not arr:\n        return 0\n    s = set(arr)\n    res = float('inf')\n    for i in range(1, len(arr)):\n        if arr[i-1] in s and arr[i] in s:\n            res = min(res, abs(arr[i-1]-arr[i]))\n    return res\n```\n\n#### 2.1 解题思路\n\n解题思路：\n\n1. 遍历每一个元素，如果当前元素左边的元素和右边的元素都在arr中，我们可以将其中一个改为其他元素，获得满足回文数组的最小元素个数\n2. 因为数组的值的范围是-1000~1000，所以我们可以将每一个元素分成两种情况，一种是当前元素左边的元素在arr中，右边的元素在arr中，另一种", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    s = set(arr)\n    res = float('inf')\n    for i in range(1, len(arr)):\n        if arr[i-1] in s and arr[i] in s:\n            res = min(res, abs(arr[i-1]-arr[i]))\n    return res\n```\n\n#### 2.1 解题思路\n\n解题思路：\n\n1. 遍历每一个元素，如果当前元素左边的元素和右边的元素都在arr中，我们可以将其中一个改为其他元素，获得满足回文数组的最小元素个数\n2. 因为数组的值的范围是-1000~1000，所以我们可以将每一个元素分成两种情况，一种是当前元素左边的元素在arr中，右边的元素在arr中，另一种"}
{"task_id": "HumanEval/73", "completion": "    # 数组是否为空，为空则变成的回文数组是空数组\n    if not arr:\n        return 0\n\n    def helper(arr, length):\n        if length == 1:\n            return 0\n        if length == 2:\n            return min(arr[0], arr[1])\n\n        if arr[length - 1] == arr[length - 2]:\n            return 1 + helper(arr, length - 2)\n        else:\n            return 1 + min(arr[length - 1], arr[length - 2]) + helper(arr, length - 2)\n\n    return helper(arr, len(arr))\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # 数组是否为空，为空则变成的回文数组是空数组\n    if not arr:\n        return 0\n\n    def helper(arr, length):\n        if length == 1:\n            return 0\n        if length == 2:\n            return min(arr[0], arr[1])\n\n        if arr[length - 1] == arr[length - 2]:\n            return 1 + helper(arr, length - 2)\n        else:\n            return 1 + min(arr[length - 1], arr[length - 2]) + helper(arr, length - 2)\n\n    return helper(arr, len(arr))\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个"}
{"task_id": "HumanEval/73", "completion": "    if len(arr) == 0:\n        return 0\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        if arr[left]!= arr[right]:\n            arr[left] = arr[right]\n        left += 1\n        right -= 1\n    return len(arr) - 1\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个数组arr，给定一个数，arr中最小差值和，返回对应的数组。\n    \"\"\"\n    if len(arr) == 0:\n        return arr\n    new_arr = []\n    for i in range(len(arr)):\n        temp_arr = arr[:i] + arr[i + 1:]\n        new_arr.append(min(temp_arr))\n    return new_arr\n\n\ndef smallest_change3(arr):\n    if len(arr) == 0:\n        return 0\n    start = 0\n    new_arr = []\n    for i in range(len(arr)):", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        if arr[left]!= arr[right]:\n            arr[left] = arr[right]\n        left += 1\n        right -= 1\n    return len(arr) - 1\n\ndef smallest_change2(arr):\n    \"\"\"\n    给定一个数组arr，给定一个数，arr中最小差值和，返回对应的数组。\n    \"\"\"\n    if len(arr) == 0:\n        return arr\n    new_arr = []\n    for i in range(len(arr)):\n        temp_arr = arr[:i] + arr[i + 1:]\n        new_arr.append(min(temp_arr))\n    return new_arr\n\n\ndef smallest_change3(arr):\n    if len(arr) == 0:\n        return 0\n    start = 0\n    new_arr = []\n    for i in range(len(arr)):"}
{"task_id": "HumanEval/73", "completion": "    # 对arr排序，然后找出循环中最小值，最大值\n    arr.sort()\n    m = arr[-1]\n    n = arr[0]\n    # 循环中最大值减循环中最小值\n    return m - n\n\n```\n\n\n\n\n## 101 - 找出有序数组中缺失的数字\n\n### 题目描述\n\n给定一个包含 0, 1, 2,..., n 中 n 个数的序列，找出 0.. n 中没有出现在序列中的那个数。\n\n假设这个序列是在随机顺序输入的，并且是唯一的。尽管我们无法在一次遍历序列的过程中找出缺失的数字，��", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # 对arr排序，然后找出循环中最小值，最大值\n    arr.sort()\n    m = arr[-1]\n    n = arr[0]\n    # 循环中最大值减循环中最小值\n    return m - n\n\n```\n\n\n\n\n## 101 - 找出有序数组中缺失的数字\n\n### 题目描述\n\n给定一个包含 0, 1, 2,..., n 中 n 个数的序列，找出 0.. n 中没有出现在序列中的那个数。\n\n假设这个序列是在随机顺序输入的，并且是唯一的。尽管我们无法在一次遍历序列的过程中找出缺失的数字，��"}
{"task_id": "HumanEval/73", "completion": "    def odd(arr):\n        if not arr:\n            return\n        while odd_index < len(arr):\n            if odd_index + 1 >= len(arr):\n                return\n            if arr[odd_index]!= arr[odd_index + 1]:\n                if arr[odd_index] > arr[odd_index + 1]:\n                    odd_index += 1\n                if arr[odd_index] < arr[odd_index + 1]:\n                    return odd_index\n        return 0\n    \n    def even(arr, odd_index):\n        if not arr:\n            if len(arr) % 2 == 0:\n                return odd_index\n            else:\n                return len(arr) - 1\n        while even_index <= len(arr)-1:\n            if arr[even_index]!= arr[even_index - 1]:\n                if arr[even_index] > arr[even_index - 1]:\n                    even_index += 1\n                if arr[even_index] < arr[even_index - 1]:\n                   ", "allcode": "\ndef smallest_change(arr):\n    \"\"\"\n    给定一个由整数组成的数组arr，求使该数组成为回文数组所需改变的最少元素个数。回文数组是指从前向后读和从后向前读都相同的数组。在一次改变中，你可以将一个元素改变为任何其他元素。\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    def odd(arr):\n        if not arr:\n            return\n        while odd_index < len(arr):\n            if odd_index + 1 >= len(arr):\n                return\n            if arr[odd_index]!= arr[odd_index + 1]:\n                if arr[odd_index] > arr[odd_index + 1]:\n                    odd_index += 1\n                if arr[odd_index] < arr[odd_index + 1]:\n                    return odd_index\n        return 0\n    \n    def even(arr, odd_index):\n        if not arr:\n            if len(arr) % 2 == 0:\n                return odd_index\n            else:\n                return len(arr) - 1\n        while even_index <= len(arr)-1:\n            if arr[even_index]!= arr[even_index - 1]:\n                if arr[even_index] > arr[even_index - 1]:\n                    even_index += 1\n                if arr[even_index] < arr[even_index - 1]:\n                   "}
{"task_id": "HumanEval/82", "completion": "    # 首先，取字符串的长度\n    length = len(string)\n    # 判断长度是否是质数，如果是，则返回 True 否则返回 False\n    if is_prime(length):\n    # 取字符串的所有字符，将字符串转换 为 set 集合，然后判断集合的大小是否等于字符串的长度\n        # if len(set(string)) == length:\n        #     return True\n        # else: return False\n        return True\n    else:\n        return False\n\n\ndef is_palindrome(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串为回文，则返回True，否则返回False    示例：\n    is_palindrome('madam') == True\n    is_palindrome('racecar') == True\n    is_palindrome('kayak') == True\n    is_palindrome('lol') == False\n    is_palind", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    # 首先，取字符串的长度\n    length = len(string)\n    # 判断长度是否是质数，如果是，则返回 True 否则返回 False\n    if is_prime(length):\n    # 取字符串的所有字符，将字符串转换 为 set 集合，然后判断集合的大小是否等于字符串的长度\n        # if len(set(string)) == length:\n        #     return True\n        # else: return False\n        return True\n    else:\n        return False\n\n\ndef is_palindrome(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串为回文，则返回True，否则返回False    示例：\n    is_palindrome('madam') == True\n    is_palindrome('racecar') == True\n    is_palindrome('kayak') == True\n    is_palindrome('lol') == False\n    is_palind"}
{"task_id": "HumanEval/82", "completion": "    if len(string) in primes:\n        # 用 if 语句，判断 字符串长度 是否是 质数\n        return True\n    else:\n        # 用 if 语句，判断 字符串长度 是否是 质数\n        return False\nprime_length('Hello')     # True\nprime_length('abcdcba')   # True\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime_length('abcd')      # False\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime_length('abcd')      # False\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) in primes:\n        # 用 if 语句，判断 字符串长度 是否是 质数\n        return True\n    else:\n        # 用 if 语句，判断 字符串长度 是否是 质数\n        return False\nprime_length('Hello')     # True\nprime_length('abcdcba')   # True\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime_length('abcd')      # False\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime_length('abcd')      # False\nprime_length('kittens')   # True\nprime_length('orange')    # False\nprime_length('abcda')     # False\nprime_length('')          # False\nprime"}
{"task_id": "HumanEval/82", "completion": "    pass\n\nif __name__ == '__main__':\n    print(prime_length('Hello'))\n    print(prime_length('abcdcba'))\n    print(prime_length('kittens'))\n    print(prime_length('orange'))\n```\n\n\n\n### 数字的字符串表示\n\n```py\ndef is_digit(string):\n    \"\"\"编写一个函数，接收一个字符串，如果该字符串是一个由数字所构成的字符串，则返回True，否则返回False    示例：\n    is_digit('19999') == True\n    is_digit('123.45') == False\n    is_digit('0') == True\n    is_digit('09') == False\n    is_digit('0123456789') == True\n    \"\"\"\n    pass\n\nif __name__ == '__main__':\n    print(is_digit('19999'))\n    print(is_digit('123.45", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    pass\n\nif __name__ == '__main__':\n    print(prime_length('Hello'))\n    print(prime_length('abcdcba'))\n    print(prime_length('kittens'))\n    print(prime_length('orange'))\n```\n\n\n\n### 数字的字符串表示\n\n```py\ndef is_digit(string):\n    \"\"\"编写一个函数，接收一个字符串，如果该字符串是一个由数字所构成的字符串，则返回True，否则返回False    示例：\n    is_digit('19999') == True\n    is_digit('123.45') == False\n    is_digit('0') == True\n    is_digit('09') == False\n    is_digit('0123456789') == True\n    \"\"\"\n    pass\n\nif __name__ == '__main__':\n    print(is_digit('19999'))\n    print(is_digit('123.45"}
{"task_id": "HumanEval/82", "completion": "    result = len(string)\n    for i in range(2,int(math.sqrt(result))):\n        if result % i == 0:\n            return False\n    return True\n\n\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    prime_list =[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]\n    if len(string) in prime_list:\n        return True\n    else:\n        return False\n\n", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    result = len(string)\n    for i in range(2,int(math.sqrt(result))):\n        if result % i == 0:\n            return False\n    return True\n\n\n\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    prime_list =[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]\n    if len(string) in prime_list:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "HumanEval/82", "completion": "    # 质数判断\n    p = 2\n    while p * p <= string:\n        if string % p == 0:\n            return False\n        p += 1\n    return True\n\n\n# 题目2：罗马数字转化为阿拉伯数字    示例：\n# roman_to_int('IV') == 4\n# roman_to_int('XL') == 40\n# roman_to_int('XCIX') == 99\ndef roman_to_int(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串是一个合法的罗马数字，则返回这个罗马数字的阿拉伯数字形式，否则返回None。合法的罗马数字规则如下：\n    1. 只能包含\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"。\n    2. 数字在从小到大", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    # 质数判断\n    p = 2\n    while p * p <= string:\n        if string % p == 0:\n            return False\n        p += 1\n    return True\n\n\n# 题目2：罗马数字转化为阿拉伯数字    示例：\n# roman_to_int('IV') == 4\n# roman_to_int('XL') == 40\n# roman_to_int('XCIX') == 99\ndef roman_to_int(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串是一个合法的罗马数字，则返回这个罗马数字的阿拉伯数字形式，否则返回None。合法的罗马数字规则如下：\n    1. 只能包含\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"。\n    2. 数字在从小到大"}
{"task_id": "HumanEval/82", "completion": "\n# Exercise 17:\ndef sum_squares(lst):\n    \"\"\"编写一个函数，接收一个List，返回List中每个元素的平方和    示例：\n    sum_squares([1, 2, 3, 4]) == 30\n    sum_squares([4, 3, 2, 1]) == 30\n    sum_squares([2, 3, 3, 2, 5]) == 47\n    \"\"\"\n\n# Exercise 18:\ndef square_string(string):\n    \"\"\"编写一个函数，接收一个字符串，返回该字符串每个字符的平方    示例：\n    square_string('Hello') == 'HellO'\n    square_string('abcd') == 'abcd'\n    square_string('Python') == 'PythoN'\n    \"\"\"\n\n# Exercise 19:\ndef add_ends(word):\n    \"\"\"编写一个函数，接收一个字符串", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n\n# Exercise 17:\ndef sum_squares(lst):\n    \"\"\"编写一个函数，接收一个List，返回List中每个元素的平方和    示例：\n    sum_squares([1, 2, 3, 4]) == 30\n    sum_squares([4, 3, 2, 1]) == 30\n    sum_squares([2, 3, 3, 2, 5]) == 47\n    \"\"\"\n\n# Exercise 18:\ndef square_string(string):\n    \"\"\"编写一个函数，接收一个字符串，返回该字符串每个字符的平方    示例：\n    square_string('Hello') == 'HellO'\n    square_string('abcd') == 'abcd'\n    square_string('Python') == 'PythoN'\n    \"\"\"\n\n# Exercise 19:\ndef add_ends(word):\n    \"\"\"编写一个函数，接收一个字符串"}
{"task_id": "HumanEval/82", "completion": "    if len(string) <= 0:\n        return False\n    length = math.sqrt(len(string)) + 1\n    for i in range(2, length):\n        if len(string) % i!= 0:\n            continue\n        return False\n    return True\n\n\n\ndef count_words(string):\n    \"\"\"编写一个函数，接收一个字符串并返回其单词总数，使用split()方法。    示例：\n    count_words('hello world') == 2\n    count_words('Hello World!') == 2\n    count_words('Hello') == 1\n    \"\"\"\n    return len(string.split())\n\n\n\ndef count_digits(string):\n    \"\"\"编写一个函数，接收一个整数字符串，返回该字符串中数字的个数，使用isdigit()方法。    示例：\n    count_digits('hello world') == 0\n    count_digits('Hello World!') == 0\n    count_digits", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) <= 0:\n        return False\n    length = math.sqrt(len(string)) + 1\n    for i in range(2, length):\n        if len(string) % i!= 0:\n            continue\n        return False\n    return True\n\n\n\ndef count_words(string):\n    \"\"\"编写一个函数，接收一个字符串并返回其单词总数，使用split()方法。    示例：\n    count_words('hello world') == 2\n    count_words('Hello World!') == 2\n    count_words('Hello') == 1\n    \"\"\"\n    return len(string.split())\n\n\n\ndef count_digits(string):\n    \"\"\"编写一个函数，接收一个整数字符串，返回该字符串中数字的个数，使用isdigit()方法。    示例：\n    count_digits('hello world') == 0\n    count_digits('Hello World!') == 0\n    count_digits"}
{"task_id": "HumanEval/82", "completion": "    def is_prime(num):\n        return all(num % div for div in range(2,num))\n    \n    return is_prime(len(string))\n```\n\n### 2. [极客时间-剑指 Offer 系列](https://time.geekbang.org/column/intro/126)\n\n#### [剑指 Offer 36. 二进制数中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-shu-zhong-1de-ge-shu-lcof/)\n>简单 二分查找 位运算\n>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 的个数。\n\n```python\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        count = 0\n        if (n<=0):\n            return count\n        while n >0:\n", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    def is_prime(num):\n        return all(num % div for div in range(2,num))\n    \n    return is_prime(len(string))\n```\n\n### 2. [极客时间-剑指 Offer 系列](https://time.geekbang.org/column/intro/126)\n\n#### [剑指 Offer 36. 二进制数中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-shu-zhong-1de-ge-shu-lcof/)\n>简单 二分查找 位运算\n>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 的个数。\n\n```python\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        count = 0\n        if (n<=0):\n            return count\n        while n >0:\n"}
{"task_id": "HumanEval/82", "completion": "    # Your code here\n    string = string.lower()\n    length = len(string)\n    for i in range(3, length):\n        if length % i == 0:\n            return False\n    else:\n        return True\n\n\ndef test_prime_length():\n    assert prime_length('Hello') == True\n    assert prime_length('abcdcba') == True\n    assert prime_length('kittens') == True\n    assert prime_length('orange') == False\n    assert prime_length('111') == False\n    assert prime_length('222') == False\n    assert prime_length('333') == False\n    assert prime_length('444') == False\n    assert prime_length('555') == False\n    assert prime_length('666') == False\n    assert prime_length('777') == False\n    assert prime_length('888') == False\n    assert prime_length('999') == False\n\n\nif __name__ == '__main__':\n    test_prime_length()\n```\n##", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    # Your code here\n    string = string.lower()\n    length = len(string)\n    for i in range(3, length):\n        if length % i == 0:\n            return False\n    else:\n        return True\n\n\ndef test_prime_length():\n    assert prime_length('Hello') == True\n    assert prime_length('abcdcba') == True\n    assert prime_length('kittens') == True\n    assert prime_length('orange') == False\n    assert prime_length('111') == False\n    assert prime_length('222') == False\n    assert prime_length('333') == False\n    assert prime_length('444') == False\n    assert prime_length('555') == False\n    assert prime_length('666') == False\n    assert prime_length('777') == False\n    assert prime_length('888') == False\n    assert prime_length('999') == False\n\n\nif __name__ == '__main__':\n    test_prime_length()\n```\n##"}
{"task_id": "HumanEval/82", "completion": "    if len(string) == 0:\n        return False\n    if len(string) > 0:\n        count = 0\n        for i in string:\n            count += 1\n            if count > 1:\n                if len(string) == len(string) - count:\n                    return False\n    return True\n\n\n\ndef count_letters(string, letter):\n    \"\"\"编写一个函数，接收一个字符串和一个字母，返回字符串中该字母出现的次数    示例：\n    count_letters('Hello', 'e') == 1\n    count_letters('Hello', 'l') == 2\n    count_letters('Hello', 'o') == 1\n    count_letters('abc', 'a') == 1\n    \"\"\"\n    letter_count = 0\n    for letter in string:\n        if letter == letter:\n            letter_count += 1\n    return letter_count\n\n\n\ndef no_anagrams(string_one, string_two):\n    \"\"\"编写一个", "allcode": "\ndef prime_length(string):\n    \"\"\"编写一个函数，接收一个字符串，如果字符串长度是质数，则返回True，否则返回False    示例：\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if len(string) == 0:\n        return False\n    if len(string) > 0:\n        count = 0\n        for i in string:\n            count += 1\n            if count > 1:\n                if len(string) == len(string) - count:\n                    return False\n    return True\n\n\n\ndef count_letters(string, letter):\n    \"\"\"编写一个函数，接收一个字符串和一个字母，返回字符串中该字母出现的次数    示例：\n    count_letters('Hello', 'e') == 1\n    count_letters('Hello', 'l') == 2\n    count_letters('Hello', 'o') == 1\n    count_letters('abc', 'a') == 1\n    \"\"\"\n    letter_count = 0\n    for letter in string:\n        if letter == letter:\n            letter_count += 1\n    return letter_count\n\n\n\ndef no_anagrams(string_one, string_two):\n    \"\"\"编写一个"}
{"task_id": "HumanEval/90", "completion": "    for i in range(1,len(lst)):\n        if lst[i] < lst[i-1]:\n            return lst[i]\n    return None\n\ndef rotate(a, d):\n    \"\"\"\n    给出一个循环数组a和一个正整数d，旋转数组。 数组被认为是循环的，也就是说，a[0]’ 是a[len(a)-1]，a[1]是a[0]等.    \n    rotate([1, 2, 3], 2) == [2, 3, 1]\n    rotate([1, 2, 3], 1) == [3, 1, 2]\n    rotate([1, 2, 3], 11) == [1, 2, 3]\n    rotate([1, 2, 3], 3) == [2, 3, 1]\n    \"\"\"\n    return a[d:] + a[:d]\n\ndef reverse(a, b):\n   ", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    for i in range(1,len(lst)):\n        if lst[i] < lst[i-1]:\n            return lst[i]\n    return None\n\ndef rotate(a, d):\n    \"\"\"\n    给出一个循环数组a和一个正整数d，旋转数组。 数组被认为是循环的，也就是说，a[0]’ 是a[len(a)-1]，a[1]是a[0]等.    \n    rotate([1, 2, 3], 2) == [2, 3, 1]\n    rotate([1, 2, 3], 1) == [3, 1, 2]\n    rotate([1, 2, 3], 11) == [1, 2, 3]\n    rotate([1, 2, 3], 3) == [2, 3, 1]\n    \"\"\"\n    return a[d:] + a[:d]\n\ndef reverse(a, b):\n   "}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 1:\n        return None\n    if len(lst) == 2:\n        return lst[0] if lst[1] == lst[0] else lst[1]\n    min_index = 0\n    for i in range(1, len(lst)):\n        if lst[min_index] > lst[i]:\n            min_index = i\n\n    small_index = 0\n    for i in range(min_index + 1, len(lst)):\n        if lst[i] < lst[small_index]:\n            small_index = i\n    return lst[small_index]\n\n\ndef next_smallest2(lst):\n    lst.sort()\n    lst.reverse()\n    return lst[1]\n\n\ndef find(lst, item):\n    \"\"\"\n    find()函数在列表中查找一个元素，如果找到该元素则返回True，否则返回False\n    \"\"\"\n    for x in lst:\n        if x == item:\n            return True\n    return False\n\n\n", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 1:\n        return None\n    if len(lst) == 2:\n        return lst[0] if lst[1] == lst[0] else lst[1]\n    min_index = 0\n    for i in range(1, len(lst)):\n        if lst[min_index] > lst[i]:\n            min_index = i\n\n    small_index = 0\n    for i in range(min_index + 1, len(lst)):\n        if lst[i] < lst[small_index]:\n            small_index = i\n    return lst[small_index]\n\n\ndef next_smallest2(lst):\n    lst.sort()\n    lst.reverse()\n    return lst[1]\n\n\ndef find(lst, item):\n    \"\"\"\n    find()函数在列表中查找一个元素，如果找到该元素则返回True，否则返回False\n    \"\"\"\n    for x in lst:\n        if x == item:\n            return True\n    return False\n\n\n"}
{"task_id": "HumanEval/90", "completion": "    smallest = None\n    for i, x in enumerate(lst):\n        if smallest is None or x < smallest:\n            smallest = x\n    return None if smallest is None else lst[lst.index(smallest)+1]\n\nnext_smallest([1, 2, 3, 4, 5])\nnext_smallest([5, 1, 4, 3, 2])\nnext_smallest([])\nnext_smallest([1, 1])\n```\n\n### 返回值最小的元素\n\n```py\ndef min_element(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数min_element()，返回列表中最小的元素。\n\n    min_element([0, 1, 2, 3]) == 0\n    min_element([2, 3, 4, 5]) == 2\n    min_element([]) == None\n    min_element([1, 1]) == None\n    min_element([5, 1, 4, 3, 2", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    smallest = None\n    for i, x in enumerate(lst):\n        if smallest is None or x < smallest:\n            smallest = x\n    return None if smallest is None else lst[lst.index(smallest)+1]\n\nnext_smallest([1, 2, 3, 4, 5])\nnext_smallest([5, 1, 4, 3, 2])\nnext_smallest([])\nnext_smallest([1, 1])\n```\n\n### 返回值最小的元素\n\n```py\ndef min_element(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数min_element()，返回列表中最小的元素。\n\n    min_element([0, 1, 2, 3]) == 0\n    min_element([2, 3, 4, 5]) == 2\n    min_element([]) == None\n    min_element([1, 1]) == None\n    min_element([5, 1, 4, 3, 2"}
{"task_id": "HumanEval/90", "completion": "    if not lst:\n        return None\n    smallest = None\n    for x in lst:\n        if smallest == None or smallest > x:\n            smallest = x\n    if smallest == None:\n        return None\n    second_smallest = None\n    for x in lst:\n        if x!= smallest and (second_smallest == None or second_smallest > x):\n            second_smallest = x\n    return second_smallest\n\n\n\ndef my_sum(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数my_sum()，返回列表中所有元素的和。\n    my_sum([1, 2, 3, 4, 5]) == 15\n    my_sum([1, 4, 9, 16, 25]) == 55\n    my_sum([]) == 0\n    my_sum([1]) == 1\n    \"\"\"\n    result = 0\n    for x in lst:\n        result += x\n    return result\n\n\n# 斐波那�", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n    smallest = None\n    for x in lst:\n        if smallest == None or smallest > x:\n            smallest = x\n    if smallest == None:\n        return None\n    second_smallest = None\n    for x in lst:\n        if x!= smallest and (second_smallest == None or second_smallest > x):\n            second_smallest = x\n    return second_smallest\n\n\n\ndef my_sum(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数my_sum()，返回列表中所有元素的和。\n    my_sum([1, 2, 3, 4, 5]) == 15\n    my_sum([1, 4, 9, 16, 25]) == 55\n    my_sum([]) == 0\n    my_sum([1]) == 1\n    \"\"\"\n    result = 0\n    for x in lst:\n        result += x\n    return result\n\n\n# 斐波那�"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 0:\n        return None\n    elif len(lst) == 1:\n        return None\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        return lst[0] if lst[0] < lst[1] else lst[1] \n    else:  # len(lst) > 2\n        if lst[0] == lst[1]:  # 第一个和第二个一样\n            return next_smallest(lst[2:])\n        elif lst[1] == lst[2]:  # 第二个和第三个一样\n            return next_smallest([lst[0]] + lst[3:])\n        elif lst[2] == lst[3]:  # 第三个和第四个一样\n            return next_smallest([lst[0], lst[1]] + lst[4:])\n        elif lst[0] < lst[1] < lst[2] < lst[3]:  # 第一个最小\n            return lst[1]\n       ", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 0:\n        return None\n    elif len(lst) == 1:\n        return None\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        return lst[0] if lst[0] < lst[1] else lst[1] \n    else:  # len(lst) > 2\n        if lst[0] == lst[1]:  # 第一个和第二个一样\n            return next_smallest(lst[2:])\n        elif lst[1] == lst[2]:  # 第二个和第三个一样\n            return next_smallest([lst[0]] + lst[3:])\n        elif lst[2] == lst[3]:  # 第三个和第四个一样\n            return next_smallest([lst[0], lst[1]] + lst[4:])\n        elif lst[0] < lst[1] < lst[2] < lst[3]:  # 第一个最小\n            return lst[1]\n       "}
{"task_id": "HumanEval/90", "completion": "    pass\n\n\ndef sum_list(lst):\n    \"\"\"\n    给出一个整数列表，返回列表中所有数字的和。    \n    sum_list([1, 2, 3, 4, 5]) == 15\n    sum_list([-1, -2, -3, -4, -5]) == -15\n    sum_list([]) == 0\n    sum_list([1, 1]) == 2\n    \"\"\"\n    pass\n\n\ndef sum_list_recursive(lst):\n    \"\"\"\n    给出一个整数列表，返回列表中所有数字的和。    \n    sum_list([1, 2, 3, 4, 5]) == 15\n    sum_list([-1, -2, -3, -4, -5]) == -15\n    sum_list([]) == 0\n    sum_list([1, 1]) == 2\n    \n    sum_list_recursive([1, 2, 3, 4", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    pass\n\n\ndef sum_list(lst):\n    \"\"\"\n    给出一个整数列表，返回列表中所有数字的和。    \n    sum_list([1, 2, 3, 4, 5]) == 15\n    sum_list([-1, -2, -3, -4, -5]) == -15\n    sum_list([]) == 0\n    sum_list([1, 1]) == 2\n    \"\"\"\n    pass\n\n\ndef sum_list_recursive(lst):\n    \"\"\"\n    给出一个整数列表，返回列表中所有数字的和。    \n    sum_list([1, 2, 3, 4, 5]) == 15\n    sum_list([-1, -2, -3, -4, -5]) == -15\n    sum_list([]) == 0\n    sum_list([1, 1]) == 2\n    \n    sum_list_recursive([1, 2, 3, 4"}
{"task_id": "HumanEval/90", "completion": "    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]\n\n\ndef list_intersection(lst1, lst2):\n    \"\"\"\n    Given 2 lists, create a new list that has the elements that are in both lists without duplication.   \n    list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4]\n    \"\"\"\n    lst1.extend(lst2)\n    lst1.sort()\n    lst1.reverse()\n    lst2 = []\n    for i in range(len(lst1)-1):\n        if lst1[i] == lst1[i+1]:\n            continue\n        else:\n            lst2.append(lst1[i])\n    return lst2\n\n\ndef list_intersection2(lst1, lst2):\n    \"\"\"\n    Given 2 lists, create a new list that has the elements that are in both lists without duplication.   \n    list_intersection2([1, 2, 3, 4", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]\n\n\ndef list_intersection(lst1, lst2):\n    \"\"\"\n    Given 2 lists, create a new list that has the elements that are in both lists without duplication.   \n    list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4]\n    \"\"\"\n    lst1.extend(lst2)\n    lst1.sort()\n    lst1.reverse()\n    lst2 = []\n    for i in range(len(lst1)-1):\n        if lst1[i] == lst1[i+1]:\n            continue\n        else:\n            lst2.append(lst1[i])\n    return lst2\n\n\ndef list_intersection2(lst1, lst2):\n    \"\"\"\n    Given 2 lists, create a new list that has the elements that are in both lists without duplication.   \n    list_intersection2([1, 2, 3, 4"}
{"task_id": "HumanEval/90", "completion": "    if not isinstance(lst, list) or len(lst)==0:\n        return None\n    if len(lst)==1:\n        return None\n\n    return min(lst[1:])\n\ndef is_leap_year(year):\n    \"\"\"\n    给你一个整数y，判断y是否是闰年\n    闰年定义：每四年为一个闰年，但这四年中有三年是闰年的， 闰年有366天， 普通年有365天\n    is_leap_year(2016) == False\n    is_leap_year(2004) == True\n    is_leap_year(2000) == True\n    \"\"\"\n    if not isinstance(year, int) or year < 0 or year > 9999:\n        return False\n    if year % 4 == 0 and year % 100!= 0:\n        return True\n    if year % 4 ==", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not isinstance(lst, list) or len(lst)==0:\n        return None\n    if len(lst)==1:\n        return None\n\n    return min(lst[1:])\n\ndef is_leap_year(year):\n    \"\"\"\n    给你一个整数y，判断y是否是闰年\n    闰年定义：每四年为一个闰年，但这四年中有三年是闰年的， 闰年有366天， 普通年有365天\n    is_leap_year(2016) == False\n    is_leap_year(2004) == True\n    is_leap_year(2000) == True\n    \"\"\"\n    if not isinstance(year, int) or year < 0 or year > 9999:\n        return False\n    if year % 4 == 0 and year % 100!= 0:\n        return True\n    if year % 4 =="}
{"task_id": "HumanEval/90", "completion": "    if not lst:\n        return None\n    max_val = max(lst)\n    lst.remove(max_val)\n    return min(lst)\n\n\ndef next_smallest2(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n    max_val = max(lst)\n    lst.remove(max_val)\n    return min(lst)\n\n\ndef next_smallest3(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n    max_val = max(lst)\n    lst.remove(max_val)\n    return min(lst)\n\n\ndef next_smallest2(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n    max_val = max(lst)\n    lst.remove(max_val)\n    return min(lst)\n\n\ndef next_smallest3(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返"}
{"task_id": "HumanEval/90", "completion": "    if len(lst) == 0:\n        return None\n    elif len(lst) == 1:\n        return None\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        elif lst[0] > lst[1]:\n            return lst[0]\n        else:\n            return lst[1]\n    else:\n        lst.sort()\n        return lst[1]\n```\n\n## 34. 实现一个函数 to_camel_case()，将字符串转换为驼峰命名法\n```python\ndef to_camel_case(s):\n    \"\"\"\n    实现一个函数 to_camel_case()，将字符串转换为驼峰命名法。\n    to_camel_case('the quick brown fox') == 'theQuickBrownFox'\n    to_camel_case('the_quick_brown_fox') == 'theQuickBrownFox'\n    to_camel_case('the", "allcode": "\ndef next_smallest(lst):\n    \"\"\"\n    给你一个整数列表，请编写函数next_smallest()，返回列表中第二小的元素。 如果没有这样的元素，则返回None。    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) == 0:\n        return None\n    elif len(lst) == 1:\n        return None\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return None\n        elif lst[0] > lst[1]:\n            return lst[0]\n        else:\n            return lst[1]\n    else:\n        lst.sort()\n        return lst[1]\n```\n\n## 34. 实现一个函数 to_camel_case()，将字符串转换为驼峰命名法\n```python\ndef to_camel_case(s):\n    \"\"\"\n    实现一个函数 to_camel_case()，将字符串转换为驼峰命名法。\n    to_camel_case('the quick brown fox') == 'theQuickBrownFox'\n    to_camel_case('the_quick_brown_fox') == 'theQuickBrownFox'\n    to_camel_case('the"}
{"task_id": "HumanEval/94", "completion": "    lst=[int(i) for i in lst]\n    res=0\n    for i in lst:\n        if i>0:\n            num=i\n            while num>1:\n                if num%2==0:\n                    num//=2\n                else:\n                    num//=3\n            res+=1\n    return res\n    #这一次我们要更快更简单一些，秒杀这道题目。不过这题并不是我们总体的秒杀题， 秒杀的意思是你一次就能输出结果.这里我们就是刷题，一次就能输出结果，就没有秒杀的概念了。\n    #我们还是要把最大的质数找出来， 然后输出它的值。 不过我们可以先不急着找最大的质数， 先�", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst=[int(i) for i in lst]\n    res=0\n    for i in lst:\n        if i>0:\n            num=i\n            while num>1:\n                if num%2==0:\n                    num//=2\n                else:\n                    num//=3\n            res+=1\n    return res\n    #这一次我们要更快更简单一些，秒杀这道题目。不过这题并不是我们总体的秒杀题， 秒杀的意思是你一次就能输出结果.这里我们就是刷题，一次就能输出结果，就没有秒杀的概念了。\n    #我们还是要把最大的质数找出来， 然后输出它的值。 不过我们可以先不急着找最大的质数， 先�"}
{"task_id": "HumanEval/94", "completion": "    # TODO 2017.1.23\n    # 因为这个题目没有讲解，所以没有作解\n    # 欢迎补充和完善这个题目下的解题思路\n    return lst\n    \n\ndef sum_of_digits(n):\n    \"\"\" 给定一个正整数n，只使用加法快速计算出这个数的各位数字之和。\n    例如： n = 12345，则计算结果为 15\n    例如： n = 1，则计算结果为 1\n    \"\"\"\n    # TODO 2017.1.19\n    # 因为这个题目没有讲解，所以没有作解\n    # 欢迎补充和完善这个题目下的解题思路\n    # 注意缺少返回值\n    # 注意", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    # TODO 2017.1.23\n    # 因为这个题目没有讲解，所以没有作解\n    # 欢迎补充和完善这个题目下的解题思路\n    return lst\n    \n\ndef sum_of_digits(n):\n    \"\"\" 给定一个正整数n，只使用加法快速计算出这个数的各位数字之和。\n    例如： n = 12345，则计算结果为 15\n    例如： n = 1，则计算结果为 1\n    \"\"\"\n    # TODO 2017.1.19\n    # 因为这个题目没有讲解，所以没有作解\n    # 欢迎补充和完善这个题目下的解题思路\n    # 注意缺少返回值\n    # 注意"}
{"task_id": "HumanEval/94", "completion": "    print(max(lst))\n    length = 0\n    for i in max(lst):\n        if i!= 0:\n            return length + 1\n        else:\n            length += 1\n\nprint(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]))\nprint(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]))\nprint(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]))\nprint(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    print(max(lst))\n    length = 0\n    for i in max(lst):\n        if i!= 0:\n            return length + 1\n        else:\n            length += 1\n\nprint(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]))\nprint(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]))\nprint(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]))\nprint(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,"}
{"task_id": "HumanEval/94", "completion": "    lst = filter(lambda x: x > 1, lst)\n    ans = 0\n    for i in lst:\n        a = 0\n        while (i % 2 == 0):\n            i = i >> 1\n            a += 1\n        if a > ans:\n            ans = a\n    return ans\n\ndef sdfkasfd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 2", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = filter(lambda x: x > 1, lst)\n    ans = 0\n    for i in lst:\n        a = 0\n        while (i % 2 == 0):\n            i = i >> 1\n            a += 1\n        if a > ans:\n            ans = a\n    return ans\n\ndef sdfkasfd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 2"}
{"task_id": "HumanEval/94", "completion": "    lst = list(filter(lambda x: x >= 0, lst))\n    result = 0\n    if not lst:\n        return result\n    elif not any(map(lambda x: x == 1, lst)):\n        return sum(map(lambda x: int(math.log10(x))+1, lst))\n    else:\n        for i, x in enumerate(lst):\n            if x == 1:\n                lst[i] = math.log10(lst[i+1])+1\n        return sum(lst)\n\ndef skjls(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    lst = list(filter(lambda x: x >= 0, lst))\n    result = 0\n    if not lst:\n        return result\n    elif not any(map(lambda x: x == 1, lst)):\n        return sum(map(lambda x: int(math.log10(x))+1, lst))\n    else:\n        for i, x in enumerate(lst):\n            if x == 1:\n                lst[i] = math.log10(lst[i+1])+1\n        return sum(lst)\n\ndef skjls(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst"}
{"task_id": "HumanEval/94", "completion": "    # 质数的定义： 在同一个数范围内，小于这个数的整数最大公因子必须为1\n    # 我们可以通过循环来查看所有元素的是否能被其他元素整除。\n    # 如果可以，则不是质数。\n    # 如果不可以，则是质数。\n    # 我们计算最大元素，并把它去掉\n    maxi = max(lst)\n    lst.remove(maxi)\n    # 我们计算最小元素，并把它去掉\n    mini = min(lst)\n    lst.remove(mini)\n\n    # 我们用一个列表存放所有质数\n    prime_lst = []\n    for num in lst:\n        flag = 0\n        for t in lst:\n            if t <= num:\n               ", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    # 质数的定义： 在同一个数范围内，小于这个数的整数最大公因子必须为1\n    # 我们可以通过循环来查看所有元素的是否能被其他元素整除。\n    # 如果可以，则不是质数。\n    # 如果不可以，则是质数。\n    # 我们计算最大元素，并把它去掉\n    maxi = max(lst)\n    lst.remove(maxi)\n    # 我们计算最小元素，并把它去掉\n    mini = min(lst)\n    lst.remove(mini)\n\n    # 我们用一个列表存放所有质数\n    prime_lst = []\n    for num in lst:\n        flag = 0\n        for t in lst:\n            if t <= num:\n               "}
{"task_id": "HumanEval/94", "completion": "    # 首先确保每个数都是自然数\n    if not all(isinstance(x,int) for x in lst):\n        return \"不能包含非自然数,请重新输入\"\n    if not all(x>0 for x in lst):\n        return \"不能包含负数,请重新输入\"\n\n    # 确保lst内没有重复数\n    if len(lst) < len(set(lst)):\n        return \"不能包含重复数,请重新输入\"\n    \n    # 确保每个数都是质数\n    if lst.count(1) < len(lst):\n        return \"不能包含非质数,请重新输入\"\n\n    # 确保lst内没有小于1000的数\n    for i in lst:\n        if i<1000:\n            return \"不能包含小于1000的数,请重新输入\"\n    # 确", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    # 首先确保每个数都是自然数\n    if not all(isinstance(x,int) for x in lst):\n        return \"不能包含非自然数,请重新输入\"\n    if not all(x>0 for x in lst):\n        return \"不能包含负数,请重新输入\"\n\n    # 确保lst内没有重复数\n    if len(lst) < len(set(lst)):\n        return \"不能包含重复数,请重新输入\"\n    \n    # 确保每个数都是质数\n    if lst.count(1) < len(lst):\n        return \"不能包含非质数,请重新输入\"\n\n    # 确保lst内没有小于1000的数\n    for i in lst:\n        if i<1000:\n            return \"不能包含小于1000的数,请重新输入\"\n    # 确"}
{"task_id": "HumanEval/94", "completion": "    \n    res = []\n    for i in lst:\n        flag = True\n        if i==0:\n            res.append(0)\n            continue\n        elif i==1:\n            res.append(1)\n            continue\n        if i<2:\n            res.append(0)\n            continue\n        for j in range(2,i):\n            if i%j==0:\n                flag = False\n                break\n        if flag:\n            res.append(i)\n    lens = []\n    for i in res:\n        lens.append(len(str(i)))\n    return sum(lens)\n\n\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    \n    res = []\n    for i in lst:\n        flag = True\n        if i==0:\n            res.append(0)\n            continue\n        elif i==1:\n            res.append(1)\n            continue\n        if i<2:\n            res.append(0)\n            continue\n        for j in range(2,i):\n            if i%j==0:\n                flag = False\n                break\n        if flag:\n            res.append(i)\n    lens = []\n    for i in res:\n        lens.append(len(str(i)))\n    return sum(lens)\n\n\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,"}
{"task_id": "HumanEval/94", "completion": "    global primes\n    primes = []\n    def findPrimes(n):\n        \"\"\"质数筛法 在函数里定义一个global变量primes， 然后将primes作为一个参数传入， 在返回函数里修改primes\"\"\"\n        for i in range(2,n):\n            if isPrime(i) == True:\n                primes.append(i)\n    \n    # 判断是否是素数\n    def isPrime(num):\n        n = int(num)\n        if n < 2:\n            return False\n        for i in primes:\n            if n % i == 0:\n                return False\n        else:\n            return True\n        \n    lst = list(set(lst))\n    findPrimes(max(lst))\n    \n    ln = []\n    for i in lst:\n        prime = primes[i]\n        num = len(str(prime))\n        ln.append(num)\n    return sum(ln)\n```\n\n> **参", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    global primes\n    primes = []\n    def findPrimes(n):\n        \"\"\"质数筛法 在函数里定义一个global变量primes， 然后将primes作为一个参数传入， 在返回函数里修改primes\"\"\"\n        for i in range(2,n):\n            if isPrime(i) == True:\n                primes.append(i)\n    \n    # 判断是否是素数\n    def isPrime(num):\n        n = int(num)\n        if n < 2:\n            return False\n        for i in primes:\n            if n % i == 0:\n                return False\n        else:\n            return True\n        \n    lst = list(set(lst))\n    findPrimes(max(lst))\n    \n    ln = []\n    for i in lst:\n        prime = primes[i]\n        num = len(str(prime))\n        ln.append(num)\n    return sum(ln)\n```\n\n> **参"}
{"task_id": "HumanEval/94", "completion": "    n = len(lst)\n    d = sum( [ 0 if x == 0 else len( factor(x) ) for x in lst ] )\n    return d\ndef skjkasdkd_2(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和  \n    如果某个值是它自己的素因子，必须至少有两位\n    要求返回位数之和\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]", "allcode": "\n\ndef skjkasdkd(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和。\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] 输出应为 25\n    对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]输出应为 13\n    对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] 输出应为11\n    对于 lst = [0,81,12,3,1,21] 输出应为 3\n    对于 lst = [0,8,1,2,1,7] 输出应为 7\n    \"\"\"\n    n = len(lst)\n    d = sum( [ 0 if x == 0 else len( factor(x) ) for x in lst ] )\n    return d\ndef skjkasdkd_2(lst):\n    \"\"\"给您一个整数列表，  您需要找出最大的质数值并返回其位数之和  \n    如果某个值是它自己的素因子，必须至少有两位\n    要求返回位数之和\n    示例如下：   对于lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] 输出应为 10\n    对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]"}
{"task_id": "HumanEval/103", "completion": "    if n>m:return -1\n    sum = 0\n    for i in range(n,m+1):\n        sum += i\n    return int(sum/(m-n+1))\n\n# 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 您可以假定该字符串只包含小写字母。 例如，在\"abaccdeff\"中，第一个不重复的字符是\"b\"，所以返回1。  \ndef first_not_dup(string):\n    count = {}\n    for i in range(len(string)):\n        if string[i] in count:\n            count[string[i]] = -1\n        else:\n            count[string[i]] = i\n    for key, val in count.items():\n        if val>=0:\n            return val\n    return -1\n\n# 给定一个字符串，", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n>m:return -1\n    sum = 0\n    for i in range(n,m+1):\n        sum += i\n    return int(sum/(m-n+1))\n\n# 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 您可以假定该字符串只包含小写字母。 例如，在\"abaccdeff\"中，第一个不重复的字符是\"b\"，所以返回1。  \ndef first_not_dup(string):\n    count = {}\n    for i in range(len(string)):\n        if string[i] in count:\n            count[string[i]] = -1\n        else:\n            count[string[i]] = i\n    for key, val in count.items():\n        if val>=0:\n            return val\n    return -1\n\n# 给定一个字符串，"}
{"task_id": "HumanEval/103", "completion": "    if n>m:\n        return -1\n    else:\n        r = []\n        for i in range(n, m+1):\n            r.append(int(i))\n        return str(round(sum(r) / len(r)))\n\ndef convert_ip(ip_address):\n    \"\"\"给你一个IP地址，您的任务是在不使用任何内置解析IP地址的情况下将其转换为十进制表示。 注意：您可以使用string.split(“.”)分割字符串。   Example:\n    convert_ip(\"127.0.0.1\") => 2130706433\n    convert_ip(\"8.8.8.8\") => 2130706434\n    convert_ip(\"8.8.8.8.8\") => -1\n    convert_ip(\"192.168.1.1\") => 3232235777\n    \"\"\"\n", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n>m:\n        return -1\n    else:\n        r = []\n        for i in range(n, m+1):\n            r.append(int(i))\n        return str(round(sum(r) / len(r)))\n\ndef convert_ip(ip_address):\n    \"\"\"给你一个IP地址，您的任务是在不使用任何内置解析IP地址的情况下将其转换为十进制表示。 注意：您可以使用string.split(“.”)分割字符串。   Example:\n    convert_ip(\"127.0.0.1\") => 2130706433\n    convert_ip(\"8.8.8.8\") => 2130706434\n    convert_ip(\"8.8.8.8.8\") => -1\n    convert_ip(\"192.168.1.1\") => 3232235777\n    \"\"\"\n"}
{"task_id": "HumanEval/103", "completion": "    if n>m:\n        return -1\n    a=[]\n    for i in range(n,m+1):\n        a.append(i)\n    b=sum(a)\n    return str(bin(b//", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n>m:\n        return -1\n    a=[]\n    for i in range(n,m+1):\n        a.append(i)\n    b=sum(a)\n    return str(bin(b//"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    avg = round((m + n) / 2)\n    return bin(avg)\n\n\ndef pangram(s):\n    \"\"\"检查参数字符串s是否是谢蒙的。 如果是，返回True，否则返回False。\n    Example:\n    pangram(\"The quick brown fox jumped over the lazy dog.\"\n    => True)\n    \"\"\"\n    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u',\n                'v', 'w', 'x', 'y', 'z']\n    count = 0\n    for i in s.lower():\n        if i in alphabet:\n            count += 1\n        if count == 26:\n            return True\n    return False\n\n\ndef palindrome(s):\n    \"\"\"�", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    avg = round((m + n) / 2)\n    return bin(avg)\n\n\ndef pangram(s):\n    \"\"\"检查参数字符串s是否是谢蒙的。 如果是，返回True，否则返回False。\n    Example:\n    pangram(\"The quick brown fox jumped over the lazy dog.\"\n    => True)\n    \"\"\"\n    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u',\n                'v', 'w', 'x', 'y', 'z']\n    count = 0\n    for i in s.lower():\n        if i in alphabet:\n            count += 1\n        if count == 26:\n            return True\n    return False\n\n\ndef palindrome(s):\n    \"\"\"�"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    return bin(round(sum(range(n,m+1))/(m-n+1)))[2:]\n```\n\n### 問題214\n\n```\n# 問題214: 寫一個函數，將字元串(字符串)中的字元(字符)循環移位，也就是說，第一個字元置於最後，第二個字元置於第一，依此類推。 這樣的字元串被稱為旋轉字元串。 例如，字符串\"abc\"旋轉一次(向右移位一位)后为\"bca\"。 類似地，\"abcdefg\"旋轉四次后为\"efgabcd\"。 一般地，", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    return bin(round(sum(range(n,m+1))/(m-n+1)))[2:]\n```\n\n### 問題214\n\n```\n# 問題214: 寫一個函數，將字元串(字符串)中的字元(字符)循環移位，也就是說，第一個字元置於最後，第二個字元置於第一，依此類推。 這樣的字元串被稱為旋轉字元串。 例如，字符串\"abc\"旋轉一次(向右移位一位)后为\"bca\"。 類似地，\"abcdefg\"旋轉四次后为\"efgabcd\"。 一般地，"}
{"task_id": "HumanEval/103", "completion": "    if m < n:\n        return -1\n    avg = float(n + m) / 2\n    if avg % 1!= 0:\n        return bin(int(avg))\n    else:\n        return bin(int(avg))\n\n\ndef average_times(m, n):\n    \"\"\"给定两个正整数m和n，返回您必须执行以计算从1到m的平均值的次数。\n    Example:\n    average_times(10, 20) // should return 1\n    average_times(7, 12) // should return 2\n    average_times(20, 33) // should return 4\n    \"\"\"\n    return (m+n)/2\n\n\ndef average_number_bits(n, m):\n    \"\"\"计算m和n之间平均值的字符串长度。\n    Example:\n    average_number_bits(20, 33) // should return 4\n    average_number_bits(", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if m < n:\n        return -1\n    avg = float(n + m) / 2\n    if avg % 1!= 0:\n        return bin(int(avg))\n    else:\n        return bin(int(avg))\n\n\ndef average_times(m, n):\n    \"\"\"给定两个正整数m和n，返回您必须执行以计算从1到m的平均值的次数。\n    Example:\n    average_times(10, 20) // should return 1\n    average_times(7, 12) // should return 2\n    average_times(20, 33) // should return 4\n    \"\"\"\n    return (m+n)/2\n\n\ndef average_number_bits(n, m):\n    \"\"\"计算m和n之间平均值的字符串长度。\n    Example:\n    average_number_bits(20, 33) // should return 4\n    average_number_bits("}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    else:\n        return '{:0b}'.format(np.round(np.mean([n, m])))\n\n\ndef reverse_string(s):\n    \"\"\"给定一个字符串，请你返回其字符逆序后的字符串。   Example:\n    reverse_string('hello') => 'olleh'\n    reverse_string('Greetings from Earth') => 'htraE morf sgniteerG'\n    reverse_string('ABC') => 'CBA'\n    \"\"\"\n    return s[::-1]\n\n\ndef reverse_name(first, last):\n    \"\"\"给定两个名字first和last，请你返回last +'' + first。   Example:\n    reverse_name('John', 'Doe') => 'Doe John'\n    reverse_name('first', 'last') => 'last first'\n    reverse_name('PyCharm', 'IDE') => 'IDE PyCharm'\n    \"\"\"\n    return last+' '+first\n\n\ndef round_num(", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    else:\n        return '{:0b}'.format(np.round(np.mean([n, m])))\n\n\ndef reverse_string(s):\n    \"\"\"给定一个字符串，请你返回其字符逆序后的字符串。   Example:\n    reverse_string('hello') => 'olleh'\n    reverse_string('Greetings from Earth') => 'htraE morf sgniteerG'\n    reverse_string('ABC') => 'CBA'\n    \"\"\"\n    return s[::-1]\n\n\ndef reverse_name(first, last):\n    \"\"\"给定两个名字first和last，请你返回last +'' + first。   Example:\n    reverse_name('John', 'Doe') => 'Doe John'\n    reverse_name('first', 'last') => 'last first'\n    reverse_name('PyCharm', 'IDE') => 'IDE PyCharm'\n    \"\"\"\n    return last+' '+first\n\n\ndef round_num("}
{"task_id": "HumanEval/103", "completion": "    if m < n:\n        return -1\n    return bin(round(sum(range(n,m+1))/(m-n+1)))[2:]\n\n#8 写一个计算中学生的均值的函数，并返回字符串的形式。 如果参数数量不为2，则应返回-1。 这个函数应该传入两个参数，并返回一个字符串。 如果一个或两个参数不是有效数字，那么也应该返回-1。\ndef avg_of_two(n, m):\n    \"\"\"Write a function that takes two parameters and returns a string. If the parameters aren't two, return -1. This function should take two parameters and return a string. If one or two parameters are not numerical, also return -1.\n    avg_of_two(2,5) => \"2.0\"\n    avg_of_two(3,-10) => -1\n    \"\"\"\n    if not isinstance(n, (int, float))", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if m < n:\n        return -1\n    return bin(round(sum(range(n,m+1))/(m-n+1)))[2:]\n\n#8 写一个计算中学生的均值的函数，并返回字符串的形式。 如果参数数量不为2，则应返回-1。 这个函数应该传入两个参数，并返回一个字符串。 如果一个或两个参数不是有效数字，那么也应该返回-1。\ndef avg_of_two(n, m):\n    \"\"\"Write a function that takes two parameters and returns a string. If the parameters aren't two, return -1. This function should take two parameters and return a string. If one or two parameters are not numerical, also return -1.\n    avg_of_two(2,5) => \"2.0\"\n    avg_of_two(3,-10) => -1\n    \"\"\"\n    if not isinstance(n, (int, float))"}
{"task_id": "HumanEval/103", "completion": "    if n > m:\n        return -1\n    sum_n = 0\n    for i in range(n, m + 1):\n        sum_n += i\n    avg_n = sum_n / (m - n + 1)\n    return oct(round(avg_n))\n\n\ndef string_to_array(str):\n    \"\"\"将字符串转换为数组。\n    \"\"\"\n    a = list(str)\n    a.append(0)  # 数组末尾补0\n    return a\n\n\ndef string_split(str, sep):\n    \"\"\"将字符串分割为字符串。当分隔符是0时，它将返回整个字符串。\n    \"\"\"\n    a = list(str)\n    b = []\n    while a:\n        b.append(a.pop(0))\n        if a[0] == sep:\n            a.pop(0)\n    return b\n\n\ndef to_binary(n):\n    \"\"\"将输入字", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    sum_n = 0\n    for i in range(n, m + 1):\n        sum_n += i\n    avg_n = sum_n / (m - n + 1)\n    return oct(round(avg_n))\n\n\ndef string_to_array(str):\n    \"\"\"将字符串转换为数组。\n    \"\"\"\n    a = list(str)\n    a.append(0)  # 数组末尾补0\n    return a\n\n\ndef string_split(str, sep):\n    \"\"\"将字符串分割为字符串。当分隔符是0时，它将返回整个字符串。\n    \"\"\"\n    a = list(str)\n    b = []\n    while a:\n        b.append(a.pop(0))\n        if a[0] == sep:\n            a.pop(0)\n    return b\n\n\ndef to_binary(n):\n    \"\"\"将输入字"}
{"task_id": "HumanEval/103", "completion": "    result_list = []\n    for i in range(n, m + 1):\n        result_list.append(i)\n    result = sum(result_list)\n    avg = result / len(result_list)\n    if avg % 1!= 0.5:\n        return str(int(avg))\n    return str(int(avg - 0.5))\n\n\ndef checkio(n, m):\n    return rounded_avg(n, m)\n\n\nif __name__ == '__main__':\n    print(\"Example:\")\n    print(checkio(1, 5))\n\n    #These \"asserts\" using only for self-checking and not necessary for\n    #auto-testing\n    assert checkio(1, 5) == \"0b11\", \"1.1\"\n    assert checkio(7, 5) == -1, \"1.2\"\n    assert checkio(10, 20) == \"0b1111\", \"1.3\"", "allcode": "\ndef rounded_avg(n, m):\n    \"\"\"给您两个正整数n和m，您的任务是计算从n到m(包括n和m)的整数的平均值。 将答案四舍五入为最接近的整数，并将其转换为二进制。 如果n大于m，则返回-1。   Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    result_list = []\n    for i in range(n, m + 1):\n        result_list.append(i)\n    result = sum(result_list)\n    avg = result / len(result_list)\n    if avg % 1!= 0.5:\n        return str(int(avg))\n    return str(int(avg - 0.5))\n\n\ndef checkio(n, m):\n    return rounded_avg(n, m)\n\n\nif __name__ == '__main__':\n    print(\"Example:\")\n    print(checkio(1, 5))\n\n    #These \"asserts\" using only for self-checking and not necessary for\n    #auto-testing\n    assert checkio(1, 5) == \"0b11\", \"1.1\"\n    assert checkio(7, 5) == -1, \"1.2\"\n    assert checkio(10, 20) == \"0b1111\", \"1.3\""}
{"task_id": "HumanEval/109", "completion": "    #首先对数组进行排序\n    arr=sorted(arr)\n    #如果数组长度大于1，且最后两个数小于等于第一个数，且第一个数不等于第二个数，则可能可以调整\n    if len(arr)>1 and arr[-1]<=arr[0] and arr[0]!=arr[1]:\n        return True\n    #如果数组长度大于1，且最后两个数小于等于第一个数，且第一个数等于第二个数，则肯定是可以调整的\n    if len(arr)>1 and arr[-1]<=arr[0] and arr[0]==arr[1]:\n        return True\n    #如果数组长度大于1，且最后两个数大于第一个数，且第一个数不等于最后一个数，则可能可以调整\n    if len(arr)>", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    #首先对数组进行排序\n    arr=sorted(arr)\n    #如果数组长度大于1，且最后两个数小于等于第一个数，且第一个数不等于第二个数，则可能可以调整\n    if len(arr)>1 and arr[-1]<=arr[0] and arr[0]!=arr[1]:\n        return True\n    #如果数组长度大于1，且最后两个数小于等于第一个数，且第一个数等于第二个数，则肯定是可以调整的\n    if len(arr)>1 and arr[-1]<=arr[0] and arr[0]==arr[1]:\n        return True\n    #如果数组长度大于1，且最后两个数大于第一个数，且第一个数不等于最后一个数，则可能可以调整\n    if len(arr)>"}
{"task_id": "HumanEval/109", "completion": "    arr.sort()\n    return True if arr == sorted(arr) else False\n```\n\n#### 2.6 max_min_distance\n\n> 给定一个由非负整数组成的数组。数组中的每个值代表一个人的身高。数组中的所有身高都保证不重复。找到身高最矮的人和身高最大的人之间的距离。\n\n```pyhton\nimport math\ndef max_min_distance(arr):\n    if len(arr) == 0:\n        return 0\n    arr.sort()\n    min_value = arr[0]\n    max_value = arr[-1]\n    return max_value - min_value\n```\n\n#### 2.7 remove_duplicates\n\n> 给定一个由正整数构成的数组arr，重复项包含在该数组中。你的任务是从数组中删除重复项，并返回数组的", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    arr.sort()\n    return True if arr == sorted(arr) else False\n```\n\n#### 2.6 max_min_distance\n\n> 给定一个由非负整数组成的数组。数组中的每个值代表一个人的身高。数组中的所有身高都保证不重复。找到身高最矮的人和身高最大的人之间的距离。\n\n```pyhton\nimport math\ndef max_min_distance(arr):\n    if len(arr) == 0:\n        return 0\n    arr.sort()\n    min_value = arr[0]\n    max_value = arr[-1]\n    return max_value - min_value\n```\n\n#### 2.7 remove_duplicates\n\n> 给定一个由正整数构成的数组arr，重复项包含在该数组中。你的任务是从数组中删除重复项，并返回数组的"}
{"task_id": "HumanEval/109", "completion": "    N=len(arr)\n    #首先找到最小值\n    left_min_index=0\n    for i in range(1,N):\n        if arr[i] < arr[left_min_index]:\n            left_min_index=i\n    #再找出最小值右边最大值\n    right_max_index=0\n    for i in range(left_min_index+1,N):\n        if arr[i]>arr[left_min_index]:\n            right_max_index=i\n    while right_max_index!=left_min_index:\n        if right_max_index<left_min_index:\n            right_max_index+=1\n        arr[right_max_index],arr[left_min_index]=arr[left_min_index],arr[right_max_index]\n        left_min_index+=1\n        right_max_index+=1\n    return arr\n#用一个字典记忆化的思路\ndef move_one_ball(arr):\n    if not arr", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    N=len(arr)\n    #首先找到最小值\n    left_min_index=0\n    for i in range(1,N):\n        if arr[i] < arr[left_min_index]:\n            left_min_index=i\n    #再找出最小值右边最大值\n    right_max_index=0\n    for i in range(left_min_index+1,N):\n        if arr[i]>arr[left_min_index]:\n            right_max_index=i\n    while right_max_index!=left_min_index:\n        if right_max_index<left_min_index:\n            right_max_index+=1\n        arr[right_max_index],arr[left_min_index]=arr[left_min_index],arr[right_max_index]\n        left_min_index+=1\n        right_max_index+=1\n    return arr\n#用一个字典记忆化的思路\ndef move_one_ball(arr):\n    if not arr"}
{"task_id": "HumanEval/109", "completion": "    if len(arr)==0:\n        return True\n    arr.sort()\n    for i in range(0,len(arr)-1):\n        if arr[i]>arr[i+1]:\n            return False\n    return True\n\n\n# 3. 找出最小的正数  \ndef find_smallest_positive_number(arr):\n    \"\"\"    我们有一个整数数组，其中的某些元素可能是小于0的，而另一些元素可能是大于0的。为了使这些元素更易于理解，我们将这个数组很容易地转换成一个新的数组。    我们将所有小于0的元素拼接到数组的开头，所有大于0的元素拼接到数组的末尾。结果数组将包含至少一个元素，并且它将被命名为小于0的正", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if len(arr)==0:\n        return True\n    arr.sort()\n    for i in range(0,len(arr)-1):\n        if arr[i]>arr[i+1]:\n            return False\n    return True\n\n\n# 3. 找出最小的正数  \ndef find_smallest_positive_number(arr):\n    \"\"\"    我们有一个整数数组，其中的某些元素可能是小于0的，而另一些元素可能是大于0的。为了使这些元素更易于理解，我们将这个数组很容易地转换成一个新的数组。    我们将所有小于0的元素拼接到数组的开头，所有大于0的元素拼接到数组的末尾。结果数组将包含至少一个元素，并且它将被命名为小于0的正"}
{"task_id": "HumanEval/109", "completion": "    arr.sort()\n    return arr == list_of_n_elements_with_integer_values_from(1, len(arr))\nif __name__ == \"__main__\":\n    #print(move_one_ball([1,2,3]))\n    #print(move_one_ball([2,1,3]))\n    #print(move_one_ball([3,1,2]))\n    #print(move_one_ball([1,2,3,1]))\n    #print(move_one_ball([3,4,1,2]))\n    #print(move_one_ball([3,3,2,1]))\n    #print(move_one_ball([1,2,3,4]))\n    #print(move_one_ball([]))\n    #print(move_one_ball([2,1,3]))\n    #print(move_one_ball([1,2,3,4]))\n    from timeit import timeit\n    # print(timeit('move_one_ball([1,2,3])', number=10000,", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    arr.sort()\n    return arr == list_of_n_elements_with_integer_values_from(1, len(arr))\nif __name__ == \"__main__\":\n    #print(move_one_ball([1,2,3]))\n    #print(move_one_ball([2,1,3]))\n    #print(move_one_ball([3,1,2]))\n    #print(move_one_ball([1,2,3,1]))\n    #print(move_one_ball([3,4,1,2]))\n    #print(move_one_ball([3,3,2,1]))\n    #print(move_one_ball([1,2,3,4]))\n    #print(move_one_ball([]))\n    #print(move_one_ball([2,1,3]))\n    #print(move_one_ball([1,2,3,4]))\n    from timeit import timeit\n    # print(timeit('move_one_ball([1,2,3])', number=10000,"}
{"task_id": "HumanEval/109", "completion": "    \n    # 解法一: 排序 + 辅助函数\n    if len(arr)<=1:\n        return True\n    arr.sort(reverse=True)\n    pre = arr[0]\n    for i in arr[1:]:\n        if i<pre:\n            return False\n        pre = i\n        \n    return True\n\ndef move_one_ball2(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    \n    # 解法一: 排序 + 辅助函数\n    if len(arr)<=1:\n        return True\n    arr.sort(reverse=True)\n    pre = arr[0]\n    for i in arr[1:]:\n        if i<pre:\n            return False\n        pre = i\n        \n    return True\n\ndef move_one_ball2(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个"}
{"task_id": "HumanEval/109", "completion": "    if not arr:\n        return True\n    if len(arr) == 1:\n        return True\n    if arr[-1] > arr[-2]:\n        return False\n    else:\n        return True\n```\n[更多思路](https://leetcode.com/problems/jump-game-ii/discuss/169063/Python-3-00ms-O(n)-solution-explained)\n```python\ndef is_valid_jump(jump_list):\n    for i in range(2, len(jump_list)):\n        if jump_list[i] > jump_list[i - 1] - 1:\n            return False\n    return True\n\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    if not arr:\n        return True\n    if len(arr) == 1:\n        return True\n    if arr[-1] > arr[-2]:\n        return False\n    else:\n        return True\n```\n[更多思路](https://leetcode.com/problems/jump-game-ii/discuss/169063/Python-3-00ms-O(n)-solution-explained)\n```python\ndef is_valid_jump(jump_list):\n    for i in range(2, len(jump_list)):\n        if jump_list[i] > jump_list[i - 1] - 1:\n            return False\n    return True\n\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组"}
{"task_id": "HumanEval/109", "completion": "    arr = [1, 2]\n    arr2 = [2, 1]\n    if len(arr) == 0:\n        return True\n    if arr == arr2:\n        return True\n    for i in range(0, len(arr)):\n        print(i)\n        if arr[i] > arr[i - 1]:\n            j = arr.index(arr[i])\n            arr = arr[:i] + arr[i + 1:] + arr[i : i + 1]\n            # print(arr)\n            if j > 0:\n                c = arr[j - 1]\n                arr.remove(arr[j - 1])\n                arr.insert(0, c)\n            return True\n        else:\n            return False\n\n\n# 逆序对的几种算法\n\n# 归并排序中，逆序对的操作为O(nlogn)\n\n# 快速排序中，逆序对的操作为O(nlogn)\n", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    arr = [1, 2]\n    arr2 = [2, 1]\n    if len(arr) == 0:\n        return True\n    if arr == arr2:\n        return True\n    for i in range(0, len(arr)):\n        print(i)\n        if arr[i] > arr[i - 1]:\n            j = arr.index(arr[i])\n            arr = arr[:i] + arr[i + 1:] + arr[i : i + 1]\n            # print(arr)\n            if j > 0:\n                c = arr[j - 1]\n                arr.remove(arr[j - 1])\n                arr.insert(0, c)\n            return True\n        else:\n            return False\n\n\n# 逆序对的几种算法\n\n# 归并排序中，逆序对的操作为O(nlogn)\n\n# 快速排序中，逆序对的操作为O(nlogn)\n"}
{"task_id": "HumanEval/109", "completion": "    array = [x for x in arr]\n    n = len(array)\n    if n <= 1:\n        return True\n    if n == 2:\n        return array[0] <= array[1]\n    if n == 3:\n        return array[0] <= array[1] and array[1] <= array[2]\n    \n    first_element = array[0]\n    array[0] = array[1]\n    array[1] = first_element\n    \n    for i in range(n - 2):\n        if n > 3:\n            if array[i + 1] > array[i + 2]:\n                array[i + 2], array[i + 1] = array[i + 1], array[i + 2]\n                n = n - 1\n                i = i - 1\n                first_element = array[0]\n                array[0] = array[1]\n                array[1] = first_element\n    return array == sorted(array)\n\ndef move_one_ball_2(arr):\n    \"\"\"", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    array = [x for x in arr]\n    n = len(array)\n    if n <= 1:\n        return True\n    if n == 2:\n        return array[0] <= array[1]\n    if n == 3:\n        return array[0] <= array[1] and array[1] <= array[2]\n    \n    first_element = array[0]\n    array[0] = array[1]\n    array[1] = first_element\n    \n    for i in range(n - 2):\n        if n > 3:\n            if array[i + 1] > array[i + 2]:\n                array[i + 2], array[i + 1] = array[i + 1], array[i + 2]\n                n = n - 1\n                i = i - 1\n                first_element = array[0]\n                array[0] = array[1]\n                array[1] = first_element\n    return array == sorted(array)\n\ndef move_one_ball_2(arr):\n    \"\"\""}
{"task_id": "HumanEval/109", "completion": "    return True\n\ndef move_all_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以对给定的数组执行以下操作以按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True", "allcode": "\ndef move_one_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以通过对给定的数组执行以下操作来按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True。    注意：给定的列表保证具有唯一的元素。\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释: 通过执行两次正确的右移位操作，可以实现非降序排列。   move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:无论如何对给定的数组进行右移位操作，都无法实现非降序排列。          \n    \"\"\"\n    return True\n\ndef move_all_ball(arr):\n    \"\"\"我们有一个由N个整数arr[1]，arr[2]..，arr[N]组成的数组‘arr’。数组中的数字将被随机排序。您的任务是确定是否可以对给定的数组执行以下操作以按非降序对数组进行排序：允许您执行任意次数的右移位操作。    一次右移操作意味着将数组的所有元素在正确方向上移动一个位置。数组的最后一个元素将移动到数组中的起始位置，即第0个索引。如果可以通过执行上述操作获得非降序的数组，则返回True，否则返回False，    如果给定数组为空，则返回True"}
{"task_id": "HumanEval/114", "completion": "    min_sum, sum = sys.maxsize, 0\n    for idx, num in enumerate(nums):\n        sum += num\n        min_sum = min(min_sum, sum)\n        if sum < 0:\n            sum = 0\n    return min_sum\n    \n    \n    \n    \n \nif __name__ == \"__main__", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    min_sum, sum = sys.maxsize, 0\n    for idx, num in enumerate(nums):\n        sum += num\n        min_sum = min(min_sum, sum)\n        if sum < 0:\n            sum = 0\n    return min_sum\n    \n    \n    \n    \n \nif __name__ == \"__main__"}
{"task_id": "HumanEval/114", "completion": "    n = len(nums)\n    if n == 0: return None\n    curr = 0\n    sum = 0\n    for i in range(n):\n        curr += nums[i]\n        if curr < 0:\n            sum = 0\n            curr = 0\n        if sum > curr:\n            sum = curr\n        else:\n            sum = sum + curr\n    return sum\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个整数数组和一个整数s，找到该数组中满足其和>=s的最短子数组的长度，如果不存在则返回0。\n    示例如下：\n    minSubArrayLen(7, [2, 3, 4, 1, 2, 4]) == 3\n    minSubArrayLen(11, [2, 3, 1, 2, 4]) == 3\n    minSubArrayLen(11, [1, 2, 3]) ==", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    n = len(nums)\n    if n == 0: return None\n    curr = 0\n    sum = 0\n    for i in range(n):\n        curr += nums[i]\n        if curr < 0:\n            sum = 0\n            curr = 0\n        if sum > curr:\n            sum = curr\n        else:\n            sum = sum + curr\n    return sum\n\n\ndef minSubArrayLen(s, nums):\n    \"\"\"\n    给定一个整数数组和一个整数s，找到该数组中满足其和>=s的最短子数组的长度，如果不存在则返回0。\n    示例如下：\n    minSubArrayLen(7, [2, 3, 4, 1, 2, 4]) == 3\n    minSubArrayLen(11, [2, 3, 1, 2, 4]) == 3\n    minSubArrayLen(11, [1, 2, 3]) =="}
{"task_id": "HumanEval/114", "completion": "    subSum = []\n    length = len(nums)\n    for i in range(length):\n        if i == 0:\n            subSum.append(nums[i])\n        else:\n            subSum.append(nums[i] + subSum[i-1])\n    return min(subSum)\n\n#------------------------------------------------------------------------------\n# 1.2 子数组最大连续和\n#------------------------------------------------------------------------------\ndef maxSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，返回最大连续和。示例如下：\n    maxSubArraySum([2, 3, 4, 1, 2, 4]) == 10\n    maxSubArraySum([-1, -2, -3]) == -1\n    \"\"\"\n    sum = 0\n    subSum = 0\n    length = len(nums)\n    for i in range(length):\n        if sum < 0:\n            sum = 0\n        if subSum < 0:\n           ", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    subSum = []\n    length = len(nums)\n    for i in range(length):\n        if i == 0:\n            subSum.append(nums[i])\n        else:\n            subSum.append(nums[i] + subSum[i-1])\n    return min(subSum)\n\n#------------------------------------------------------------------------------\n# 1.2 子数组最大连续和\n#------------------------------------------------------------------------------\ndef maxSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，返回最大连续和。示例如下：\n    maxSubArraySum([2, 3, 4, 1, 2, 4]) == 10\n    maxSubArraySum([-1, -2, -3]) == -1\n    \"\"\"\n    sum = 0\n    subSum = 0\n    length = len(nums)\n    for i in range(length):\n        if sum < 0:\n            sum = 0\n        if subSum < 0:\n           "}
{"task_id": "HumanEval/114", "completion": "    pre = None\n    total = 0\n    for num in nums:\n        if pre is None:\n            pre = 0\n        else:\n            total += num\n            pre -= num\n            if total >= pre:\n                return pre + num\n    return total\n\ndef minSubArraySumBetter(nums):\n    \"\"\"\n    核心思想是动态规划，定义dp值为区间[i, j]的最小和，那么有：\n    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + nums[i]\n    初始化：dp[j] = nums[j]\n    \"\"\"\n    nums_length = len(nums)\n    dp = [0] * nums_length\n    for i in range(nums_length):\n        dp[i] = nums[i]\n        for j in range(i + 1, nums_length):\n            dp[j] = min(dp[j], dp", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    pre = None\n    total = 0\n    for num in nums:\n        if pre is None:\n            pre = 0\n        else:\n            total += num\n            pre -= num\n            if total >= pre:\n                return pre + num\n    return total\n\ndef minSubArraySumBetter(nums):\n    \"\"\"\n    核心思想是动态规划，定义dp值为区间[i, j]的最小和，那么有：\n    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + nums[i]\n    初始化：dp[j] = nums[j]\n    \"\"\"\n    nums_length = len(nums)\n    dp = [0] * nums_length\n    for i in range(nums_length):\n        dp[i] = nums[i]\n        for j in range(i + 1, nums_length):\n            dp[j] = min(dp[j], dp"}
{"task_id": "HumanEval/114", "completion": "    \n    if not nums:\n        return 0\n\n    pre_sum, index = [0], 0\n    for i in range(len(nums)):\n        pre_sum.append(pre_sum[index] + nums[i])\n        index = 0 if pre_sum[-1] >= 0 else index + 1\n    \n    min_value = nums[0]\n    for i in range(len(nums)):\n        if min_value > nums[i]:\n            min_value = nums[i]\n        if min_value == nums[i]:\n            index = i\n            break\n\n    return min_value\n\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))\n    print(minSubArraySum([-1, -2, -3]))\n    print(minSubArraySum([1,2,3,4,5,6,7,8]))\n    print(minSubArraySum([2, 3, 4, -", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    \n    if not nums:\n        return 0\n\n    pre_sum, index = [0], 0\n    for i in range(len(nums)):\n        pre_sum.append(pre_sum[index] + nums[i])\n        index = 0 if pre_sum[-1] >= 0 else index + 1\n    \n    min_value = nums[0]\n    for i in range(len(nums)):\n        if min_value > nums[i]:\n            min_value = nums[i]\n        if min_value == nums[i]:\n            index = i\n            break\n\n    return min_value\n\n\n\nif __name__ == \"__main__\":\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))\n    print(minSubArraySum([-1, -2, -3]))\n    print(minSubArraySum([1,2,3,4,5,6,7,8]))\n    print(minSubArraySum([2, 3, 4, -"}
{"task_id": "HumanEval/114", "completion": "    s, l, r = 0, 0, 0\n    m = sys.maxsize\n    while r < len(nums):\n        # [l, r]\n        s += nums[r]\n        while s >= 0:\n            if r - l + 1 < m:\n                m = r - l + 1\n            s -= nums[l]\n            l += 1\n        r += 1\n    l = (m-1)\n    return s[l]\n\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    s, l = 0, 0\n    m = sys.maxsize\n    for r", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    s, l, r = 0, 0, 0\n    m = sys.maxsize\n    while r < len(nums):\n        # [l, r]\n        s += nums[r]\n        while s >= 0:\n            if r - l + 1 < m:\n                m = r - l + 1\n            s -= nums[l]\n            l += 1\n        r += 1\n    l = (m-1)\n    return s[l]\n\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    s, l = 0, 0\n    m = sys.maxsize\n    for r"}
{"task_id": "HumanEval/114", "completion": "    sum, start = 0, 0\n    min_sum = float('inf')\n    for end in range(len(nums)):\n        sum += nums[end]\n        while sum >= 0:\n            min_sum = min(min_sum, sum)\n            sum -= nums[start]\n            start += 1\n    return min_sum\n\ndef minSubArray(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出子数组的长度。\n    示例如下：\n    minSubArrayLen([2, 3, 4, 1, 2, 4]) == 2\n    minSubArrayLen([-1, -2, -3]) == 3\n    \"\"\"\n    total = 0\n    min_len = float('inf')\n    for i in range(len(nums)):\n        total += nums[i]\n        while total >= 0:\n            min_len = min(min_len", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    sum, start = 0, 0\n    min_sum = float('inf')\n    for end in range(len(nums)):\n        sum += nums[end]\n        while sum >= 0:\n            min_sum = min(min_sum, sum)\n            sum -= nums[start]\n            start += 1\n    return min_sum\n\ndef minSubArray(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出子数组的长度。\n    示例如下：\n    minSubArrayLen([2, 3, 4, 1, 2, 4]) == 2\n    minSubArrayLen([-1, -2, -3]) == 3\n    \"\"\"\n    total = 0\n    min_len = float('inf')\n    for i in range(len(nums)):\n        total += nums[i]\n        while total >= 0:\n            min_len = min(min_len"}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return 0\n    # 数组偏移量从0开始\n    offset = 0\n    sum = 0\n    result_sum = sys.maxsize\n    for i in range(len(nums)):\n        sum += nums[i]\n        # 如果是一个非空子数组，那么是从offset开始的\n        # 当sum小于0的时候，offset向右移动一位，当数组为空时，offset = i+1，sum = 0\n        while sum < 0:\n            sum -= nums[offset]\n            offset += 1\n            if offset == len(nums):\n                offset = i+1\n                sum = 0\n        result_sum = min(result_sum, sum)\n    return result_sum\n    \n# 刷题遇到的问题，如果可以去掉重复的问题，就可以用set来解决\n# 如何去掉重复的问题\n# 1.", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    # 数组偏移量从0开始\n    offset = 0\n    sum = 0\n    result_sum = sys.maxsize\n    for i in range(len(nums)):\n        sum += nums[i]\n        # 如果是一个非空子数组，那么是从offset开始的\n        # 当sum小于0的时候，offset向右移动一位，当数组为空时，offset = i+1，sum = 0\n        while sum < 0:\n            sum -= nums[offset]\n            offset += 1\n            if offset == len(nums):\n                offset = i+1\n                sum = 0\n        result_sum = min(result_sum, sum)\n    return result_sum\n    \n# 刷题遇到的问题，如果可以去掉重复的问题，就可以用set来解决\n# 如何去掉重复的问题\n# 1."}
{"task_id": "HumanEval/114", "completion": "    if not nums:\n        return None\n\n    min_sum = sys.maxsize\n    start_index = 0\n    end_index = 0\n    total_sum = 0\n    for end_index in range(len(nums)):\n        total_sum += nums[end_index]\n        if total_sum < min_sum:\n            min_sum = total_sum\n            start_index = 0\n            for j in range(start_index, end_index+1):\n                if total_sum < min_sum:\n                    min_sum = total_sum\n                    start_index = j\n                    break\n                \n        if total_sum > min_sum:\n            total_sum = 0\n            for j in range(start_index, end_index+1):\n                if total_sum < min_sum:\n                    min_sum = total_sum\n                    start_index = j+1\n                    break\n    return min_sum\n\nif __name__ == '__main__':\n    # print(minSubArraySum([2, 3,", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return None\n\n    min_sum = sys.maxsize\n    start_index = 0\n    end_index = 0\n    total_sum = 0\n    for end_index in range(len(nums)):\n        total_sum += nums[end_index]\n        if total_sum < min_sum:\n            min_sum = total_sum\n            start_index = 0\n            for j in range(start_index, end_index+1):\n                if total_sum < min_sum:\n                    min_sum = total_sum\n                    start_index = j\n                    break\n                \n        if total_sum > min_sum:\n            total_sum = 0\n            for j in range(start_index, end_index+1):\n                if total_sum < min_sum:\n                    min_sum = total_sum\n                    start_index = j+1\n                    break\n    return min_sum\n\nif __name__ == '__main__':\n    # print(minSubArraySum([2, 3,"}
{"task_id": "HumanEval/114", "completion": "    # return min_subarray_sum(nums, 0, len(nums) - 1)\n    return min_subarray_sum_2pointers(nums)\n\n\ndef min_subarray_sum(nums, start, end):\n    \"\"\"\n    动态规划：从0-9的数字，最小的子数组总和肯定是 14 到 19 的最小，所以每次的循环都往前滑一位，然后更新子数组最小值\n    :param nums:\n    :return:\n    \"\"\"\n    if start >= end:\n        return nums[start]\n    for i in range(start, end):\n        # 当前位置的和 - 当前位置的和 下一位子数组最小\n        min_sum = min(min_subarray_sum(nums, start, i), min_subarray_sum(nums, i + 1, end), nums[start] +", "allcode": "\ndef minSubArraySum(nums):\n    \"\"\"\n    给定一个整数数组，找到具有最小总和的任意一个非空子数组，输出最小总和值。示例如下：\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # return min_subarray_sum(nums, 0, len(nums) - 1)\n    return min_subarray_sum_2pointers(nums)\n\n\ndef min_subarray_sum(nums, start, end):\n    \"\"\"\n    动态规划：从0-9的数字，最小的子数组总和肯定是 14 到 19 的最小，所以每次的循环都往前滑一位，然后更新子数组最小值\n    :param nums:\n    :return:\n    \"\"\"\n    if start >= end:\n        return nums[start]\n    for i in range(start, end):\n        # 当前位置的和 - 当前位置的和 下一位子数组最小\n        min_sum = min(min_subarray_sum(nums, start, i), min_subarray_sum(nums, i + 1, end), nums[start] +"}
{"task_id": "MBPP/12", "completion": "\n    # 首先按列求和得到每一列的和\n    col = [sum(x) for x in zip(*M)]\n    col.sort()\n    # 按照求和的结果排序，遍历M\n    result = []\n    for i in range(len(M)):\n        for j in col[::-1]:\n            if M[i].count(j) >= 1:\n                result.append(M[i][M[i].index(j)])\n                break\n    return result\n\ndef _test():\n    M = [[2, 1, 3], [5, 1, 3], [7, 1, 3]]\n    assert sort_matrix(M) == [7, 5, 2]\n    M = [[1, 2, 3], [2, 3, 4], [1, 2, 3]]\n    assert sort_matrix(M) == [1, 2, 2]\n_test()\n\ndef solution(nums: List[int]) -> List", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 首先按列求和得到每一列的和\n    col = [sum(x) for x in zip(*M)]\n    col.sort()\n    # 按照求和的结果排序，遍历M\n    result = []\n    for i in range(len(M)):\n        for j in col[::-1]:\n            if M[i].count(j) >= 1:\n                result.append(M[i][M[i].index(j)])\n                break\n    return result\n\ndef _test():\n    M = [[2, 1, 3], [5, 1, 3], [7, 1, 3]]\n    assert sort_matrix(M) == [7, 5, 2]\n    M = [[1, 2, 3], [2, 3, 4], [1, 2, 3]]\n    assert sort_matrix(M) == [1, 2, 2]\n_test()\n\ndef solution(nums: List[int]) -> List"}
{"task_id": "MBPP/12", "completion": "\n    if not M or not M[0]:\n        return M\n    m = len(M)\n    n = len(M[0])\n    S = []\n    for i in range(m):\n        temp = sum(M[i])\n        S.append(temp)\n    S.sort()\n    A = []\n    for i in range(m):\n        temp = M[i]\n        for j in range(n):\n            temp[j] /= S[i]\n        A.append(temp)\n    A.sort(key = lambda x:(sum(x), x))\n    return A\n```\n### 找出中位数的数\n找出给定数组中的中位数。如果数组的大小是偶数，请在数组中间两个数的平均值作为中位数。\n```python\ndef median_of_array(arr: List[int]):\n    '''\n    找出给定数组中的中位数。如果数组的大小是偶数", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    if not M or not M[0]:\n        return M\n    m = len(M)\n    n = len(M[0])\n    S = []\n    for i in range(m):\n        temp = sum(M[i])\n        S.append(temp)\n    S.sort()\n    A = []\n    for i in range(m):\n        temp = M[i]\n        for j in range(n):\n            temp[j] /= S[i]\n        A.append(temp)\n    A.sort(key = lambda x:(sum(x), x))\n    return A\n```\n### 找出中位数的数\n找出给定数组中的中位数。如果数组的大小是偶数，请在数组中间两个数的平均值作为中位数。\n```python\ndef median_of_array(arr: List[int]):\n    '''\n    找出给定数组中的中位数。如果数组的大小是偶数"}
{"task_id": "MBPP/12", "completion": "\n    M1 = sorted(M,key=sum)\n    return M1\n```\n\n## 5. 字典\n> 字典是一种特殊容器，它由键和值的对象组成，键唯一，值是可变对象。\n\n### 1. 初始化\n> 1. 使用{key:value}来初始化。\n> 2. 字典可以当做对象的属性。\n\n```python\nd1 = {'name':'zhangsan','age':20}\nd2 = dict(name='zhangsan',age=20)\n```\n\n### 2. 访问\n> 1. 直接访问值。\n> 2. 值是可变对象，可以修改。\n\n```python\nprint(d1['age'])\nd1['age'] = 21\nprint(d1['age'])\n```\n\n### 3. 添加和删除\n> 1.", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    M1 = sorted(M,key=sum)\n    return M1\n```\n\n## 5. 字典\n> 字典是一种特殊容器，它由键和值的对象组成，键唯一，值是可变对象。\n\n### 1. 初始化\n> 1. 使用{key:value}来初始化。\n> 2. 字典可以当做对象的属性。\n\n```python\nd1 = {'name':'zhangsan','age':20}\nd2 = dict(name='zhangsan',age=20)\n```\n\n### 2. 访问\n> 1. 直接访问值。\n> 2. 值是可变对象，可以修改。\n\n```python\nprint(d1['age'])\nd1['age'] = 21\nprint(d1['age'])\n```\n\n### 3. 添加和删除\n> 1."}
{"task_id": "MBPP/12", "completion": "\n```\n\n## 方案：\n- 先获取列表内容，转换成字典，再升序排序，得到字典后，再转回到列表中\n```python\ndef sort_matrix(M: List[float]):\n    \"\"\"\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    \"\"\"\n    D = dict(zip(range(len(M)), M))\n    D = sorted(D.items(), key=lambda x: x[1], reverse=False)\n    D = [i[0] for i in D]\n    return [M[i] for i in D]\n```\n- 先获取列表内容，转换成字典，再升序排序，得到字典后，再转回到列表中\n```python\ndef sort_matrix(M: List[float]):\n    \"\"\"\n    给定一个矩阵M，编", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n```\n\n## 方案：\n- 先获取列表内容，转换成字典，再升序排序，得到字典后，再转回到列表中\n```python\ndef sort_matrix(M: List[float]):\n    \"\"\"\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    \"\"\"\n    D = dict(zip(range(len(M)), M))\n    D = sorted(D.items(), key=lambda x: x[1], reverse=False)\n    D = [i[0] for i in D]\n    return [M[i] for i in D]\n```\n- 先获取列表内容，转换成字典，再升序排序，得到字典后，再转回到列表中\n```python\ndef sort_matrix(M: List[float]):\n    \"\"\"\n    给定一个矩阵M，编"}
{"task_id": "MBPP/12", "completion": "\n    m = len(M)\n    n = len(M[0])\n    for i in range(m):\n        for j in range(n):\n            M[i][j] = M[i][j] * M[i][j]\n    new_M = []\n    for i in range(m):\n        new_M.append(sum(M[i]))\n    for i in range(m):\n        for j in range(n):\n            M[i][j] = M[i][j] / new_M[i]\n    for i in range(m):\n        M[i].sort(reverse=True)\n    return M\n\nif __name__ == '__main__':\n    array = [[1, 9, 3], [8, 3, 4], [2, 5, 6]]\n    print(sort_matrix(array))\n```\n\n### 哈希表\n\n```python\ndef sort_matrix(M: List[List[int]]):\n    '''\n    给定一个矩阵M，编写", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    m = len(M)\n    n = len(M[0])\n    for i in range(m):\n        for j in range(n):\n            M[i][j] = M[i][j] * M[i][j]\n    new_M = []\n    for i in range(m):\n        new_M.append(sum(M[i]))\n    for i in range(m):\n        for j in range(n):\n            M[i][j] = M[i][j] / new_M[i]\n    for i in range(m):\n        M[i].sort(reverse=True)\n    return M\n\nif __name__ == '__main__':\n    array = [[1, 9, 3], [8, 3, 4], [2, 5, 6]]\n    print(sort_matrix(array))\n```\n\n### 哈希表\n\n```python\ndef sort_matrix(M: List[List[int]]):\n    '''\n    给定一个矩阵M，编写"}
{"task_id": "MBPP/12", "completion": "\n    arr = sorted(M, key=lambda x: x[0])\n    return [item for item in arr]\n```\n\n## 1532. 最小的k个数\n\n[1532. 最小的k个数](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)\n\n### 问题\n\n给定一个整数数组 nums 和一个正整数 k, 找到最小的 k 个数，使得它们的和是不小于 nums 中所有元素之和的最小值。\n\n示例 1：\n\n输入：nums = [1,7,11], k = 2\n输出：[1,7] 或者 [1,11]\n示例 2：\n\n输入：nums = [1,1,1], k = 2\n输出：[1,1]\n\n提示：\n\n1 <= k <= nums.length <=", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    arr = sorted(M, key=lambda x: x[0])\n    return [item for item in arr]\n```\n\n## 1532. 最小的k个数\n\n[1532. 最小的k个数](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)\n\n### 问题\n\n给定一个整数数组 nums 和一个正整数 k, 找到最小的 k 个数，使得它们的和是不小于 nums 中所有元素之和的最小值。\n\n示例 1：\n\n输入：nums = [1,7,11], k = 2\n输出：[1,7] 或者 [1,11]\n示例 2：\n\n输入：nums = [1,1,1], k = 2\n输出：[1,1]\n\n提示：\n\n1 <= k <= nums.length <="}
{"task_id": "MBPP/12", "completion": "\n    # 先求行和，再将行和按升序排序。\n    M_sum = np.sum(M, axis=1)\n    M_sort = M_sum.argsort()\n    M_sort_res = M[M_sort]\n    return M_sort_res\n```\n\n### 3. 层层套递归\n\n```python\ndef sum_all(M: List[List[float]]) -> float:\n    R = M[0]\n    for r in M[1:]:\n        R = sum_all_r(R, r)\n    return R\ndef sum_all_r(R1: List[float], R2: List[float]) -> List[float]:\n    r1 = R1[0]\n    r2 = R2[0]\n    res = []\n    for i in range(len(r1)):\n        res.append(r1[i] + r2[i])\n    return res\nif __name__ == '__main__':\n    print(", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # 先求行和，再将行和按升序排序。\n    M_sum = np.sum(M, axis=1)\n    M_sort = M_sum.argsort()\n    M_sort_res = M[M_sort]\n    return M_sort_res\n```\n\n### 3. 层层套递归\n\n```python\ndef sum_all(M: List[List[float]]) -> float:\n    R = M[0]\n    for r in M[1:]:\n        R = sum_all_r(R, r)\n    return R\ndef sum_all_r(R1: List[float], R2: List[float]) -> List[float]:\n    r1 = R1[0]\n    r2 = R2[0]\n    res = []\n    for i in range(len(r1)):\n        res.append(r1[i] + r2[i])\n    return res\nif __name__ == '__main__':\n    print("}
{"task_id": "MBPP/12", "completion": "\n    # M = [[2, 4, 1], [8, 3, 6], [5, 9, 7]]\n    # [[2, 4, 1], [5, 9, 7], [8, 3, 6]]\n    # 把每一行的和降序排列，然后绕着遍历排序；\n    # 即根据第一行，第二行，第三行的和来排序\n    ans = [] \n    sumR = []\n    for i in M:\n        sumR.append(sum(i))\n    ans = sorted(sumR)\n    idx = 0\n    for i in M:\n        i.sort(reverse=True)\n        for j in i:\n            M[idx].append(j)\n            idx += 1\n    return M\n\ndef sort_matrix1(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # M = [[2, 4, 1], [8, 3, 6], [5, 9, 7]]\n    # [[2, 4, 1], [5, 9, 7], [8, 3, 6]]\n    # 把每一行的和降序排列，然后绕着遍历排序；\n    # 即根据第一行，第二行，第三行的和来排序\n    ans = [] \n    sumR = []\n    for i in M:\n        sumR.append(sum(i))\n    ans = sorted(sumR)\n    idx = 0\n    for i in M:\n        i.sort(reverse=True)\n        for j in i:\n            M[idx].append(j)\n            idx += 1\n    return M\n\ndef sort_matrix1(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数"}
{"task_id": "MBPP/12", "completion": "\n    # [\n    #   [1, 1, 0],\n    #   [1, 1, 0],\n    #   [0, 0, 0],\n    #   [0, 1, 1],\n    #   [1, 1, 1]\n    # ]\n    # 输出为:\n    # [\n    #   [1, 0, 0],\n    #   [1, 0, 0],\n    #   [1, 0, 0],\n    #   [0, 1, 1],\n    #   [0, 1, 1]\n    # ]\n    rowsum = [0] * len(M[0])\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            rowsum[j] += M[i][j]\n    \n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            k = j - rowsum[j]\n            if not k >= 0:\n", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    # [\n    #   [1, 1, 0],\n    #   [1, 1, 0],\n    #   [0, 0, 0],\n    #   [0, 1, 1],\n    #   [1, 1, 1]\n    # ]\n    # 输出为:\n    # [\n    #   [1, 0, 0],\n    #   [1, 0, 0],\n    #   [1, 0, 0],\n    #   [0, 1, 1],\n    #   [0, 1, 1]\n    # ]\n    rowsum = [0] * len(M[0])\n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            rowsum[j] += M[i][j]\n    \n    for i in range(len(M)):\n        for j in range(len(M[i])):\n            k = j - rowsum[j]\n            if not k >= 0:\n"}
{"task_id": "MBPP/12", "completion": "\n    '''\n    M = [\n       [ 1, 1 ],\n       [ 1,  -1 ],\n       [ 1, 1 ],\n    ]\n    '''\n    M = [[1,1,1],[1,1,1],[1,1,1],[1,-1,1]]\n    def merge_row_sum(x,y):\n        if x[0] > y[0]:\n            return x\n        else:\n            return y\n    M =", "allcode": "from typing import List\ndef sort_matrix(M: List[float]):\n    '''\n    给定一个矩阵M，编写一个函数，将其按行求和结果的升序进行排序。\n    '''\n    '''\n    M = [\n       [ 1, 1 ],\n       [ 1,  -1 ],\n       [ 1, 1 ],\n    ]\n    '''\n    M = [[1,1,1],[1,1,1],[1,1,1],[1,-1,1]]\n    def merge_row_sum(x,y):\n        if x[0] > y[0]:\n            return x\n        else:\n            return y\n    M ="}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    for i in range(len(binum)):\n        if binum[i] == \"1\":\n            dec += 2**(len(binum)-i-1)\n    return dec\n```\n\n将十进制数转化为二进制数。\n\n```python\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    \n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = \"\"\n    while num > 0:\n        binum = str(num % 2) + binum\n        num = num//2\n    return binum\n```\n\n#### 1.3.2 至浮点数\n\n将十进制数转化为至浮点数。\n\n```python\ndef decimal_to_float(num): \n    '''\n    将给定的十进制数转化为�", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    for i in range(len(binum)):\n        if binum[i] == \"1\":\n            dec += 2**(len(binum)-i-1)\n    return dec\n```\n\n将十进制数转化为二进制数。\n\n```python\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    \n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = \"\"\n    while num > 0:\n        binum = str(num % 2) + binum\n        num = num//2\n    return binum\n```\n\n#### 1.3.2 至浮点数\n\n将十进制数转化为至浮点数。\n\n```python\ndef decimal_to_float(num): \n    '''\n    将给定的十进制数转化为�"}
{"task_id": "MBPP/24", "completion": "\n    num = 0\n    power = 0\n    while(binum > 0):\n        num = num + (binum % 10) * (10 ** power)\n        binum = binum // 10\n        power = power + 1\n    return num\n\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = 0\n    while(num > 0):\n        binum = (num % 2) * 10 + binum\n        num = num // 2\n    return binum\n\n\ndef _main():\n    print('This is a sample test')\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n    print('This is end of test.')\n    \n```\n\n\n\n### 3.1", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    num = 0\n    power = 0\n    while(binum > 0):\n        num = num + (binum % 10) * (10 ** power)\n        binum = binum // 10\n        power = power + 1\n    return num\n\n\ndef decimal_to_binary(num): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    binum = 0\n    while(num > 0):\n        binum = (num % 2) * 10 + binum\n        num = num // 2\n    return binum\n\n\ndef _main():\n    print('This is a sample test')\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n    print('This is end of test.')\n    \n```\n\n\n\n### 3.1"}
{"task_id": "MBPP/24", "completion": "\n\n    number=0\n    for digit in binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n\n    number=0\n    for digit in binu"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    pos = 0\n\n    while binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    pos = 0\n\n    while binu"}
{"task_id": "MBPP/24", "completion": "\n    decimal_num = 0\n    for digit in binum:\n        decimal_num *= 2\n        decimal_num += int(digit)\n    return decimal_num\n\n\ndef pow_3(num):\n    '''\n    计算给定数的3次方\n    >>> pow_3(3)\n    27\n    >>> pow_3(10)\n    1000\n    '''\n    return num**3\n\n\ndef make_power_3_decorator(func):\n    '''\n    给定函数创建一个新的装饰器，\n    该装饰器将给定函数的结果乘以3\n    >>> make_power_3_decorator(pow_3)(3)\n    27\n    >>> make_power_3_decorator(pow_3)(4)\n    81\n    '''\n    def new_func(x):\n        return func(x) * 3\n    return new_func\n\n\ndef add_one(func):\n    '''\n    给定函数创建一个新", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal_num = 0\n    for digit in binum:\n        decimal_num *= 2\n        decimal_num += int(digit)\n    return decimal_num\n\n\ndef pow_3(num):\n    '''\n    计算给定数的3次方\n    >>> pow_3(3)\n    27\n    >>> pow_3(10)\n    1000\n    '''\n    return num**3\n\n\ndef make_power_3_decorator(func):\n    '''\n    给定函数创建一个新的装饰器，\n    该装饰器将给定函数的结果乘以3\n    >>> make_power_3_decorator(pow_3)(3)\n    27\n    >>> make_power_3_decorator(pow_3)(4)\n    81\n    '''\n    def new_func(x):\n        return func(x) * 3\n    return new_func\n\n\ndef add_one(func):\n    '''\n    给定函数创建一个新"}
{"task_id": "MBPP/24", "completion": "\n    res = 0 \n    i = 0\n    while binu", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    res = 0 \n    i = 0\n    while binu"}
{"task_id": "MBPP/24", "completion": "\n    dec = 0\n    # 取倒数第二位为基数，倒数第一位为余数\n    for i in range(len(binum)):\n        dec += (binum[i] * (2 ** (len(binum) - 1 - i)))\n    return dec\n\n\ndef decimal_to_binary(deci): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    # 整数部分\n    int_d = deci // 2\n    # 余数部分\n    rem_d = deci % 2\n    bin_d = str(rem_d)\n    # 递归调用，终止条件是整数部分为0\n    if int_d:\n        bin_d = decimal_to_binary(int_d) + bin", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    dec = 0\n    # 取倒数第二位为基数，倒数第一位为余数\n    for i in range(len(binum)):\n        dec += (binum[i] * (2 ** (len(binum) - 1 - i)))\n    return dec\n\n\ndef decimal_to_binary(deci): \n    '''\n    将给定的十进制数转化为二进制数。\n    >>> decimal_to_binary(9)\n    1001\n    >>> decimal_to_binary(10)\n    1010\n    '''\n    # 整数部分\n    int_d = deci // 2\n    # 余数部分\n    rem_d = deci % 2\n    bin_d = str(rem_d)\n    # 递归调用，终止条件是整数部分为0\n    if int_d:\n        bin_d = decimal_to_binary(int_d) + bin"}
{"task_id": "MBPP/24", "completion": "\n    result = 0\n    # 从右往左进行计算\n    for i in range(2, len(binum)+1): \n        result += int(binum[-i]) * 2**(i-1)\n    return int(result)\n\ndef hex_to_decimal(hexnum): \n    '''\n    将给定的十六进制数转化为十进制数。\n    >>> hex_to_decimal(0x10)\n    16\n    >>> hex_to_decimal(0x20)\n    32\n    '''\n    result = 0\n    for i, ch in enumerate(hexnum): \n        result += int(ch, 16) * (16**(len(hexnum) - i - 1))\n    return result\n    \nif __name__ == '__main__': \n    for i in [1001, '1001', 1001*2, '1001'*2, [1001]*2]: \n        print(binary_", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    result = 0\n    # 从右往左进行计算\n    for i in range(2, len(binum)+1): \n        result += int(binum[-i]) * 2**(i-1)\n    return int(result)\n\ndef hex_to_decimal(hexnum): \n    '''\n    将给定的十六进制数转化为十进制数。\n    >>> hex_to_decimal(0x10)\n    16\n    >>> hex_to_decimal(0x20)\n    32\n    '''\n    result = 0\n    for i, ch in enumerate(hexnum): \n        result += int(ch, 16) * (16**(len(hexnum) - i - 1))\n    return result\n    \nif __name__ == '__main__': \n    for i in [1001, '1001', 1001*2, '1001'*2, [1001]*2]: \n        print(binary_"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    length = len(binum)\n    for i in range(length):\n        decimal += int(binum[i]) * 2**(length - i - 1)\n    return decimal\n\n\nif __name__ == '__main__':\n    # test case 1\n    num = '1010'\n    print('input = {}'.format(num))\n    print('output = {}'.format(binary_to_decimal(num)))\n\n    # test case 2\n    num = '0011'\n    print('input = {}'.format(num))\n    print('output = {}'.format(binary_to_decimal(num)))\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    decimal = 0\n    length = len(binum)\n    for i in range(length):\n        decimal += int(binum[i]) * 2**(length - i - 1)\n    return decimal\n\n\nif __name__ == '__main__':\n    # test case 1\n    num = '1010'\n    print('input = {}'.format(num))\n    print('output = {}'.format(binary_to_decimal(num)))\n\n    # test case 2\n    num = '0011'\n    print('input = {}'.format(num))\n    print('output = {}'.format(binary_to_decimal(num)))\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n"}
{"task_id": "MBPP/24", "completion": "\n    return int(binum,2)\n    \nif __name__ == '__main__':\n    print('Please input the binary number, and I will give you the decimal number.')\n    while True:\n        try:\n            binary=input()\n            print(binary_to_dec", "allcode": "def binary_to_decimal(binum): \n    '''\n    将给定的二进制数转化为十进制数。\n    >>> binary_to_decimal(1001)\n    9\n    >>> binary_to_decimal(1010)\n    10\n    '''\n    return int(binum,2)\n    \nif __name__ == '__main__':\n    print('Please input the binary number, and I will give you the decimal number.')\n    while True:\n        try:\n            binary=input()\n            print(binary_to_dec"}
{"task_id": "MBPP/27", "completion": "\n    newlist = []\n    pattern = re.compile(r'\\d+')\n    for item in strlist:\n        newlist.append(pattern.sub('', item))\n    return newlist\n\n\nprint(remove(['abc123', 'def456', 'ghi789']))\nprint(remove(['abc123xyz', 'define456', '789ghi']))\n\ndef remove1(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    >>> remove1([])\n    []\n    '''\n    return [pattern.sub('', item) for item in strlist \\\n            if item and pattern.search(item)]", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    newlist = []\n    pattern = re.compile(r'\\d+')\n    for item in strlist:\n        newlist.append(pattern.sub('', item))\n    return newlist\n\n\nprint(remove(['abc123', 'def456', 'ghi789']))\nprint(remove(['abc123xyz', 'define456', '789ghi']))\n\ndef remove1(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    >>> remove1([])\n    []\n    '''\n    return [pattern.sub('', item) for item in strlist \\\n            if item and pattern.search(item)]"}
{"task_id": "MBPP/27", "completion": "\n    strlist = [re.sub('\\d', '', item) for item in strlist]\n    return strlist\n```\n\n### 11. 判断列表是否有重复的元素\n\n```python\ndef has_duplicates(lst):\n    \"\"\"\n    给定一个数组，返回True或者False,如果数组中有重复的元素\n    >>> has_duplicates([1, 2, 3, 4, 5, 6, 7, 8])\n    False\n    >>> has_duplicates([1, 2, 3, 3])\n    True\n    >>> has_duplicates([1, 2, 3, 3, 4, 5, 6, 7, 8])\n    True\n    >>> has_duplicates(['a', 'b', 'c', 'a'])\n    True\n    >>> has_duplicates(['a', 'b', 'c', 'd'])\n    False\n    \"\"\"\n    return len(lst)!= len(set(lst))\n```\n\n### 12.", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    strlist = [re.sub('\\d', '', item) for item in strlist]\n    return strlist\n```\n\n### 11. 判断列表是否有重复的元素\n\n```python\ndef has_duplicates(lst):\n    \"\"\"\n    给定一个数组，返回True或者False,如果数组中有重复的元素\n    >>> has_duplicates([1, 2, 3, 4, 5, 6, 7, 8])\n    False\n    >>> has_duplicates([1, 2, 3, 3])\n    True\n    >>> has_duplicates([1, 2, 3, 3, 4, 5, 6, 7, 8])\n    True\n    >>> has_duplicates(['a', 'b', 'c', 'a'])\n    True\n    >>> has_duplicates(['a', 'b', 'c', 'd'])\n    False\n    \"\"\"\n    return len(lst)!= len(set(lst))\n```\n\n### 12."}
{"task_id": "MBPP/27", "completion": "\n    slist = []\n    for str in strlist:\n        new_str = ''\n        for c in str:\n            if c.isalpha():\n                new_str += c\n        slist.append(new_str)\n    return slist\n\n\ndef first(strlist, x):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回x出现的第一个位置。\n    >>> first(['abc123', 'def456', 'ghi789'], 'abc')\n    0\n    >>> first(['abc123', 'def456', 'ghi789'], '456')\n    1\n    >>> first(['abc123', 'def456', 'ghi789'], '789')\n    2\n    '''\n    for i, str in enumerate(strlist):\n        if x in str:\n            return i\n    return -1\n\n\ndef last(strlist, x):\n    '''\n    给定一个字符串列表strlist，", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    slist = []\n    for str in strlist:\n        new_str = ''\n        for c in str:\n            if c.isalpha():\n                new_str += c\n        slist.append(new_str)\n    return slist\n\n\ndef first(strlist, x):\n    '''\n    给定一个字符串列表strlist，编写一个函数，返回x出现的第一个位置。\n    >>> first(['abc123', 'def456', 'ghi789'], 'abc')\n    0\n    >>> first(['abc123', 'def456', 'ghi789'], '456')\n    1\n    >>> first(['abc123', 'def456', 'ghi789'], '789')\n    2\n    '''\n    for i, str in enumerate(strlist):\n        if x in str:\n            return i\n    return -1\n\n\ndef last(strlist, x):\n    '''\n    给定一个字符串列表strlist，"}
{"task_id": "MBPP/27", "completion": "\n    # 找出数字\n    re_num = re.compile('\\d+')\n    result = []\n    for i in strlist:\n        result.append(re_num.sub('',i))\n    return result\n\nstrlist = ['abc123', 'def456', 'ghi789', 'abc123xyz', 'define456', '789ghi']\nprint remove(strlist)\n```\n\n### 10.3 多行替换\n\n**题目**\n\n给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\nimport re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def45", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    # 找出数字\n    re_num = re.compile('\\d+')\n    result = []\n    for i in strlist:\n        result.append(re_num.sub('',i))\n    return result\n\nstrlist = ['abc123', 'def456', 'ghi789', 'abc123xyz', 'define456', '789ghi']\nprint remove(strlist)\n```\n\n### 10.3 多行替换\n\n**题目**\n\n给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\nimport re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def45"}
{"task_id": "MBPP/27", "completion": "\n    # Your code here\n    new_list = []\n    for x in strlist:\n        new_list.append(re.sub('\\d+', '', x))\n    return new_list\n\n\ndef count_code(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，统计每个字符串中各个字母的出现频率。\n    >>> count_code(['abc123', 'def456', 'ghi789'])\n    {'a': 2, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 3, 'j': 0, 'k': 0, 'l': 0,'m': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0,'s': 0, 't': 0, 'u': 0", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    # Your code here\n    new_list = []\n    for x in strlist:\n        new_list.append(re.sub('\\d+', '', x))\n    return new_list\n\n\ndef count_code(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，统计每个字符串中各个字母的出现频率。\n    >>> count_code(['abc123', 'def456', 'ghi789'])\n    {'a': 2, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 3, 'j': 0, 'k': 0, 'l': 0,'m': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0,'s': 0, 't': 0, 'u': 0"}
{"task_id": "MBPP/27", "completion": "\n    newlist = []\n    for s in strlist:\n        newlist.append(re.sub('[0-9]', '', s))\n    return newlist\nmylist = ['abc123', 'def456', 'ghi789']\nprint(remove(mylist))\n\n```\n\n### 字典\n```python\n# 字典\n# 字典的解析\n# 字典的遍历\n# 字典的更新\n# 修改字典\n# 深复制和浅复制\n\n```\n\n### 迭代器\n```python\n#迭代器\n# next()\n# range()\n# enumerate()\n\ndef countdown(n):\n    '''\n    将1到n依次打印出来\n    >>>countdown(5)\n\n    1\n    2\n    3\n    4\n    5\n    '''\n    while n > 0:\n        print(n)\n        n = n - 1\ncountdown(5)\n\n", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    newlist = []\n    for s in strlist:\n        newlist.append(re.sub('[0-9]', '', s))\n    return newlist\nmylist = ['abc123', 'def456', 'ghi789']\nprint(remove(mylist))\n\n```\n\n### 字典\n```python\n# 字典\n# 字典的解析\n# 字典的遍历\n# 字典的更新\n# 修改字典\n# 深复制和浅复制\n\n```\n\n### 迭代器\n```python\n#迭代器\n# next()\n# range()\n# enumerate()\n\ndef countdown(n):\n    '''\n    将1到n依次打印出来\n    >>>countdown(5)\n\n    1\n    2\n    3\n    4\n    5\n    '''\n    while n > 0:\n        print(n)\n        n = n - 1\ncountdown(5)\n\n"}
{"task_id": "MBPP/27", "completion": "\n    return list(filter(lambda x: re.sub('\\d+','',x) if isinstance(x,str) else x, strlist))\n\n\ndef replace_all(target,sub,newsub):\n    '''\n    用newsub来代替target中的sub\n    >>> replace_all('abc123 xyz', '1', 'one')\n    'abcone23 xyz'\n    >>> replace_all('abc123 xyz', '123', 'one')\n    'abcone xyz'\n    '''\n    return re.sub(sub, newsub, target)\n\ndef replace_first(target,sub,newsub):\n    '''\n    用newsub来代替target中的第一个sub\n    >>> replace_first('abc123 xyz', '1', 'one')\n    'abcone23 xyz'\n    >>> replace_first('abc123 xyz', '123', 'one')\n    'abc1one xyz'\n    '''\n    return re.sub(sub, newsub, target,", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    return list(filter(lambda x: re.sub('\\d+','',x) if isinstance(x,str) else x, strlist))\n\n\ndef replace_all(target,sub,newsub):\n    '''\n    用newsub来代替target中的sub\n    >>> replace_all('abc123 xyz', '1', 'one')\n    'abcone23 xyz'\n    >>> replace_all('abc123 xyz', '123', 'one')\n    'abcone xyz'\n    '''\n    return re.sub(sub, newsub, target)\n\ndef replace_first(target,sub,newsub):\n    '''\n    用newsub来代替target中的第一个sub\n    >>> replace_first('abc123 xyz', '1', 'one')\n    'abcone23 xyz'\n    >>> replace_first('abc123 xyz', '123', 'one')\n    'abc1one xyz'\n    '''\n    return re.sub(sub, newsub, target,"}
{"task_id": "MBPP/27", "completion": "\n    r = []\n\n    for s in strlist:\n        pattern = re.compile('\\d+')\n        r.append(pattern.sub('', s))\n    return r\n```\n\n### 4.1.2 替换\n\n#### str1.replace(str2, str3)\n\nstr1中所有的str2替换成str3\n\n```python\n>>> str1 = 'abc123xyz'\n>>> str1.replace('123', '456')\n'abc456xyz'\n```\n\n#### re.sub(str1, str2, str3)\n\n> 把str3中所有的str1替换成str2\n\n```python\n# 这个replace只能替换字符串中的一个字符，如果字符串里面有多个字符则仅仅替换第一个\n>>> str1 = 'abc123xyz'\n>>> str1.replace('123', '456')\n'", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    r = []\n\n    for s in strlist:\n        pattern = re.compile('\\d+')\n        r.append(pattern.sub('', s))\n    return r\n```\n\n### 4.1.2 替换\n\n#### str1.replace(str2, str3)\n\nstr1中所有的str2替换成str3\n\n```python\n>>> str1 = 'abc123xyz'\n>>> str1.replace('123', '456')\n'abc456xyz'\n```\n\n#### re.sub(str1, str2, str3)\n\n> 把str3中所有的str1替换成str2\n\n```python\n# 这个replace只能替换字符串中的一个字符，如果字符串里面有多个字符则仅仅替换第一个\n>>> str1 = 'abc123xyz'\n>>> str1.replace('123', '456')\n'"}
{"task_id": "MBPP/27", "completion": "\n    # write code here\n    def remove_num(string):\n        str = ''\n        for item in string:\n            if not str.isdigit():\n                str += item\n        return str\n\n    res = []\n    for i in strlist:\n        res.append(remove_num(i))\n    return res\n\n# def remove(strlist):\n#     '''\n#     给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n#     >>> remove(['abc123', 'def456', 'ghi789'])\n#     ['abc', 'def', 'ghi']\n#     >>> remove(['abc123xyz', 'define456', '789ghi'])\n#     ['abcxyz', 'define', 'ghi']\n#     '''\n#     # write code here\n#     def remove_num(string):\n#         str = ''\n#         for i in string:\n#             if not i.isdigit():\n#                 str += i\n#         return", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    # write code here\n    def remove_num(string):\n        str = ''\n        for item in string:\n            if not str.isdigit():\n                str += item\n        return str\n\n    res = []\n    for i in strlist:\n        res.append(remove_num(i))\n    return res\n\n# def remove(strlist):\n#     '''\n#     给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n#     >>> remove(['abc123', 'def456', 'ghi789'])\n#     ['abc', 'def', 'ghi']\n#     >>> remove(['abc123xyz', 'define456', '789ghi'])\n#     ['abcxyz', 'define', 'ghi']\n#     '''\n#     # write code here\n#     def remove_num(string):\n#         str = ''\n#         for i in string:\n#             if not i.isdigit():\n#                 str += i\n#         return"}
{"task_id": "MBPP/27", "completion": "\n    pattern = re.compile('\\d')\n    result = []\n    for s in strlist:\n        result.append(pattern.sub('', s))\n    return result\n\nprint(remove(['abc123', 'def456', 'ghi789']))\n```\n\n## 13. 有序列表\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 有序列表\ndef sum(numbers):\n    '''\n    编写一个sum函数，求一个数列的和，如果不知道列表的长度，也能计算。\n    >>> sum([1, 2, 3])\n    6\n    >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    55\n    >>> sum([])\n    0\n    '''\n    result = 0\n    for i in numbers:\n        result += i\n    return result\n\nprint(sum([1, 2, 3", "allcode": "import re \ndef remove(strlist):\n    '''\n    给定一个字符串列表strlist，编写一个函数，将每个字符串中的数字全部删除。\n    >>> remove(['abc123', 'def456', 'ghi789'])\n    ['abc', 'def', 'ghi']\n    >>> remove(['abc123xyz', 'define456', '789ghi'])\n    ['abcxyz', 'define', 'ghi']\n    '''\n    pattern = re.compile('\\d')\n    result = []\n    for s in strlist:\n        result.append(pattern.sub('', s))\n    return result\n\nprint(remove(['abc123', 'def456', 'ghi789']))\n```\n\n## 13. 有序列表\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 有序列表\ndef sum(numbers):\n    '''\n    编写一个sum函数，求一个数列的和，如果不知道列表的长度，也能计算。\n    >>> sum([1, 2, 3])\n    6\n    >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    55\n    >>> sum([])\n    0\n    '''\n    result = 0\n    for i in numbers:\n        result += i\n    return result\n\nprint(sum([1, 2, 3"}
{"task_id": "MBPP/42", "completion": "\n    Sum = 0\n    for i in arr:\n        Sum+=arr.count(i)\n    return Sum\n\ndef find_Factorial(n):\n    '''\n       !n的定义：n!=n*(n-1)*(n-2)...*1\n    >>> find_Factorial(5)\n    120\n    >>> find_Factorial(6)\n    720\n    >>> find_Factorial(5)\n    120\n    >>> find_Factorial(6)\n    720\n    '''\n    Factorial = 1\n    while n>1:\n        Factorial = Factorial*n\n        n-=1\n    return Factorial\n\ndef find_Palindrome(str):\n    '''\n    字符串回文 ： 字符串正好可以由2个镜像进行镜像翻转得到，比如：aba， 也就是反转一下，就变成了abba，和原字符串就是一样的，但", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    Sum = 0\n    for i in arr:\n        Sum+=arr.count(i)\n    return Sum\n\ndef find_Factorial(n):\n    '''\n       !n的定义：n!=n*(n-1)*(n-2)...*1\n    >>> find_Factorial(5)\n    120\n    >>> find_Factorial(6)\n    720\n    >>> find_Factorial(5)\n    120\n    >>> find_Factorial(6)\n    720\n    '''\n    Factorial = 1\n    while n>1:\n        Factorial = Factorial*n\n        n-=1\n    return Factorial\n\ndef find_Palindrome(str):\n    '''\n    字符串回文 ： 字符串正好可以由2个镜像进行镜像翻转得到，比如：aba， 也就是反转一下，就变成了abba，和原字符串就是一样的，但"}
{"task_id": "MBPP/42", "completion": "\n    return sum(set(arr))\n\n# 9.给定一个数组，要求我们找到一个数组中的两个数，使得他们相加等于一个给定的值target。\n# 要求数组中的数字不能重复出现。\n\ndef twoSum(nums, target):\n  \"\"\"\n   :type nums: List[int]\n   :type target: int\n   :rtype: List[int]\n  \"\"\"\n  nums.sort()\n  i = 0\n  j = len(nums) - 1\n  while (i < j):\n    if nums[i] + nums[j] < target:\n      i += 1\n    elif nums[i] + nums[j] > target:\n      j -= 1\n    else:\n      res = [nums[i], nums[j]]\n      return res\n  return []\n\n# 10.给定一个整数数组，判断数组中是否有两个不同的", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    return sum(set(arr))\n\n# 9.给定一个数组，要求我们找到一个数组中的两个数，使得他们相加等于一个给定的值target。\n# 要求数组中的数字不能重复出现。\n\ndef twoSum(nums, target):\n  \"\"\"\n   :type nums: List[int]\n   :type target: int\n   :rtype: List[int]\n  \"\"\"\n  nums.sort()\n  i = 0\n  j = len(nums) - 1\n  while (i < j):\n    if nums[i] + nums[j] < target:\n      i += 1\n    elif nums[i] + nums[j] > target:\n      j -= 1\n    else:\n      res = [nums[i], nums[j]]\n      return res\n  return []\n\n# 10.给定一个整数数组，判断数组中是否有两个不同的"}
{"task_id": "MBPP/42", "completion": "\n    # 创建一个空的集合，用于存放数组中的唯一数字\n    num_list = []\n    # 创建一个空的集合，用于存放重复出现的数字\n    dup_list = []\n    # 返回值\n    return_num = 0\n\n    # 从小到大排序\n    for i in sorted(arr):\n        # 如果集合num_list没有元素，将集合num_list存入集合dup_list中，同时将元素i存入集合num_list中\n        if not num_list:\n            dup_list.append(num_list)\n            num_list.append(i)\n        # 如果集合num_list包含元素i，则说明i已经存在，那么将元素i存入集合dup_list中\n        elif i in num_list:\n            dup_list.append(i)\n        # 如果集合num_list不包含元素", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    # 创建一个空的集合，用于存放数组中的唯一数字\n    num_list = []\n    # 创建一个空的集合，用于存放重复出现的数字\n    dup_list = []\n    # 返回值\n    return_num = 0\n\n    # 从小到大排序\n    for i in sorted(arr):\n        # 如果集合num_list没有元素，将集合num_list存入集合dup_list中，同时将元素i存入集合num_list中\n        if not num_list:\n            dup_list.append(num_list)\n            num_list.append(i)\n        # 如果集合num_list包含元素i，则说明i已经存在，那么将元素i存入集合dup_list中\n        elif i in num_list:\n            dup_list.append(i)\n        # 如果集合num_list不包含元素"}
{"task_id": "MBPP/42", "completion": "\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[j] == arr[i]:\n                ans += arr[i]\n    return ans\n\n\ndef find_max_subarray(arr):\n    '''\n        求最大子数组和\n    一个数组可能有负数，但是如果数组中最大的数是正数，那么数组的和是正数，所以不会变成负数。\n    例如[1,-2,3,-4]，最大子数组和为[3,-4]，为-4.\n    它的和为-4，所以最大子数组和的和为-4.\n    >>> find_max_subarray([1, -2, 3, -4])\n    -4\n    >>> find_max_subarray([-1, -2, -3, -4])\n    -1\n    >>> find_max_subarray([-5, -10, ", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[j] == arr[i]:\n                ans += arr[i]\n    return ans\n\n\ndef find_max_subarray(arr):\n    '''\n        求最大子数组和\n    一个数组可能有负数，但是如果数组中最大的数是正数，那么数组的和是正数，所以不会变成负数。\n    例如[1,-2,3,-4]，最大子数组和为[3,-4]，为-4.\n    它的和为-4，所以最大子数组和的和为-4.\n    >>> find_max_subarray([1, -2, 3, -4])\n    -4\n    >>> find_max_subarray([-1, -2, -3, -4])\n    -1\n    >>> find_max_subarray([-5, -10, "}
{"task_id": "MBPP/42", "completion": "\n    if len(arr) == 0:\n        return 0\n    ans = 0\n    set = set()\n    for key in arr:\n        if key in set:\n            ans += key\n        else:\n            set.add(key)\n    return ans\n\n\n### 寻找数组中所有重复出现过的字符串的首字母\n## \ndef find_All(arr): \n    '''\n    给你一个字符串数组，请你找出其中所有 互不相同 的单词，顺序保持不变。\n    \n    输入: [\"this\", \"is\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification\"]\n    输出: [\"this\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification\"]\n    注意:\n        1.   假设您的函数只接受单词表作为输入，并且返回单��", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    if len(arr) == 0:\n        return 0\n    ans = 0\n    set = set()\n    for key in arr:\n        if key in set:\n            ans += key\n        else:\n            set.add(key)\n    return ans\n\n\n### 寻找数组中所有重复出现过的字符串的首字母\n## \ndef find_All(arr): \n    '''\n    给你一个字符串数组，请你找出其中所有 互不相同 的单词，顺序保持不变。\n    \n    输入: [\"this\", \"is\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification\"]\n    输出: [\"this\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification\"]\n    注意:\n        1.   假设您的函数只接受单词表作为输入，并且返回单��"}
{"task_id": "MBPP/42", "completion": "\n    dict = {}\n    total = 0\n    for i in arr:\n        dict[i] = dict.get(i, 0) + 1\n    for key in dict:\n        total += dict[key] * key\n    return total\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dict = {}\n    total = 0\n    for i in arr:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict[", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dict = {}\n    total = 0\n    for i in arr:\n        dict[i] = dict.get(i, 0) + 1\n    for key in dict:\n        total += dict[key] * key\n    return total\n\ndef find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    dict = {}\n    total = 0\n    for i in arr:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict["}
{"task_id": "MBPP/42", "completion": "\n    arr.sort()  # 对数组进行排序\n    # 定义一个变量和一个哈希表\n    sum_ = 0  # 记录最后的和\n    dic = {}  # 建立哈希表\n    # 将元素依次存放到哈希表中\n    for x in arr:\n        # 如果哈希表中不存在这个元素，则存入哈希表\n        if x not in dic:\n            dic[x] = 1\n        else:  # 如果哈希表中存在这个元素，则将它的次数进行累加\n            dic[x] += 1\n    # 将所有元素依次从哈希表中取出，并根据次数计算它们在结果中的贡献\n    for x in arr:\n        sum_ += dic[x] * x\n    return sum_\n\n\ndef", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    arr.sort()  # 对数组进行排序\n    # 定义一个变量和一个哈希表\n    sum_ = 0  # 记录最后的和\n    dic = {}  # 建立哈希表\n    # 将元素依次存放到哈希表中\n    for x in arr:\n        # 如果哈希表中不存在这个元素，则存入哈希表\n        if x not in dic:\n            dic[x] = 1\n        else:  # 如果哈希表中存在这个元素，则将它的次数进行累加\n            dic[x] += 1\n    # 将所有元素依次从哈希表中取出，并根据次数计算它们在结果中的贡献\n    for x in arr:\n        sum_ += dic[x] * x\n    return sum_\n\n\ndef"}
{"task_id": "MBPP/42", "completion": "\n    d = dict() \n    s = 0\n    for i in arr:\n        if i not in d.keys():\n            d[i] = i\n        else:\n            d[i] += i\n    return d\n\nif __name__ == \"__main__\":\n    arr = [1,1,2,3,2,4]\n    print(find_Sum(arr))\n```\n\n\n### 算法分析\n1. 递归函数中，栈空间静态分配(递归层数不固定)：\n![栈空间静态分配](https://raw.githubusercontent.com/w-xuefeng/DataStructure_for_Algorithm/master/picture/stack_space_static.jpg)\n2. 递归函数中，栈空间动态分配(递归层数固定)：\n![栈空间动态分配](https://", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    d = dict() \n    s = 0\n    for i in arr:\n        if i not in d.keys():\n            d[i] = i\n        else:\n            d[i] += i\n    return d\n\nif __name__ == \"__main__\":\n    arr = [1,1,2,3,2,4]\n    print(find_Sum(arr))\n```\n\n\n### 算法分析\n1. 递归函数中，栈空间静态分配(递归层数不固定)：\n![栈空间静态分配](https://raw.githubusercontent.com/w-xuefeng/DataStructure_for_Algorithm/master/picture/stack_space_static.jpg)\n2. 递归函数中，栈空间动态分配(递归层数固定)：\n![栈空间动态分配](https://"}
{"task_id": "MBPP/42", "completion": "\n    sum = 0\n    for i in range(len(arr)):\n        if arr.count(arr[i])!= 1:\n            sum += arr[i] * arr.count(arr[i])\n    return sum\n\n\n    # 核心思路：\n    # 在这里我们使用了哈希表的特性，将出现过的元素都作为键，值为1，\n    # 如果出现过重复，则键对应的值+1，最终计算和就可以了。\n    # 即：元素出现n次，值为n次*原值\n    # 这里我们使用了python的in-operator，意味着如果在哈希表中没有\n    # 找到相应的键，就返回false，否则返回true。\n    # 所以我们可以把这个判断做为条件加入到 for循环", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    sum = 0\n    for i in range(len(arr)):\n        if arr.count(arr[i])!= 1:\n            sum += arr[i] * arr.count(arr[i])\n    return sum\n\n\n    # 核心思路：\n    # 在这里我们使用了哈希表的特性，将出现过的元素都作为键，值为1，\n    # 如果出现过重复，则键对应的值+1，最终计算和就可以了。\n    # 即：元素出现n次，值为n次*原值\n    # 这里我们使用了python的in-operator，意味着如果在哈希表中没有\n    # 找到相应的键，就返回false，否则返回true。\n    # 所以我们可以把这个判断做为条件加入到 for循环"}
{"task_id": "MBPP/42", "completion": "\n    s = 0\n    a = []\n    for i in arr:\n        if i not in a:\n            a.append(i)\n        else:\n            s += i\n    return s\n\n\ndef find_Max(arr):\n    '''\n    返回数组arr中所有元素的最大值。\n    >>> find_Max([1,1,2])\n    2\n    >>> find_Max([4, 5, 7, 5, 4, 8])\n    8\n    >>> find_Max([1,5,2,3])\n    5\n    '''\n    return max(arr)\n\ndef find_Min(arr):\n    '''\n    返回数组arr中所有元素的最小值。\n    >>> find_Min([1,1,2])\n    1\n    >>> find_Min([4, 5, 7, 5, 4, 8])\n    4\n    >>> find_Min([1,5,2,3])\n    1\n    '''\n    return min(arr)\n\ndef find_AllElements(", "allcode": "def find_Sum(arr): \n    '''\n        求一个数组中所有重复出现过的元素的和。\n    如果一个数字多次出现，那么它在计算和时应该被计算多次。\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    >>> find_Sum([1,1,2])\n    2\n    >>> find_Sum([4, 5, 7, 5, 4, 8])\n    18\n    '''\n    s = 0\n    a = []\n    for i in arr:\n        if i not in a:\n            a.append(i)\n        else:\n            s += i\n    return s\n\n\ndef find_Max(arr):\n    '''\n    返回数组arr中所有元素的最大值。\n    >>> find_Max([1,1,2])\n    2\n    >>> find_Max([4, 5, 7, 5, 4, 8])\n    8\n    >>> find_Max([1,5,2,3])\n    5\n    '''\n    return max(arr)\n\ndef find_Min(arr):\n    '''\n    返回数组arr中所有元素的最小值。\n    >>> find_Min([1,1,2])\n    1\n    >>> find_Min([4, 5, 7, 5, 4, 8])\n    4\n    >>> find_Min([1,5,2,3])\n    1\n    '''\n    return min(arr)\n\ndef find_AllElements("}
{"task_id": "MBPP/149", "completion": "\n    pass\n\n\ndef max_len_sub1(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([3, 1, 4, 5, 2])\n    6\n    '''\n    pass\n\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 5, 2, 3, 2, 4])\n    6\n    '''\n    pass\n\n\ndef max_len_sub3(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    pass\n\n\ndef max_len_sub1(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([3, 1, 4, 5, 2])\n    6\n    '''\n    pass\n\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 5, 2, 3, 2, 4])\n    6\n    '''\n    pass\n\n\ndef max_len_sub3(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差"}
{"task_id": "MBPP/149", "completion": "\n    length = 3\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 2] == 1:\n            length += 1\n    return length\n\ndef is_sort(arr: List[int]):\n    '''\n    给定一个数组arr，编写一个函数，判断arr是否是一个递增序列，如果是则返回True，否则返回False。\n    >>> is_sort([1, 2, 4, 5, 6])\n    True\n    >>> is_sort([1, 2, 6, 5, 4])\n    False\n    '''\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\n\ndef max_sub(arr: List[int]) -> List[int]:\n    '''\n    给定一个数组arr，编写一个函数，求arr中最长子序列的和，该子序列中相邻元素的差值为1。\n    如果数组中", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    length = 3\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 2] == 1:\n            length += 1\n    return length\n\ndef is_sort(arr: List[int]):\n    '''\n    给定一个数组arr，编写一个函数，判断arr是否是一个递增序列，如果是则返回True，否则返回False。\n    >>> is_sort([1, 2, 4, 5, 6])\n    True\n    >>> is_sort([1, 2, 6, 5, 4])\n    False\n    '''\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\n\ndef max_sub(arr: List[int]) -> List[int]:\n    '''\n    给定一个数组arr，编写一个函数，求arr中最长子序列的和，该子序列中相邻元素的差值为1。\n    如果数组中"}
{"task_id": "MBPP/149", "completion": "\n\n\n    max_length = 1\n    min_index = -1\n    curr_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            curr_length += 1\n            max_length = max(max_length, curr_length)\n        else:\n            # 因为已经遍历到i - 1的元素，所以在这里i - min_index是固定的\n            curr_length = i - min_index\n            min_index = i\n    return max_length\n\n\n\n\ndef max_len_sub_2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n\n    if not arr:\n        return 0\n    if len(arr) == 1:", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n\n\n    max_length = 1\n    min_index = -1\n    curr_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            curr_length += 1\n            max_length = max(max_length, curr_length)\n        else:\n            # 因为已经遍历到i - 1的元素，所以在这里i - min_index是固定的\n            curr_length = i - min_index\n            min_index = i\n    return max_length\n\n\n\n\ndef max_len_sub_2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n\n    if not arr:\n        return 0\n    if len(arr) == 1:"}
{"task_id": "MBPP/149", "completion": "\n    res = 1\n    for i in range(len(arr)-1):\n        if arr[i] == arr[i+1]:\n            continue\n        res = max(res, i+2-arr[i] if i+1-arr[i]<0 else i+2-arr[i])\n    return res\n\nif __name__ == \"__main__\":\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n```\n\n## 11\n```\nfrom typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    res = 1\n    for i in range(len(arr)-1):\n        if arr[i] == arr[i+1]:\n            continue\n        res = max", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    res = 1\n    for i in range(len(arr)-1):\n        if arr[i] == arr[i+1]:\n            continue\n        res = max(res, i+2-arr[i] if i+1-arr[i]<0 else i+2-arr[i])\n    return res\n\nif __name__ == \"__main__\":\n    print(max_len_sub([1, 2, 3, 4, 5, 3, 2]))\n```\n\n## 11\n```\nfrom typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    res = 1\n    for i in range(len(arr)-1):\n        if arr[i] == arr[i+1]:\n            continue\n        res = max"}
{"task_id": "MBPP/149", "completion": "\n    len1=len(arr)\n    if(len1<=1):\n        return len1\n    len2=1\n    dp=[1 for i in range(len1)]\n    diff=0\n    for i in range(1,len1):\n        if(arr[i]>arr[diff]):\n            dp[i]=dp[diff]+1\n        else:\n            while(diff>0 and arr[i]!=arr[diff]-1):\n                diff=dp[diff]\n            if(arr[i]==arr[diff]-1):\n                dp[i]=dp[diff]+1\n                if(dp[i]>len2):\n                    len2=dp[i]\n            else:\n                dp[i]=1\n                if(arr[i]!=arr[diff]):\n                    diff=i\n        # print(dp)\n    return len2\n\n\n'''\n题目描述\n给出函数max_of_subseq，该函数用于计算一个数组中的最长连续子序列的最大值（连续指连续元素之", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    len1=len(arr)\n    if(len1<=1):\n        return len1\n    len2=1\n    dp=[1 for i in range(len1)]\n    diff=0\n    for i in range(1,len1):\n        if(arr[i]>arr[diff]):\n            dp[i]=dp[diff]+1\n        else:\n            while(diff>0 and arr[i]!=arr[diff]-1):\n                diff=dp[diff]\n            if(arr[i]==arr[diff]-1):\n                dp[i]=dp[diff]+1\n                if(dp[i]>len2):\n                    len2=dp[i]\n            else:\n                dp[i]=1\n                if(arr[i]!=arr[diff]):\n                    diff=i\n        # print(dp)\n    return len2\n\n\n'''\n题目描述\n给出函数max_of_subseq，该函数用于计算一个数组中的最长连续子序列的最大值（连续指连续元素之"}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    max_len = 0\n    i = 0\n    while i < len(arr) - 1:\n        if arr[i] < arr[i+1]:\n            i += 1\n            temp_len = 1\n            while i < len(arr) - 1 and arr[i] < arr[i+1]:\n                temp_len += 1\n                i += 1\n            max_len = max(max_len, temp_len)\n        else:\n            i += 1\n    return max_len\n\ndef max_subarr_sum(nums:list) -> int:\n    '''\n    最大子序列和\n    '''\n    if not nums:\n        return 0\n    max_sum = nums[0]\n    sum = 0\n    for x in nums:\n        sum = max(sum + x, x)\n        max_sum = max(max_sum, sum)\n    return max_sum\n\ndef max_subarray(nums:list) -> int:\n    '''\n    最大", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    max_len = 0\n    i = 0\n    while i < len(arr) - 1:\n        if arr[i] < arr[i+1]:\n            i += 1\n            temp_len = 1\n            while i < len(arr) - 1 and arr[i] < arr[i+1]:\n                temp_len += 1\n                i += 1\n            max_len = max(max_len, temp_len)\n        else:\n            i += 1\n    return max_len\n\ndef max_subarr_sum(nums:list) -> int:\n    '''\n    最大子序列和\n    '''\n    if not nums:\n        return 0\n    max_sum = nums[0]\n    sum = 0\n    for x in nums:\n        sum = max(sum + x, x)\n        max_sum = max(max_sum, sum)\n    return max_sum\n\ndef max_subarray(nums:list) -> int:\n    '''\n    最大"}
{"task_id": "MBPP/149", "completion": "\n    dp = [1 for i in arr]\n    max_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]+1:\n            dp[i] = dp[i-1]+1\n        elif arr[i] == arr[i-1]-1 and dp[i-1] > 0:\n            dp[i] = dp[i-1]+1\n        else:\n            dp[i] = 1\n\n        max_length = max(max_length, dp[i])\n    return max_length\n\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub2([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    dp = [1 for i in arr]\n    max_length = 1\n    for", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    dp = [1 for i in arr]\n    max_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]+1:\n            dp[i] = dp[i-1]+1\n        elif arr[i] == arr[i-1]-1 and dp[i-1] > 0:\n            dp[i] = dp[i-1]+1\n        else:\n            dp[i] = 1\n\n        max_length = max(max_length, dp[i])\n    return max_length\n\n\ndef max_len_sub2(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub2([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    dp = [1 for i in arr]\n    max_length = 1\n    for"}
{"task_id": "MBPP/149", "completion": "\n```\n\n## 排序算法\n\n### 冒泡排序\n\n```python\ndef bubbleSort(arr):\n    '''\n    冒泡排序\n    对数组进行遍历，如果相邻元素大小逆序，则交换位置，否则跳过。\n    '''\n    for i in range(0, len(arr)): \n        for j in range(0, len(arr) - 1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n```\n\n### 选择排序\n\n```python\ndef selectionSort(arr):\n    '''\n    选择排序\n    在数组中选出一个最小值到最前面，然后在剩下的数组中重复上面的过程\n    '''\n    for i in range(0, len(arr)-1):\n        min = i\n        for j in range(", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n```\n\n## 排序算法\n\n### 冒泡排序\n\n```python\ndef bubbleSort(arr):\n    '''\n    冒泡排序\n    对数组进行遍历，如果相邻元素大小逆序，则交换位置，否则跳过。\n    '''\n    for i in range(0, len(arr)): \n        for j in range(0, len(arr) - 1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n```\n\n### 选择排序\n\n```python\ndef selectionSort(arr):\n    '''\n    选择排序\n    在数组中选出一个最小值到最前面，然后在剩下的数组中重复上面的过程\n    '''\n    for i in range(0, len(arr)-1):\n        min = i\n        for j in range("}
{"task_id": "MBPP/149", "completion": "\n    # 记录最长子序列的长度\n    max_len = 0\n    # 记录最长子序列的最大差值，最大差值的定义是子序列中相邻两个数的差值\n    max_diff = 0\n\n    # 当前子序列的最大差值\n    current_diff = 0\n    # 当前子序列的长度\n    current_len = 0\n\n    for i, item in enumerate(arr):\n        if i == len(arr) - 1:\n            current_diff = arr[i] - arr[i-1]\n            if max_diff < current_diff:\n                max_diff = current_diff\n            current_len += 1\n        elif arr[i] - arr[i-1] == 1:\n            current_diff = arr[i] - arr[i-1]\n            current_len += 1\n        else:\n            if max_len < current_len:\n                max_len = current_len\n                max_diff = current_diff\n            current_len = 1\n           ", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    # 记录最长子序列的长度\n    max_len = 0\n    # 记录最长子序列的最大差值，最大差值的定义是子序列中相邻两个数的差值\n    max_diff = 0\n\n    # 当前子序列的最大差值\n    current_diff = 0\n    # 当前子序列的长度\n    current_len = 0\n\n    for i, item in enumerate(arr):\n        if i == len(arr) - 1:\n            current_diff = arr[i] - arr[i-1]\n            if max_diff < current_diff:\n                max_diff = current_diff\n            current_len += 1\n        elif arr[i] - arr[i-1] == 1:\n            current_diff = arr[i] - arr[i-1]\n            current_len += 1\n        else:\n            if max_len < current_len:\n                max_len = current_len\n                max_diff = current_diff\n            current_len = 1\n           "}
{"task_id": "MBPP/149", "completion": "\n    if not arr:\n        return\n    dp = [1 for _ in range(len(arr))]\n    res = 1\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] == arr[j] + 1:\n                dp[i] = max(dp[", "allcode": "from typing import List\ndef max_len_sub(arr:List[int]):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长子序列的长度，该子序列中相邻元素的差值为1。\n    >>> max_len_sub([1, 2, 3, 4, 5, 3, 2])\n    6\n    '''\n    if not arr:\n        return\n    dp = [1 for _ in range(len(arr))]\n    res = 1\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] == arr[j] + 1:\n                dp[i] = max(dp["}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr) # 观察序列的长度是否大于等于2\n   if n <= 2: # 如果是长度小于等于2，返回序列长度\n      return n \n   l = [0] * n # 初始化，长度为n的一维数组，元素都是0\n   l[0] = 1 # 第i个元素(i从1开始)最长递增子序列的长度等于1\n   l[1] = 1 # 第i个元素(i从1开始)最长递减子序列的长度等于1\n   for i in range(2, n): # 从2开始，依次访问每个元素\n       dp = max(l[i-1], l[i-2])+1 if arr[i] >= arr[i-1] and arr[i] >= arr[i-2] else 1 # 比较递增与递减的子序列的长度，取最大值，加1\n       l[i] = dp # 给定元素的最长双调子序列的长度等于dp\n   return max(l) # 返回所有元素中最长的那个元素对应的最长双调子序列的长度\n\n\nif __name__ == \"__main__\":\n   test_case = [[1, 2, 3, 4, 5, 3, 2], [5,1,2,3,4,5,4,3,2]]\n   for i in test_case:\n      result = lbs(i)\n      print(result)\n   \n```\n\n# 20. 柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr) # 观察序列的长度是否大于等于2\n   if n <= 2: # 如果是长度小于等于2，返回序列长度\n      return n \n   l = [0] * n # 初始化，长度为n的一维数组，元素都是0\n   l[0] = 1 # 第i个元素(i从1开始)最长递增子序列的长度等于1\n   l[1] = 1 # 第i个元素(i从1开始)最长递减子序列的长度等于1\n   for i in range(2, n): # 从2开始，依次访问每个元素\n       dp = max(l[i-1], l[i-2])+1 if arr[i] >= arr[i-1] and arr[i] >= arr[i-2] else 1 # 比较递增与递减的子序列的长度，取最大值，加1\n       l[i] = dp # 给定元素的最长双调子序列的长度等于dp\n   return max(l) # 返回所有元素中最长的那个元素对应的最长双调子序列的长度\n\n\nif __name__ == \"__main__\":\n   test_case = [[1, 2, 3, 4, 5, 3, 2], [5,1,2,3,4,5,4,3,2]]\n   for i in test_case:\n      result = lbs(i)\n      print(result)\n   \n```\n\n# 20. 柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每"}
{"task_id": "MBPP/v522", "completion": "\n   if len(arr) < 2:\n       return 1\n   t = []  # 保存每一步的结果\n   t.append(1)\n   for i in range(1, len(arr)):\n       if arr[i] < arr[i - 1]:\n           t.append(1)\n       else:\n           t.append(1 + min(t[i - 1], t[i - 2]))\n   return max(t) \n\n\n# 给定一个数组arr，编写一个函数，求arr中的最长回文子序列的长度，回文序列指序列是一个回文串。\ndef lps(arr): \n   '''\n    >>> a = [1, 4, 4, 3, 8, 8] \n    >>> lps(a) \n    3\n    '''\n   r = 0\n   l = 0\n   for i in arr:\n       if l > 0 and arr[i] < arr[i - l]:\n           t = max(r, l)\n           l = t\n       else:\n           r = l\n           l += 1\n   return max(r, l)\n\n\n\n# 给定一个数组A，存放的是一个二叉树的层序遍历，编写一个函数，计算出叶子节点的个数。(叶子节点是指不再有子节点的节点)\ndef count_leaves(A): \n   '''\n   给定一个数组A，存放的是一个二叉树的层序遍历，编写一个函数，计算出叶子节点的个数。(叶子节点是指不再有子节点的节点)\n    >>> count_leaves([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   if len(arr) < 2:\n       return 1\n   t = []  # 保存每一步的结果\n   t.append(1)\n   for i in range(1, len(arr)):\n       if arr[i] < arr[i - 1]:\n           t.append(1)\n       else:\n           t.append(1 + min(t[i - 1], t[i - 2]))\n   return max(t) \n\n\n# 给定一个数组arr，编写一个函数，求arr中的最长回文子序列的长度，回文序列指序列是一个回文串。\ndef lps(arr): \n   '''\n    >>> a = [1, 4, 4, 3, 8, 8] \n    >>> lps(a) \n    3\n    '''\n   r = 0\n   l = 0\n   for i in arr:\n       if l > 0 and arr[i] < arr[i - l]:\n           t = max(r, l)\n           l = t\n       else:\n           r = l\n           l += 1\n   return max(r, l)\n\n\n\n# 给定一个数组A，存放的是一个二叉树的层序遍历，编写一个函数，计算出叶子节点的个数。(叶子节点是指不再有子节点的节点)\ndef count_leaves(A): \n   '''\n   给定一个数组A，存放的是一个二叉树的层序遍历，编写一个函数，计算出叶子节点的个数。(叶子节点是指不再有子节点的节点)\n    >>> count_leaves([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11"}
{"task_id": "MBPP/v522", "completion": "\n   # 双调子序列长度\n   lds_len = 0\n   # 某个元素的上一个元素\n   _arr = [-1] * len(arr)\n   idx = 0\n   for i in range(len(arr)):\n       # 该元素大于上一个元素，说明子序列开始\n       if arr[i] > arr[_arr[i]]:\n           # 如果子序列比当前的更短，则当前子序列更新为之前的\n           lds_len = max(lds_len, i - _arr[i])\n           _arr[i] = idx\n           idx += 1\n       # 否则，该元素与上一个元素是同递增或同递减的，比如升序或降序的数组\n       else:\n           # 查找第1个比当前元素大的元素\n           while arr[i] <= arr[_arr[i]]:\n               _arr[i] = _arr[_arr[i]]\n           # 如果子序列比当前的更短，则当前子序列更新为之前的\n           lds_len = max(lds_len, i - _arr[i])\n           _arr[i] = _arr[i]\n   # 返回最长双调子序列的长度\n   return lds_len\n \n \narr = [5,1,2,3,4,5,4,3,2]\nprint('最长双调子序列长度：', lbs(arr))\n \n\n```\n\n```python\ndef lds(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长单调子序列的长度，单调子序列指该序列按照递增或递减的顺序排列。\n    >>> lds", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   # 双调子序列长度\n   lds_len = 0\n   # 某个元素的上一个元素\n   _arr = [-1] * len(arr)\n   idx = 0\n   for i in range(len(arr)):\n       # 该元素大于上一个元素，说明子序列开始\n       if arr[i] > arr[_arr[i]]:\n           # 如果子序列比当前的更短，则当前子序列更新为之前的\n           lds_len = max(lds_len, i - _arr[i])\n           _arr[i] = idx\n           idx += 1\n       # 否则，该元素与上一个元素是同递增或同递减的，比如升序或降序的数组\n       else:\n           # 查找第1个比当前元素大的元素\n           while arr[i] <= arr[_arr[i]]:\n               _arr[i] = _arr[_arr[i]]\n           # 如果子序列比当前的更短，则当前子序列更新为之前的\n           lds_len = max(lds_len, i - _arr[i])\n           _arr[i] = _arr[i]\n   # 返回最长双调子序列的长度\n   return lds_len\n \n \narr = [5,1,2,3,4,5,4,3,2]\nprint('最长双调子序列长度：', lbs(arr))\n \n\n```\n\n```python\ndef lds(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长单调子序列的长度，单调子序列指该序列按照递增或递减的顺序排列。\n    >>> lds"}
{"task_id": "MBPP/v522", "completion": "\n   n=len(arr)\n   if n<=1:\n      return n\n   dp=[1]*n\n   pre_max=arr[0]\n   for idx in range(1,n):\n      if arr[idx]>pre_max:\n         pre_max=arr[idx]\n         dp[idx]=dp[idx-1]+1\n      else:\n         start=idx-1\n         while start>=0 and arr[start]>arr[idx]:\n            start-=1\n         pre_max=arr[start]\n         dp[idx]=dp[start]+1\n   ret=0\n   for x in range(n):\n      ret=max(ret,dp[x])\n   return ret\n```\n\n### lds (最长下降子序列)\n\n```python\ndef lds(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长下降子序列的长度。\n    >>> lds([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n=len(arr)\n   if n<=1:\n      return n\n   dp=[1]*n\n   pre_max=arr[0]\n   for idx in range(1,n):\n      if arr[idx]<pre_max:\n         pre_max=arr[idx]\n         dp[idx]=dp[idx-1]+1\n      else:\n         start=idx-1\n         while start>=0 and arr[start]<arr[idx]:\n            start-=1\n         pre_max=arr[start]\n         dp[idx]=dp[start]+1\n   ret=0\n   for x in range(n):\n      ret=max(ret,dp[x])\n   return ret\n```\n\n### lcp (最长公共上升子序列)\n\n>在一个字符串中找到一个字符串的最长公共上升字串，即当����", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n=len(arr)\n   if n<=1:\n      return n\n   dp=[1]*n\n   pre_max=arr[0]\n   for idx in range(1,n):\n      if arr[idx]>pre_max:\n         pre_max=arr[idx]\n         dp[idx]=dp[idx-1]+1\n      else:\n         start=idx-1\n         while start>=0 and arr[start]>arr[idx]:\n            start-=1\n         pre_max=arr[start]\n         dp[idx]=dp[start]+1\n   ret=0\n   for x in range(n):\n      ret=max(ret,dp[x])\n   return ret\n```\n\n### lds (最长下降子序列)\n\n```python\ndef lds(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长下降子序列的长度。\n    >>> lds([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n=len(arr)\n   if n<=1:\n      return n\n   dp=[1]*n\n   pre_max=arr[0]\n   for idx in range(1,n):\n      if arr[idx]<pre_max:\n         pre_max=arr[idx]\n         dp[idx]=dp[idx-1]+1\n      else:\n         start=idx-1\n         while start>=0 and arr[start]<arr[idx]:\n            start-=1\n         pre_max=arr[start]\n         dp[idx]=dp[start]+1\n   ret=0\n   for x in range(n):\n      ret=max(ret,dp[x])\n   return ret\n```\n\n### lcp (最长公共上升子序列)\n\n>在一个字符串中找到一个字符串的最长公共上升字串，即当����"}
{"task_id": "MBPP/v522", "completion": "\n   m = []\n   n = len(arr)\n   dp = [1] * n # i开头的数组长度为1\n   for i in range(n-1):\n       if arr[i] < arr[i+1]:\n           dp[i+1] = dp[i] + 1\n           m.append(arr[i+1])\n   \n   for i in range(1, n):\n       if arr[i-1] > arr[i]:\n           dp[i] = max(dp[i], dp[i-1] + 1)\n           m.append(arr[i])\n   return dp[n-1], m\n\n# 最长上升子序列问题\ndef lis(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长上升子序列的长度。\n    >>> lis([1, 2, 3, 4, 5, 3, 2])\n    4\n    >>> lis([5,1,2,3,4,5,4,3,2])\n    7\n    '''\n   m = []\n   n = len(arr)\n   dp = [1] * n # i开头的数组长度为1\n   for i in range(n-1):\n       if arr[i] < arr[i+1]:\n           dp[i+1] = dp[i] + 1\n           m.append(arr[i+1])\n   \n   for i in range(n-1):\n       for j in range(i+1, n):\n           if arr[j] > arr[i]:\n               dp[j] = max(dp[j], dp[i] + 1)\n               m.append(arr[j])\n   return dp[n-1], m\n\n# 0-1背包问题\ndef knapSack(W, w, v): \n   '''\n    有一个背包总共有", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   m = []\n   n = len(arr)\n   dp = [1] * n # i开头的数组长度为1\n   for i in range(n-1):\n       if arr[i] < arr[i+1]:\n           dp[i+1] = dp[i] + 1\n           m.append(arr[i+1])\n   \n   for i in range(1, n):\n       if arr[i-1] > arr[i]:\n           dp[i] = max(dp[i], dp[i-1] + 1)\n           m.append(arr[i])\n   return dp[n-1], m\n\n# 最长上升子序列问题\ndef lis(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长上升子序列的长度。\n    >>> lis([1, 2, 3, 4, 5, 3, 2])\n    4\n    >>> lis([5,1,2,3,4,5,4,3,2])\n    7\n    '''\n   m = []\n   n = len(arr)\n   dp = [1] * n # i开头的数组长度为1\n   for i in range(n-1):\n       if arr[i] < arr[i+1]:\n           dp[i+1] = dp[i] + 1\n           m.append(arr[i+1])\n   \n   for i in range(n-1):\n       for j in range(i+1, n):\n           if arr[j] > arr[i]:\n               dp[j] = max(dp[j], dp[i] + 1)\n               m.append(arr[j])\n   return dp[n-1], m\n\n# 0-1背包问题\ndef knapSack(W, w, v): \n   '''\n    有一个背包总共有"}
{"task_id": "MBPP/v522", "completion": "\n   if arr is None or len(arr) == 0: \n      return 0 \n   dp = [1]*len(arr)\n   for i in range(1, len(arr)): \n       if arr[i] > arr[i - 1]: \n           dp[i] = dp[i - 1] + 1\n       else: \n           temp = 1\n           while i - temp >= 0 and arr[i] < arr[i - temp]: \n               temp += 1\n           temp = temp - 1\n           dp[i] = temp + 1\n   return max(dp) \n\ndef lbs1(arr): \n   '''\n   >>> lbs1([1, 2, 3, 4, 5, 3, 2])\n   >>> lbs1([5,1,2,3,4,5,4,3,2])\n   '''\n   res = [1] * len(arr)\n   for i in range(1, len(arr)): \n       temp = 1\n       while i - temp >= 0 and arr[i] < arr[i - temp]: \n           temp += 1\n       temp = temp - 1\n       if i - temp - 1 >= 0:\n           res[i] = max(res[i - temp - 1], temp + 1)\n       else:\n           res[i] = temp + 1\n   return max(res)\n\ndef flip_str(str):\n    '''\n    给出一个字符串str，每次能进行两种操作，1.首尾拼接 2.去掉最后一个字符，请问在最后一步总是能将字符串变成回文串\n    示例： \n        1.abcde， 去掉e， 就变成了abc， 在最后一步能将字符串变成回文串\n        2.abcde， 去掉d， 就变成了abe， 在最后一��", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   if arr is None or len(arr) == 0: \n      return 0 \n   dp = [1]*len(arr)\n   for i in range(1, len(arr)): \n       if arr[i] > arr[i - 1]: \n           dp[i] = dp[i - 1] + 1\n       else: \n           temp = 1\n           while i - temp >= 0 and arr[i] < arr[i - temp]: \n               temp += 1\n           temp = temp - 1\n           dp[i] = temp + 1\n   return max(dp) \n\ndef lbs1(arr): \n   '''\n   >>> lbs1([1, 2, 3, 4, 5, 3, 2])\n   >>> lbs1([5,1,2,3,4,5,4,3,2])\n   '''\n   res = [1] * len(arr)\n   for i in range(1, len(arr)): \n       temp = 1\n       while i - temp >= 0 and arr[i] < arr[i - temp]: \n           temp += 1\n       temp = temp - 1\n       if i - temp - 1 >= 0:\n           res[i] = max(res[i - temp - 1], temp + 1)\n       else:\n           res[i] = temp + 1\n   return max(res)\n\ndef flip_str(str):\n    '''\n    给出一个字符串str，每次能进行两种操作，1.首尾拼接 2.去掉最后一个字符，请问在最后一步总是能将字符串变成回文串\n    示例： \n        1.abcde， 去掉e， 就变成了abc， 在最后一步能将字符串变成回文串\n        2.abcde， 去掉d， 就变成了abe， 在最后一��"}
{"task_id": "MBPP/v522", "completion": "\n    n = len(arr)\n    dp = [1]*n\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef lbs2(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    n = len(arr)\n    dp = [1]*n\n    prev = [0]*n\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j] and dp[i] < dp[j]+1:\n                dp[i] = dp[j]+1\n                prev[i] = j\n    return [dp, prev]\n\ndef lbs3(arr):\n    '''\n    >>> lbs3([1, 2, 3, 1, 2])\n    [1, 2, 2]\n    '''\n    n = len(arr)\n    dp = [1]*n\n    prev = [0]*n\n    res = []\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j] and dp[i] < dp[j]+1:\n                dp[i] = dp[j]+1\n                prev[i] = j\n        res.append(i)\n    return [dp, prev, res]\n\ndef lbs4(arr):\n    '''\n    给定一个数组arr，编写一个", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    n = len(arr)\n    dp = [1]*n\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef lbs2(arr):\n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs2([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs2([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    n = len(arr)\n    dp = [1]*n\n    prev = [0]*n\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j] and dp[i] < dp[j]+1:\n                dp[i] = dp[j]+1\n                prev[i] = j\n    return [dp, prev]\n\ndef lbs3(arr):\n    '''\n    >>> lbs3([1, 2, 3, 1, 2])\n    [1, 2, 2]\n    '''\n    n = len(arr)\n    dp = [1]*n\n    prev = [0]*n\n    res = []\n    for i in range(n):\n        for j in range(i+1):\n            if arr[i] > arr[j] and dp[i] < dp[j]+1:\n                dp[i] = dp[j]+1\n                prev[i] = j\n        res.append(i)\n    return [dp, prev, res]\n\ndef lbs4(arr):\n    '''\n    给定一个数组arr，编写一个"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   l = [1]*n\n   for i in range(1, n):\n       for j in range(i):\n           if arr[i] > arr[j] and l[i] < l[j]+1:\n               l[i] = l[j]+1\n   return max(l)\n\ndef lbs2(arr, dp = {}): \n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    if arr in dp:\n        return dp[arr]\n    n = len(arr)\n    l = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and l[i] < l[j] + 1:\n                l[i] = l[j] + 1\n    res = l[n-1]\n    for i in range(1, n):\n        res = max(res, l[i])\n    dp[arr] = res\n    return res\n\ndef lbs3(arr):\n    n = len(arr)\n    l = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j] and l[i] < l[j] + 1:\n                l[i] = l[j] + 1\n        res = l[n - 1]\n        for i in range(n):\n            res = max(res, l[i])\n    return res\n\n\nif __name__ == '__main__':\n    print(lbs([5, 1,", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   l = [1]*n\n   for i in range(1, n):\n       for j in range(i):\n           if arr[i] > arr[j] and l[i] < l[j]+1:\n               l[i] = l[j]+1\n   return max(l)\n\ndef lbs2(arr, dp = {}): \n    '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n    if arr in dp:\n        return dp[arr]\n    n = len(arr)\n    l = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and l[i] < l[j] + 1:\n                l[i] = l[j] + 1\n    res = l[n-1]\n    for i in range(1, n):\n        res = max(res, l[i])\n    dp[arr] = res\n    return res\n\ndef lbs3(arr):\n    n = len(arr)\n    l = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j] and l[i] < l[j] + 1:\n                l[i] = l[j] + 1\n        res = l[n - 1]\n        for i in range(n):\n            res = max(res, l[i])\n    return res\n\n\nif __name__ == '__main__':\n    print(lbs([5, 1,"}
{"task_id": "MBPP/v522", "completion": "\n   '''\n   1 \n   最长的增序子序列的长度也就是数组的长度\n   2 \n   最长的递增子序列的长度是给定数组的长度\n   3 \n   最大的不增子序列的长度也是给定数组的长度\n   4 \n   最长的递减子序列的长度也就是数组的长度\n   '''\n   if not arr: return 0\n   len_arr = len(arr)\n   dp = [1 for i in range(len_arr)]\n   # 这里是最长增序子序列的长度\n   max_num = arr[0]\n   for i in range(1, len_arr):\n       if arr[i] > max_num:\n           dp[i] = dp[i - 1] + 1\n           max_num = arr[i]\n       elif arr[i] < max_num:\n           max_num = arr[i]\n           dp[i] = 1\n   max_num = arr[len_", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   '''\n   1 \n   最长的增序子序列的长度也就是数组的长度\n   2 \n   最长的递增子序列的长度是给定数组的长度\n   3 \n   最大的不增子序列的长度也是给定数组的长度\n   4 \n   最长的递减子序列的长度也就是数组的长度\n   '''\n   if not arr: return 0\n   len_arr = len(arr)\n   dp = [1 for i in range(len_arr)]\n   # 这里是最长增序子序列的长度\n   max_num = arr[0]\n   for i in range(1, len_arr):\n       if arr[i] > max_num:\n           dp[i] = dp[i - 1] + 1\n           max_num = arr[i]\n       elif arr[i] < max_num:\n           max_num = arr[i]\n           dp[i] = 1\n   max_num = arr[len_"}
{"task_id": "MBPP/v522", "completion": "\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]>arr[j]:\n            if dp[i]<1+dp[j]:\n               dp[i]=1+dp[j]\n   return max(dp)\n\ndef hrs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长递减子序列的长度。\n    >>> hrs([1, 2, 3, 4, 5, 3, 2])\n    3\n    >>> hrs([5,1,2,3,4,5,4,3,2])\n    4\n    '''\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]<arr[j]:\n            if dp[i]<1+dp[j]:\n               dp[i]=1+dp[j]\n   return max(dp)\n\ndef ls(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长跳跃子序列的长度。\n    >>> ls([1, 2, 3, 4, 5, 3, 2])\n    4\n    >>> ls([5,1,2,3,4,5,4,3,2])\n    5\n    '''\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]-arr[j]<=dp[i]:\n            dp[i]=arr[i]-arr[j]\n   return max(dp)\n\ndef ls2(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr", "allcode": "def lbs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长双调子序列的长度，双调序列指该序列先递增，再递减。\n    >>> lbs([1, 2, 3, 4, 5, 3, 2])\n    7\n    >>> lbs([5,1,2,3,4,5,4,3,2])\n    8\n    '''\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]>arr[j]:\n            if dp[i]<1+dp[j]:\n               dp[i]=1+dp[j]\n   return max(dp)\n\ndef hrs(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长递减子序列的长度。\n    >>> hrs([1, 2, 3, 4, 5, 3, 2])\n    3\n    >>> hrs([5,1,2,3,4,5,4,3,2])\n    4\n    '''\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]<arr[j]:\n            if dp[i]<1+dp[j]:\n               dp[i]=1+dp[j]\n   return max(dp)\n\ndef ls(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr中的最长跳跃子序列的长度。\n    >>> ls([1, 2, 3, 4, 5, 3, 2])\n    4\n    >>> ls([5,1,2,3,4,5,4,3,2])\n    5\n    '''\n   n = len(arr)\n   dp = [1 for _ in range(n)]\n   for i in range(n):\n      for j in range(i):\n         if arr[i]-arr[j]<=dp[i]:\n            dp[i]=arr[i]-arr[j]\n   return max(dp)\n\ndef ls2(arr): \n   '''\n    给定一个数组arr，编写一个函数，求arr"}
{"task_id": "MBPP/v564", "completion": "\n    return sum([i<j and arr[i]!=arr[j] for i in range(len(arr)) for j in range(i+1,len(arr))])\n\n# 二分查找(针对排好序的数组)\n# 一般查找的时间复杂度是O(n)\n# 针对排好序的数组，可以用二分法的方式，将查找的复杂度降低为O(logn)\n# 不过要求数组必须是有序的\ndef binary_search(target,arr):\n    '''\n    对于一个排好序的数组arr，\n    查找某个元素target是否在数组arr中。\n    如果存在，返回target的索引，否则返回-1。\n    >>> binary_search(1,[1, 2, 3, 4])\n    0\n    >>> binary_search(", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    return sum([i<j and arr[i]!=arr[j] for i in range(len(arr)) for j in range(i+1,len(arr))])\n\n# 二分查找(针对排好序的数组)\n# 一般查找的时间复杂度是O(n)\n# 针对排好序的数组，可以用二分法的方式，将查找的复杂度降低为O(logn)\n# 不过要求数组必须是有序的\ndef binary_search(target,arr):\n    '''\n    对于一个排好序的数组arr，\n    查找某个元素target是否在数组arr中。\n    如果存在，返回target的索引，否则返回-1。\n    >>> binary_search(1,[1, 2, 3, 4])\n    0\n    >>> binary_search("}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    count = 0\n    arr.sort()\n    for i in range(n):\n        j = i + 1\n        k = n - 1\n        while j < k:\n            if arr[i]!= arr[j]:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    count = 0\n    n = len(arr)\n    for i in range(n - 1):\n        for j in", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    count = 0\n    arr.sort()\n    for i in range(n):\n        j = i + 1\n        k = n - 1\n        while j < k:\n            if arr[i]!= arr[j]:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    count = 0\n    n = len(arr)\n    for i in range(n - 1):\n        for j in"}
{"task_id": "MBPP/v564", "completion": "\n    ans = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i+1, l):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\n\ndef count_Triplets(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素三元组的个数。\n    不相等的元素三元组指的是一组(arr[i],arr[j],arr[k])，其中i < j < k且arr[i]!= arr[j]!= arr[k]。\n    >>> count_Triplets([1, 2, 3, 4, 5])\n    10\n    >>> count_Triplets([1, 2, 3, 4, 5])\n    10\n    '''\n    ans = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i+1,l", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    ans = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i+1, l):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\n\ndef count_Triplets(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素三元组的个数。\n    不相等的元素三元组指的是一组(arr[i],arr[j],arr[k])，其中i < j < k且arr[i]!= arr[j]!= arr[k]。\n    >>> count_Triplets([1, 2, 3, 4, 5])\n    10\n    >>> count_Triplets([1, 2, 3, 4, 5])\n    10\n    '''\n    ans = 0\n    l = len(arr)\n    for i in range(l):\n        for j in range(i+1,l"}
{"task_id": "MBPP/v564", "completion": "\n    c = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                c += 1\n    return c\n\nprint(count_Pairs([1, 2, 3, 4]))\nprint(count_Pairs([1, 1, 1]))\n\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    c = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1,", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    c = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                c += 1\n    return c\n\nprint(count_Pairs([1, 2, 3, 4]))\nprint(count_Pairs([1, 1, 1]))\n\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    c = 0\n    for i in range(len(arr)-1):\n        for j in range(i+1,"}
{"task_id": "MBPP/v564", "completion": "\n    count = 0\n    length = len(arr)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if arr[i]!= arr[j]:\n                count += 1\n                \n    return count\n\ndef number_Of_Words_In_A_Book(arr, n):\n    '''\n    编写一段程序，用于统计输入的字符串数组中，包含的单词数量。\n    输入的数组arr每个元素均以字符串的形式给出。\n    输入的数组arr中每个元素的长度都是不超过20个字符。\n    >>> number_Of_Words_In_A_Book(['hello world!', 'hello world!'], 1024)\n    2\n    >>> number_Of_Words_In_A_Book(['hello world!', 'goodbye world!'], 1024)\n    2\n    >>> number_Of_Words_In_A_Book(['", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    count = 0\n    length = len(arr)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if arr[i]!= arr[j]:\n                count += 1\n                \n    return count\n\ndef number_Of_Words_In_A_Book(arr, n):\n    '''\n    编写一段程序，用于统计输入的字符串数组中，包含的单词数量。\n    输入的数组arr每个元素均以字符串的形式给出。\n    输入的数组arr中每个元素的长度都是不超过20个字符。\n    >>> number_Of_Words_In_A_Book(['hello world!', 'hello world!'], 1024)\n    2\n    >>> number_Of_Words_In_A_Book(['hello world!', 'goodbye world!'], 1024)\n    2\n    >>> number_Of_Words_In_A_Book(['"}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    arr.sort()\n    c = 0\n    for i in range(n - 1):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        j = i + 1\n        while j < n and arr[i]!= arr[j]:\n            j += 1\n        c += j - i - 1\n    return c\n\n\ndef count_Triplets(arr, target): \n    '''\n    给定一个值为正整数的数组arr，编写一个函数，计算符合下列条件的子数组个数。\n    每个子数组都包含数值sum，且sum 是值为正整数的数组arr的一个倍数。\n    题目保证sum在[1, 100000]范围内，即arr中每个数字都是[1, ", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    arr.sort()\n    c = 0\n    for i in range(n - 1):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        j = i + 1\n        while j < n and arr[i]!= arr[j]:\n            j += 1\n        c += j - i - 1\n    return c\n\n\ndef count_Triplets(arr, target): \n    '''\n    给定一个值为正整数的数组arr，编写一个函数，计算符合下列条件的子数组个数。\n    每个子数组都包含数值sum，且sum 是值为正整数的数组arr的一个倍数。\n    题目保证sum在[1, 100000]范围内，即arr中每个数字都是[1, "}
{"task_id": "MBPP/v564", "completion": "\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\ndef count_Pairs(arr): \n    '''\n", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]!= arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]!= arr[j]:\n                ans += 1\n    return ans\n\ndef count_Pairs(arr): \n    '''\n"}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i] == arr[j]:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i][j-1] + 1\n    res = 0\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                # (arr[i],arr[i])\n                res += dp[i][j] - 1\n            else:\n                res += dp[i][j]\n    return res\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i] == arr[j]:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i][j-1] + 1\n    res = 0\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                # (arr[i],arr[i])\n                res += dp[i][j] - 1\n            else:\n                res += dp[i][j]\n    return res\n\ndef count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i]"}
{"task_id": "MBPP/v564", "completion": "\n    '''\n    思路整理：\n    本质上是一个排序，后面一半的元素比前面一半的元素大，\n    排序完成后依次遍历不同的元素，累计即可。\n    '''\n    res = 0\n    # 排序\n    arr.sort()\n    # 遍历不同的元素\n    for i in range(0, len(arr) - 1):\n        j = i + 1\n        while j < len(arr):\n            if arr[i]!= arr[j]:\n                res += 1\n            j += 1\n    return res\n\ndef solution():\n    '''\n    >>> solution()\n    '''\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    print(count_Pairs(arr))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    '''\n    思路整理：\n    本质上是一个排序，后面一半的元素比前面一半的元素大，\n    排序完成后依次遍历不同的元素，累计即可。\n    '''\n    res = 0\n    # 排序\n    arr.sort()\n    # 遍历不同的元素\n    for i in range(0, len(arr) - 1):\n        j = i + 1\n        while j < len(arr):\n            if arr[i]!= arr[j]:\n                res += 1\n            j += 1\n    return res\n\ndef solution():\n    '''\n    >>> solution()\n    '''\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    print(count_Pairs(arr))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest."}
{"task_id": "MBPP/v564", "completion": "\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i]!= arr[j]:\n                res += 1\n    return res\n    \n\ndef numIdenticalPairs(A):\n    '''\n\n    A = [1,2,3,1]\n    :param A:\n    :return:\n    '''\n    return count_Pairs(A)\n\ndef reverse(A, start, end):\n    '''\n    A = [1,2,3,4]\n    start = 2\n    end = 3\n    :param A:\n    :param start:\n    :param end:\n    :return:\n    '''\n    for i in range(start + 1, end + 1):\n        A[i], A[start] = A[start], A[i]\n    return A\n\ndef reversePairs(A):\n    '''\n    A = [1,3,2,3,1]\n    :param A:\n    :return:", "allcode": "def count_Pairs(arr): \n    '''\n    给定一个数组arr，编写一个函数，求arr中所有不相等的元素对的个数。\n    不相等的元素对指的是一组(arr[i],arr[j])，其中i < j且arr[i] != arr[j]。\n    >>> count_Pairs([1, 2, 3, 4])\n    6\n    >>> count_Pairs([1, 1, 1])\n    0\n    '''\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i]!= arr[j]:\n                res += 1\n    return res\n    \n\ndef numIdenticalPairs(A):\n    '''\n\n    A = [1,2,3,1]\n    :param A:\n    :return:\n    '''\n    return count_Pairs(A)\n\ndef reverse(A, start, end):\n    '''\n    A = [1,2,3,4]\n    start = 2\n    end = 3\n    :param A:\n    :param start:\n    :param end:\n    :return:\n    '''\n    for i in range(start + 1, end + 1):\n        A[i], A[start] = A[start], A[i]\n    return A\n\ndef reversePairs(A):\n    '''\n    A = [1,3,2,3,1]\n    :param A:\n    :return:"}
{"task_id": "MBPP/train620", "completion": "\n    for i in range(1, len(arr)): \n        if arr[i] % arr[i - 1] == 0: \n            arr[i] = arr[i - 1] \n        else: \n            arr[i] = max(arr[i], arr[i - 1])\n    return max(arr)\n\n\ndef longest_increasing_subsequence(arr):\n    '''\n    给定一个数组arr，写一个函数，求arr中最长的子上升序列长度。\n    >>> longest_increasing_subsequence([10, 5, 3, 5, 6, 7, 7, 8, 9, 10])\n    5\n    >>> longest_increasing_subsequence([1, 10, 2, 9, 3, 8, 4, 7, 5, 6])\n    5\n    '''\n    # 数组长度\n    n = len(arr) \n  \n    # LIS数组，lis[i]表示以i结尾的子序列的最长上升子序列的长度\n    lis = [1 for i in range(n)] \n  \n    for i in range", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    for i in range(1, len(arr)): \n        if arr[i] % arr[i - 1] == 0: \n            arr[i] = arr[i - 1] \n        else: \n            arr[i] = max(arr[i], arr[i - 1])\n    return max(arr)\n\n\ndef longest_increasing_subsequence(arr):\n    '''\n    给定一个数组arr，写一个函数，求arr中最长的子上升序列长度。\n    >>> longest_increasing_subsequence([10, 5, 3, 5, 6, 7, 7, 8, 9, 10])\n    5\n    >>> longest_increasing_subsequence([1, 10, 2, 9, 3, 8, 4, 7, 5, 6])\n    5\n    '''\n    # 数组长度\n    n = len(arr) \n  \n    # LIS数组，lis[i]表示以i结尾的子序列的最长上升子序列的长度\n    lis = [1 for i in range(n)] \n  \n    for i in range"}
{"task_id": "MBPP/train620", "completion": "\n    from itertools import groupby\n    '''\n    满足相邻元素可以整除的集合，不同的排列相等，这里用set()去重\n    '''\n    ans = max(map(len, set([list(group) for key, group in groupby(sorted(arr))])))\n    return ans\n\n\n\ndef is_sorted(arr):\n    '''\n    给定一个数组 a，编写一个函数，判断所有元素是否按递增顺序排列。\n    >>> is_sorted([1, 3, 6, 13, 17, 18])\n    True\n    >>> is_sorted([2, 4, 8, 12])\n    True\n    '''\n    return all(a<=b for a, b in zip(arr, arr[1:]))\n\n\n\n\ndef is_pair_sorted(arr):\n    '''\n    给定一个数组 a，编写一个函数，判断所有元素是否按递增顺序排列。\n    >>> is_sorted([1, 3, 6, 13, 17, 18", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    from itertools import groupby\n    '''\n    满足相邻元素可以整除的集合，不同的排列相等，这里用set()去重\n    '''\n    ans = max(map(len, set([list(group) for key, group in groupby(sorted(arr))])))\n    return ans\n\n\n\ndef is_sorted(arr):\n    '''\n    给定一个数组 a，编写一个函数，判断所有元素是否按递增顺序排列。\n    >>> is_sorted([1, 3, 6, 13, 17, 18])\n    True\n    >>> is_sorted([2, 4, 8, 12])\n    True\n    '''\n    return all(a<=b for a, b in zip(arr, arr[1:]))\n\n\n\n\ndef is_pair_sorted(arr):\n    '''\n    给定一个数组 a，编写一个函数，判断所有元素是否按递增顺序排列。\n    >>> is_sorted([1, 3, 6, 13, 17, 18"}
{"task_id": "MBPP/train620", "completion": "\n    # 把数组排序\n    arr.sort()\n    # 设置两个变量，分别表示尝试枚举的位置和最大子集长度\n    sub_len = 0\n    try_index = 0\n    # 对数组进行遍历\n    for i in range(len(arr)):\n        # 如果可以整除\n        if i==0 or arr[i]%arr[i-1] == 0:\n            # 则更新最大子集长度\n            sub_len += 1\n        else:\n            # 否则，回溯，尝试下一个元素\n            sub_len -= 1\n            try_index += 1\n    return sub_len\n\ndef sub_sum(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的所有子集中最大的子集和。\n    >>> sub_sum([1, 2, 3, 4, 3])\n    9\n    >>> sub_sum([1, 2, 3, 4])\n    10\n    '''\n    arr.sort()\n    best", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    # 把数组排序\n    arr.sort()\n    # 设置两个变量，分别表示尝试枚举的位置和最大子集长度\n    sub_len = 0\n    try_index = 0\n    # 对数组进行遍历\n    for i in range(len(arr)):\n        # 如果可以整除\n        if i==0 or arr[i]%arr[i-1] == 0:\n            # 则更新最大子集长度\n            sub_len += 1\n        else:\n            # 否则，回溯，尝试下一个元素\n            sub_len -= 1\n            try_index += 1\n    return sub_len\n\ndef sub_sum(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的所有子集中最大的子集和。\n    >>> sub_sum([1, 2, 3, 4, 3])\n    9\n    >>> sub_sum([1, 2, 3, 4])\n    10\n    '''\n    arr.sort()\n    best"}
{"task_id": "MBPP/train620", "completion": "\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n\n    def merge(arr, l, mid, r):\n        '''\n        利用归并排序将arr分为若干组。\n        每一组中，如果相邻的两个元素能整除，则返回该组的大小，否则返回1\n        '''\n        size = 1\n        for i in range(l, r+1):\n            if i == mid:\n                size *= 2\n                i += 1\n            if arr[i] % arr[i - 1] == 0:\n                continue\n            else:\n                return size\n        return size\n\n    l, r = 0, len(arr) - 1\n    while l < r:\n        mid = (l + r) >> 1\n        i = merge(arr, l, mid, r)\n        k = merge(arr, l, l + i, mid)\n        l = l + i + k\n\n    return l\n\n\ndef largest_rectangle(height):\n    '''\n    给定一个数组，求其中最大的正方形.\n    >>> largest_rectangle([1", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n\n    def merge(arr, l, mid, r):\n        '''\n        利用归并排序将arr分为若干组。\n        每一组中，如果相邻的两个元素能整除，则返回该组的大小，否则返回1\n        '''\n        size = 1\n        for i in range(l, r+1):\n            if i == mid:\n                size *= 2\n                i += 1\n            if arr[i] % arr[i - 1] == 0:\n                continue\n            else:\n                return size\n        return size\n\n    l, r = 0, len(arr) - 1\n    while l < r:\n        mid = (l + r) >> 1\n        i = merge(arr, l, mid, r)\n        k = merge(arr, l, l + i, mid)\n        l = l + i + k\n\n    return l\n\n\ndef largest_rectangle(height):\n    '''\n    给定一个数组，求其中最大的正方形.\n    >>> largest_rectangle([1"}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    # dp[i][j]表示以a[i]结尾的最大子集的大小，且最后一个数相等\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    # 初始化\n    for i in range(n):\n        dp[i][i] = 1\n    # 递推\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i]%arr[j]==0:\n                dp[i][j] = max(dp[i][j-1]+1, dp[i+1][j])\n    return max([dp[i][n-1] for i in range(n)])\n\n\ndef largest_equal_subset(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以相等。\n    >>> largest_equal_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_equal_subset([2", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    # dp[i][j]表示以a[i]结尾的最大子集的大小，且最后一个数相等\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    # 初始化\n    for i in range(n):\n        dp[i][i] = 1\n    # 递推\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i]%arr[j]==0:\n                dp[i][j] = max(dp[i][j-1]+1, dp[i+1][j])\n    return max([dp[i][n-1] for i in range(n)])\n\n\ndef largest_equal_subset(arr):\n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以相等。\n    >>> largest_equal_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_equal_subset([2"}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort()\n    ans = 0\n    N = len(arr)\n    for i in range(N-1, 0, -1):\n        tmp = 0\n        j = i\n        while j < N:\n            if arr[j]%arr[i] == 0:\n                tmp += 1\n            j += 1\n        if tmp > ans:\n            ans = tmp\n    return ans\n\ndef main():\n    '''\n    主函数运行\n    '''\n    arr = [3, 1, 5, 9, 11, 25, 17, 19]\n    print(f'arr = {arr}, largest_subset(arr) = {largest_subset(arr)}')\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print(f'arr = {arr}, largest_subset(arr) = {largest_subset(arr)}')\n    arr = [2, 4, 8, 12]\n    print(f'arr", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort()\n    ans = 0\n    N = len(arr)\n    for i in range(N-1, 0, -1):\n        tmp = 0\n        j = i\n        while j < N:\n            if arr[j]%arr[i] == 0:\n                tmp += 1\n            j += 1\n        if tmp > ans:\n            ans = tmp\n    return ans\n\ndef main():\n    '''\n    主函数运行\n    '''\n    arr = [3, 1, 5, 9, 11, 25, 17, 19]\n    print(f'arr = {arr}, largest_subset(arr) = {largest_subset(arr)}')\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print(f'arr = {arr}, largest_subset(arr) = {largest_subset(arr)}')\n    arr = [2, 4, 8, 12]\n    print(f'arr"}
{"task_id": "MBPP/train620", "completion": "\n\n    return max([len(i) for i in get_divisible_subset(arr)])\n\n\n# 给定一个整数数组arr，编写一个函数，找出arr中所有子数组和为给定值sum的个数。\n# 注意：子数组可以是空子数组（0个元素），这种子数组要计数。\n# 范例：\n# 输入：[2, 4, 6, 8], 6\n# 输出：2\n# 解释：\n# 有两个子数组和为6：[2, 4]，[4, 6]\n# 输入：[2, 4, 6, 8], 10\n# 输出：0\n# 解释：\n# 没有子数组和为10\ndef subarray_count(arr, sum): \n    '''\n    >>> subarray_count([2, 4, 6, 8], 6)\n    2\n    >>> subarray_count([2, 4, 6, 8], 10)\n    0\n    '''\n\n    if not arr:\n        return 0\n\n   ", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n\n    return max([len(i) for i in get_divisible_subset(arr)])\n\n\n# 给定一个整数数组arr，编写一个函数，找出arr中所有子数组和为给定值sum的个数。\n# 注意：子数组可以是空子数组（0个元素），这种子数组要计数。\n# 范例：\n# 输入：[2, 4, 6, 8], 6\n# 输出：2\n# 解释：\n# 有两个子数组和为6：[2, 4]，[4, 6]\n# 输入：[2, 4, 6, 8], 10\n# 输出：0\n# 解释：\n# 没有子数组和为10\ndef subarray_count(arr, sum): \n    '''\n    >>> subarray_count([2, 4, 6, 8], 6)\n    2\n    >>> subarray_count([2, 4, 6, 8], 10)\n    0\n    '''\n\n    if not arr:\n        return 0\n\n   "}
{"task_id": "MBPP/train620", "completion": "\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if (arr[i] % arr[j]) == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n# 剑指Offer48-I\n\n## 题目描述\n\n输入一个整数数组，数组中的一个或多个整数组成一个子数组。求所有子数组的和的最大值。例如，输入的数组为\n\n```\n-2,11,-4,13,5,-2\n```\n\n输出为`33`，其中一个最大的子数组为`11,-4,13,5`。\n\n\n\n## 思路\n\n动态规划：\n\n```\nif dp[i] == 0:\n    dp[i] = max(nums[i],dp", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if (arr[i] % arr[j]) == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n```\n\n# 剑指Offer48-I\n\n## 题目描述\n\n输入一个整数数组，数组中的一个或多个整数组成一个子数组。求所有子数组的和的最大值。例如，输入的数组为\n\n```\n-2,11,-4,13,5,-2\n```\n\n输出为`33`，其中一个最大的子数组为`11,-4,13,5`。\n\n\n\n## 思路\n\n动态规划：\n\n```\nif dp[i] == 0:\n    dp[i] = max(nums[i],dp"}
{"task_id": "MBPP/train620", "completion": "\n\n    n = len(arr) # 数组长度\n    dp = [0] * (n+1) # 初始化dp数组\n\n    # 从大到小枚举当前元素\n    for i in range(n-1, -1, -1):\n        dp[i] = 1 # 默认第i个数是一个集合\n        j = i+1\n        while (j < n):\n            if (arr[i] % arr[j] == 0):\n                dp[i] = max(dp[i], dp[j]+1)\n            j += 1\n\n    return dp[0]\n\ndef maximum_sum_contiguous_subarray(arr):\n    '''\n    计算数组中具有最大和的连续子数组的和。\n    >>> maximum_sum_contiguous_subarray([34, -50, 42, 14, -5, 86])\n    130\n    >>> maximum_sum_contiguous_subarray([-1, -2, -3, -4, -5])\n    -1\n    '''\n\n    n = len(arr)\n    max_so_far =", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n\n    n = len(arr) # 数组长度\n    dp = [0] * (n+1) # 初始化dp数组\n\n    # 从大到小枚举当前元素\n    for i in range(n-1, -1, -1):\n        dp[i] = 1 # 默认第i个数是一个集合\n        j = i+1\n        while (j < n):\n            if (arr[i] % arr[j] == 0):\n                dp[i] = max(dp[i], dp[j]+1)\n            j += 1\n\n    return dp[0]\n\ndef maximum_sum_contiguous_subarray(arr):\n    '''\n    计算数组中具有最大和的连续子数组的和。\n    >>> maximum_sum_contiguous_subarray([34, -50, 42, 14, -5, 86])\n    130\n    >>> maximum_sum_contiguous_subarray([-1, -2, -3, -4, -5])\n    -1\n    '''\n\n    n = len(arr)\n    max_so_far ="}
{"task_id": "MBPP/train620", "completion": "\n    arr.sort()\n    max_len = 0\n    for i in range(1, len(arr)):\n        if arr[i-1] % arr[i] == 0:\n            max_len += 1\n        else:\n            max_len = max_len - 1 \n            if max_len < 0:\n                max_len = 0\n    return max_len\n\n# 3\ndef sum_of_integers(number):\n    '''\n    给出一个整数n,返回从1到n的所有整数的和。\n    >>> sum_of_integers(10)\n    55\n    >>> sum_of_integers(5)\n    15\n    '''\n    res = 0\n    for i in range(1, number+1):\n        res += i\n    return res\n\n# 4\ndef reverse(number): \n    '''\n    给出一个整数n，返回n的逆序数字。\n    >>> reverse(1234)\n    4321\n    >>> reverse(341)\n    143\n    >>> reverse(111)\n    111\n    '''\n    res = 0\n    number = str(", "allcode": "def largest_subset(arr): \n    '''\n    给定一个数组a，编写一个函数，求a的最大子集的大小，该子集中的相邻每一对元素都可以整除。\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([2, 4, 8, 12])\n    3\n    '''\n    arr.sort()\n    max_len = 0\n    for i in range(1, len(arr)):\n        if arr[i-1] % arr[i] == 0:\n            max_len += 1\n        else:\n            max_len = max_len - 1 \n            if max_len < 0:\n                max_len = 0\n    return max_len\n\n# 3\ndef sum_of_integers(number):\n    '''\n    给出一个整数n,返回从1到n的所有整数的和。\n    >>> sum_of_integers(10)\n    55\n    >>> sum_of_integers(5)\n    15\n    '''\n    res = 0\n    for i in range(1, number+1):\n        res += i\n    return res\n\n# 4\ndef reverse(number): \n    '''\n    给出一个整数n，返回n的逆序数字。\n    >>> reverse(1234)\n    4321\n    >>> reverse(341)\n    143\n    >>> reverse(111)\n    111\n    '''\n    res = 0\n    number = str("}
{"task_id": "MBPP/train689", "completion": "\n    # 返回值和参数至少有一个是列表,数组\n    if not arr:\n        return 0\n    min_sum = 0\n    max_jump = 0\n    for ele in range(len(arr)-1):\n        max_jump = max(max_jump, arr[ele])\n        if ele >= max_jump:\n            min_sum += 1\n            max_jump = 0\n    return min_sum\n\n\ndef max_sum(arr):\n    '''\n    编写一个函数，找出子数组的最大值之和，其中子数组是连续的元素，并且不包含重复元素。\n    >>> max_sum([3, -1, 5, 2, -1, 4])\n    9\n    '''\n    total = 0    # 累加器\n    max_sum = 0  # 最大和\n    for ele in arr:\n        total = max(total+ele, ele)\n        max_sum = max(max_sum,", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # 返回值和参数至少有一个是列表,数组\n    if not arr:\n        return 0\n    min_sum = 0\n    max_jump = 0\n    for ele in range(len(arr)-1):\n        max_jump = max(max_jump, arr[ele])\n        if ele >= max_jump:\n            min_sum += 1\n            max_jump = 0\n    return min_sum\n\n\ndef max_sum(arr):\n    '''\n    编写一个函数，找出子数组的最大值之和，其中子数组是连续的元素，并且不包含重复元素。\n    >>> max_sum([3, -1, 5, 2, -1, 4])\n    9\n    '''\n    total = 0    # 累加器\n    max_sum = 0  # 最大和\n    for ele in arr:\n        total = max(total+ele, ele)\n        max_sum = max(max_sum,"}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    if n == 1:\n        return 0\n    # 1. 确定初始状态\n    # 1.1 初始状态: 开始跳转的下标 index 和最小需要跳转的次数 count\n    index, count = 0, 0\n    # 1.2 遍历数组\n    while index < n - 1:\n        # 1.3 获取当前元素可以跳转的最大距离\n        curr_max_dist = arr[index]\n        # 1.4 找到有最大距离的下标\n        r = index + curr_max_dist\n        if r < n - 1:\n            # 1.5 如果找到了最大距离\n            # 则将对应元素的值更新为当前元素的值\n            arr[r] = arr[index]\n        else:\n            # 1.6 如果没有��", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    if n == 1:\n        return 0\n    # 1. 确定初始状态\n    # 1.1 初始状态: 开始跳转的下标 index 和最小需要跳转的次数 count\n    index, count = 0, 0\n    # 1.2 遍历数组\n    while index < n - 1:\n        # 1.3 获取当前元素可以跳转的最大距离\n        curr_max_dist = arr[index]\n        # 1.4 找到有最大距离的下标\n        r = index + curr_max_dist\n        if r < n - 1:\n            # 1.5 如果找到了最大距离\n            # 则将对应元素的值更新为当前元素的值\n            arr[r] = arr[index]\n        else:\n            # 1.6 如果没有��"}
{"task_id": "MBPP/train689", "completion": "\n    i, n = 0, len(arr)\n    jumps = [0] * n\n    for i in range(n):\n        jumps[i] = -1\n    jumps[n - 1] = 0\n    for i in range(n - 1, 0, -1):\n        if jumps[i] == -1: \n            jumps[i - 1] = min_jumps(arr[i:]) + 1\n        else:\n            jumps[i - 1] = jumps[i] + 1\n    return jumps[0]\n\ndef min_jumps_2(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    i, n = 0, len(arr)\n    jumps = [0] * n\n    for i in range(n):\n        jumps[i] = -1\n    jumps[n - 1] = 0\n    for i in range(n - 1, 0, -1):\n        if jumps[i] == -1: \n            jumps[i - 1] = min_jumps(arr[i:]) + 1\n        else:\n            jumps[i - 1] = jumps[i] + 1\n    return jumps[0]\n\ndef min_jumps_2(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n"}
{"task_id": "MBPP/train689", "completion": "\n    queue = [0]\n    visited = [False for i in arr]\n    visited[0] = True\n    count = 0\n    while queue:\n        count += 1\n        for i in range(len(queue)):\n            pos = queue.pop()\n            right = pos + arr[pos]\n            if right < len(arr) and not visited[right]:\n                queue.append(right)\n                visited[right] = True\n    \n    return count\n\n\nif __name__ == '__main__':\n    print(min_jumps([1, 3, 6, 13, 17, 18]))\n    print(min_jumps([1, 2, 4, 8, 9, 10, 16, 17, 18, 20]))\n    print(min_jumps([1, 2, 3, 4, 5]))\n    print(min_jumps([1, 2, 1]))\n    print(min_jumps([1, 0, 0, 0, 1, 0, 0]))\n    print(min", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    queue = [0]\n    visited = [False for i in arr]\n    visited[0] = True\n    count = 0\n    while queue:\n        count += 1\n        for i in range(len(queue)):\n            pos = queue.pop()\n            right = pos + arr[pos]\n            if right < len(arr) and not visited[right]:\n                queue.append(right)\n                visited[right] = True\n    \n    return count\n\n\nif __name__ == '__main__':\n    print(min_jumps([1, 3, 6, 13, 17, 18]))\n    print(min_jumps([1, 2, 4, 8, 9, 10, 16, 17, 18, 20]))\n    print(min_jumps([1, 2, 3, 4, 5]))\n    print(min_jumps([1, 2, 1]))\n    print(min_jumps([1, 0, 0, 0, 1, 0, 0]))\n    print(min"}
{"task_id": "MBPP/train689", "completion": "\n    # write code here\n    # 1. 最多能换次数\n    # 2. 递归地决定每一步到底能走多远\n    # 3. 优化方向： 只取最值的方向\n    max_num = 0\n    for i in arr:\n        max_num = max(max_num, i)\n    return dfs(arr, 1, max_num)\n\ndef dfs(arr, idx, max_num):\n    if idx >= len(arr)-1:\n        return 0\n\n    l = max(0, arr[idx])\n    r = min(len(arr)-1, arr[idx]+max_num)\n\n    ans = maxsize\n    for i in range(l, r+1):\n        ans = min(ans, 1+dfs(arr, i, max_num))\n    return ans\n\ndef min_jumps2(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素�", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # write code here\n    # 1. 最多能换次数\n    # 2. 递归地决定每一步到底能走多远\n    # 3. 优化方向： 只取最值的方向\n    max_num = 0\n    for i in arr:\n        max_num = max(max_num, i)\n    return dfs(arr, 1, max_num)\n\ndef dfs(arr, idx, max_num):\n    if idx >= len(arr)-1:\n        return 0\n\n    l = max(0, arr[idx])\n    r = min(len(arr)-1, arr[idx]+max_num)\n\n    ans = maxsize\n    for i in range(l, r+1):\n        ans = min(ans, 1+dfs(arr, i, max_num))\n    return ans\n\ndef min_jumps2(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素�"}
{"task_id": "MBPP/train689", "completion": "\n\n    n = len(arr)\n    if n == 0: return None\n\n    dp = [float('inf') for _ in range(n)] \n    # dp[i]: 从数组第 i 个元素跳转到末尾，需要的最少步数\n    dp[n - 1] = 0\n    # dp[i] 表示以数组第 i 个元素为终点时，最小的步数\n\n    for i in range(n - 2, -1, -1): \n        # 对数组进行逆向遍历\n        for j in range(i + 1, min(i + arr[i], n)): \n            # 从 i 到 j 的最小步数不超过 arr[i]，最大不超过 n\n            dp[i] = min(dp[i], dp[j] + 1)\n    return dp[0]\n\ndef max_sum_subarray(arr): \n    '''\n    编写一个", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n\n    n = len(arr)\n    if n == 0: return None\n\n    dp = [float('inf') for _ in range(n)] \n    # dp[i]: 从数组第 i 个元素跳转到末尾，需要的最少步数\n    dp[n - 1] = 0\n    # dp[i] 表示以数组第 i 个元素为终点时，最小的步数\n\n    for i in range(n - 2, -1, -1): \n        # 对数组进行逆向遍历\n        for j in range(i + 1, min(i + arr[i], n)): \n            # 从 i 到 j 的最小步数不超过 arr[i]，最大不超过 n\n            dp[i] = min(dp[i], dp[j] + 1)\n    return dp[0]\n\ndef max_sum_subarray(arr): \n    '''\n    编写一个"}
{"task_id": "MBPP/train689", "completion": "\n    n = len(arr)\n    min_steps = [0] * n\n    min_steps[n-1] = 0\n    for i in range(n-2, -1, -1):\n        j = 1\n        while (i + j < n and j < arr[i]):\n            if min_steps[i+j] == 0:\n                # 不能到达\n                j += 1\n            else:\n                j += min_steps[i+j]\n        min_steps[i] = j\n    return min_steps[0]\n```\n\n## Dijkstra算法\n1. 如果没有起始点，不能进行广度优先搜索，因此，Dijkstra算法不能成立。\n2. 如果存在负环，必然导致Dijkstra算法无法正常执行。假设图中任意一条边的权值为$w_i$，那么遍历这条边后，最短路径改变的", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    n = len(arr)\n    min_steps = [0] * n\n    min_steps[n-1] = 0\n    for i in range(n-2, -1, -1):\n        j = 1\n        while (i + j < n and j < arr[i]):\n            if min_steps[i+j] == 0:\n                # 不能到达\n                j += 1\n            else:\n                j += min_steps[i+j]\n        min_steps[i] = j\n    return min_steps[0]\n```\n\n## Dijkstra算法\n1. 如果没有起始点，不能进行广度优先搜索，因此，Dijkstra算法不能成立。\n2. 如果存在负环，必然导致Dijkstra算法无法正常执行。假设图中任意一条边的权值为$w_i$，那么遍历这条边后，最短路径改变的"}
{"task_id": "MBPP/train689", "completion": "\n    # step 1: check if the array is empty\n    if not arr:\n        return 0\n    # step 2: get the first element, which is the final number\n    step = 1\n    # step 3: using a while loop, get the min_step\n    n = len(arr) - 1\n    while n > 0:\n        # step 4: if the current element can reach the final number\n        if arr[n] >= n:\n            # step 5: the current element is the final number\n            step += 1\n            break\n        n -= 1\n    return step\n\n\narr = [1,3,6,13,17,18]\nmin_jumps(arr)\n```\n\n### 斐波那契数列\n\n- 定义：一个数列，从第 3 项开始，每一项都等于先前的两项之和\n- 斐波那契数列\n- 斐波那契递推公式：f(n) = f(n-1) + f", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # step 1: check if the array is empty\n    if not arr:\n        return 0\n    # step 2: get the first element, which is the final number\n    step = 1\n    # step 3: using a while loop, get the min_step\n    n = len(arr) - 1\n    while n > 0:\n        # step 4: if the current element can reach the final number\n        if arr[n] >= n:\n            # step 5: the current element is the final number\n            step += 1\n            break\n        n -= 1\n    return step\n\n\narr = [1,3,6,13,17,18]\nmin_jumps(arr)\n```\n\n### 斐波那契数列\n\n- 定义：一个数列，从第 3 项开始，每一项都等于先前的两项之和\n- 斐波那契数列\n- 斐波那契递推公式：f(n) = f(n-1) + f"}
{"task_id": "MBPP/train689", "completion": "\n    pass\n\n\ndef max_sub_array(arr: list) -> int:\n    '''\n    编写一个函数，找出包含正数的数组中的连续子数组的最大和。\n    >>> max_sub_array([-1, 2, 3, -9, 1])\n    5\n    >>> max_sub_array([-2, -3, 4, -1, -2, 1, 5, -3])\n    7\n    '''\n    pass\n\n\ndef max_candy_given(arr: list) -> int:\n    '''\n    编写一个函数，找出包含正数的数组中的连续子数组的最大和。\n    >>> max_candy_given([1, 2, 3])\n    6\n    >>> max_candy_given([2, 4, 6])\n    12\n    '''\n    pass\n\ndef max_trapping_water(arr: list) -> int:\n    '''\n    编写一个函数，��", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    pass\n\n\ndef max_sub_array(arr: list) -> int:\n    '''\n    编写一个函数，找出包含正数的数组中的连续子数组的最大和。\n    >>> max_sub_array([-1, 2, 3, -9, 1])\n    5\n    >>> max_sub_array([-2, -3, 4, -1, -2, 1, 5, -3])\n    7\n    '''\n    pass\n\n\ndef max_candy_given(arr: list) -> int:\n    '''\n    编写一个函数，找出包含正数的数组中的连续子数组的最大和。\n    >>> max_candy_given([1, 2, 3])\n    6\n    >>> max_candy_given([2, 4, 6])\n    12\n    '''\n    pass\n\ndef max_trapping_water(arr: list) -> int:\n    '''\n    编写一个函数，��"}
{"task_id": "MBPP/train689", "completion": "\n    # arr = [1, 3, 6, 8, 9, 13, 15, 21, 23, 27, 41, 57, 58, 75, 99]\n    # 设置一个数组跳跃数，用缓存来记录跳跃数\n    steps = [float('inf')] * len(arr)\n    # 记录最后数组的下标值\n    last = 0\n\n    # 最后一个数组的最后一个位置\n    steps[len(arr) - 1] = 0\n    # 用最后一个数的值来替代一个循环\n    for i in range(len(arr)-2, -1, -1):\n        for j in range(i+1, min(i+arr[i]+1, len(arr))): \n            steps[i] = 1 + min(steps[i], steps[j])\n\n        last = min(steps[i], last)\n    return", "allcode": "def min_jumps(arr): \n    '''\n    编写一个函数，找出从数组的第 1 个元素跳转到数组末尾的最少步数。对于给定的整数数组 \"arr\"，每个元素的值代表从该元素向前移动的最大步数。\n    >>> min_jumps([1, 3, 6, 13, 17, 18])\n    3\n    '''\n    # arr = [1, 3, 6, 8, 9, 13, 15, 21, 23, 27, 41, 57, 58, 75, 99]\n    # 设置一个数组跳跃数，用缓存来记录跳跃数\n    steps = [float('inf')] * len(arr)\n    # 记录最后数组的下标值\n    last = 0\n\n    # 最后一个数组的最后一个位置\n    steps[len(arr) - 1] = 0\n    # 用最后一个数的值来替代一个循环\n    for i in range(len(arr)-2, -1, -1):\n        for j in range(i+1, min(i+arr[i]+1, len(arr))): \n            steps[i] = 1 + min(steps[i], steps[j])\n\n        last = min(steps[i], last)\n    return"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef maxProfit(prices):\n    '''\n    给定一组价格 'prices', 计算你最多能赚多少钱。\n\n    >>> maxProfit([1, 8, 3, 5])\n    8\n    >>> maxProfit([1, 8, 3, 5])\n    6\n    '''\n    n = len(prices)\n    if n <= 0:\n        return 0\n    first = 0\n    max_profit = 0\n    for i in range(n):\n        first += prices[i]\n        max_profit = max(max_profit, first)\n        first -= prices[i]\n\n    return max_profit\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n\n    请你找出这两个有序数组的中位数，并且要求算法", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef maxProfit(prices):\n    '''\n    给定一组价格 'prices', 计算你最多能赚多少钱。\n\n    >>> maxProfit([1, 8, 3, 5])\n    8\n    >>> maxProfit([1, 8, 3, 5])\n    6\n    '''\n    n = len(prices)\n    if n <= 0:\n        return 0\n    first = 0\n    max_profit = 0\n    for i in range(n):\n        first += prices[i]\n        max_profit = max(max_profit, first)\n        first -= prices[i]\n\n    return max_profit\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n\n    请你找出这两个有序数组的中位数，并且要求算法"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef moveZeroes(nums):\n    '''\n    给定一个数组nums，编写一个函数将所有的0移动到数组的末尾，同时保证非零元素的相对位置不变。\n    注意：\n    必须在原数组上操作，不能拷贝额外的数组。\n    尽量减少操作次数\n    >>> moveZeroes([0,1,0,3,12])\n    [1, 3, 12, 0, 0]\n    >>> moveZeroes([0,1])\n    [1, 0]\n    >>> moveZeroes([0])\n    [0]\n    >>> moveZeroes([0,0,0,0,0])\n    [0, 0, 0, 0, 0]\n    '''\n    nums.reverse()\n    while 0 in nums:\n        nums.remove(0)\n    nums.reverse()\n\n", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef moveZeroes(nums):\n    '''\n    给定一个数组nums，编写一个函数将所有的0移动到数组的末尾，同时保证非零元素的相对位置不变。\n    注意：\n    必须在原数组上操作，不能拷贝额外的数组。\n    尽量减少操作次数\n    >>> moveZeroes([0,1,0,3,12])\n    [1, 3, 12, 0, 0]\n    >>> moveZeroes([0,1])\n    [1, 0]\n    >>> moveZeroes([0])\n    [0]\n    >>> moveZeroes([0,0,0,0,0])\n    [0, 0, 0, 0, 0]\n    '''\n    nums.reverse()\n    while 0 in nums:\n        nums.remove(0)\n    nums.reverse()\n\n"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == \"__main__\":\n    print(sumOfLeftLeaves(tree))\n    # print(maxDepth(tree))\n    # print(isSymmetric(tree))\n    # print(tree.val)\n    # print(mergeTrees(tree1, tree2).val)\n    print(invertTreePreOrder(tree3).val)\n    print(invertTreeInOrder(tree3).val)\n    print(invertTreePostOrder(tree3).val)\n    print(getMinimumDifference(bst))\n   ", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == \"__main__\":\n    print(sumOfLeftLeaves(tree))\n    # print(maxDepth(tree))\n    # print(isSymmetric(tree))\n    # print(tree.val)\n    # print(mergeTrees(tree1, tree2).val)\n    print(invertTreePreOrder(tree3).val)\n    print(invertTreeInOrder(tree3).val)\n    print(invertTreePostOrder(tree3).val)\n    print(getMinimumDifference(bst))\n   "}
{"task_id": "leetcode/21", "completion": "\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    Given two sorted linked lists list1 and list2, merge them together into one sorted list and return it.\n    '''\n    def merge(list1, list2):\n        if list1 and list2:\n            if list1.val <= list2.val:\n                dummy.next = list1\n                dummy = dummy.next\n                list1 = list1.next\n            else:\n                dummy.next = list2\n                dummy = dummy.next\n                list2 = list2.next\n        if list1:\n            dummy.next = list1\n        if list2:\n            dummy.next = list2\n        return dummy_head.next\n\n    dummy_head = ListNode(0)\n    dummy = dummy_head\n    while list1 and list2:\n        if list1.val <= list2.val:\n            dummy.next = list1\n            dummy = dummy.next\n            list1 = list1.next\n        else:\n            dummy.next = list2\n            dummy = dummy.next\n            list2 =", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef mergeTwoLists2(list1, list2):\n    '''\n    Given two sorted linked lists list1 and list2, merge them together into one sorted list and return it.\n    '''\n    def merge(list1, list2):\n        if list1 and list2:\n            if list1.val <= list2.val:\n                dummy.next = list1\n                dummy = dummy.next\n                list1 = list1.next\n            else:\n                dummy.next = list2\n                dummy = dummy.next\n                list2 = list2.next\n        if list1:\n            dummy.next = list1\n        if list2:\n            dummy.next = list2\n        return dummy_head.next\n\n    dummy_head = ListNode(0)\n    dummy = dummy_head\n    while list1 and list2:\n        if list1.val <= list2.val:\n            dummy.next = list1\n            dummy = dummy.next\n            list1 = list1.next\n        else:\n            dummy.next = list2\n            dummy = dummy.next\n            list2 ="}
{"task_id": "leetcode/21", "completion": "\n\n\ndef findMedianSortedArrays(list1, list2):\n    '''\n    给定两个大小分别为 m 和 n 的有序数组 nums1 和 nums2, 找到其中最小的一个元素。\n    示例:\n        输入:\n            nums1 = [1, 3], m = 2\n            nums2 = [2],     n = 1\n        输出: 2\n        提示:\n            你可以假设 nums1 和 nums2 不为空。\n            来源: 力扣（LeetCode）\n            链接: https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n    '''\n    list_merge = mergeTwoLists(list1, list2)\n    return list_merge[len(list_merge) // 2]\n\n\nif __name__ == '__main__':\n    list1 = [1, 2, 4]\n    list2", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef findMedianSortedArrays(list1, list2):\n    '''\n    给定两个大小分别为 m 和 n 的有序数组 nums1 和 nums2, 找到其中最小的一个元素。\n    示例:\n        输入:\n            nums1 = [1, 3], m = 2\n            nums2 = [2],     n = 1\n        输出: 2\n        提示:\n            你可以假设 nums1 和 nums2 不为空。\n            来源: 力扣（LeetCode）\n            链接: https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n    '''\n    list_merge = mergeTwoLists(list1, list2)\n    return list_merge[len(list_merge) // 2]\n\n\nif __name__ == '__main__':\n    list1 = [1, 2, 4]\n    list2"}
{"task_id": "leetcode/21", "completion": "\n```\n\n**反转整数**\n\n给出一个 32 位有符号整数，你需要将这个整数中每位上的数字反转过来（也就是，数字 1 变成数字 10000，12 变成 21）。如果输入的整数超过 32 位，请填充 0 向左补齐。\n\n**解法1：** 递归实现\n\n```python\ndef reverse(x: int) -> int:\n    '''\n    给出整数，将整数中每个位的数字反转\n    >>> reverse(123)\n    321\n    >>> reverse(-123)\n    -321\n    >>> reverse(1534236469)\n    0\n    '''\n    if x == 0:\n        return 0\n    reverse_first_part = reverse(x // 10", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n```\n\n**反转整数**\n\n给出一个 32 位有符号整数，你需要将这个整数中每位上的数字反转过来（也就是，数字 1 变成数字 10000，12 变成 21）。如果输入的整数超过 32 位，请填充 0 向左补齐。\n\n**解法1：** 递归实现\n\n```python\ndef reverse(x: int) -> int:\n    '''\n    给出整数，将整数中每个位的数字反转\n    >>> reverse(123)\n    321\n    >>> reverse(-123)\n    -321\n    >>> reverse(1534236469)\n    0\n    '''\n    if x == 0:\n        return 0\n    reverse_first_part = reverse(x // 10"}
{"task_id": "leetcode/21", "completion": "\n```\n\n### 31. 合并K个排序的数组\n\n```python\nListNode\n\nclass Solution:\n    @staticmethod\n    def mergeKLists(lists):\n        if lists is None or len(lists) == 0:\n            return None\n        return Solution.mergeKListsRecu(lists, 0, len(lists) - 1)\n\n    @staticmethod\n    def mergeKListsRecu(lists, left, right):\n        if left == right:\n            return lists[left]\n        elif left < right:\n            mid = (left + right) // 2\n            return Solution.mergeTwoLists(Solution.mergeKListsRecu(lists, left, mid), Solution.mergeKListsRecu(lists, mid + 1, right))\n```\n\n### 32. 求两个数的乘积\n\n```python\nclass Solution:\n    @staticmethod\n    def multiply(num1, num2):\n        '''\n        给定两个整数 num1 和 num", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n```\n\n### 31. 合并K个排序的数组\n\n```python\nListNode\n\nclass Solution:\n    @staticmethod\n    def mergeKLists(lists):\n        if lists is None or len(lists) == 0:\n            return None\n        return Solution.mergeKListsRecu(lists, 0, len(lists) - 1)\n\n    @staticmethod\n    def mergeKListsRecu(lists, left, right):\n        if left == right:\n            return lists[left]\n        elif left < right:\n            mid = (left + right) // 2\n            return Solution.mergeTwoLists(Solution.mergeKListsRecu(lists, left, mid), Solution.mergeKListsRecu(lists, mid + 1, right))\n```\n\n### 32. 求两个数的乘积\n\n```python\nclass Solution:\n    @staticmethod\n    def multiply(num1, num2):\n        '''\n        给定两个整数 num1 和 num"}
{"task_id": "leetcode/21", "completion": "\n\n\ndef hasCycle(head):\n    '''\n    Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\n    There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\n    Return true if there is a cycle in the linked list. Otherwise, return false.\n    >>> hasCycle([3, 2, 0, -4])\n    True\n    >>> hasCycle([1, 2])\n    False\n    >>> hasCycle([1])\n    False\n    '''\n\n    if not head:\n        return False\n    if head.next == head:\n        return True\n\n    fast = head.next\n    slow = head\n    while fast!= slow:\n        if fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        else:\n            return False\n    return True\n\n\n", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\ndef hasCycle(head):\n    '''\n    Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\n    There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\n    Return true if there is a cycle in the linked list. Otherwise, return false.\n    >>> hasCycle([3, 2, 0, -4])\n    True\n    >>> hasCycle([1, 2])\n    False\n    >>> hasCycle([1])\n    False\n    '''\n\n    if not head:\n        return False\n    if head.next == head:\n        return True\n\n    fast = head.next\n    slow = head\n    while fast!= slow:\n        if fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        else:\n            return False\n    return True\n\n\n"}
{"task_id": "leetcode/21", "completion": "\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.mergeKLists([\n        ListNode(1, ListNode(2, ListNode(4))),\n        ListNode(1, ListNode(3, ListNode(4)))\n    ]))\n    print(s.mergeKLists([\n        ListNode(0, ListNode(0)),\n        ListNode(1, ListNode(0))\n    ]))\n\n    print(s.mergeKLists([\n        ListNode(1, ListNode(3, ListNode(7))),\n        ListNode(0, ListNode(2, ListNode(6))),\n        ListNode(4, ListNode(5, ListNode(9)))\n    ]))\n\n    print(s.mergeKLists([\n        ListNode(-1, ListNode(0, ListNode(8, ListNode(9)))),\n        ListNode(0, ListNode(0, ListNode(1, ListNode(7)))),\n        ListNode(1, ListNode(1, ListNode(6, ListNode(9", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.mergeKLists([\n        ListNode(1, ListNode(2, ListNode(4))),\n        ListNode(1, ListNode(3, ListNode(4)))\n    ]))\n    print(s.mergeKLists([\n        ListNode(0, ListNode(0)),\n        ListNode(1, ListNode(0))\n    ]))\n\n    print(s.mergeKLists([\n        ListNode(1, ListNode(3, ListNode(7))),\n        ListNode(0, ListNode(2, ListNode(6))),\n        ListNode(4, ListNode(5, ListNode(9)))\n    ]))\n\n    print(s.mergeKLists([\n        ListNode(-1, ListNode(0, ListNode(8, ListNode(9)))),\n        ListNode(0, ListNode(0, ListNode(1, ListNode(7)))),\n        ListNode(1, ListNode(1, ListNode(6, ListNode(9"}
{"task_id": "leetcode/21", "completion": "\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        '''\n        给定一个链表数组，每个链表都已经按照插入顺序排好。\n        请你将所有链表合并成一个排序的链表，返回排序后的链表。\n\n        :param lists:\n        :return:\n        '''\n\n        n = len(lists)\n        if n == 0:\n            return lists\n\n        l = mergeTwoLists(lists[0], lists[1])\n        res = []\n        while len(l):\n            res.append(l[0])\n            l = del_first_element(l)\n        return res\n\n\nclass Solution2(object):\n    def mergeKLists(self, lists):\n        '''\n        给定一个链表数组，每个链表都已经按照插入顺序排好。", "allcode": "def mergeTwoLists(list1, list2):\n    '''\n    给定两个排序好的列表 'list1' 和 'list2', 把它们合并成一个排序好的列表。\n    >>> mergeTwoLists([1,2,4], [1,3,4])\n    [1, 1, 2, 3, 4, 4]\n    >>> mergeTwoLists([], [])\n    []\n    '''\n    list_res = list1 + list2\n    list_res.sort()\n    return list_res\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        '''\n        给定一个链表数组，每个链表都已经按照插入顺序排好。\n        请你将所有链表合并成一个排序的链表，返回排序后的链表。\n\n        :param lists:\n        :return:\n        '''\n\n        n = len(lists)\n        if n == 0:\n            return lists\n\n        l = mergeTwoLists(lists[0], lists[1])\n        res = []\n        while len(l):\n            res.append(l[0])\n            l = del_first_element(l)\n        return res\n\n\nclass Solution2(object):\n    def mergeKLists(self, lists):\n        '''\n        给定一个链表数组，每个链表都已经按照插入顺序排好。"}
{"task_id": "leetcode/35", "completion": "\n    if not nums or nums == []:\n        return -1\n    for index, num in enumerate(nums):\n        if num == target:\n            return index\n        elif num > target:\n            return index\n    return len(nums)\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    >>> singleNumber([4, 1, 2, 1, 2])\n    4\n    >>> singleNumber([1])\n    1\n    >>> singleNumber([4, 1, 2, 1, 4, 2])\n    1\n    '''\n    len_nums = 2 * len(nums)\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\n\ndef singleNumber2(nums):\n    '''\n    给定一", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if not nums or nums == []:\n        return -1\n    for index, num in enumerate(nums):\n        if num == target:\n            return index\n        elif num > target:\n            return index\n    return len(nums)\n\n\ndef singleNumber(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    >>> singleNumber([4, 1, 2, 1, 2])\n    4\n    >>> singleNumber([1])\n    1\n    >>> singleNumber([4, 1, 2, 1, 4, 2])\n    1\n    '''\n    len_nums = 2 * len(nums)\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\n\ndef singleNumber2(nums):\n    '''\n    给定一"}
{"task_id": "leetcode/35", "completion": "\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n\n    return left\n\n\nif __name__ == '__main__':\n    # 简单功能测试\n    data = [1,3,5,6]\n    print(searchInsert(data, 5))\n    print(searchInsert(data, 2))\n    print(searchInsert(data, 7))\n\n    # 时间复杂度统计测试\n    import time\n    start = time.time()\n    for i in range(10000000):\n        searchInsert([1,3,5,6], 7)\n    print(time.time() - start)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n\n    return left\n\n\nif __name__ == '__main__':\n    # 简单功能测试\n    data = [1,3,5,6]\n    print(searchInsert(data, 5))\n    print(searchInsert(data, 2))\n    print(searchInsert(data, 7))\n\n    # 时间复杂度统计测试\n    import time\n    start = time.time()\n    for i in range(10000000):\n        searchInsert([1,3,5,6], 7)\n    print(time.time() - start)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "leetcode/35", "completion": "\n    for i, v in enumerate(nums):\n        if v >= target:\n            return i\n    return len(nums)\n\n\ndef isUgly(num):\n    '''\n    给定一个整数，编写一个函数来判断它是否是丑数。\n    丑数就是只包含质因数 2, 3, 5的正整数。\n    >>> isUgly(6)\n    True\n    >>> isUgly(8)\n    False\n    >>> isUgly(14)\n    False\n    >>> isUgly(7)\n    True\n    '''\n    if num == 0:\n        return False\n    while True:\n        if num == 1:\n            return True\n        if num % 2 == 0:\n            num = num // 2\n        elif num % 3 == 0:\n            num = num // 3\n        elif num % 5 == 0:\n            num = num // 5\n        else:\n            return False\n\n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    for i, v in enumerate(nums):\n        if v >= target:\n            return i\n    return len(nums)\n\n\ndef isUgly(num):\n    '''\n    给定一个整数，编写一个函数来判断它是否是丑数。\n    丑数就是只包含质因数 2, 3, 5的正整数。\n    >>> isUgly(6)\n    True\n    >>> isUgly(8)\n    False\n    >>> isUgly(14)\n    False\n    >>> isUgly(7)\n    True\n    '''\n    if num == 0:\n        return False\n    while True:\n        if num == 1:\n            return True\n        if num % 2 == 0:\n            num = num // 2\n        elif num % 3 == 0:\n            num = num // 3\n        elif num % 5 == 0:\n            num = num // 5\n        else:\n            return False\n\n"}
{"task_id": "leetcode/35", "completion": "\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left == len(nums):\n        return 0\n\n    return left\n\n\n@time_cost\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    >>> twoSum([2, ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left == len(nums):\n        return 0\n\n    return left\n\n\n@time_cost\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    >>> twoSum([2, "}
{"task_id": "leetcode/35", "completion": "\n    if len(nums) == 0:\n        return 0\n    elif len(nums) == 1:\n        return 1\n    else:\n        for i in range(len(nums)):\n            if nums[i] >= target:\n                return i\n        else:\n            return len(nums)+1\n\n\ndef merge(nums1, m, nums2, n):\n    \"\"\"\n    >>> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n    [1,2,2,3,5,6]\n    \"\"\"\n    i = 0\n    j = 0\n    k = 0\n    while i < m and j < n:\n        if nums1[i] < nums2[j]:\n            nums1[k] = nums1[i]\n            i += 1\n        else:\n            nums1[k] = nums2[j]\n            j += 1\n        k += 1\n   ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if len(nums) == 0:\n        return 0\n    elif len(nums) == 1:\n        return 1\n    else:\n        for i in range(len(nums)):\n            if nums[i] >= target:\n                return i\n        else:\n            return len(nums)+1\n\n\ndef merge(nums1, m, nums2, n):\n    \"\"\"\n    >>> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n    [1,2,2,3,5,6]\n    \"\"\"\n    i = 0\n    j = 0\n    k = 0\n    while i < m and j < n:\n        if nums1[i] < nums2[j]:\n            nums1[k] = nums1[i]\n            i += 1\n        else:\n            nums1[k] = nums2[j]\n            j += 1\n        k += 1\n   "}
{"task_id": "leetcode/35", "completion": "\n    if target in nums:\n        return nums.index(target)\n    # 当target小于nums中的最小值时\n    if target < nums[0]:\n        return 0\n    # 当target大于nums中的最大值时\n    elif target > nums[-1]:\n        return len(nums)\n    # 在nums中寻找target的下标\n    else:\n        l, h = 0, len(nums) - 1\n        while l <= h:\n            m = (l + h) >> 1\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n                if nums[m] < nums[m + 1]:\n                    break\n            elif nums[m] > target:\n                h = m - 1\n                if nums[m - 1] < nums[m]:\n                    break\n\n        return l\n\nif __name__ == \"__main__\":\n    print", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    if target in nums:\n        return nums.index(target)\n    # 当target小于nums中的最小值时\n    if target < nums[0]:\n        return 0\n    # 当target大于nums中的最大值时\n    elif target > nums[-1]:\n        return len(nums)\n    # 在nums中寻找target的下标\n    else:\n        l, h = 0, len(nums) - 1\n        while l <= h:\n            m = (l + h) >> 1\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n                if nums[m] < nums[m + 1]:\n                    break\n            elif nums[m] > target:\n                h = m - 1\n                if nums[m - 1] < nums[m]:\n                    break\n\n        return l\n\nif __name__ == \"__main__\":\n    print"}
{"task_id": "leetcode/35", "completion": "\n    start, end = 0, len(nums) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return start\n    \ndef searchInsert(nums: List[int], target: int) -> int:\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    start, end = 0, len(nums) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return start\n    \ndef searchInsert(nums: List[int], target: int) -> int:\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)"}
{"task_id": "leetcode/35", "completion": "\n    l = len(nums)\n    if l == 0:\n        return 0\n    if l == 1:\n        if nums[0] == target:\n            return 0\n        if nums[0] < target:\n            return 1\n        return 0\n\n    n = int((l-1) / 2)\n    if nums[n] == target:\n        return n\n    if nums[n] < target:\n        if target <= nums[n+1]:\n            return n+1\n        return n+2\n    return n\n\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert2([1,3,5,6], ", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    l = len(nums)\n    if l == 0:\n        return 0\n    if l == 1:\n        if nums[0] == target:\n            return 0\n        if nums[0] < target:\n            return 1\n        return 0\n\n    n = int((l-1) / 2)\n    if nums[n] == target:\n        return n\n    if nums[n] < target:\n        if target <= nums[n+1]:\n            return n+1\n        return n+2\n    return n\n\ndef searchInsert2(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert2([1,3,5,6], "}
{"task_id": "leetcode/35", "completion": "\n    n = len(nums)\n    if target <= nums[0]:\n        return 0\n    if target >= nums[-1]:\n        return n\n\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) >> 1\n        if target < nums[mid]:\n            right = mid - 1\n        elif target > nums[mid]:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\ndef searchInsert2(nums, target):\n    '''\n    >>> searchInsert2([1,3,5,6], 5)\n    2\n    >>> searchInsert2([1,3,5,6], 2)\n    1\n    >>> searchInsert2([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    if target <= nums[0]:\n        return 0\n    if target >= nums[-1]:\n        return n\n\n    left, right = 0, n - 1\n    while left", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    if target <= nums[0]:\n        return 0\n    if target >= nums[-1]:\n        return n\n\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) >> 1\n        if target < nums[mid]:\n            right = mid - 1\n        elif target > nums[mid]:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\ndef searchInsert2(nums, target):\n    '''\n    >>> searchInsert2([1,3,5,6], 5)\n    2\n    >>> searchInsert2([1,3,5,6], 2)\n    1\n    >>> searchInsert2([1,3,5,6], 7)\n    4\n    '''\n    n = len(nums)\n    if target <= nums[0]:\n        return 0\n    if target >= nums[-1]:\n        return n\n\n    left, right = 0, n - 1\n    while left"}
{"task_id": "leetcode/35", "completion": "\n    return bisect.bisect_left(nums, target)\n", "allcode": "def searchInsert(nums, target):\n    '''\n    给定一个有序数组 'nums' 和一个目标值 'target', 如果 'target' 在数组中存在, 则返回它的索引。如果 'target' 不在数组中存在, 则返回它将会被按顺序插入的位置的索引。\n    >>> searchInsert([1,3,5,6], 5)\n    2\n    >>> searchInsert([1,3,5,6], 2)\n    1\n    >>> searchInsert([1,3,5,6], 7)\n    4\n    '''\n    return bisect.bisect_left(nums, target)\n"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 (nums) 和一个整数  (k), 判断数组中是否存在两个 相邻 的元素  (两个元素之间的绝对差不超过 k) 。\n    >>> containsNearbyDuplicate([1,2,3,1],2)\n    True\n    >>> containsNearbyDuplicate([1,0,1,1],1)\n    True\n    >>> containsNearbyDuplicate([1,2,3,1,2,3],2)\n    True\n    '''\n    if k < 1:\n        return False\n    for i in range(len(num", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n    return False\n\n\ndef containsNearbyDuplicate(nums, k):\n    '''\n    给定一个整数数组 (nums) 和一个整数  (k), 判断数组中是否存在两个 相邻 的元素  (两个元素之间的绝对差不超过 k) 。\n    >>> containsNearbyDuplicate([1,2,3,1],2)\n    True\n    >>> containsNearbyDuplicate([1,0,1,1],1)\n    True\n    >>> containsNearbyDuplicate([1,2,3,1,2,3],2)\n    True\n    '''\n    if k < 1:\n        return False\n    for i in range(len(num"}
{"task_id": "leetcode/217", "completion": "\n    len_nums = len(nums)\n    if len_nums == 0:\n        return False\n    elif len_nums == 1:\n        return False\n    else:\n        dict_nums = {}\n        for num in nums:\n            dict_nums[num] = 1\n        if len(dict_nums)!= len_nums:\n            return True\n        else:\n            return False\n\ndef containsDuplicate2(nums):\n    '''\n    >>> containsDuplicate2([1,2,3,1])\n    True\n    >>> containsDuplicate2([1,2,3,4])\n    False\n    '''\n    return len(set(nums))!= len(nums)\n\ndef containsDuplicate3(nums):\n    '''\n    >>> containsDuplicate3([1,2,3,1])\n    True\n    >>> containsDuplicate3([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsDup", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    len_nums = len(nums)\n    if len_nums == 0:\n        return False\n    elif len_nums == 1:\n        return False\n    else:\n        dict_nums = {}\n        for num in nums:\n            dict_nums[num] = 1\n        if len(dict_nums)!= len_nums:\n            return True\n        else:\n            return False\n\ndef containsDuplicate2(nums):\n    '''\n    >>> containsDuplicate2([1,2,3,1])\n    True\n    >>> containsDuplicate2([1,2,3,4])\n    False\n    '''\n    return len(set(nums))!= len(nums)\n\ndef containsDuplicate3(nums):\n    '''\n    >>> containsDuplicate3([1,2,3,1])\n    True\n    >>> containsDuplicate3([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsDup"}
{"task_id": "leetcode/217", "completion": "\n    return len(set(nums))!= len(nums)\n\n    # 第二种方法\n    # return len(set(nums))!= len(nums)\n\n\ndef validAnagram(s, t):\n    '''\n    给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n    >>> validAnagram('anagram', 'nagaram')\n    True\n    >>> validAnagram('rat', 'car')\n    False\n    '''\n    if len(s)!= len(t):\n        return False\n\n    from collections import Counter\n    s_counter = Counter(s)\n    t_counter = Counter(t)\n\n    return s_counter == t_counter\n\n\ndef reverseWords(s):\n    '''\n    给定一个字符串，逐个翻转字符串中的每个单词。\n    >>> reverseWords('  hello world!  ')\n    'world! hello'", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(set(nums))!= len(nums)\n\n    # 第二种方法\n    # return len(set(nums))!= len(nums)\n\n\ndef validAnagram(s, t):\n    '''\n    给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n    >>> validAnagram('anagram', 'nagaram')\n    True\n    >>> validAnagram('rat', 'car')\n    False\n    '''\n    if len(s)!= len(t):\n        return False\n\n    from collections import Counter\n    s_counter = Counter(s)\n    t_counter = Counter(t)\n\n    return s_counter == t_counter\n\n\ndef reverseWords(s):\n    '''\n    给定一个字符串，逐个翻转字符串中的每个单词。\n    >>> reverseWords('  hello world!  ')\n    'world! hello'"}
{"task_id": "leetcode/217", "completion": "\n    return len(nums)!= len(set(nums))\n\ndef findContinuousSequence(target):\n    '''\n    寻找和为目标值的连续子数组\n    输入: target = 9\n    输出: [[2,3,4],[4,5],[7]]\n    '''\n    result = []\n    seq = []\n    l = 0\n    r = 0\n    while l < r:\n        if sum(seq) < target:\n            seq.append(r+1)\n            r += 1\n            if sum(seq) == target:\n                result.append(seq[:])\n        else:\n            seq.pop(0)\n            l += 1\n    return result\n\ndef movingCount(m, n, k):\n    '''\n    岛屿的最大面积\n    给出一个由 0 和 1 组成的矩阵，其中 1 代表陆地和 0 代表水域。\n    请", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef findContinuousSequence(target):\n    '''\n    寻找和为目标值的连续子数组\n    输入: target = 9\n    输出: [[2,3,4],[4,5],[7]]\n    '''\n    result = []\n    seq = []\n    l = 0\n    r = 0\n    while l < r:\n        if sum(seq) < target:\n            seq.append(r+1)\n            r += 1\n            if sum(seq) == target:\n                result.append(seq[:])\n        else:\n            seq.pop(0)\n            l += 1\n    return result\n\ndef movingCount(m, n, k):\n    '''\n    岛屿的最大面积\n    给出一个由 0 和 1 组成的矩阵，其中 1 代表陆地和 0 代表水域。\n    请"}
{"task_id": "leetcode/217", "completion": "\n    # 先排序，然后检查相邻元素是否重复\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\ndef rotate(nums, k):\n    '''\n    将数组的前k个 移动到 数组的后面\n    >>> nums = [1,2,3,4,5,6,7]\n    >>> rotate(nums, 3)\n    >>> nums\n    [5,6,7,1,2,3,4]\n    '''\n    k = k % len(nums)\n    nums[:] = nums[len(nums)-k:]+nums[:len(nums)-k]\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素\n\n    方法一，排序，然后检查相", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 先排序，然后检查相邻元素是否重复\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n\ndef rotate(nums, k):\n    '''\n    将数组的前k个 移动到 数组的后面\n    >>> nums = [1,2,3,4,5,6,7]\n    >>> rotate(nums, 3)\n    >>> nums\n    [5,6,7,1,2,3,4]\n    '''\n    k = k % len(nums)\n    nums[:] = nums[len(nums)-k:]+nums[:len(nums)-k]\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素\n\n    方法一，排序，然后检查相"}
{"task_id": "leetcode/217", "completion": "\n    # 我的第一种方法\n    if len(nums) < 1:\n        return False\n    # 我的第二种方法\n    # 遍历一遍，对比元素是否相等\n    # 如果有相等的，则返回true\n    # for i in range(len(nums)):\n    #     for y in nums[i+1:]:\n    #         if nums[i]", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 我的第一种方法\n    if len(nums) < 1:\n        return False\n    # 我的第二种方法\n    # 遍历一遍，对比元素是否相等\n    # 如果有相等的，则返回true\n    # for i in range(len(nums)):\n    #     for y in nums[i+1:]:\n    #         if nums[i]"}
{"task_id": "leetcode/217", "completion": "\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i-1] == nums[i]:\n            return True\n    return False\n\ndef productExceptSelf(nums):\n    '''\n    给定一个长度为 n 的整数数组 nums, 其中 n > 1, 返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n    >>> productExceptSelf([1,2,3,4])\n    [24,12,8,6]\n    >>> productExceptSelf([-1,1,0,-3,3])\n    [0,-3,9,0,-3]\n    '''\n    n = len(nums)\n    result = [1]*n\n    for i in range(n):\n        for j in range(i+1, n):\n            result[i] *= nums[j]\n            result", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i-1] == nums[i]:\n            return True\n    return False\n\ndef productExceptSelf(nums):\n    '''\n    给定一个长度为 n 的整数数组 nums, 其中 n > 1, 返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n    >>> productExceptSelf([1,2,3,4])\n    [24,12,8,6]\n    >>> productExceptSelf([-1,1,0,-3,3])\n    [0,-3,9,0,-3]\n    '''\n    n = len(nums)\n    result = [1]*n\n    for i in range(n):\n        for j in range(i+1, n):\n            result[i] *= nums[j]\n            result"}
{"task_id": "leetcode/217", "completion": "\n    hash_map = {}\n    for i in nums :\n        if i in hash_map :\n            return True\n        hash_map[i] = 1\n    return False\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现两次或更多次，返回 true. 如果数组中每个元素都不相同，返回 false.\n    >>> containsDuplicate([1,2,3,4,5])\n    False\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,1,1,3,3,4,3,2,4,2])\n    True\n    >>> containsDuplicate([1, 2, 3, 4, 11, 12, 5, 6, 7, 8])\n    True\n    '''\n    hash_map = {}\n\n    for i in nums :", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    hash_map = {}\n    for i in nums :\n        if i in hash_map :\n            return True\n        hash_map[i] = 1\n    return False\n\n\ndef containsDuplicate2(nums):\n    '''\n    给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现两次或更多次，返回 true. 如果数组中每个元素都不相同，返回 false.\n    >>> containsDuplicate([1,2,3,4,5])\n    False\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,1,1,3,3,4,3,2,4,2])\n    True\n    >>> containsDuplicate([1, 2, 3, 4, 11, 12, 5, 6, 7, 8])\n    True\n    '''\n    hash_map = {}\n\n    for i in nums :"}
{"task_id": "leetcode/217", "completion": "\n    return len(nums)!= len(set(nums))\n\ndef containsDuplicateBetter(nums):\n    '''\n    使用集合的方式，更快。\n    >>> containsDuplicateBetter([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsDuplicate(nums):\n    '''\n    使用循环的方式完成\n    '''\n    for i in range(len(nums)):\n        if nums.count(nums[i]) > 1:\n            return True\n    return False\n\ndef containsDuplicate(nums: List[int]) -> bool:\n    '''\n    遍历每个元素，存储在字典中。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsDuplicateBetter(nums):\n    '''\n    使用集合的方式，更快。\n    >>> containsDuplicateBetter([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    return len(nums)!= len(set(nums))\n\ndef containsDuplicate(nums):\n    '''\n    使用循环的方式完成\n    '''\n    for i in range(len(nums)):\n        if nums.count(nums[i]) > 1:\n            return True\n    return False\n\ndef containsDuplicate(nums: List[int]) -> bool:\n    '''\n    遍历每个元素，存储在字典中。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False"}
{"task_id": "leetcode/217", "completion": "\n    # 这种方法很简单，但是效率不高\n    # 如果是有序的,可以用二分\n    numsNew = nums\n    # 先倒序排一下\n    numsNew.sort()\n    if numsNew[-1]!= numsNew[-2]:\n        return False\n    return True\n\n\ndef findDuplicate(nums):\n    '''\n\n    :param nums:\n    :return:\n    '''\n    # 哈希\n\n    # 解法1: 哈希\n    # 另：也可以用list来代替set，但是会浪费一些空间\n    # 思路：\n    # 1. 构建一个哈希表，如果i位置上的数字已经存在，那么就把这个i移到最后，即nums[i] = nums[-1]\n    # 2.", "allcode": "def containsDuplicate(nums):\n    '''\n    给定一个整数数组 'nums', 如果数组中存在重复元素, 则返回 true, 如果数组中不存在重复元素, 则返回 false。\n    >>> containsDuplicate([1,2,3,1])\n    True\n    >>> containsDuplicate([1,2,3,4])\n    False\n    '''\n    # 这种方法很简单，但是效率不高\n    # 如果是有序的,可以用二分\n    numsNew = nums\n    # 先倒序排一下\n    numsNew.sort()\n    if numsNew[-1]!= numsNew[-2]:\n        return False\n    return True\n\n\ndef findDuplicate(nums):\n    '''\n\n    :param nums:\n    :return:\n    '''\n    # 哈希\n\n    # 解法1: 哈希\n    # 另：也可以用list来代替set，但是会浪费一些空间\n    # 思路：\n    # 1. 构建一个哈希表，如果i位置上的数字已经存在，那么就把这个i移到最后，即nums[i] = nums[-1]\n    # 2."}
{"task_id": "leetcode/697", "completion": "\n    if len(nums) == 1:\n        return 1\n    counts = collections.Counter(nums)\n    maxs = list(counts.values())[0]\n    indexs = list(counts.keys())\n    start = -1\n    for i in range(len(nums)):\n        n = nums[i]\n        if counts[n] == maxs:\n            if start == -1:\n                start = i\n            end = i\n    return end - start + 1\n\n\n\n# 371 两整数之和\n# 输入: A = [1,2,3,4], B = [3,2,2,1]\n# 输出: 4\n# 解释:\n# 数组A中两两元素的和为: 1 + 2 = 3\n#        2 + 3 = 5\n#        3 + 4 = 7\n#        4 + 1 = 5\n# 数组B中两两元素的和为: 3 + 2 = 5\n#              2 + 2 = 4\n#              2 + 1 = 3\n#              ", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    if len(nums) == 1:\n        return 1\n    counts = collections.Counter(nums)\n    maxs = list(counts.values())[0]\n    indexs = list(counts.keys())\n    start = -1\n    for i in range(len(nums)):\n        n = nums[i]\n        if counts[n] == maxs:\n            if start == -1:\n                start = i\n            end = i\n    return end - start + 1\n\n\n\n# 371 两整数之和\n# 输入: A = [1,2,3,4], B = [3,2,2,1]\n# 输出: 4\n# 解释:\n# 数组A中两两元素的和为: 1 + 2 = 3\n#        2 + 3 = 5\n#        3 + 4 = 7\n#        4 + 1 = 5\n# 数组B中两两元素的和为: 3 + 2 = 5\n#              2 + 2 = 4\n#              2 + 1 = 3\n#              "}
{"task_id": "leetcode/697", "completion": "\n    max_frequency = 0\n    number_frequency = collections.Counter(nums)\n    max_len = len(nums)\n    for frequency in number_frequency.values():\n        if frequency > max_frequency:\n            max_frequency = frequency\n\n    for number, frequency in number_frequency.items():\n        if frequency == max_frequency:\n            min_len = len(nums)\n            start, end = 0, 0\n            for i in range(len(nums)):\n                if nums[i] == number:\n                    start = i\n                    break\n            for i in range(len(nums)):\n                if nums[end] == number:\n                    end = i\n                elif nums[end]!= number:\n                    end = i - 1\n            if min_len > (end - start + 1):\n                min_len = (end - start + 1)\n            end += 1\n\n    return min_len\n\ndef findShortestSubArray2(nums):\n    count = collections.Counter(nums)\n    result = float('inf')\n    sub_array = []\n    sub_array_", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    max_frequency = 0\n    number_frequency = collections.Counter(nums)\n    max_len = len(nums)\n    for frequency in number_frequency.values():\n        if frequency > max_frequency:\n            max_frequency = frequency\n\n    for number, frequency in number_frequency.items():\n        if frequency == max_frequency:\n            min_len = len(nums)\n            start, end = 0, 0\n            for i in range(len(nums)):\n                if nums[i] == number:\n                    start = i\n                    break\n            for i in range(len(nums)):\n                if nums[end] == number:\n                    end = i\n                elif nums[end]!= number:\n                    end = i - 1\n            if min_len > (end - start + 1):\n                min_len = (end - start + 1)\n            end += 1\n\n    return min_len\n\ndef findShortestSubArray2(nums):\n    count = collections.Counter(nums)\n    result = float('inf')\n    sub_array = []\n    sub_array_"}
{"task_id": "leetcode/697", "completion": "\n    # 注意这里我们的子数组是连续的，没有重复的元素\n    # 第一步：找到nums中出现频数最高的元素a，对应的出现频数为max_freq\n    # 第二步：找到出现频数为max_freq的元素最短的子数组min_sub_array_len\n    # 第三步：返回min_sub_array_len\n    # 第四步：时间复杂度为O(n)，空间复杂度为O(n)\n    count_dict = collections.Counter(nums)\n    max_freq = 0\n    max_frequent_num = 0\n    for key, value in count_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_frequent_num = key\n    min_sub_array_len = len(nums)\n    for key, value in count_dict.items():\n        if value == max_freq", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 注意这里我们的子数组是连续的，没有重复的元素\n    # 第一步：找到nums中出现频数最高的元素a，对应的出现频数为max_freq\n    # 第二步：找到出现频数为max_freq的元素最短的子数组min_sub_array_len\n    # 第三步：返回min_sub_array_len\n    # 第四步：时间复杂度为O(n)，空间复杂度为O(n)\n    count_dict = collections.Counter(nums)\n    max_freq = 0\n    max_frequent_num = 0\n    for key, value in count_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_frequent_num = key\n    min_sub_array_len = len(nums)\n    for key, value in count_dict.items():\n        if value == max_freq"}
{"task_id": "leetcode/697", "completion": "\n    num2count = collections.defaultdict(int)\n    num2startIndex = collections.defaultdict(int)\n    num2endIndex = collections.defaultdict(int)\n    maxCount = 0\n    maxLength = len(nums)\n    for i, num in enumerate(nums):\n        num2count[num] += 1\n        num2startIndex[num] = i\n        num2endIndex[num] = i\n        if num2count[num] > maxCount:\n            maxCount = num2count[num]\n            maxLength = i - num2startIndex[num] + 1\n        elif num2count[num] == maxCount:\n            length = i - num2startIndex[num] + 1\n            if length < maxLength:\n                maxLength = length\n    return maxLength\n\n\n# 1036. 递增的二元子数组\ndef findNumberOfLIS(nums):\n    '''\n    给你一个整数数组 nums ，找到其中最长且 严格递增 的序列的长度。\n\n    比方", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    num2count = collections.defaultdict(int)\n    num2startIndex = collections.defaultdict(int)\n    num2endIndex = collections.defaultdict(int)\n    maxCount = 0\n    maxLength = len(nums)\n    for i, num in enumerate(nums):\n        num2count[num] += 1\n        num2startIndex[num] = i\n        num2endIndex[num] = i\n        if num2count[num] > maxCount:\n            maxCount = num2count[num]\n            maxLength = i - num2startIndex[num] + 1\n        elif num2count[num] == maxCount:\n            length = i - num2startIndex[num] + 1\n            if length < maxLength:\n                maxLength = length\n    return maxLength\n\n\n# 1036. 递增的二元子数组\ndef findNumberOfLIS(nums):\n    '''\n    给你一个整数数组 nums ，找到其中最长且 严格递增 的序列的长度。\n\n    比方"}
{"task_id": "leetcode/697", "completion": "\n    from collections import Counter\n    count = Counter(nums)\n    degree = max(count.values())\n    if degree == 1:\n        return len(nums)\n    res = []\n    for key, value in count.items():\n        res.append([key, value])\n    res.sort(key=lambda x: x[1], reverse=True)\n    # 获取最大的度\n    max_value = res[0][1]\n    min_length = None\n    for value in res:\n        if value[1] == max_value:\n            length = value[0][1]-value[0][0]\n            min_length = length if min_length is None else min(min_length, length)\n    return min_length\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()\n    print(findShortestSubArray([1,2,2,3,1]))\n    print(findShortestSubArray([1,2,2,3,1,4,2]))\n# @lc code=end\n\n# @lc info=start\n# 1. 解答成功:", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    from collections import Counter\n    count = Counter(nums)\n    degree = max(count.values())\n    if degree == 1:\n        return len(nums)\n    res = []\n    for key, value in count.items():\n        res.append([key, value])\n    res.sort(key=lambda x: x[1], reverse=True)\n    # 获取最大的度\n    max_value = res[0][1]\n    min_length = None\n    for value in res:\n        if value[1] == max_value:\n            length = value[0][1]-value[0][0]\n            min_length = length if min_length is None else min(min_length, length)\n    return min_length\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()\n    print(findShortestSubArray([1,2,2,3,1]))\n    print(findShortestSubArray([1,2,2,3,1,4,2]))\n# @lc code=end\n\n# @lc info=start\n# 1. 解答成功:"}
{"task_id": "leetcode/697", "completion": "\n    counts = collections.Counter(nums)\n    max_count = max(counts.values())\n    result = len(nums)\n    for k,v in counts.items():\n        if v == max_count:\n            r = len(nums) - nums.index(k)\n            result = min(r, result)\n    return result\n\n\ndef findDisappearedNumbers(nums):\n    '''\n    给定一个范围在  1 ≤ a[i] ≤ n  （n = 数组大小）的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n    找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n    你能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n    >>> findDisapp", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    counts = collections.Counter(nums)\n    max_count = max(counts.values())\n    result = len(nums)\n    for k,v in counts.items():\n        if v == max_count:\n            r = len(nums) - nums.index(k)\n            result = min(r, result)\n    return result\n\n\ndef findDisappearedNumbers(nums):\n    '''\n    给定一个范围在  1 ≤ a[i] ≤ n  （n = 数组大小）的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n    找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n    你能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n    >>> findDisapp"}
{"task_id": "leetcode/697", "completion": "\n    sub = collections.defaultdict(list)\n    for index, num in enumerate(nums):\n        sub[num].append(index)\n    ans = len(nums) + 1\n    for nums in sub.values():\n        length, start = len(nums), nums[0]\n        for index in nums[1:]:\n            if index - start > length:\n               ", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    sub = collections.defaultdict(list)\n    for index, num in enumerate(nums):\n        sub[num].append(index)\n    ans = len(nums) + 1\n    for nums in sub.values():\n        length, start = len(nums), nums[0]\n        for index in nums[1:]:\n            if index - start > length:\n               "}
{"task_id": "leetcode/697", "completion": "\n    # 找到度数最大的元素\n    index = Counter(nums).most_common()[0][0]\n    # 返回[index, index+len-1]\n    sub = [index, index]\n    for i,n in enumerate(nums):\n        if n == index:\n            sub[1] = i\n    if sub[0] == sub[1]:\n        return 1\n    return sub[1] - sub[0] + 1\n```\n\n### 2.3\n\n\n```python\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 'nums' 和一个整数目标值 'target', 请你在该数组中找出 和为目标值 'target' 的那两个整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素在答案里不能重复出现。\n    >>> twoSum", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    # 找到度数最大的元素\n    index = Counter(nums).most_common()[0][0]\n    # 返回[index, index+len-1]\n    sub = [index, index]\n    for i,n in enumerate(nums):\n        if n == index:\n            sub[1] = i\n    if sub[0] == sub[1]:\n        return 1\n    return sub[1] - sub[0] + 1\n```\n\n### 2.3\n\n\n```python\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 'nums' 和一个整数目标值 'target', 请你在该数组中找出 和为目标值 'target' 的那两个整数, 并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是, 数组中同一个元素在答案里不能重复出现。\n    >>> twoSum"}
{"task_id": "leetcode/697", "completion": "\n    from collections import Counter, defaultdict\n    from collections import deque\n    res, deg = 0, 0\n    freq_dict = defaultdict(int)\n    for i in range(len(nums)):\n        freq_dict[nums[i]] += 1\n        deg = max(deg, freq_dict[nums[i]])\n    print(freq_dict)\n    for i in range(len(nums)):\n        freq_dict[nums[i]] -= 1\n        if freq_dict[nums[i]] == deg-1:\n            res = max(res, i-start+1)\n    return res\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    from collections import Counter, defaultdict\n    from collections import deque\n    res, deg = 0, 0\n    freq_dict = defaultdict(int)\n    for i in range(len(nums)):\n        freq_dict[nums[i]] += 1\n        deg = max(deg, freq_dict[nums[i]])\n    print(freq_dict)\n    for i in range(len(nums)):\n        freq_dict[nums[i]] -= 1\n        if freq_dict[nums[i]] == deg-1:\n            res = max(res, i-start+1)\n    return res\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "leetcode/697", "completion": "\n    num_dict = collections.defaultdict(int)\n    num_dict_count = collections.defaultdict(int)\n    res = len(nums)\n    for i, num in enumerate(nums):\n\n        num_dict[num] = num_dict.get(num, 0) + 1\n        num_dict_count[num_dict[num]] = num_dict_count.get(num_dict[num], 0) + 1\n\n        if i >= res:\n            n = nums[i-res:i]\n            m = max(num_dict.values())\n            if num_dict_count[m] == res:\n                res = min(res, len(n))\n        else:\n            m = max(num_dict.values())\n            if num_dict_count[m] == i + 1:\n                res = min(res, len(nums))\n    return res\n```\n\n## 100. 相同的树\n\n```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n", "allcode": "import collections\ndef findShortestSubArray(nums):\n    '''\n    给定一个非空非负整数数组 'nums', 数组的度的定义为数组中任一元素出现频数的最大值。\n    你的任务是找到与 'nums' 拥有相同大小的度的最短连续子数组, 返回其长度。\n    >>> findShortestSubArray([1,2,2,3,1])\n    2\n    >>> findShortestSubArray([1,2,2,3,1,4,2])\n    6\n    '''\n    num_dict = collections.defaultdict(int)\n    num_dict_count = collections.defaultdict(int)\n    res = len(nums)\n    for i, num in enumerate(nums):\n\n        num_dict[num] = num_dict.get(num, 0) + 1\n        num_dict_count[num_dict[num]] = num_dict_count.get(num_dict[num], 0) + 1\n\n        if i >= res:\n            n = nums[i-res:i]\n            m = max(num_dict.values())\n            if num_dict_count[m] == res:\n                res = min(res, len(n))\n        else:\n            m = max(num_dict.values())\n            if num_dict_count[m] == i + 1:\n                res = min(res, len(nums))\n    return res\n```\n\n## 100. 相同的树\n\n```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n"}
{"task_id": "leetcode/832", "completion": "\n    m = len(image)\n    n = len(image[0])\n    res = [[0] * n for _ in range(m)]\n    # m = len(image)\n    # n = len(image[0])\n    for i in range(m):\n        for j in range(n):\n            if (i + 1, j + 1) in image:\n                res[i][j] = image[i][j]\n            else:\n                res[i][j] = 1 - image[i][j]\n    return res\n\n\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# leetcode submit region begin(Prohibit modification and deletion)\n# 18\n# 18\n# 0\n# 0\n# 0\n# 5\n# 15\n# 347\n# 0\n# 0\n# 0\n# 236\n# 0\n# 0\n", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    m = len(image)\n    n = len(image[0])\n    res = [[0] * n for _ in range(m)]\n    # m = len(image)\n    # n = len(image[0])\n    for i in range(m):\n        for j in range(n):\n            if (i + 1, j + 1) in image:\n                res[i][j] = image[i][j]\n            else:\n                res[i][j] = 1 - image[i][j]\n    return res\n\n\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# leetcode submit region begin(Prohibit modification and deletion)\n# 18\n# 18\n# 0\n# 0\n# 0\n# 5\n# 15\n# 347\n# 0\n# 0\n# 0\n# 236\n# 0\n# 0\n"}
{"task_id": "leetcode/832", "completion": "\n    res = []\n    image.reverse()\n    for i in range(len(image)):\n        res.append([])\n        for j in range(len(image[i])):\n            if image[i][j] == 0:\n                res[i].append(1)\n            else:\n                res[i].append(0)\n    return res\n\n# Tests.\nassert flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]) == [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\nassert flipAndInvertImage([[1, 1, 0], [1, 0, 1]]) == [[0, 1, 0], [1, 1, 0]]\nassert flipAndInvertImage([[0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]]) == [[1, 0,", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    res = []\n    image.reverse()\n    for i in range(len(image)):\n        res.append([])\n        for j in range(len(image[i])):\n            if image[i][j] == 0:\n                res[i].append(1)\n            else:\n                res[i].append(0)\n    return res\n\n# Tests.\nassert flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]) == [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\nassert flipAndInvertImage([[1, 1, 0], [1, 0, 1]]) == [[0, 1, 0], [1, 1, 0]]\nassert flipAndInvertImage([[0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]]) == [[1, 0,"}
{"task_id": "leetcode/832", "completion": "\n    new_image = []\n    for col in image:\n        new_col = []\n        for i in col:\n            if i == 0:\n                i = 1\n            else:\n                i = 0\n            new_col.append(i)\n        new_col = new_col[::-1]\n        new_image.append(new_col)\n    return new_image\n## Test\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n    print(flipAndInvertImage([[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]))\n    print(flipAndInvertImage([[0,0,0],[1,1,0],[1,0,1]]))\n    print(flipAndInvertImage([[1,1,0,0],[0,0,1,1],[0,1,1,0],[1,0,0", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    new_image = []\n    for col in image:\n        new_col = []\n        for i in col:\n            if i == 0:\n                i = 1\n            else:\n                i = 0\n            new_col.append(i)\n        new_col = new_col[::-1]\n        new_image.append(new_col)\n    return new_image\n## Test\nif __name__ == '__main__':\n    print(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n    print(flipAndInvertImage([[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]))\n    print(flipAndInvertImage([[0,0,0],[1,1,0],[1,0,1]]))\n    print(flipAndInvertImage([[1,1,0,0],[0,0,1,1],[0,1,1,0],[1,0,0"}
{"task_id": "leetcode/832", "completion": "\n    res = []\n    for i in range(len(image)):\n        temp = []\n        for j in range(len(image[0])):\n            temp.append(image[i][len(image[0])-1-j])\n        res.append(temp[::-1])\n    return res\ndef flipAndInvertImage2(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    res = []\n    for i in range(len(image)):\n        temp = []\n        for j in range(len(image[0])):\n            temp.append(image[i][len(image[0])-1-j])\n        res.append(temp[::-1])\n    return res\ndef flipAndInvertImage2(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], ["}
{"task_id": "leetcode/832", "completion": "\n    def flipVertical(lst):\n        return [lst[i] for i in range(len(lst)-1,-1,-1)]\n\n    return flipVertical([flipVertical(i) for i in image])\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\ndef isPalindrome(s):\n    '''\n    Determine if the string is a palindrome.\n    A palindrome is a string of characters that reads the same forwards and backwards.\n    Ignore cases and ignore non-alphanumeric characters.\n    >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n    True\n    >>> isPalindrome(\"race a car\")\n    False\n    '''\n    res = []\n    for i in s:\n        if i.isalnum():\n            res.append(i.lower())\n    return res == res[::-1]\n\nprint(", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    def flipVertical(lst):\n        return [lst[i] for i in range(len(lst)-1,-1,-1)]\n\n    return flipVertical([flipVertical(i) for i in image])\n\nprint(flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]]))\n\n# Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\ndef isPalindrome(s):\n    '''\n    Determine if the string is a palindrome.\n    A palindrome is a string of characters that reads the same forwards and backwards.\n    Ignore cases and ignore non-alphanumeric characters.\n    >>> isPalindrome(\"A man, a plan, a canal: Panama\")\n    True\n    >>> isPalindrome(\"race a car\")\n    False\n    '''\n    res = []\n    for i in s:\n        if i.isalnum():\n            res.append(i.lower())\n    return res == res[::-1]\n\nprint("}
{"task_id": "leetcode/832", "completion": "\n    # Flip horizontally\n    result = [[image[n][m] for n in range(len(image))] for m in range(len(image[0]))]\n        \n    # Invert\n    for i in range(len(result)):\n        for j in range(len(result[0])):\n            result[i][j] = 1 - result[i][j]\n    \n    return result\n\ndef main(n, m, arr):\n    n = int(n)\n    m = int(m)\n    matrix = [[int(x) for x in list(arr[i])] for i in range(len(arr))]\n    row = flipAndInvertImage(matrix)\n    print(' '.join(map(str, row[n-1])))\n    col = flipAndInvertImage([[x[m-1] for x in matrix] for m in range(len(matrix[0]))])\n    \n    for i in col:\n        print(' '.join(map(str, i)))\n        \n    return\n\n# print(flipAndInvertImage([", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    # Flip horizontally\n    result = [[image[n][m] for n in range(len(image))] for m in range(len(image[0]))]\n        \n    # Invert\n    for i in range(len(result)):\n        for j in range(len(result[0])):\n            result[i][j] = 1 - result[i][j]\n    \n    return result\n\ndef main(n, m, arr):\n    n = int(n)\n    m = int(m)\n    matrix = [[int(x) for x in list(arr[i])] for i in range(len(arr))]\n    row = flipAndInvertImage(matrix)\n    print(' '.join(map(str, row[n-1])))\n    col = flipAndInvertImage([[x[m-1] for x in matrix] for m in range(len(matrix[0]))])\n    \n    for i in col:\n        print(' '.join(map(str, i)))\n        \n    return\n\n# print(flipAndInvertImage(["}
{"task_id": "leetcode/832", "completion": "\n    return [[1 - i for i in image[::-1]] for image in image]\n\n\n# 1657. Minimum Number of Operations to Make Array Equal\ndef minOperations(nums1, nums2):\n    return sum(abs(x - y) for x, y in zip(nums1, nums2))\n\n\n# 1727. Minimum Number of K-Consecutive Numbers Sums\ndef minKBitFlips(nums, k):\n    N = len(nums)\n    dp = [0] * N\n    for i in range(N):\n        if i >= k and nums[i-k] == nums[i] and nums[i-k+1] == nums[i]:\n            dp[i] = dp[i - k]\n        else:\n            dp[i] = dp[i-1] + 1\n    return dp[N-1]\n\n\n# 1698. Maximum Number of Non-Overlapping Substrings\nimport collections\ndef", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    return [[1 - i for i in image[::-1]] for image in image]\n\n\n# 1657. Minimum Number of Operations to Make Array Equal\ndef minOperations(nums1, nums2):\n    return sum(abs(x - y) for x, y in zip(nums1, nums2))\n\n\n# 1727. Minimum Number of K-Consecutive Numbers Sums\ndef minKBitFlips(nums, k):\n    N = len(nums)\n    dp = [0] * N\n    for i in range(N):\n        if i >= k and nums[i-k] == nums[i] and nums[i-k+1] == nums[i]:\n            dp[i] = dp[i - k]\n        else:\n            dp[i] = dp[i-1] + 1\n    return dp[N-1]\n\n\n# 1698. Maximum Number of Non-Overlapping Substrings\nimport collections\ndef"}
{"task_id": "leetcode/832", "completion": "\n    def flip(i):\n        return list(reversed(i))\n    \n    def invert(i):\n        new_list = []\n        for j in i:\n            if j == 0:\n                new_list.append(1)\n            else:\n                new_list.append(0)\n        return new_list\n    \n    image = list(map(flip, image))\n    image = list(map(invert, image))\n    return image\n\ndef flipAndInvertImage_2(image):\n    def flip(i):\n        return list(reversed(i))\n\n    def invert(i):\n        new_list = []\n        for j in i:\n            if j == 0:\n                new_list.append(1)\n            else:\n                new_list.append(0)\n        return new_list\n\n    image = flip(image)\n    image = invert(image)\n    return image\n\ndef flipAndInvertImage_3(image):\n    image = list(map(lambda i: list(revers", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    def flip(i):\n        return list(reversed(i))\n    \n    def invert(i):\n        new_list = []\n        for j in i:\n            if j == 0:\n                new_list.append(1)\n            else:\n                new_list.append(0)\n        return new_list\n    \n    image = list(map(flip, image))\n    image = list(map(invert, image))\n    return image\n\ndef flipAndInvertImage_2(image):\n    def flip(i):\n        return list(reversed(i))\n\n    def invert(i):\n        new_list = []\n        for j in i:\n            if j == 0:\n                new_list.append(1)\n            else:\n                new_list.append(0)\n        return new_list\n\n    image = flip(image)\n    image = invert(image)\n    return image\n\ndef flipAndInvertImage_3(image):\n    image = list(map(lambda i: list(revers"}
{"task_id": "leetcode/832", "completion": "\n    mat = image[::-1]\n    for i in range(len(mat)):\n        mat[i] = [1 - j for j in mat[i]]\n    return mat\n\ndef reverseWords(s):\n    '''\n    Given an input string, reverse the string word by word.\n    >>> reverseWords(\"the sky is blue\")\n    \"blue is sky the\"\n    '''\n    arr = s.split()\n    result = []\n    for i in range(len(arr)):\n        arr[i] = arr[i][::-1]\n        result.append(arr[i])\n    return''.join(result)\n\ndef longestOnes(A, K):\n    '''\n    Given an array A of 0s and 1s, we may change up to K values from 0 to 1.\n    Return the length of the longest (contiguous) subarray that contains only 1s.\n    >>> longestOnes([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    mat = image[::-1]\n    for i in range(len(mat)):\n        mat[i] = [1 - j for j in mat[i]]\n    return mat\n\ndef reverseWords(s):\n    '''\n    Given an input string, reverse the string word by word.\n    >>> reverseWords(\"the sky is blue\")\n    \"blue is sky the\"\n    '''\n    arr = s.split()\n    result = []\n    for i in range(len(arr)):\n        arr[i] = arr[i][::-1]\n        result.append(arr[i])\n    return''.join(result)\n\ndef longestOnes(A, K):\n    '''\n    Given an array A of 0s and 1s, we may change up to K values from 0 to 1.\n    Return the length of the longest (contiguous) subarray that contains only 1s.\n    >>> longestOnes([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2"}
{"task_id": "leetcode/832", "completion": "\n    \n    image_new = [[False for i in range(len(image))] for j in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            image_new[i][j] = not (image[i][-1 - j])\n    return image_new\n\n# test\n# matrix_image = []\n# matrix_image = [[0,0,0],[0,1,0],[1,1,1]]\n# matrix_image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n# matrix_image = [[1,1,0,0],[1,0,0", "allcode": "import collections\ndef flipAndInvertImage(image):\n    '''\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n    For example, inverting [0,1,1] results in [1,0,0].\n    >>> flipAndInvertImage([[1,1,0],[1,0,1],[0,0,0]])\n    [[1, 0, 0], [0, 1, 0], [1, 1, 1]]\n    '''\n    \n    image_new = [[False for i in range(len(image))] for j in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[i])):\n            image_new[i][j] = not (image[i][-1 - j])\n    return image_new\n\n# test\n# matrix_image = []\n# matrix_image = [[0,0,0],[0,1,0],[1,1,1]]\n# matrix_image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n# matrix_image = [[1,1,0,0],[1,0,0"}
{"task_id": "leetcode/300", "completion": "\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。\n    比方说，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS2([1, 2, 3, 4])\n    4\n    >>> lengthOfLIS2", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef lengthOfLIS2(nums):\n    '''\n    给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n    子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。\n    比方说，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS2([1, 2, 3, 4])\n    4\n    >>> lengthOfLIS2"}
{"task_id": "leetcode/300", "completion": "\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(dp)):\n        for j in range(i):\n            if dp[j] < nums[i] and dp[i] <= nums[i]:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\nif __name__ == '__main__':\n    print(lengthOfLIS([7,7,7,7,7,7,7]))\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([0,3,1,6,2,2,7]))\n    print(lengthOfLIS([3,6,2,7]))\n    print(lengthOfLIS([]))\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([10,9,2", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(dp)):\n        for j in range(i):\n            if dp[j] < nums[i] and dp[i] <= nums[i]:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\nif __name__ == '__main__':\n    print(lengthOfLIS([7,7,7,7,7,7,7]))\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([0,3,1,6,2,2,7]))\n    print(lengthOfLIS([3,6,2,7]))\n    print(lengthOfLIS([]))\n    print(lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(lengthOfLIS([10,9,2"}
{"task_id": "leetcode/300", "completion": "\n    len = len(nums)\n    if len == 0:\n        return 0\n    dp = [1] * len\n    res = 1\n    for i in range(len):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        res = max(res, dp[i])\n    return res\n\ndef lengthOfLIS2(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef lengthOfLIS3(nums, n):\n    \"\"\"", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    len = len(nums)\n    if len == 0:\n        return 0\n    dp = [1] * len\n    res = 1\n    for i in range(len):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        res = max(res, dp[i])\n    return res\n\ndef lengthOfLIS2(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef lengthOfLIS3(nums, n):\n    \"\"\""}
{"task_id": "leetcode/300", "completion": "\n    # 状态方程: dp[i]是以第i个数结尾的最长递增子序列的长度\n    # 初始条件: dp[0] = 1\n    dp = [1 for _ in range(len(nums))]\n    res = 0\n    for i in range(1,len(nums)):\n        for j in range(0,i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i],dp[j]+1)\n        res = max(dp[i],res)\n    return res\n\n\n# ----------------- 1.1 求一个数组中的乘积最大的连续子数组  -----------------\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # 状态方程: dp[i]是以第i个数结尾的最长递增子序列的长度\n    # 初始条件: dp[0] = 1\n    dp = [1 for _ in range(len(nums))]\n    res = 0\n    for i in range(1,len(nums)):\n        for j in range(0,i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i],dp[j]+1)\n        res = max(dp[i],res)\n    return res\n\n\n# ----------------- 1.1 求一个数组中的乘积最大的连续子数组  -----------------\ndef maxSubArray(nums):\n    '''\n    给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回"}
{"task_id": "leetcode/300", "completion": "\n    L = [1 for _ in range(len(nums))]\n    prevMax = [nums[0] for _ in range(len(nums))]\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > prevMax[j]:\n                L[i] = max(L[i], L[j] + 1)\n                prevMax[i] = prevMax[j]\n    return max(L)\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 'nums' 可能包含重复元素.\n    这会影响子序列的长度上限。\n    例如, [1,3,5,4,2,2] 可能包含重复元素, 所以 'nums[1]=5' 不能拥有子序列长度为3.\n    所以, 我们将子序列上限扩展到", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    L = [1 for _ in range(len(nums))]\n    prevMax = [nums[0] for _ in range(len(nums))]\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > prevMax[j]:\n                L[i] = max(L[i], L[j] + 1)\n                prevMax[i] = prevMax[j]\n    return max(L)\n\n\ndef lengthOfLIS_dp(nums):\n    '''\n    给定一个整数数组 'nums', 'nums' 可能包含重复元素.\n    这会影响子序列的长度上限。\n    例如, [1,3,5,4,2,2] 可能包含重复元素, 所以 'nums[1]=5' 不能拥有子序列长度为3.\n    所以, 我们将子序列上限扩展到"}
{"task_id": "leetcode/300", "completion": "\n    if len(nums) == 0:\n        return 0\n    dp = [0] * len(nums)\n    dp[0] = 1\n    max_length = 1\n    for i in range(1, len(nums)):\n        max_length = max(max_length, dp[i])\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max_length\n\n\ndef test_lengthOfLIS():\n    s = Solution()\n    print(s.lengthOfLIS([10, 9, 2, 5, 3, 7, ", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    if len(nums) == 0:\n        return 0\n    dp = [0] * len(nums)\n    dp[0] = 1\n    max_length = 1\n    for i in range(1, len(nums)):\n        max_length = max(max_length, dp[i])\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max_length\n\n\ndef test_lengthOfLIS():\n    s = Solution()\n    print(s.lengthOfLIS([10, 9, 2, 5, 3, 7, "}
{"task_id": "leetcode/300", "completion": "\n    # 贪心\n    ########## 精简\n    nums_copy = copy.copy(nums)\n    nums_copy.sort()\n    # 获取到列表 7,7,7,7,7,7,7\n    # 使用贪心 找到最大的数字 7\n    # 返回个数 7\n    # 然后把个数取负\n    # 返回个数 7\n    # 累加 7 + 7 + 7 + 7 + 7\n    # 返回 28\n    # 对应的位置 0 2 3 4 5 6\n    ans = 1\n    for i in range(1, len(nums_copy)):\n        if nums_copy[i] > nums_copy[i - 1]:\n            ans += 1\n    # print(ans)\n    return ans\n    # 正向遍历 28\n    # 反", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # 贪心\n    ########## 精简\n    nums_copy = copy.copy(nums)\n    nums_copy.sort()\n    # 获取到列表 7,7,7,7,7,7,7\n    # 使用贪心 找到最大的数字 7\n    # 返回个数 7\n    # 然后把个数取负\n    # 返回个数 7\n    # 累加 7 + 7 + 7 + 7 + 7\n    # 返回 28\n    # 对应的位置 0 2 3 4 5 6\n    ans = 1\n    for i in range(1, len(nums_copy)):\n        if nums_copy[i] > nums_copy[i - 1]:\n            ans += 1\n    # print(ans)\n    return ans\n    # 正向遍历 28\n    # 反"}
{"task_id": "leetcode/300", "completion": "\n    n = len(nums)\n    if n < 2:\n        return n\n    # dp[i]表示nums[:i+1]序列的最长LIS\n    dp = [1] * n\n    # i 表示检查的位置\n    for i in range(n):\n        for j in range(i):\n            # 如果nums[i] > nums[j]并且dp[i] < dp[j]+1,则更新\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        '''\n        请你返回给定二维整数数组 matrix 的 最长递增路径 的长度。\n        即，整", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    n = len(nums)\n    if n < 2:\n        return n\n    # dp[i]表示nums[:i+1]序列的最长LIS\n    dp = [1] * n\n    # i 表示检查的位置\n    for i in range(n):\n        for j in range(i):\n            # 如果nums[i] > nums[j]并且dp[i] < dp[j]+1,则更新\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n\n\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        '''\n        请你返回给定二维整数数组 matrix 的 最长递增路径 的长度。\n        即，整"}
{"task_id": "leetcode/300", "completion": "\n    # 宽度优先搜索遍历整个二叉搜索树\n    @functools.lru_cache(maxsize=None)\n    def dp(i):\n        if i >= len(nums):\n            return 0\n        else:\n            return max(dp(i + 1), dp(i + 2) + 1)\n\n    return 1 + dp(0)\n\n\n# 动态规划方法\ndef lengthOfLIS1(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    # 宽度优先搜索遍历整个二叉搜索树\n    @functools.lru_cache(maxsize=None)\n    def dp(i):\n        if i >= len(nums):\n            return 0\n        else:\n            return max(dp(i + 1), dp(i + 2) + 1)\n\n    return 1 + dp(0)\n\n\n# 动态规划方法\ndef lengthOfLIS1(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,"}
{"task_id": "leetcode/300", "completion": "\n    lis = [1] * len(nums)\n    # 找到nums中的每一个数字，找到比他大的最小的数字\n    for i in range(1, len(nums)):\n        for j in range(0, i):\n            if nums[j] < nums[i]:\n                if lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n    return max(lis)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n# 100%, 8ms\n# class Solution(object):\n#     def lengthOfLIS(self, nums):\n#         \"\"\"\n#         :type nums: List[int]\n#         :rtype: int\n#         \"\"\"\n#         if not nums: return 0\n\n#         n = len(nums)\n#         lis = [1] * n\n#         p", "allcode": "def lengthOfLIS(nums):\n    '''\n    给定一个整数数组 'nums', 返回最长严格递增子序列的长度。\n    子序列是从数组中删除一些元素（或不删除）得到的序列, 并且元素的相对位置不变。\n    例如, [3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n    >>> lengthOfLIS([10,9,2,5,3,7,101,18])\n    4\n    >>> lengthOfLIS([7,7,7,7,7,7,7])\n    1\n    '''\n    lis = [1] * len(nums)\n    # 找到nums中的每一个数字，找到比他大的最小的数字\n    for i in range(1, len(nums)):\n        for j in range(0, i):\n            if nums[j] < nums[i]:\n                if lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n    return max(lis)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n# 100%, 8ms\n# class Solution(object):\n#     def lengthOfLIS(self, nums):\n#         \"\"\"\n#         :type nums: List[int]\n#         :rtype: int\n#         \"\"\"\n#         if not nums: return 0\n\n#         n = len(nums)\n#         lis = [1] * n\n#         p"}
{"task_id": "leetcode/414", "completion": "\n    first, second, third = -999999999999999, -999999999999999, -999999999999999\n    max_num = max(nums)\n    for num in nums:\n        if num == max_num:\n            if first == num:\n                second = third\n                third = num\n            elif second == num:\n                third = num\n            else:\n                second = num\n        elif first == max_num:\n            if second == num:\n                first = third\n                second = num\n            elif third == num:\n                first = num\n            else:\n                second = third", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    first, second, third = -999999999999999, -999999999999999, -999999999999999\n    max_num = max(nums)\n    for num in nums:\n        if num == max_num:\n            if first == num:\n                second = third\n                third = num\n            elif second == num:\n                third = num\n            else:\n                second = num\n        elif first == max_num:\n            if second == num:\n                first = third\n                second = num\n            elif third == num:\n                first = num\n            else:\n                second = third"}
{"task_id": "leetcode/414", "completion": "\n    arr = sorted(set(nums), reverse=True)\n    if len(arr) < 3: return arr[0]\n    else: return arr[2]\n\ndef thirdMax2(nums):\n    '''\n    返回数组中第三大的数。如果不存在, 则返回最大的数。\n    这里需要注意一点，如果有重复元素，我们要保留第一次出现的那个。\n    >>> thirdMax([1,2,3,4,5,4,3,2,1])\n    3\n    >>> thirdMax([1,2,2,3,3,1])\n    3\n    >>> thirdMax([2,2,3,4,3,3,1])\n    2\n    '''\n    arr = sorted(set(nums), reverse=True)\n    if len(arr) < 3: return arr[0]\n    else: return arr[2]\n\ndef thirdMax3(nums):\n    '''\n    返回数组中第三大的数。", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    arr = sorted(set(nums), reverse=True)\n    if len(arr) < 3: return arr[0]\n    else: return arr[2]\n\ndef thirdMax2(nums):\n    '''\n    返回数组中第三大的数。如果不存在, 则返回最大的数。\n    这里需要注意一点，如果有重复元素，我们要保留第一次出现的那个。\n    >>> thirdMax([1,2,3,4,5,4,3,2,1])\n    3\n    >>> thirdMax([1,2,2,3,3,1])\n    3\n    >>> thirdMax([2,2,3,4,3,3,1])\n    2\n    '''\n    arr = sorted(set(nums), reverse=True)\n    if len(arr) < 3: return arr[0]\n    else: return arr[2]\n\ndef thirdMax3(nums):\n    '''\n    返回数组中第三大的数。"}
{"task_id": "leetcode/414", "completion": "\n    # 使用python的sort，排序，再取第三位\n    if len(nums) < 3:\n        return max(nums)\n    nums.sort(reverse=True)\n    return nums[2]\n\n    '''\n    思路：\n    1.python sort，排序\n    2.取出第三位，判断是否是最大的数\n    '''\n\nif __name__ == '__main__':\n    print thirdMax([3, 2, 1])\n    print thirdMax([3, 2, 2, 1])\n    print thirdMax([1, 2, 2, 1])\n    print thirdMax([1, 2, 4, 1])\n    print thirdMax([1, 2, 4, 1, 9, 10])\n    print thirdMax([1, 2, 4, 1, 10])\n    print thirdMax([1, 1, 2, 2, 1, 4])\n    print thirdMax([1, 1", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    # 使用python的sort，排序，再取第三位\n    if len(nums) < 3:\n        return max(nums)\n    nums.sort(reverse=True)\n    return nums[2]\n\n    '''\n    思路：\n    1.python sort，排序\n    2.取出第三位，判断是否是最大的数\n    '''\n\nif __name__ == '__main__':\n    print thirdMax([3, 2, 1])\n    print thirdMax([3, 2, 2, 1])\n    print thirdMax([1, 2, 2, 1])\n    print thirdMax([1, 2, 4, 1])\n    print thirdMax([1, 2, 4, 1, 9, 10])\n    print thirdMax([1, 2, 4, 1, 10])\n    print thirdMax([1, 1, 2, 2, 1, 4])\n    print thirdMax([1, 1"}
{"task_id": "leetcode/414", "completion": "\n    nums.sort()\n    # 含义是从后往前判断，如果不存在，return后面那个数，如果存在，return前面那个数\n    return nums[-3] if len(nums) >= 3 else max(nums)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n```\n\n## 链表相关\n\n### 面试题20: 链表中倒数第k个节点（递归）（简单）\n\n题目描述\n\n```\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如一个链表有6个节点，从头", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums.sort()\n    # 含义是从后往前判断，如果不存在，return后面那个数，如果存在，return前面那个数\n    return nums[-3] if len(nums) >= 3 else max(nums)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n```\n\n## 链表相关\n\n### 面试题20: 链表中倒数第k个节点（递归）（简单）\n\n题目描述\n\n```\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如一个链表有6个节点，从头"}
{"task_id": "leetcode/414", "completion": "\n    if len(nums) < 3:\n        return max(nums)\n    # 先取最大值\n    first = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= first]\n    # 取第二大的值\n    second = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= second]\n    # 取第三大的值\n    third = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= second]\n    # 又饿了\n    if len(nums) == 0:\n        return first\n    elif len(nums) == 1:\n        return third\n    else:\n        return nums[0]\n\ndef canThreePartsEqualSum(A):\n    '''\n    给定一个整数数组 A，只有当", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if len(nums) < 3:\n        return max(nums)\n    # 先取最大值\n    first = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= first]\n    # 取第二大的值\n    second = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= second]\n    # 取第三大的值\n    third = max(nums)\n    # 排除掉最大值\n    nums = [x for x in nums if x!= second]\n    # 又饿了\n    if len(nums) == 0:\n        return first\n    elif len(nums) == 1:\n        return third\n    else:\n        return nums[0]\n\ndef canThreePartsEqualSum(A):\n    '''\n    给定一个整数数组 A，只有当"}
{"task_id": "leetcode/414", "completion": "\n    if len(nums) <= 2:\n        return max(nums)\n    nums.sort()\n    cnt = Counter(nums)\n    print(cnt)\n    for k,v in cnt.items():\n        if v == 3:\n            return k\n    return nums[-3]\n\ndef test_thirdMax():\n    assert thirdMax([3,2,1]) == 1\n    assert thirdMax([1,2,2,1]) == 2\n\n# -*- coding:utf-8 -*-\n# class Solution:\n#     def thirdMax(self, nums):\n#         \"\"\"\n#         给定一个整数数组，找出其中第三大的数。\n#         如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。\n#         :type nums: List[int]\n#         :rtype: int\n#         \"\"\"\n#         s = list(set(nums))\n#", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    if len(nums) <= 2:\n        return max(nums)\n    nums.sort()\n    cnt = Counter(nums)\n    print(cnt)\n    for k,v in cnt.items():\n        if v == 3:\n            return k\n    return nums[-3]\n\ndef test_thirdMax():\n    assert thirdMax([3,2,1]) == 1\n    assert thirdMax([1,2,2,1]) == 2\n\n# -*- coding:utf-8 -*-\n# class Solution:\n#     def thirdMax(self, nums):\n#         \"\"\"\n#         给定一个整数数组，找出其中第三大的数。\n#         如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。\n#         :type nums: List[int]\n#         :rtype: int\n#         \"\"\"\n#         s = list(set(nums))\n#"}
{"task_id": "leetcode/414", "completion": "\n    # 先把最小的数去掉，保留最大的三个数\n    nums.sort()\n    # nums[-3]: 倒数第三个元素\n    return nums[-3] if len(nums) >=3 else nums[-1]\n\n\ndef isPerfectSquare(num):\n    '''\n    给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 true，否则返回 false。\n    说明：不要使用任何内置的库函数，如  sqrt。\n    示例 1:\n    >>> isPerfectSquare(16)\n    True\n    示例 2:\n    >>> isPerfectSquare(14)\n    False\n    '''\n    x = 0\n    y = num\n    while x <= y:\n        m = (x + y) / 2\n        if m * m == num:\n            return True\n        elif m * m > num:\n", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    # 先把最小的数去掉，保留最大的三个数\n    nums.sort()\n    # nums[-3]: 倒数第三个元素\n    return nums[-3] if len(nums) >=3 else nums[-1]\n\n\ndef isPerfectSquare(num):\n    '''\n    给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 true，否则返回 false。\n    说明：不要使用任何内置的库函数，如  sqrt。\n    示例 1:\n    >>> isPerfectSquare(16)\n    True\n    示例 2:\n    >>> isPerfectSquare(14)\n    False\n    '''\n    x = 0\n    y = num\n    while x <= y:\n        m = (x + y) / 2\n        if m * m == num:\n            return True\n        elif m * m > num:\n"}
{"task_id": "leetcode/414", "completion": "\n    nums = sorted(set(nums))\n    cnt = l = len(nums)\n    if cnt < 3:\n        return nums[-1]\n    for i in range(-1, -cnt - 1, -1):\n        if nums[i]!= nums[-1]:\n            return nums[i]\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    >>> nums = [-2,1,-3,4,-1,2,1,-5,4]\n    >>> maxSubArray(nums) = 6\n    '''\n    sum = max_sum = nums[0]\n    for i in range(len(nums)):\n        sum += nums[i]\n        max_sum = max(sum, max_sum)\n        if sum < 0:\n            sum =", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    nums = sorted(set(nums))\n    cnt = l = len(nums)\n    if cnt < 3:\n        return nums[-1]\n    for i in range(-1, -cnt - 1, -1):\n        if nums[i]!= nums[-1]:\n            return nums[i]\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    >>> nums = [-2,1,-3,4,-1,2,1,-5,4]\n    >>> maxSubArray(nums) = 6\n    '''\n    sum = max_sum = nums[0]\n    for i in range(len(nums)):\n        sum += nums[i]\n        max_sum = max(sum, max_sum)\n        if sum < 0:\n            sum ="}
{"task_id": "leetcode/414", "completion": "\n    max1 = -1000000001\n    max2 = -1000000001\n    max3 = -1000000001\n    for num in nums:\n        if max1 < num:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif max2 < num:\n            max3 = max2\n            max2 = num\n        elif max3 < num:\n            max3 = num\n\n    return max3 if max3!= -1000000001 else max1\n\n\n\nif __name__ == \"__main__\":\n    nums = [3,2,1]\n    print(thirdMax(nums))\n```\n\n## 相似问题\n\n```\n给定一个整数数组，找出两个整数乘积最大的数对。\n\nhttps://leetcode-cn.com/problems/maximum-product-subarray/\n\n给你一", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    max1 = -1000000001\n    max2 = -1000000001\n    max3 = -1000000001\n    for num in nums:\n        if max1 < num:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif max2 < num:\n            max3 = max2\n            max2 = num\n        elif max3 < num:\n            max3 = num\n\n    return max3 if max3!= -1000000001 else max1\n\n\n\nif __name__ == \"__main__\":\n    nums = [3,2,1]\n    print(thirdMax(nums))\n```\n\n## 相似问题\n\n```\n给定一个整数数组，找出两个整数乘积最大的数对。\n\nhttps://leetcode-cn.com/problems/maximum-product-subarray/\n\n给你一"}
{"task_id": "leetcode/414", "completion": "\n    max_nums = set()\n    max_1 = max_2 = max_3 = -sys.maxsize\n\n    for num in nums:\n        if num > max_1:\n            max_3, max_2, max_1 = max_2, max_1, num\n        elif num > max_2:\n            max_3, max_2 = max_2, num\n        elif num > max_3:\n            max_3 = num\n        max_nums.add(max_1)\n        max_nums.add(max_2)\n        max_nums.add(max_3)\n    \n    return max_3 if len(max_nums) < 3 else max(max_nums - {max_1, max_2, max_3})\n\nif __name__ == '__main__':\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([3,2,1,7]))\n    print(thirdMax([3,2,1,", "allcode": "def thirdMax(nums):\n    '''\n    给定一个整数数组 'nums', 返回数组中第三大的数。如果不存在, 则返回最大的数。\n    >>> thirdMax([3,2,1])\n    1\n    >>> thirdMax([1,2,2,1])\n    2\n    '''\n    max_nums = set()\n    max_1 = max_2 = max_3 = -sys.maxsize\n\n    for num in nums:\n        if num > max_1:\n            max_3, max_2, max_1 = max_2, max_1, num\n        elif num > max_2:\n            max_3, max_2 = max_2, num\n        elif num > max_3:\n            max_3 = num\n        max_nums.add(max_1)\n        max_nums.add(max_2)\n        max_nums.add(max_3)\n    \n    return max_3 if len(max_nums) < 3 else max(max_nums - {max_1, max_2, max_3})\n\nif __name__ == '__main__':\n    print(thirdMax([3,2,1]))\n    print(thirdMax([1,2,2,1]))\n    print(thirdMax([3,2,1,7]))\n    print(thirdMax([3,2,1,"}
{"task_id": "leetcode/961", "completion": "\n    res=collections.Counter(nums)\n    return res[max(res,key=lambda x:res[x])]\n```\n\n### 算法1\n\n- 统计每个数字出现的次数，然后找出次数最大的数字并返回\n\n### 算法2\n\n- 先对数组进行一次排序，再取出中位数作为返回值。\n\n```python\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n=len(nums)\n    nums.sort()\n    return nums[int(n/2)]\n```\n\n### 算法", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    res=collections.Counter(nums)\n    return res[max(res,key=lambda x:res[x])]\n```\n\n### 算法1\n\n- 统计每个数字出现的次数，然后找出次数最大的数字并返回\n\n### 算法2\n\n- 先对数组进行一次排序，再取出中位数作为返回值。\n\n```python\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    n=len(nums)\n    nums.sort()\n    return nums[int(n/2)]\n```\n\n### 算法"}
{"task_id": "leetcode/961", "completion": "\n    dic = collections.Counter(nums)\n    return max(dic, key = dic.get)\n\nprint(repeatedNTimes([3,3,1,1,3,3]))\n\n# 1. 利用 collections.Counter\n\n\n# 2. 利用集合\ndef finddup(nums):\n    t = {}\n    for item in nums:\n        if item in t:\n            return item\n        else:\n            t[item] = True\n\nprint(finddup([1, 2, 3, 1, 1]))\n\n# 3. 利用字典\ndef findDuplicate(nums):\n    t = {}\n    for item in nums:\n        if item not in t:\n            t[item] = 1\n        else:\n           ", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    dic = collections.Counter(nums)\n    return max(dic, key = dic.get)\n\nprint(repeatedNTimes([3,3,1,1,3,3]))\n\n# 1. 利用 collections.Counter\n\n\n# 2. 利用集合\ndef finddup(nums):\n    t = {}\n    for item in nums:\n        if item in t:\n            return item\n        else:\n            t[item] = True\n\nprint(finddup([1, 2, 3, 1, 1]))\n\n# 3. 利用字典\ndef findDuplicate(nums):\n    t = {}\n    for item in nums:\n        if item not in t:\n            t[item] = 1\n        else:\n           "}
{"task_id": "leetcode/961", "completion": "\n    return collections.Counter(nums).most_common()[0][0]\n```\n\n### 找不同的数字猜测游戏\n\n```python\ndef findTheDifference(s, s1):\n    '''\n    找到两个字符串的不同字符\n    Find the different character in two strings\n    >>> findTheDifference('abcd','abcde')\n    'e'\n    >>> findTheDifference('abcbd','abcdde')\n    'd'\n    '''\n    if len(s) == len(s1):\n        return s1[len(s):]\n    else:\n        return s1[len(s):len(s)+1]\n```\n\n### 拼接数字\n\n```python\ndef toNums(nums):\n    '''\n    把数字字符串拼接成一个数字\n    >>> toNums(['1', '2', '3'])\n    123\n    >>> toNums(['0', '1', '2", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return collections.Counter(nums).most_common()[0][0]\n```\n\n### 找不同的数字猜测游戏\n\n```python\ndef findTheDifference(s, s1):\n    '''\n    找到两个字符串的不同字符\n    Find the different character in two strings\n    >>> findTheDifference('abcd','abcde')\n    'e'\n    >>> findTheDifference('abcbd','abcdde')\n    'd'\n    '''\n    if len(s) == len(s1):\n        return s1[len(s):]\n    else:\n        return s1[len(s):len(s)+1]\n```\n\n### 拼接数字\n\n```python\ndef toNums(nums):\n    '''\n    把数字字符串拼接成一个数字\n    >>> toNums(['1', '2', '3'])\n    123\n    >>> toNums(['0', '1', '2"}
{"task_id": "leetcode/961", "completion": "\n    # 遍历列表，将元素的个数存到集合\n    for i in nums:\n        # 如果集合中没有这个元素，则将这个元素的个数加到集合中\n        if i not in res:\n            res[i] = 1\n        else:\n            res[i] += 1\n    # 遍历结果集合，将元素的个数与 res[i] 进行大小比较，如果相等则返回该元素\n    for i in res:\n        if res[i] == n + 1:\n            return i\n```\n\n+ 【题4】169. 多数元素（蓄水池抽样算法）\n\n题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 n/2 的元素。\n\n算", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # 遍历列表，将元素的个数存到集合\n    for i in nums:\n        # 如果集合中没有这个元素，则将这个元素的个数加到集合中\n        if i not in res:\n            res[i] = 1\n        else:\n            res[i] += 1\n    # 遍历结果集合，将元素的个数与 res[i] 进行大小比较，如果相等则返回该元素\n    for i in res:\n        if res[i] == n + 1:\n            return i\n```\n\n+ 【题4】169. 多数元素（蓄水池抽样算法）\n\n题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 n/2 的元素。\n\n算"}
{"task_id": "leetcode/961", "completion": "\n    count = collections.Counter(nums)\n    for n in count.values():\n        if n > 1:\n            return n\n```\n\n**250. 卡牌分组**\n\n> 给定一副牌，每张牌上都写着一个整数。\n>\n> 此时，你需要 choose 一个含 1 到 max(nums) 的数字 S。\n>\n> 最终的分组是 S (对应牌上的数字) = nums[0] + nums[1] +... + nums[i] +... + nums[j] +... + nums[len(nums) - 1]\n>\n> 在 nums 的子数组中，按下标 i 分别对应着 nums[i]，如果 S == nums[i] 的话，就返回 i。\n>\n> 否则，答案为 -1。\n", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    count = collections.Counter(nums)\n    for n in count.values():\n        if n > 1:\n            return n\n```\n\n**250. 卡牌分组**\n\n> 给定一副牌，每张牌上都写着一个整数。\n>\n> 此时，你需要 choose 一个含 1 到 max(nums) 的数字 S。\n>\n> 最终的分组是 S (对应牌上的数字) = nums[0] + nums[1] +... + nums[i] +... + nums[j] +... + nums[len(nums) - 1]\n>\n> 在 nums 的子数组中，按下标 i 分别对应着 nums[i]，如果 S == nums[i] 的话，就返回 i。\n>\n> 否则，答案为 -1。\n"}
{"task_id": "leetcode/961", "completion": "\n    d = collections.Counter(nums)\n    for k, v in d.items():\n        if v == len(nums) // 2:\n            return k\n    return None\n```\n\n最后", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    d = collections.Counter(nums)\n    for k, v in d.items():\n        if v == len(nums) // 2:\n            return k\n    return None\n```\n\n最后"}
{"task_id": "leetcode/961", "completion": "\n    return reduce(lambda a,b: a^b)\n\n'''\n数组中的数字 极小值\n给定长度为 n+1 的数组 arr，其数字位于范围 [1,n] 中，包括 n。arr[0] 是一个有效的数字，其他数字都不是 arr 中的有效数字。\n请返回 最小的有效数字  arr 中。\n如果最小的有效数字不止一个，请返回 最小的有效数字  arr 中。如果无有效数字，返回 -1 。\n\n示例:\n进阶:\n请实现时间复杂度为 O(n) 的解法\n\n输入：[1,2,3,4,5]\n输出：-1\n解释：不存在有效的数字\n\n输入：[3,4,5,1,2]\n输出：3\n解释：", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    return reduce(lambda a,b: a^b)\n\n'''\n数组中的数字 极小值\n给定长度为 n+1 的数组 arr，其数字位于范围 [1,n] 中，包括 n。arr[0] 是一个有效的数字，其他数字都不是 arr 中的有效数字。\n请返回 最小的有效数字  arr 中。\n如果最小的有效数字不止一个，请返回 最小的有效数字  arr 中。如果无有效数字，返回 -1 。\n\n示例:\n进阶:\n请实现时间复杂度为 O(n) 的解法\n\n输入：[1,2,3,4,5]\n输出：-1\n解释：不存在有效的数字\n\n输入：[3,4,5,1,2]\n输出：3\n解释："}
{"task_id": "leetcode/961", "completion": "\n    # 1. 统计每个数字出现的次数\n    # dict.get(key[, default]) -> value\n    # 如果指定 key 存在于字典中，则返回对应的值；如果不存在，返回 default 值。 \n    # 字典中返回的是一个元祖，所以要取第一个值\n    count = {}\n    for i in nums:\n        count[i] = count.get(i, 0) + 1\n    \n    # 2. 再从 count 中得到出现次数第 n 多的数字\n    # 2.1 先取出每个数字出现的次数，放到一个列表中\n    counts = [count[i] for i in count]\n    # 2.2 排序\n    counts.sort()\n    # 2.3 取出第 n 多的数字(次数第 n 多的数字)\n    return counts[-1]\n\n\n\nif __name", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # 1. 统计每个数字出现的次数\n    # dict.get(key[, default]) -> value\n    # 如果指定 key 存在于字典中，则返回对应的值；如果不存在，返回 default 值。 \n    # 字典中返回的是一个元祖，所以要取第一个值\n    count = {}\n    for i in nums:\n        count[i] = count.get(i, 0) + 1\n    \n    # 2. 再从 count 中得到出现次数第 n 多的数字\n    # 2.1 先取出每个数字出现的次数，放到一个列表中\n    counts = [count[i] for i in count]\n    # 2.2 排序\n    counts.sort()\n    # 2.3 取出第 n 多的数字(次数第 n 多的数字)\n    return counts[-1]\n\n\n\nif __name"}
{"task_id": "leetcode/961", "completion": "\n    dic = collections.defaultdict(int)\n    for n in nums:\n        dic[n] += 1\n    for k, v in dic.items():\n        if v > 1:\n            return k\n    return 0\n\n# 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以列方向，依次打印出每个元素的值。\ndef printMatrix(matrix):\n    '''\n    :param matrix:\n    :return:\n    '''\n    row = 0\n    col = 0\n    while col < len(matrix[0]):\n        for i in range(len(matrix)):\n            print(matrix[i][col], end=\" \")\n            row += 1\n        col += 1\n        for i in range(len(matrix) - 1, 0, -1):\n            print(matrix[i - 1][col], end=\" \")\n            row += 1\n\n\nclass ListNode(object):\n    def __init__(", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    dic = collections.defaultdict(int)\n    for n in nums:\n        dic[n] += 1\n    for k, v in dic.items():\n        if v > 1:\n            return k\n    return 0\n\n# 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以列方向，依次打印出每个元素的值。\ndef printMatrix(matrix):\n    '''\n    :param matrix:\n    :return:\n    '''\n    row = 0\n    col = 0\n    while col < len(matrix[0]):\n        for i in range(len(matrix)):\n            print(matrix[i][col], end=\" \")\n            row += 1\n        col += 1\n        for i in range(len(matrix) - 1, 0, -1):\n            print(matrix[i - 1][col], end=\" \")\n            row += 1\n\n\nclass ListNode(object):\n    def __init__("}
{"task_id": "leetcode/961", "completion": "\n    # 记录出现次数\n    c = collections.Counter(nums)\n    # return 出现最多次数的元素\n    return c.most_common(1)[0][0]\n\n\nif __name__ == '__main__':\n    print(repeatedNTimes([1, 2, 3, 3]))\n```\n\n## 剑指 2020.5.2 - [1032. 托普利茨矩阵](https://leetcode-cn.com/problems/sudoku-solver/)\n\n```python\nfrom collections import Counter\nimport collections\nclass Solution:\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        '''\n        给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历顺序返回这个矩阵中的所有元", "allcode": "import collections\ndef repeatedNTimes(nums):\n    '''\n    在大小为 2 * n 的数组 'nums' 中有 n + 1 个不同的元素, 其中有一个元素重复了 n 次。\n    返回重复了 n 次的那个元素。\n    Return the element repeated n times.\n    >>> repeatedNTimes([1,2,3,3])\n    3\n    '''\n    # 记录出现次数\n    c = collections.Counter(nums)\n    # return 出现最多次数的元素\n    return c.most_common(1)[0][0]\n\n\nif __name__ == '__main__':\n    print(repeatedNTimes([1, 2, 3, 3]))\n```\n\n## 剑指 2020.5.2 - [1032. 托普利茨矩阵](https://leetcode-cn.com/problems/sudoku-solver/)\n\n```python\nfrom collections import Counter\nimport collections\nclass Solution:\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        '''\n        给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历顺序返回这个矩阵中的所有元"}
{"task_id": "leetcode/747", "completion": "\n    n = len(nums)\n    if n <= 1:\n        return 0\n    first = max(nums)\n    idx = nums.index(first)\n    if n == 2 and first >= (nums[0] + nums[1]) * 2:\n        return idx\n    second = max(i for i in nums if i!= first)\n    return idx if first >= second * 2 else -1\n\n# 剑指 Offer 11. 旋转数组的最小数字\ndef minArray(nums):\n    '''\n    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n    输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。\n    例如, 数组 [3,4,5,1,2] 为 [1,2,3,4,", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    n = len(nums)\n    if n <= 1:\n        return 0\n    first = max(nums)\n    idx = nums.index(first)\n    if n == 2 and first >= (nums[0] + nums[1]) * 2:\n        return idx\n    second = max(i for i in nums if i!= first)\n    return idx if first >= second * 2 else -1\n\n# 剑指 Offer 11. 旋转数组的最小数字\ndef minArray(nums):\n    '''\n    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n    输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。\n    例如, 数组 [3,4,5,1,2] 为 [1,2,3,4,"}
{"task_id": "leetcode/747", "completion": "\n    # 利用python内置函数\n    if max(nums) >= len(nums) * 2:\n        return nums.index(max(nums))\n    return -1\n\n\ndef addDigits(num):\n    '''\n    给定一个非负整数 num, 反复将各个位上的数字相加，直到结果为一位数。\n    返回各个位上的数字相加的结果。\n    注意: 您可以假设该非负整数 num 小于 5000。\n    >>> addDigits(38)\n    2\n    >>> addDigits(19887)\n    2\n    '''\n    return int(num - int(str(num)[::-1]) if num > 0 else 0)\n\n\ndef findMaxConsecutiveOnes(nums):\n    '''\n    给你一个二进制数组 nums ，在该数组中， 计算长度", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    # 利用python内置函数\n    if max(nums) >= len(nums) * 2:\n        return nums.index(max(nums))\n    return -1\n\n\ndef addDigits(num):\n    '''\n    给定一个非负整数 num, 反复将各个位上的数字相加，直到结果为一位数。\n    返回各个位上的数字相加的结果。\n    注意: 您可以假设该非负整数 num 小于 5000。\n    >>> addDigits(38)\n    2\n    >>> addDigits(19887)\n    2\n    '''\n    return int(num - int(str(num)[::-1]) if num > 0 else 0)\n\n\ndef findMaxConsecutiveOnes(nums):\n    '''\n    给你一个二进制数组 nums ，在该数组中， 计算长度"}
{"task_id": "leetcode/747", "completion": "\n    length = len(nums)\n    if length == 1:\n        return 0\n    k = nums[0]\n    flag = 0\n    for i in range(1, length):\n        if nums[i] > k:\n            k = nums[i]\n            flag = 1\n        elif nums[i] > 0 and k == nums[0] and nums[i] > k/2:\n            flag = 1\n    if flag:\n        return length - 1\n    else:\n        return -1\n\n\nif __name__ == '__main__':\n    nums = [3, 6, 1, 0]\n    print(dominantIndex(nums))\n    nums = [", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    length = len(nums)\n    if length == 1:\n        return 0\n    k = nums[0]\n    flag = 0\n    for i in range(1, length):\n        if nums[i] > k:\n            k = nums[i]\n            flag = 1\n        elif nums[i] > 0 and k == nums[0] and nums[i] > k/2:\n            flag = 1\n    if flag:\n        return length - 1\n    else:\n        return -1\n\n\nif __name__ == '__main__':\n    nums = [3, 6, 1, 0]\n    print(dominantIndex(nums))\n    nums = ["}
{"task_id": "leetcode/747", "completion": "\n    def maxIndex(nums):\n        max = -sys.maxsize\n        idx = 0\n        for i, e in enumerate(nums):\n            if e > max:\n                max, idx = e, i\n        return idx\n    n = len(nums)\n    if n < 2:\n        return -1\n    idx = maxIndex(nums)\n    if nums[idx] >= nums[0] * 2:\n        return idx\n    else:\n        return -1\n```\n\n\n\n\n#### 1015. 可被 5 整除的二进制前缀\n\n[原题链接](https://leetcode-cn.com/problems/prefixes-div-by-5/)\n\n```\n我们定义，在一个由若干 0 和 1 组成的字符串 S 中，是否存在多个 连续的 1 使得这些 1 之间的所有数位都是 0，例如：\n\n", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    def maxIndex(nums):\n        max = -sys.maxsize\n        idx = 0\n        for i, e in enumerate(nums):\n            if e > max:\n                max, idx = e, i\n        return idx\n    n = len(nums)\n    if n < 2:\n        return -1\n    idx = maxIndex(nums)\n    if nums[idx] >= nums[0] * 2:\n        return idx\n    else:\n        return -1\n```\n\n\n\n\n#### 1015. 可被 5 整除的二进制前缀\n\n[原题链接](https://leetcode-cn.com/problems/prefixes-div-by-5/)\n\n```\n我们定义，在一个由若干 0 和 1 组成的字符串 S 中，是否存在多个 连续的 1 使得这些 1 之间的所有数位都是 0，例如：\n\n"}
{"task_id": "leetcode/747", "completion": "\n    nums = sorted(nums)\n    if nums[-1] >= 2 * nums[-2]:\n        return nums.index(nums[-1])\n    else:\n        return -1\n\n# 数组\ndef maxDepth(nums):\n    '''\n    返回数组中最大数字的索引。如果存在多个最大数字，请返回索引处于最小值。\n    例如, 如果数组是 [3, 2, 1, 0]，你将返回 3。\n    >>> maxDepth([3,6,1,0])\n    1\n    >>> maxDepth([1,2,3,4])\n    -1\n    '''\n    return nums.index(max(nums))\n\ndef minDepth(nums):\n    '''\n    返回数组中最小数字的索引。如果存在多个最小数字，请返回索引处于最大值。\n    >>> minDepth([3,6,1,0])\n    2", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    nums = sorted(nums)\n    if nums[-1] >= 2 * nums[-2]:\n        return nums.index(nums[-1])\n    else:\n        return -1\n\n# 数组\ndef maxDepth(nums):\n    '''\n    返回数组中最大数字的索引。如果存在多个最大数字，请返回索引处于最小值。\n    例如, 如果数组是 [3, 2, 1, 0]，你将返回 3。\n    >>> maxDepth([3,6,1,0])\n    1\n    >>> maxDepth([1,2,3,4])\n    -1\n    '''\n    return nums.index(max(nums))\n\ndef minDepth(nums):\n    '''\n    返回数组中最小数字的索引。如果存在多个最小数字，请返回索引处于最大值。\n    >>> minDepth([3,6,1,0])\n    2"}
{"task_id": "leetcode/747", "completion": "\n    max_num = 0\n    max_index = -1\n    for i in range(len(nums)):\n        if nums[i] > max_num:\n            max_index = i\n            max_num = nums[i]\n    if max_num > 0:\n        for i in range(len(nums)):\n            if nums[i] > nums[max_index] and nums[i] / 2 > nums[max_index]:\n                return -1\n    return max_index\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串, 请你找出其中不含有重复字符的 最长子串 的长度.\n    示例1:\n    >>> lengthOfLongestSubstring('abcabcbb')\n    3\n    示例2:\n    >>> lengthOfLongestSubstring('bbbbb')\n    1\n    示例3:\n    >>> lengthOfLongestSubstring('pwwkew')\n    3\n    '''\n    char_", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    max_num = 0\n    max_index = -1\n    for i in range(len(nums)):\n        if nums[i] > max_num:\n            max_index = i\n            max_num = nums[i]\n    if max_num > 0:\n        for i in range(len(nums)):\n            if nums[i] > nums[max_index] and nums[i] / 2 > nums[max_index]:\n                return -1\n    return max_index\n\ndef lengthOfLongestSubstring(s):\n    '''\n    给定一个字符串, 请你找出其中不含有重复字符的 最长子串 的长度.\n    示例1:\n    >>> lengthOfLongestSubstring('abcabcbb')\n    3\n    示例2:\n    >>> lengthOfLongestSubstring('bbbbb')\n    1\n    示例3:\n    >>> lengthOfLongestSubstring('pwwkew')\n    3\n    '''\n    char_"}
{"task_id": "leetcode/747", "completion": "\n    maxValue = max(nums)\n    if len(nums) == 1 or nums[0] == maxValue:\n        return 0\n    i = 1\n    while i < len(nums):\n        if nums[i] == maxValue:\n            return i\n        elif maxValue > nums[i] * 2:\n            return -1\n        i += 1\n\n\ndef maxSlidingWindow(nums, k):\n    '''\n    https://leetcode.com/problems/sliding-window-maximum/\n    给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n    返回滑动窗口中的最大值。\n    注意：你只能看到最多", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    maxValue = max(nums)\n    if len(nums) == 1 or nums[0] == maxValue:\n        return 0\n    i = 1\n    while i < len(nums):\n        if nums[i] == maxValue:\n            return i\n        elif maxValue > nums[i] * 2:\n            return -1\n        i += 1\n\n\ndef maxSlidingWindow(nums, k):\n    '''\n    https://leetcode.com/problems/sliding-window-maximum/\n    给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n    返回滑动窗口中的最大值。\n    注意：你只能看到最多"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) < 2:\n        return 0\n    result = [0, -1, 1]\n    for i, num in enumerate(nums):\n        if num * 2 >= nums[result[1]]:\n            result[1] = i\n            result[0] = max(result[0], num)\n    return result[1] if result[0] == result[1] * 2 else -1\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。\n    假设只有一个重复的整数，找出这个重复的数。\n    例如, 对于 [1,3,4,2,2], 重复的数是 2\n    >>> findDuplicate([4,5,6", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) < 2:\n        return 0\n    result = [0, -1, 1]\n    for i, num in enumerate(nums):\n        if num * 2 >= nums[result[1]]:\n            result[1] = i\n            result[0] = max(result[0], num)\n    return result[1] if result[0] == result[1] * 2 else -1\n\ndef findDuplicate(nums):\n    '''\n    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。\n    假设只有一个重复的整数，找出这个重复的数。\n    例如, 对于 [1,3,4,2,2], 重复的数是 2\n    >>> findDuplicate([4,5,6"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1:\n        return 0\n    maxNumIdx = maxIndex(nums)\n    maxNum = nums[maxNumIdx]\n    notMaxNumIdx = []\n    for i in range(len(nums)):\n        if i!= maxNumIdx:\n            if maxNum < nums[i]:\n                return -1\n            if nums[i]!= maxNum * 2:\n                notMaxNumIdx.append(i)\n    for i in notMaxNumIdx:\n        if maxNum < nums[i]:\n            return -1\n    return maxNumIdx if len(notMaxNumIdx) == 0 else -1\n\n\ndef dominantIndex_easy2hard(nums):\n    '''\n    算法思路:\n        先使用最大值去掉除自己外所有较小的元素。\n        如果最大值对了，那么就直接返回最大值的索引即可。\n        否则，判断最大", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1:\n        return 0\n    maxNumIdx = maxIndex(nums)\n    maxNum = nums[maxNumIdx]\n    notMaxNumIdx = []\n    for i in range(len(nums)):\n        if i!= maxNumIdx:\n            if maxNum < nums[i]:\n                return -1\n            if nums[i]!= maxNum * 2:\n                notMaxNumIdx.append(i)\n    for i in notMaxNumIdx:\n        if maxNum < nums[i]:\n            return -1\n    return maxNumIdx if len(notMaxNumIdx) == 0 else -1\n\n\ndef dominantIndex_easy2hard(nums):\n    '''\n    算法思路:\n        先使用最大值去掉除自己外所有较小的元素。\n        如果最大值对了，那么就直接返回最大值的索引即可。\n        否则，判断最大"}
{"task_id": "leetcode/747", "completion": "\n    if len(nums) == 1:\n        return 0\n    max_num = max(nums)\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] == max_num:\n            index = i\n            break\n    for i in range(len(nums)):\n        if i!= index:\n            if nums[i]!= 0 and nums[i] <= max_num/2:\n                return -1\n    return index\n\n\ndef dominantIndex2(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并�", "allcode": "def dominantIndex(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并且它至少是数组中每个其他数字的两倍, 所以返回 3。\n    >>> dominantIndex([3,6,1,0])\n    1\n    >>> dominantIndex([1,2,3,4])\n    -1\n    '''\n    if len(nums) == 1:\n        return 0\n    max_num = max(nums)\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] == max_num:\n            index = i\n            break\n    for i in range(len(nums)):\n        if i!= index:\n            if nums[i]!= 0 and nums[i] <= max_num/2:\n                return -1\n    return index\n\n\ndef dominantIndex2(nums):\n    '''\n    给定一个整数数组 'nums', 其中最大的整数是唯一的。\n    判断最大元素是否至少是数组中每个其他数字的两倍。如果是, 返回最大元素的索引, 否则返回 -1。\n    例如, 如果 'nums' = [1, 2, 3, 4], 最大元素是 4, 并�"}
{"task_id": "leetcode/1200", "completion": "\n    if len(arr) >= 2:\n        res = []\n        arr.sort()\n        min_diff = float(\"inf\")\n        for i in range(len(arr)-1):\n            for j in range(i+1, len(arr)):\n                diff = arr[j] - arr[i]\n                if diff < min_diff:\n                    res = [[arr[i], arr[j]]]\n                    min_diff = diff\n                elif diff == min_diff:\n                    res.append([arr[i], arr[j]])\n        return res\n    return []\n\n\ndef twoSum(nums: list, target: int) -> list:\n    '''\n    Given an array of integers nums and an integer target, \n    return indices of the two numbers such that they add up to target.\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([3, 2, 4], 6)\n    [1, 2]\n    '''\n    if nums and target:", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if len(arr) >= 2:\n        res = []\n        arr.sort()\n        min_diff = float(\"inf\")\n        for i in range(len(arr)-1):\n            for j in range(i+1, len(arr)):\n                diff = arr[j] - arr[i]\n                if diff < min_diff:\n                    res = [[arr[i], arr[j]]]\n                    min_diff = diff\n                elif diff == min_diff:\n                    res.append([arr[i], arr[j]])\n        return res\n    return []\n\n\ndef twoSum(nums: list, target: int) -> list:\n    '''\n    Given an array of integers nums and an integer target, \n    return indices of the two numbers such that they add up to target.\n    >>> twoSum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> twoSum([3, 2, 4], 6)\n    [1, 2]\n    '''\n    if nums and target:"}
{"task_id": "leetcode/1200", "completion": "\n    # 先排序\n    arr.sort()\n    # 找到所有能构成结果的pair\n    result = []\n    # last存放最后一个数\n    last = arr[-1]\n    # 找到a\n    for i in range(len(arr) - 1):\n        # a相当于i+1\n        a = arr[i + 1]\n        # b = last - a\n        b = last - a\n        if a > b:\n            # 大于0\n            if a > 0:\n                result.append([a, b])\n            # 小于0\n            else:\n                if b in arr:\n                    result.append([a, a])\n                else:\n                    result.append([min(a, b), max(a, b)])\n        else:\n            # 小于0\n            if b > 0:\n                result.append([a, b])\n            # 大于0\n            else:\n                if a in arr:\n                    result.append([a", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 先排序\n    arr.sort()\n    # 找到所有能构成结果的pair\n    result = []\n    # last存放最后一个数\n    last = arr[-1]\n    # 找到a\n    for i in range(len(arr) - 1):\n        # a相当于i+1\n        a = arr[i + 1]\n        # b = last - a\n        b = last - a\n        if a > b:\n            # 大于0\n            if a > 0:\n                result.append([a, b])\n            # 小于0\n            else:\n                if b in arr:\n                    result.append([a, a])\n                else:\n                    result.append([min(a, b), max(a, b)])\n        else:\n            # 小于0\n            if b > 0:\n                result.append([a, b])\n            # 大于0\n            else:\n                if a in arr:\n                    result.append([a"}
{"task_id": "leetcode/1200", "completion": "\n    # 排序\n    arr = sorted(arr)\n    n = len(arr)\n    # 先将首个元素出列，递归计算其余元素\n    result = []\n    for i in range(1, n):\n        diff = arr[i] - arr[0]\n        for j in range(1, i):\n            if abs(arr[j] - arr[i]) < diff:\n                diff = abs(arr[j] - arr[i])\n                result = [[arr[0], arr[i]],\n                          [arr[0], arr[j]],\n                          [arr[i], arr[j] + diff]]\n    # print(result)\n    return result\n\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 排序\n    arr = sorted(arr)\n    n = len(arr)\n    # 先将首个元素出列，递归计算其余元素\n    result = []\n    for i in range(1, n):\n        diff = arr[i] - arr[0]\n        for j in range(1, i):\n            if abs(arr[j] - arr[i]) < diff:\n                diff = abs(arr[j] - arr[i])\n                result = [[arr[0], arr[i]],\n                          [arr[0], arr[j]],\n                          [arr[i], arr[j] + diff]]\n    # print(result)\n    return result\n\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对"}
{"task_id": "leetcode/1200", "completion": "\n    # 先对数组进行排序\n    arr = sorted(arr)\n    differences = []\n    for i in range(len(arr) - 1):\n        differences.append(arr[i + 1] - arr[i])\n    # 去掉排序后相邻数字相差一的差异\n    differences = list(set(differences))\n    res = []\n    for i in range(len(diff", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 先对数组进行排序\n    arr = sorted(arr)\n    differences = []\n    for i in range(len(arr) - 1):\n        differences.append(arr[i + 1] - arr[i])\n    # 去掉排序后相邻数字相差一的差异\n    differences = list(set(differences))\n    res = []\n    for i in range(len(diff"}
{"task_id": "leetcode/1200", "completion": "\n    if not arr or len(arr) < 2:\n        return [[x, x] for x in arr]\n    arr.sort()\n    min_abs_diff = abs(arr[0] - arr[-1])\n    res = []\n    for n in range(len(arr) - 1):\n        if abs(arr[n] - arr[n + 1]) < min_abs_diff:\n            min_abs_diff = abs(arr[n] - arr[n + 1])\n            res = [[arr[n], arr[n + 1]]]\n        elif abs(arr[n] - arr[n + 1]) == min_abs_diff:\n            res.append([arr[n], arr[n + 1]])\n    return res\n    \ndef minimumAbsDifference(arr):\n    '''\n    :type arr: List[int]\n    :rtype: List[List[int]]\n    '''\n    if not arr or len(arr) < 2:\n        if len(arr) == 1:\n            return [[arr[0], arr[0", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if not arr or len(arr) < 2:\n        return [[x, x] for x in arr]\n    arr.sort()\n    min_abs_diff = abs(arr[0] - arr[-1])\n    res = []\n    for n in range(len(arr) - 1):\n        if abs(arr[n] - arr[n + 1]) < min_abs_diff:\n            min_abs_diff = abs(arr[n] - arr[n + 1])\n            res = [[arr[n], arr[n + 1]]]\n        elif abs(arr[n] - arr[n + 1]) == min_abs_diff:\n            res.append([arr[n], arr[n + 1]])\n    return res\n    \ndef minimumAbsDifference(arr):\n    '''\n    :type arr: List[int]\n    :rtype: List[List[int]]\n    '''\n    if not arr or len(arr) < 2:\n        if len(arr) == 1:\n            return [[arr[0], arr[0"}
{"task_id": "leetcode/1200", "completion": "\n    if len(arr) == 1:\n        return []\n    d = {}\n    for i in range(len(arr)):\n        d[arr[i]] = d.get(arr[i], [])\n    res = []\n    for k, v in d.items():\n        if len(v) > 1:\n            res.append(v)\n    return res\n\n\ndef minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n   ", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    if len(arr) == 1:\n        return []\n    d = {}\n    for i in range(len(arr)):\n        d[arr[i]] = d.get(arr[i], [])\n    res = []\n    for k, v in d.items():\n        if len(v) > 1:\n            res.append(v)\n    return res\n\n\ndef minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n   "}
{"task_id": "leetcode/1200", "completion": "\n    # 差值最小, 记录极小值索引\n    min_val = sys.maxsize\n    a_idx = b_idx = None\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # 差值最小\n            if abs(arr[i] - arr[j]) < min_val:\n                # 顺序找到索引\n                min_val = abs(arr[i] - arr[j])\n                a_idx = i\n                b_idx = j\n\n    # 遍历完不找到\n    if a_idx is None:\n        return []\n\n    # 找到最小值, 记录下来\n    ret = [arr[a_idx:b_idx+1]]\n\n    # 但还有其他可能的解\n    while a_idx > 0:\n        a_idx -= 1\n        b_idx += 1\n        ret.append(arr", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 差值最小, 记录极小值索引\n    min_val = sys.maxsize\n    a_idx = b_idx = None\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # 差值最小\n            if abs(arr[i] - arr[j]) < min_val:\n                # 顺序找到索引\n                min_val = abs(arr[i] - arr[j])\n                a_idx = i\n                b_idx = j\n\n    # 遍历完不找到\n    if a_idx is None:\n        return []\n\n    # 找到最小值, 记录下来\n    ret = [arr[a_idx:b_idx+1]]\n\n    # 但还有其他可能的解\n    while a_idx > 0:\n        a_idx -= 1\n        b_idx += 1\n        ret.append(arr"}
{"task_id": "leetcode/1200", "completion": "\n    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if abs(arr[i] - arr[j]) == abs(arr[i] - arr[j]) \\\n                    and arr[i]!= arr[j] \\\n                    and arr[i] + arr[j] < sum(arr):\n                result.append([arr[i], arr[j]])\n    return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.minNumberOfFrogs(\"croakcroa\")\n    s.largestRectangleArea([2, 1, 5, 6, 2, 3])\n    s.kthLargestValue(None, 1, 2)\n    s.containsDuplicate([1, 2, 3, 1])\n    s.containsNearbyDuplicate([1, 0, 1, 1], 2)\n    s.countElements([1, 1, 2,", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if abs(arr[i] - arr[j]) == abs(arr[i] - arr[j]) \\\n                    and arr[i]!= arr[j] \\\n                    and arr[i] + arr[j] < sum(arr):\n                result.append([arr[i], arr[j]])\n    return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.minNumberOfFrogs(\"croakcroa\")\n    s.largestRectangleArea([2, 1, 5, 6, 2, 3])\n    s.kthLargestValue(None, 1, 2)\n    s.containsDuplicate([1, 2, 3, 1])\n    s.containsNearbyDuplicate([1, 0, 1, 1], 2)\n    s.countElements([1, 1, 2,"}
{"task_id": "leetcode/1200", "completion": "\n    # 对原数组进行排序\n    arr.sort()\n    res = []\n    # 遍历 arr 中的每个数字\n    for i in range(1, len(arr)):\n        # 计算第一个数字和其他每个数字之间的绝对差值的最小值\n        # 如果绝对差值最小值为 0, 就已经在上一个 for 循环中添加到结果数组中了\n        if abs(arr[i] - arr[i - 1])!= 0:\n            res.append([arr[i - 1], arr[i]])\n    return res\n\n\ndef maximumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最大的数对。\n    按升序返回所", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    # 对原数组进行排序\n    arr.sort()\n    res = []\n    # 遍历 arr 中的每个数字\n    for i in range(1, len(arr)):\n        # 计算第一个数字和其他每个数字之间的绝对差值的最小值\n        # 如果绝对差值最小值为 0, 就已经在上一个 for 循环中添加到结果数组中了\n        if abs(arr[i] - arr[i - 1])!= 0:\n            res.append([arr[i - 1], arr[i]])\n    return res\n\n\ndef maximumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最大的数对。\n    按升序返回所"}
{"task_id": "leetcode/1200", "completion": "\n    print('========solution=========')\n    arr.sort()\n    length = len(arr)\n    results = []\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            results.append([arr[i], arr[j]])\n    return results\n\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference2([4,2,1,3])\n    [[1, 2], [2, 3], [3", "allcode": "def minimumAbsDifference(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference([4,2,1,3])\n    [[1, 2], [2, 3], [3, 4]]\n    >>> minimumAbsDifference([1,3,6,10,15])\n    [[1, 3]]\n    '''\n    print('========solution=========')\n    arr.sort()\n    length = len(arr)\n    results = []\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            results.append([arr[i], arr[j]])\n    return results\n\n\ndef minimumAbsDifference2(arr):\n    '''\n    给定一个没有重复数字的整数数组 'arr', 找到并返回所有在 'arr' 中的绝对差值最小的数对。\n    按升序返回所有数对, 每个数对 [a, b] 满足:\n    a, b 是 arr 中的两个数; a < b; b - a 等于 'arr' 中任意两个数的绝对差值中的最小值。\n    >>> minimumAbsDifference2([4,2,1,3])\n    [[1, 2], [2, 3], [3"}
{"task_id": "leetcode/1385", "completion": "\n    arr1 = sorted(arr1)\n    arr2 = sorted(arr2)\n    arr1_i = 0\n    arr2_i = 0\n    arr1_v = arr1[arr1_i]\n    arr2_v = arr2[arr2_i]\n    d_count = 0\n    for i in range(len(arr1)):\n        while (abs(arr1_v - arr2_v) <= d) and (arr2_i < len(arr2)):\n            arr2_v = arr2[arr2_i]\n            arr2_i += 1\n        if arr2_i == len(arr2):\n            return i-arr1_i\n        arr1_v = arr1[arr1_i]\n        arr1_i += 1\n    return i-arr1_i\n\n\nif __name__ == \"__main__\":\n    # arr = [1, 2, 3, 4, 5, 6]\n    # d = 2\n    # print(findTheDistanceValue(arr, arr, d", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1 = sorted(arr1)\n    arr2 = sorted(arr2)\n    arr1_i = 0\n    arr2_i = 0\n    arr1_v = arr1[arr1_i]\n    arr2_v = arr2[arr2_i]\n    d_count = 0\n    for i in range(len(arr1)):\n        while (abs(arr1_v - arr2_v) <= d) and (arr2_i < len(arr2)):\n            arr2_v = arr2[arr2_i]\n            arr2_i += 1\n        if arr2_i == len(arr2):\n            return i-arr1_i\n        arr1_v = arr1[arr1_i]\n        arr1_i += 1\n    return i-arr1_i\n\n\nif __name__ == \"__main__\":\n    # arr = [1, 2, 3, 4, 5, 6]\n    # d = 2\n    # print(findTheDistanceValue(arr, arr, d"}
{"task_id": "leetcode/1385", "completion": "\n    from collections import Counter\n    m, n = len(arr1), len(arr2)\n    ct = Counter(arr2)\n    count = 0\n    for num in arr1:\n        if num in ct:\n            count += max(ct[num] - 1, 0)\n        else:\n            count += len([x for x in arr2 if abs(x - num) <= d])\n        ct[num] -= 1\n    return count\n\n\ndef maxDistToClosest(arr):\n    '''\n    给定一个整数数组 arr，找到最长的连续子数组的长度，该子数组中的任意两个元素之间的绝对差别不超过1。\n    >>> maxDistToClosest([1, 1, 4, 2, 1, 4, 2, 4, 4])\n    5\n    >>> maxDistToClosest([1, 4, 2, 1, 4, 2", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    from collections import Counter\n    m, n = len(arr1), len(arr2)\n    ct = Counter(arr2)\n    count = 0\n    for num in arr1:\n        if num in ct:\n            count += max(ct[num] - 1, 0)\n        else:\n            count += len([x for x in arr2 if abs(x - num) <= d])\n        ct[num] -= 1\n    return count\n\n\ndef maxDistToClosest(arr):\n    '''\n    给定一个整数数组 arr，找到最长的连续子数组的长度，该子数组中的任意两个元素之间的绝对差别不超过1。\n    >>> maxDistToClosest([1, 1, 4, 2, 1, 4, 2, 4, 4])\n    5\n    >>> maxDistToClosest([1, 4, 2, 1, 4, 2"}
{"task_id": "leetcode/1385", "completion": "\n    return 0\n\n# 买卖股票的最佳时机\ndef maxProfit(prices):\n    '''\n    给定一个数组, 其中第i个数代表一支给定股票在第i天的价格. 你在进行若干笔交易时, 你需要设计一个算法来计算最大利润。\n    但是只允许进行下列几种交易:\n        - 在 任意i 时刻, 你可以买入这只股票\n        - 在 任意i 时刻, 你可以卖出这只股票\n    返回你最大的利润.\n    >>> maxProfit([3,3,5,0,0,3,1,4])\n    6\n    >>> maxProfit([1,2,3,", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return 0\n\n# 买卖股票的最佳时机\ndef maxProfit(prices):\n    '''\n    给定一个数组, 其中第i个数代表一支给定股票在第i天的价格. 你在进行若干笔交易时, 你需要设计一个算法来计算最大利润。\n    但是只允许进行下列几种交易:\n        - 在 任意i 时刻, 你可以买入这只股票\n        - 在 任意i 时刻, 你可以卖出这只股票\n    返回你最大的利润.\n    >>> maxProfit([3,3,5,0,0,3,1,4])\n    6\n    >>> maxProfit([1,2,3,"}
{"task_id": "leetcode/1385", "completion": "\n    return len([i for i in arr1 if i in arr2 and abs(i - arr2[arr1.index(i)]) > d])\n\n\nprint(findTheDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3))\n\n\n# 5. 两个整数的百分百相同\ndef checkMajority(arr, r):\n    '''\n    给定一个整数数组 'arr'，和一个整数 'r'，返回 'r' 与数组中所有元素的百分百匹配结果。\n    %百分比匹配 (百分比相等) 定义为满足对于每个元素 arr[i]，都有 arr[i] = r * arr[i] / 100。\n    >>> checkMajority([1, 5, 9, 1, 5, 9], 5)\n    1\n   ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    return len([i for i in arr1 if i in arr2 and abs(i - arr2[arr1.index(i)]) > d])\n\n\nprint(findTheDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3))\n\n\n# 5. 两个整数的百分百相同\ndef checkMajority(arr, r):\n    '''\n    给定一个整数数组 'arr'，和一个整数 'r'，返回 'r' 与数组中所有元素的百分百匹配结果。\n    %百分比匹配 (百分比相等) 定义为满足对于每个元素 arr[i]，都有 arr[i] = r * arr[i] / 100。\n    >>> checkMajority([1, 5, 9, 1, 5, 9], 5)\n    1\n   "}
{"task_id": "leetcode/1385", "completion": "\n    '''\n    思路：\n    1.扫描两个数组，分别计算每个数组中离'd'的近似距离的个数\n    2.比较两个距离值的大小，返回距离值较小者\n    '''\n    d = abs(d)\n    count1 = 0\n    count2 = 0\n    for i in arr1:\n        if i - d not in arr2:\n            count1 += 1\n        if i + d not in arr2:\n            count2 += 1\n    if count1 < count2:\n        return count1\n    return count2\n\n\ndef majorityElement(nums):\n    '''\n    给定一个大小为n的整数数组，找出其中所有出现超过n/3的元素。\n    示例:\n    >>> majorityElement([3,2,3])\n    [3]\n    >>> majorityElement([2", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    '''\n    思路：\n    1.扫描两个数组，分别计算每个数组中离'd'的近似距离的个数\n    2.比较两个距离值的大小，返回距离值较小者\n    '''\n    d = abs(d)\n    count1 = 0\n    count2 = 0\n    for i in arr1:\n        if i - d not in arr2:\n            count1 += 1\n        if i + d not in arr2:\n            count2 += 1\n    if count1 < count2:\n        return count1\n    return count2\n\n\ndef majorityElement(nums):\n    '''\n    给定一个大小为n的整数数组，找出其中所有出现超过n/3的元素。\n    示例:\n    >>> majorityElement([3,2,3])\n    [3]\n    >>> majorityElement([2"}
{"task_id": "leetcode/1385", "completion": "\n    a = map(x.count, [arr1, arr2])\n    return max(sum(y[x] for x in range(len(y))) - d for y in combinations_with_replacement(a, 2))\n\n\nif __name__ == '__main__':\n    print(findTheDistanceValue([4, 5, 8], [10, 9, 1, 8], 2))\n    print(findTheDistanceValue([1, 4, ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    a = map(x.count, [arr1, arr2])\n    return max(sum(y[x] for x in range(len(y))) - d for y in combinations_with_replacement(a, 2))\n\n\nif __name__ == '__main__':\n    print(findTheDistanceValue([4, 5, 8], [10, 9, 1, 8], 2))\n    print(findTheDistanceValue([1, 4, "}
{"task_id": "leetcode/1385", "completion": "\n    arr1_cnt = Counter(arr1)\n    arr2_cnt = Counter(arr2)\n    res = 0\n    for k, v in arr2_cnt.items():\n        if v >= arr1_cnt[k+d] and v >= arr1_cnt[k-d]:\n            res += 1 + min(arr1_cnt[k+d], arr1_cnt[k-d]) - v\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    arr1_cnt = Counter(arr1)\n    arr2_cnt = Counter(arr2)\n    res = 0\n    for k, v in arr2_cnt.items():\n        if v >= arr1_cnt[k+d] and v >= arr1_cnt[k-d]:\n            res += 1 + min(arr1_cnt[k+d], arr1_cnt[k-d]) - v\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "leetcode/1385", "completion": "\n    # 先统计arr1的集合元素个数\n    arr1_map = collections.Counter(arr1)\n    # 统计arr2的元素个数\n    arr2_map = collections.Counter(arr2)\n    \n    # 统计arr1中不在arr2中的元素\n    diff_map = dict()\n    for k, v in arr1_map.items():\n        if k not in arr2_map:\n            diff_map[k] = v\n    \n    # 统计超过d离群值的元素个数\n    max_value = 0\n    for k,v in diff_map.items():\n        if max_value < v:\n            max_value = v\n    return max_value\n\n\ndef convertToTitle(n):\n    '''\n    将给出的数字转化为标题字母,如1->A,26->Z,27->AA,28->AB\n    示例 1:\n\n    Input: 1\n    Output: \"A\"\n    Example ", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    # 先统计arr1的集合元素个数\n    arr1_map = collections.Counter(arr1)\n    # 统计arr2的元素个数\n    arr2_map = collections.Counter(arr2)\n    \n    # 统计arr1中不在arr2中的元素\n    diff_map = dict()\n    for k, v in arr1_map.items():\n        if k not in arr2_map:\n            diff_map[k] = v\n    \n    # 统计超过d离群值的元素个数\n    max_value = 0\n    for k,v in diff_map.items():\n        if max_value < v:\n            max_value = v\n    return max_value\n\n\ndef convertToTitle(n):\n    '''\n    将给出的数字转化为标题字母,如1->A,26->Z,27->AA,28->AB\n    示例 1:\n\n    Input: 1\n    Output: \"A\"\n    Example "}
{"task_id": "leetcode/1385", "completion": "\n    res = 0\n    for i in arr1:\n        for j in arr2:\n            if abs(i - j) <= d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == \"__main__\":\n    arr1 = [4, 5, 8]\n    arr2 = [10, 9, 1, 8]\n    d = 2\n    res = findTheDistanceValue(arr1, arr2, d)\n    print(res)\n\n    arr1 = [1, 4, 2, 3]\n    arr2 = [-4, -3, 6, 10, 20, 30]\n    d = 3\n    res = findTheDistanceValue(arr1, arr2, d)\n    print(res)\n\n    arr1 = [2, 1, 100, 3]\n    arr2 = [-5, -2, 10, -3, 7]\n    d = 6\n    res = findTheDistanceValue(arr1, arr2,", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n    res = 0\n    for i in arr1:\n        for j in arr2:\n            if abs(i - j) <= d:\n                res += 1\n                break\n    return res\n\n\nif __name__ == \"__main__\":\n    arr1 = [4, 5, 8]\n    arr2 = [10, 9, 1, 8]\n    d = 2\n    res = findTheDistanceValue(arr1, arr2, d)\n    print(res)\n\n    arr1 = [1, 4, 2, 3]\n    arr2 = [-4, -3, 6, 10, 20, 30]\n    d = 3\n    res = findTheDistanceValue(arr1, arr2, d)\n    print(res)\n\n    arr1 = [2, 1, 100, 3]\n    arr2 = [-5, -2, 10, -3, 7]\n    d = 6\n    res = findTheDistanceValue(arr1, arr2,"}
{"task_id": "leetcode/1385", "completion": "\n\n    result = 0\n    for x, y in zip(arr1, arr2):\n        if abs(x - y) > d:\n            result += 1\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n```\n\n## 最大差值与长度\n\n```python\n# -*- coding:utf-8 -*-\n# class Solution:\n#     def maximumGap(self, nums):\n#         return self.getMaxValue(nums)\n\n#     def getMaxValue(self, arr):\n#         '''\n#         给定一个非空且只包含非负数的整数数组，返回最大差值。\n#         >>> s = Solution()\n#         >>> s.getMaxValue([1, 2, 3, 4, 5])\n#         4\n#         '''\n#         if len(arr) < 2:\n#             return 0\n#         max_val", "allcode": "def findTheDistanceValue(arr1, arr2, d):\n    '''\n    给定两个整数数组 'arr1' 和 'arr2', 以及一个整数 'd', 返回两个数组之间的距离值。\n    距离值 定义为满足arr1数组中指定元素arr[i]的数量，满足对于arr2中的每个元素arr2[j]，都有|arr[i]-arr2[j]| > d。\n    >>> findTheDistanceValue([4,5,8], [10,9,1,8], 2)\n    2\n    >>> findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3)\n    2\n    >>> findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6)\n    1\n    '''\n\n    result = 0\n    for x, y in zip(arr1, arr2):\n        if abs(x - y) > d:\n            result += 1\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n```\n\n## 最大差值与长度\n\n```python\n# -*- coding:utf-8 -*-\n# class Solution:\n#     def maximumGap(self, nums):\n#         return self.getMaxValue(nums)\n\n#     def getMaxValue(self, arr):\n#         '''\n#         给定一个非空且只包含非负数的整数数组，返回最大差值。\n#         >>> s = Solution()\n#         >>> s.getMaxValue([1, 2, 3, 4, 5])\n#         4\n#         '''\n#         if len(arr) < 2:\n#             return 0\n#         max_val"}
{"task_id": "leetcode/349", "completion": "\n    d = {}\n    ans = []\n    for n in nums1:\n        if n in d:\n            d[n] += 1\n        else:\n            d[n] = 1\n    for n in nums2:\n        if n in d:\n            if d[n] > 0:\n                ans.append(n)\n                d[n] -= 1\n    return ans\n\n\ndef intersection_(nums1, nums2):\n    '''\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    '''\n    d = {num: 0 for num in nums1}\n    ans = []\n    for num in nums2:\n        if num in d:\n            if d[num] > 0:\n                ans.append(num)\n                d[num] -= 1\n    return ans\n\n\ndef intersection_(nums1, nums2):\n    '''\n    :type nums1: List[int]\n    :type nums2:", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    d = {}\n    ans = []\n    for n in nums1:\n        if n in d:\n            d[n] += 1\n        else:\n            d[n] = 1\n    for n in nums2:\n        if n in d:\n            if d[n] > 0:\n                ans.append(n)\n                d[n] -= 1\n    return ans\n\n\ndef intersection_(nums1, nums2):\n    '''\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    '''\n    d = {num: 0 for num in nums1}\n    ans = []\n    for num in nums2:\n        if num in d:\n            if d[num] > 0:\n                ans.append(num)\n                d[num] -= 1\n    return ans\n\n\ndef intersection_(nums1, nums2):\n    '''\n    :type nums1: List[int]\n    :type nums2:"}
{"task_id": "leetcode/349", "completion": "\n    p1 = 0\n    p2 = 0\n    n1 = len(nums1)\n    n2 = len(nums2)\n\n    if n1 == 0 or n2 == 0:\n        return []\n\n    result = []\n    while p1 < n1 and p2 < n2:\n        if nums1[p1] < nums2[p2]:\n            p1 += 1\n        elif nums1[p1] > nums2[p2]:\n            p2 += 1\n        else:\n            result.append(nums1[p1])\n            p1 += 1\n            p2 += 1\n    \n    return result\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    p1 = 0\n    p2 = 0\n    n1 = len(nums1)\n    n2 = len(nums2)\n\n    if n1 == 0 or n2 == 0:\n        return []\n\n    result = []\n    while p1 < n1 and p2 < n2:\n        if nums1[p1] < nums2[p2]:\n            p1 += 1\n        elif nums1[p1] > nums2[p2]:\n            p2 += 1\n        else:\n            result.append(nums1[p1])\n            p1 += 1\n            p2 += 1\n    \n    return result\n\ndef union(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的并集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> union([1,2,"}
{"task_id": "leetcode/349", "completion": "\n    def get_map(nums):\n        map = {}\n        for num in nums:\n            if num not in map:\n                map.update({num: 1})\n            else:\n                map.update({num: map[num]+1})\n        return map\n\n    def get_diff(map1, map2):\n        common_nums = []\n        for num in map1:\n            if num in map2:\n                result = min(map2[num], map1[num])\n                for i in range(result):\n                    common_nums.append(num)\n        return common_nums\n\n    map1 = get_map(nums1)\n    map2 = get_map(nums2)\n    return get_diff(map1, map2)\n\n# 279. 完全平方数\ndef numSquares(n):\n    '''\n    给定正整数 'n', 找到若干个完全平方数（比如 1, 4, 9, 16,...", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    def get_map(nums):\n        map = {}\n        for num in nums:\n            if num not in map:\n                map.update({num: 1})\n            else:\n                map.update({num: map[num]+1})\n        return map\n\n    def get_diff(map1, map2):\n        common_nums = []\n        for num in map1:\n            if num in map2:\n                result = min(map2[num], map1[num])\n                for i in range(result):\n                    common_nums.append(num)\n        return common_nums\n\n    map1 = get_map(nums1)\n    map2 = get_map(nums2)\n    return get_diff(map1, map2)\n\n# 279. 完全平方数\ndef numSquares(n):\n    '''\n    给定正整数 'n', 找到若干个完全平方数（比如 1, 4, 9, 16,..."}
{"task_id": "leetcode/349", "completion": "\n    return list(set(nums1).intersection(nums2))\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1).intersection(nums2))\n\n\ndef intersection3(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1).intersection(nums2))\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    return list(set(nums1).intersection(nums2))\n\n\ndef intersection3(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以"}
{"task_id": "leetcode/349", "completion": "\n    ret = []\n    hashmap = {}\n    for i in range(len(nums1)):\n        hashmap[nums1[i]] = 1\n\n    for i in range(len(nums2)):\n        if nums2[i] in hashmap:\n            ret.append(nums2[i])\n\n    return sorted(list(set(ret)))\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ret = []\n    hashmap = {}\n\n    nums1.sort()\n    nums2.sort", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ret = []\n    hashmap = {}\n    for i in range(len(nums1)):\n        hashmap[nums1[i]] = 1\n\n    for i in range(len(nums2)):\n        if nums2[i] in hashmap:\n            ret.append(nums2[i])\n\n    return sorted(list(set(ret)))\n\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ret = []\n    hashmap = {}\n\n    nums1.sort()\n    nums2.sort"}
{"task_id": "leetcode/349", "completion": "\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1.intersection(set2))\n```\n\n## 题解\n\n数组`nums1`和`nums2`是两个数组，问其中有哪些元素在两个数组都出现了，要求交集是排序的，并且不重复。\n\n思路：\n\n因为只有交集有唯一的元素满足要求，所以我们可以先把两个数组排序，然后通过双指针来解决这个问题。\n\n```python\ndef intersection(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    intersection_list = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            intersection", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1.intersection(set2))\n```\n\n## 题解\n\n数组`nums1`和`nums2`是两个数组，问其中有哪些元素在两个数组都出现了，要求交集是排序的，并且不重复。\n\n思路：\n\n因为只有交集有唯一的元素满足要求，所以我们可以先把两个数组排序，然后通过双指针来解决这个问题。\n\n```python\ndef intersection(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    intersection_list = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            intersection"}
{"task_id": "leetcode/349", "completion": "\n    ans = list()\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n        nums1, nums2 = nums2, nums1\n        n1, n2 = n2, n1\n    for i in nums2:\n        if i in nums1:\n            ans.append(i)\n    ans.sort()\n    return ans\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ans = list()\n    m1 = len", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ans = list()\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n        nums1, nums2 = nums2, nums1\n        n1, n2 = n2, n1\n    for i in nums2:\n        if i in nums1:\n            ans.append(i)\n    ans.sort()\n    return ans\n\ndef intersection2(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection2([1,2,2,1], [2,2])\n    [2]\n    >>> intersection2([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    ans = list()\n    m1 = len"}
{"task_id": "leetcode/349", "completion": "\n    hash = {}\n    m = nums1\n    n = nums2\n    res = []\n    for i in m:\n        hash[i] = '1'\n    for j in n:\n        if hash.get(j):\n            res.append(j)\n    return sorted(list(set(res)))\n\n\ndef find_the_difference(s, t):\n    '''\n    我们定义，在 '0' 和 '1' 字符之间转换的字符串，称作是翻转对。 例如，\"010\" 可以通过 \"101\" 和 \"11001\" 转换得到；但是 \"011\" 和 \"1011\" 却无法转换得到，因为 '1' 一共出现了三次，而需要被 \"01\" 替换的只有两次。 \n    >>> find_the_difference('abcd', 'abcde')\n    'e'\n    >>> find_the_", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    hash = {}\n    m = nums1\n    n = nums2\n    res = []\n    for i in m:\n        hash[i] = '1'\n    for j in n:\n        if hash.get(j):\n            res.append(j)\n    return sorted(list(set(res)))\n\n\ndef find_the_difference(s, t):\n    '''\n    我们定义，在 '0' 和 '1' 字符之间转换的字符串，称作是翻转对。 例如，\"010\" 可以通过 \"101\" 和 \"11001\" 转换得到；但是 \"011\" 和 \"1011\" 却无法转换得到，因为 '1' 一共出现了三次，而需要被 \"01\" 替换的只有两次。 \n    >>> find_the_difference('abcd', 'abcde')\n    'e'\n    >>> find_the_"}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    i = 0\n    j = 0\n    result = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            result.append(nums1[i])\n            i += 1\n            j += 1\n            continue\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return result\n\nif __name__ == '__main__':\n    nums1 = [1, 2, 2, 1]\n    nums2 = [2, 2]\n    print(intersection(num", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i = 0\n    j = 0\n    result = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            result.append(nums1[i])\n            i += 1\n            j += 1\n            continue\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return result\n\nif __name__ == '__main__':\n    nums1 = [1, 2, 2, 1]\n    nums2 = [2, 2]\n    print(intersection(num"}
{"task_id": "leetcode/349", "completion": "\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    max_len = min(len(nums1), len(nums2))\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\n\ndef get_kth_node(head, k):\n    '''\n    返回链表中倒数第k个节点\n    :param head:\n    :param k:\n    :return:\n    '''\n    node1, node2 = head, head\n    while k > 1:\n        k -= 1\n        node1 = node1.next\n    while node1:\n        node1 = node1.next\n        node", "allcode": "def intersection(nums1, nums2):\n    '''\n    给定两个整数数组 'nums1' 和 'nums2', 返回它们的交集。返回的列表中的每个元素都是唯一的, 并且以升序返回。\n    >>> intersection([1,2,2,1], [2,2])\n    [2]\n    >>> intersection([4,9,5], [9,4,9,8,4])\n    [4,9]\n    '''\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    max_len = min(len(nums1), len(nums2))\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n    return res\n\n\ndef get_kth_node(head, k):\n    '''\n    返回链表中倒数第k个节点\n    :param head:\n    :param k:\n    :return:\n    '''\n    node1, node2 = head, head\n    while k > 1:\n        k -= 1\n        node1 = node1.next\n    while node1:\n        node1 = node1.next\n        node"}
{"task_id": "leetcode/1491", "completion": "\n    return round(sum(salary) - min(salary) - max(salary))\n", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round(sum(salary) - min(salary) - max(salary))\n"}
{"task_id": "leetcode/1491", "completion": "\n    # FIXME: 需要考虑数组中有重复的数字\n    salary.sort()\n    return int(sum(salary[1:-1]) / len(salary[1:-1]))\n\n\ndef _average(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> _average([4000,3000,1000,2000])\n    2500\n    >>> _average([1000,2000,3000])\n    2000\n    '''\n    # FIXME: 需要考虑数组中有重复的数字\n    salary", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    # FIXME: 需要考虑数组中有重复的数字\n    salary.sort()\n    return int(sum(salary[1:-1]) / len(salary[1:-1]))\n\n\ndef _average(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> _average([4000,3000,1000,2000])\n    2500\n    >>> _average([1000,2000,3000])\n    2000\n    '''\n    # FIXME: 需要考虑数组中有重复的数字\n    salary"}
{"task_id": "leetcode/1491", "completion": "\n    from heapq import nsmallest\n    return int(sum(nsmallest(len(salary) - 2, salary)) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n```\n\n\n### 6、滑动窗口算法\n\n```python\n#!/usr/bin/env python3\n#encoding: utf-8\n\n'''\n给定一个数组，求数组中每两个数之和的最大值。\n例如：\n    输入：[7, 2, 4]\n    输出：13\n    解释：滑动窗口为[7,2,4]，7+2=9，2+4=6，最大值为13\n\n    输入：[1, 2, 3, 4, 5]\n    输出：15\n    解释：滑动窗口为[", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    from heapq import nsmallest\n    return int(sum(nsmallest(len(salary) - 2, salary)) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n```\n\n\n### 6、滑动窗口算法\n\n```python\n#!/usr/bin/env python3\n#encoding: utf-8\n\n'''\n给定一个数组，求数组中每两个数之和的最大值。\n例如：\n    输入：[7, 2, 4]\n    输出：13\n    解释：滑动窗口为[7,2,4]，7+2=9，2+4=6，最大值为13\n\n    输入：[1, 2, 3, 4, 5]\n    输出：15\n    解释：滑动窗口为["}
{"task_id": "leetcode/1491", "completion": "\n    return sum(salary) - min(salary) - max(salary) // len(salary)\n```\n\n### 4. 鳄鱼和垃圾\n\n给定一个由若干垃圾箱组成的行，每个垃圾箱含有若干鳄鱼。\n请返回最多能收集多少鳄鱼（鳄鱼可以重叠）。\n\n```python\ndef garbage(trash):\n    '''\n    给定一行由若干垃圾箱组成的行'trash', 每个垃圾箱含有若干鳄鱼, 返回最多能收集多少鳄鱼（鳄鱼可以重叠）。\n    >>> garbage(['#','##','#','###'])\n    7\n    >>> garbage(['#','", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return sum(salary) - min(salary) - max(salary) // len(salary)\n```\n\n### 4. 鳄鱼和垃圾\n\n给定一个由若干垃圾箱组成的行，每个垃圾箱含有若干鳄鱼。\n请返回最多能收集多少鳄鱼（鳄鱼可以重叠）。\n\n```python\ndef garbage(trash):\n    '''\n    给定一行由若干垃圾箱组成的行'trash', 每个垃圾箱含有若干鳄鱼, 返回最多能收集多少鳄鱼（鳄鱼可以重叠）。\n    >>> garbage(['#','##','#','###'])\n    7\n    >>> garbage(['#','"}
{"task_id": "leetcode/1491", "completion": "\n    return round((sum(salary)-max(salary)-min(salary))/len(salary))\n\n    # 方法2\n    m = min(salary)\n    M = max(salary)\n    return round((sum(salary)-2*m-M)/len(salary))\n\n    # 方法3\n    return round(sum(salary) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\n# 面试题 03.06. 回文子串\ndef is_substr_palindrome(s):\n    \"\"\"\n    在字符串中找到最长的回文子串\n\n    https://leetcode-cn.com/problems/longest-palindromic-substring/\n\n    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 100", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return round((sum(salary)-max(salary)-min(salary))/len(salary))\n\n    # 方法2\n    m = min(salary)\n    M = max(salary)\n    return round((sum(salary)-2*m-M)/len(salary))\n\n    # 方法3\n    return round(sum(salary) / (len(salary) - 2))\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()\n\n\n# 面试题 03.06. 回文子串\ndef is_substr_palindrome(s):\n    \"\"\"\n    在字符串中找到最长的回文子串\n\n    https://leetcode-cn.com/problems/longest-palindromic-substring/\n\n    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 100"}
{"task_id": "leetcode/1491", "completion": "\n    if len(salary) == 1:\n        return 0\n    average = sum(salary) - min(salary) - max(salary)\n    return int((average - average % 1) / len(salary))\n\n\ndef find(search_list, target):\n    \"\"\"给定一个排序好的数组'search_list' 和一个整数 'target',\n    在数组中找到 target, 返回找到的 target 的下标(下标从 0 开始)。\n    如果数组中没有 target, 返回 -1。\n    >>> find([1, 2, 3, 4, 5], 3)\n    2\n    >>> find([1, 2, 3, 4, 5], 10)\n    -1\n    >>> find([3, 2, 5, 1, 7], 9)\n    -1\n    \"\"\"\n    low = 0\n    high = len(search_list) - 1\n    while", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    if len(salary) == 1:\n        return 0\n    average = sum(salary) - min(salary) - max(salary)\n    return int((average - average % 1) / len(salary))\n\n\ndef find(search_list, target):\n    \"\"\"给定一个排序好的数组'search_list' 和一个整数 'target',\n    在数组中找到 target, 返回找到的 target 的下标(下标从 0 开始)。\n    如果数组中没有 target, 返回 -1。\n    >>> find([1, 2, 3, 4, 5], 3)\n    2\n    >>> find([1, 2, 3, 4, 5], 10)\n    -1\n    >>> find([3, 2, 5, 1, 7], 9)\n    -1\n    \"\"\"\n    low = 0\n    high = len(search_list) - 1\n    while"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    length = len(salary)\n    return int((sum(salary[1:length-1]) / (length - 2) + 0.5))\n\n\ndef average1(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average1([4000,3000,1000,2000])\n    2500\n    >>> average1([1000,2000,3000])\n    2000\n    '''\n    return int(sum(salary)/(len(salary)-2))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复��", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    length = len(salary)\n    return int((sum(salary[1:length-1]) / (length - 2) + 0.5))\n\n\ndef average1(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average1([4000,3000,1000,2000])\n    2500\n    >>> average1([1000,2000,3000])\n    2000\n    '''\n    return int(sum(salary)/(len(salary)-2))\n\n\ndef average2(salary):\n    '''\n    给定一个没有重复��"}
{"task_id": "leetcode/1491", "completion": "\n    return int(sum(salary[:-1])/(len(salary)-2))\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return int(sum(salary[1:-1])/len(salary[1:-1]))\n\ndef average3(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 sal", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    return int(sum(salary[:-1])/(len(salary)-2))\n\ndef average2(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average2([4000,3000,1000,2000])\n    2500\n    >>> average2([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return int(sum(salary[1:-1])/len(salary[1:-1]))\n\ndef average3(salary):\n    '''\n    给定一个没有重复整数的数组'salary', 其中 sal"}
{"task_id": "leetcode/1491", "completion": "\n    salary = sorted(salary)\n    min_salary = salary[0]\n    max_salary = salary[-1]\n    return int((sum(salary[1:-1])-min_salary-max_salary)/(len(salary)-2))\n\ndef get_num_from_list(L):\n    '''\n    给定一个数组，求该数组中不同数字的个数及各个数字出现的次数。\n    返回一个列表：[num1,num2,num3...]\n    >>> get_num_from_list ([1, 2, 3, 1, 1])\n    [1, 2, 3]\n    >>> get_num_from_list ([1, 2, 3, 2, 2])\n    [1, 2, 3]\n    '''\n    ret = []\n    for i in range(1,len(L)+1):\n        ret.append(i)\n    for i in range(len(L)):\n        for j in range", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary = sorted(salary)\n    min_salary = salary[0]\n    max_salary = salary[-1]\n    return int((sum(salary[1:-1])-min_salary-max_salary)/(len(salary)-2))\n\ndef get_num_from_list(L):\n    '''\n    给定一个数组，求该数组中不同数字的个数及各个数字出现的次数。\n    返回一个列表：[num1,num2,num3...]\n    >>> get_num_from_list ([1, 2, 3, 1, 1])\n    [1, 2, 3]\n    >>> get_num_from_list ([1, 2, 3, 2, 2])\n    [1, 2, 3]\n    '''\n    ret = []\n    for i in range(1,len(L)+1):\n        ret.append(i)\n    for i in range(len(L)):\n        for j in range"}
{"task_id": "leetcode/1491", "completion": "\n    salary.sort()\n    return int((sum(salary[1:-1]) / (len(salary)-2))+0.5)\n\n\ndef find_max_len(strs):\n    '''\n    给定一个字符串数组，找到参数中最长的字符串长度。\n    返回长度值。\n    >>> strs = ['a','abc','de','fgh']\n    >>> find_max_len(strs)\n    4\n    >>> strs = ['aaaa','','b']\n    >>> find_max_len(strs)\n    4\n    '''\n    ans = 0\n    for strs_one in strs:\n        if len(strs_one) > ans:\n            ans = len(strs_one)\n    return ans\n\n\ndef make_str(num, length):\n    '''\n    给定一个整数 'num' 和一个整数 'length'。\n    返回一个长度为 'length' 的 字符串 ，以 'num", "allcode": "def average(salary):\n    '''\n    给定一个没有重复整数的数组 'salary', 其中 salary[i] 是第 i 个员工的工资。\n    返回去掉最低工资和最高工资后的平均工资，结果四舍五入，返回整数。\n    >>> average([4000,3000,1000,2000])\n    2500\n    >>> average([1000,2000,3000])\n    2000\n    '''\n    salary.sort()\n    return int((sum(salary[1:-1]) / (len(salary)-2))+0.5)\n\n\ndef find_max_len(strs):\n    '''\n    给定一个字符串数组，找到参数中最长的字符串长度。\n    返回长度值。\n    >>> strs = ['a','abc','de','fgh']\n    >>> find_max_len(strs)\n    4\n    >>> strs = ['aaaa','','b']\n    >>> find_max_len(strs)\n    4\n    '''\n    ans = 0\n    for strs_one in strs:\n        if len(strs_one) > ans:\n            ans = len(strs_one)\n    return ans\n\n\ndef make_str(num, length):\n    '''\n    给定一个整数 'num' 和一个整数 'length'。\n    返回一个长度为 'length' 的 字符串 ，以 'num"}
{"task_id": "leetcode/561", "completion": "\n    s = 0\n    nums.sort()\n    for i in range(len(nums)//2):\n        s += nums[i*2] + nums[i*2+1]\n    return s\n\n\ndef reverseString(s):\n    '''\n    反转字符串\n    给定一个字符串, 逐个翻转字符串中的每个单词。\n    说明:\n    不要用额外的数组空间,\n    你必须以O(1)的空间复杂度来进行这个操作\n    >>> reverseString(\"hello\")\n    \"olleh\"\n    >>> reverseString(\"abc\")\n    \"cba\"\n    '''\n    s = list(s)\n    for i in range(len(s)//2):\n        s[i], s[~i] = s[~i], s[i]\n    return ''.join(s)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个�", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    s = 0\n    nums.sort()\n    for i in range(len(nums)//2):\n        s += nums[i*2] + nums[i*2+1]\n    return s\n\n\ndef reverseString(s):\n    '''\n    反转字符串\n    给定一个字符串, 逐个翻转字符串中的每个单词。\n    说明:\n    不要用额外的数组空间,\n    你必须以O(1)的空间复杂度来进行这个操作\n    >>> reverseString(\"hello\")\n    \"olleh\"\n    >>> reverseString(\"abc\")\n    \"cba\"\n    '''\n    s = list(s)\n    for i in range(len(s)//2):\n        s[i], s[~i] = s[~i], s[i]\n    return ''.join(s)\n\n\ndef twoSum(nums, target):\n    '''\n    给定一个�"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    result = 0\n    for i in range(0, len(nums), 2):\n        result += nums[i]\n    return result\n\n\ndef minSwaps(s):\n    '''\n    在一个长度为 n 的字符串 s 中，只包含 'x' 和 'y' 两种字符。我们想要将所有的 'x' 转换成 'y' ，所以我们可以交换一个 'x' 和相邻字符。\n    给定一个长度为 n 的字符串，返回在交换后可以得到的最大值的数量。\n    >>> minSwaps('xy')\n    1\n    >>> minSwaps('xx')\n    2\n    '''\n    x = y = 0\n    for i in s:\n        if i == 'x':\n            x += 1\n        if i == 'y':\n            y += 1\n    return x + y - 1\n\n\ndef isAlien", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    result = 0\n    for i in range(0, len(nums), 2):\n        result += nums[i]\n    return result\n\n\ndef minSwaps(s):\n    '''\n    在一个长度为 n 的字符串 s 中，只包含 'x' 和 'y' 两种字符。我们想要将所有的 'x' 转换成 'y' ，所以我们可以交换一个 'x' 和相邻字符。\n    给定一个长度为 n 的字符串，返回在交换后可以得到的最大值的数量。\n    >>> minSwaps('xy')\n    1\n    >>> minSwaps('xx')\n    2\n    '''\n    x = y = 0\n    for i in s:\n        if i == 'x':\n            x += 1\n        if i == 'y':\n            y += 1\n    return x + y - 1\n\n\ndef isAlien"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    max_sum = 0\n    for i in range(0, len(nums), 2):\n        max_sum += nums[i]\n    return max_sum\n\n\ndef isValid(s):\n    '''\n    给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n    有效字符串需满足：\n    左括号必须用相同类型的右括号闭合。\n    左括号必须以正确的顺序闭合。\n    注意空字符串可被认为是有效字符串。\n     >>> isValid(\"()\")\n     True\n     >>> isValid(\"()[]{}\")\n     True\n     >>> isValid(\"(]\")\n     False\n    '''\n    stack = []\n    for item in s:\n        if item == '(' or item == '[' or item == '{':", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    max_sum = 0\n    for i in range(0, len(nums), 2):\n        max_sum += nums[i]\n    return max_sum\n\n\ndef isValid(s):\n    '''\n    给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n    有效字符串需满足：\n    左括号必须用相同类型的右括号闭合。\n    左括号必须以正确的顺序闭合。\n    注意空字符串可被认为是有效字符串。\n     >>> isValid(\"()\")\n     True\n     >>> isValid(\"()[]{}\")\n     True\n     >>> isValid(\"(]\")\n     False\n    '''\n    stack = []\n    for item in s:\n        if item == '(' or item == '[' or item == '{':"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\nclass Solution:\n    def numSubarrayB", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    res = 0\n    for i in range(0, len(nums), 2):\n        res += nums[i]\n    return res\n\n\nclass Solution:\n    def numSubarrayB"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort(reverse=False)\n    pre = 0\n    for i in range(len(nums)-1):\n        pre += nums[i]\n    return pre\n\n\ndef addBoldTag(s, dict):\n    '''\n    给你一个字符串 s 和一个字典 d，s 中的字母不区分大小写，请你判断是否能够通过将 d 中的字母组合在一起（可以重复使用字典中的字母），从而形成字符串 s 。\n    如果能, 则返回 True ；否则, 返回 False 。\n    >>> addBoldTag(\"abcd\", {\"bc\":\"cd\",\"efg\":\"hijk\"})\n    \"a<u>bc</u>d<u>efg</u>\"\n    >>> addBoldTag(\"aefbgd\", {\"bc\":\"cd\",\"efg\":\"hijk\"})\n    False\n    '''\n    res = \"\"\n    for i in s:\n        if i in dict:\n", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort(reverse=False)\n    pre = 0\n    for i in range(len(nums)-1):\n        pre += nums[i]\n    return pre\n\n\ndef addBoldTag(s, dict):\n    '''\n    给你一个字符串 s 和一个字典 d，s 中的字母不区分大小写，请你判断是否能够通过将 d 中的字母组合在一起（可以重复使用字典中的字母），从而形成字符串 s 。\n    如果能, 则返回 True ；否则, 返回 False 。\n    >>> addBoldTag(\"abcd\", {\"bc\":\"cd\",\"efg\":\"hijk\"})\n    \"a<u>bc</u>d<u>efg</u>\"\n    >>> addBoldTag(\"aefbgd\", {\"bc\":\"cd\",\"efg\":\"hijk\"})\n    False\n    '''\n    res = \"\"\n    for i in s:\n        if i in dict:\n"}
{"task_id": "leetcode/561", "completion": "\n    n = len(nums)\n    nums.sort()\n    ret = 0\n    for i in range(n):\n        num = nums[i] + nums[i+1]\n        if num > ret:\n            ret = num\n    return ret\n\n\ndef sumSubarrayMins(nums):\n    '''return: 最小的和'''\n    '''\n    给定一个正整数数组 nums （下标从 1 开始），请找到具有最小和的连续子数组，并返回其和。\n    示例：\n    >>> sumSubarrayMins([3,1,2,4,3])\n    5\n    >>> sumSubarrayMins([6,2,1,4,3])\n    8\n    >>> sumSubarrayMins([1,2,3,4,5])\n    14\n    '''\n    n = len(nums)\n    ret = nums[0]\n    for i in range(1, n):\n        nums[i]", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    n = len(nums)\n    nums.sort()\n    ret = 0\n    for i in range(n):\n        num = nums[i] + nums[i+1]\n        if num > ret:\n            ret = num\n    return ret\n\n\ndef sumSubarrayMins(nums):\n    '''return: 最小的和'''\n    '''\n    给定一个正整数数组 nums （下标从 1 开始），请找到具有最小和的连续子数组，并返回其和。\n    示例：\n    >>> sumSubarrayMins([3,1,2,4,3])\n    5\n    >>> sumSubarrayMins([6,2,1,4,3])\n    8\n    >>> sumSubarrayMins([1,2,3,4,5])\n    14\n    '''\n    n = len(nums)\n    ret = nums[0]\n    for i in range(1, n):\n        nums[i]"}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    return sum(nums[i] + nums[i + 1] for i in range(0, len(nums), 2))\n\n\ndef majorityElement(nums):\n    '''\n    给定一个大小为 n 的数组, 找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n    你可以假设数组是非空的, 并且给定的数组总是存在多数元素。\n    你可以假设数组不会包含重复元素。\n    示例 1:\n    nums = [3,2,3]\n    多数元素是 3, 为 3 出现 2 次, 超过数组长度的一半, 也就是两个 3 一组, 所以答案是 3\n    示例 ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    return sum(nums[i] + nums[i + 1] for i in range(0, len(nums), 2))\n\n\ndef majorityElement(nums):\n    '''\n    给定一个大小为 n 的数组, 找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n    你可以假设数组是非空的, 并且给定的数组总是存在多数元素。\n    你可以假设数组不会包含重复元素。\n    示例 1:\n    nums = [3,2,3]\n    多数元素是 3, 为 3 出现 2 次, 超过数组长度的一半, 也就是两个 3 一组, 所以答案是 3\n    示例 "}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n## 2 打家劫舍 II\n\n> [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums: return 0\n        if len(nums) == 1: return nums[0]\n        if len(nums) == 2: return max(nums)\n        dp = [nums[0], nums[0]]\n        for i in range(2, len(nums)):\n            dp.append(max(dp[i - 2] + nums[i], dp[i - 1]))\n       ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    sum = 0\n    for i in range(0, len(nums), 2):\n        sum += nums[i]\n    return sum\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```\n\n## 2 打家劫舍 II\n\n> [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums: return 0\n        if len(nums) == 1: return nums[0]\n        if len(nums) == 2: return max(nums)\n        dp = [nums[0], nums[0]]\n        for i in range(2, len(nums)):\n            dp.append(max(dp[i - 2] + nums[i], dp[i - 1]))\n       "}
{"task_id": "leetcode/561", "completion": "\n    nums.sort()\n    size = len(nums)\n    ans = 0\n    for", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    nums.sort()\n    size = len(nums)\n    ans = 0\n    for"}
{"task_id": "leetcode/561", "completion": "\n    n = len(nums)\n    nums = sorted(nums)\n    ans = 0\n    for i in range(n // 2):\n        ans += nums[i] + nums[-i - 1]\n    return ans\n\n\ndef arrayPairSum1(nums):\n    '''\n    >>> arrayPairSum1([1,4,3,2])\n    4\n    >>> arrayPairSum1([6,2,6,5,1,2])\n    9\n    '''\n    nums = sorted(nums)\n    n = len(nums)\n    arr = [0] * (n // 2)\n    for i in range(0, n, 2):\n        arr[i // 2] = nums[i] + nums[i + 1]\n    return max(arr)\n\n\ndef arrayPairSum2(nums):\n    '''\n    >>> arrayPairSum2([1,4,3,2])\n    4\n    >>> arrayPairSum2([6,2,6,5,1,2])\n    9\n   ", "allcode": "def arrayPairSum(nums):\n    '''\n    给定一个长度为 2n 的整数数组 nums, 将 nums 中的元素两两配对并组成 n 个数对, 使得每对数对的最小值之和最大。\n    返回最大的和。\n    >>> arrayPairSum([1,4,3,2])\n    4\n    >>> arrayPairSum([6,2,6,5,1,2])\n    9\n    '''\n    n = len(nums)\n    nums = sorted(nums)\n    ans = 0\n    for i in range(n // 2):\n        ans += nums[i] + nums[-i - 1]\n    return ans\n\n\ndef arrayPairSum1(nums):\n    '''\n    >>> arrayPairSum1([1,4,3,2])\n    4\n    >>> arrayPairSum1([6,2,6,5,1,2])\n    9\n    '''\n    nums = sorted(nums)\n    n = len(nums)\n    arr = [0] * (n // 2)\n    for i in range(0, n, 2):\n        arr[i // 2] = nums[i] + nums[i + 1]\n    return max(arr)\n\n\ndef arrayPairSum2(nums):\n    '''\n    >>> arrayPairSum2([1,4,3,2])\n    4\n    >>> arrayPairSum2([6,2,6,5,1,2])\n    9\n   "}
{"task_id": "leetcode/209", "completion": "\n    left = 0\n    right = 0\n    ans = float('inf')\n    temp = 0\n    while right < len(nums):\n        temp += nums[right]\n        right += 1\n        while temp >= target:\n            ans = min(ans, right - left)\n            temp -= nums[left]\n            left += 1\n    return ans if ans!= float('inf') else 0\n\n\ndef checkPossibility(nums):\n    '''\n    给你一个长度为 n 的整数数组 nums 。你有两个可以操作 nums 的选项：\n        1.选择 1 处的数字并将其增加 1 。\n        2.选择 2 处的数字并将其增加 1 。\n    你最多调用 k 次操作（ k <= 10000）。\n    返回你能够获得的最大值。\n\n    >>> nums = [1,1,1]", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    left = 0\n    right = 0\n    ans = float('inf')\n    temp = 0\n    while right < len(nums):\n        temp += nums[right]\n        right += 1\n        while temp >= target:\n            ans = min(ans, right - left)\n            temp -= nums[left]\n            left += 1\n    return ans if ans!= float('inf') else 0\n\n\ndef checkPossibility(nums):\n    '''\n    给你一个长度为 n 的整数数组 nums 。你有两个可以操作 nums 的选项：\n        1.选择 1 处的数字并将其增加 1 。\n        2.选择 2 处的数字并将其增加 1 。\n    你最多调用 k 次操作（ k <= 10000）。\n    返回你能够获得的最大值。\n\n    >>> nums = [1,1,1]"}
{"task_id": "leetcode/209", "completion": "\n    # 贪心思想 从左往右找 每次循环 存储在 子数组中的和大于等于 target 的最小子数组的长度\n    # 和 子数组长度 循环\n    # 但是 这里 这样做是有问题 就是在贪心\n    # 因为 题目给的 子数组 是连续的 所以 就是\n    # 从左往右 每次循环 子数组的最小值 会越来越小 就不能满足题目的要求\n    length = len(nums)\n    min_val = 0\n    max_val = float('inf')\n    for i in range(length):\n        min_val = max(nums[i], min_val + nums[i])\n        if max_val >= min_val:\n            max_val = min_val", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 贪心思想 从左往右找 每次循环 存储在 子数组中的和大于等于 target 的最小子数组的长度\n    # 和 子数组长度 循环\n    # 但是 这里 这样做是有问题 就是在贪心\n    # 因为 题目给的 子数组 是连续的 所以 就是\n    # 从左往右 每次循环 子数组的最小值 会越来越小 就不能满足题目的要求\n    length = len(nums)\n    min_val = 0\n    max_val = float('inf')\n    for i in range(length):\n        min_val = max(nums[i], min_val + nums[i])\n        if max_val >= min_val:\n            max_val = min_val"}
{"task_id": "leetcode/209", "completion": "\n    # 先排序，如果排序后，target是小于所有值的，则返回0\n    # 否则遍历每个数，计算当前数字加上累计和和target的差值，如果差值大于0，则说明当前数组和小于target\n    if nums is None or len(nums) == 0:\n        return 0\n    nums = sorted(nums)\n    # 因为排序后最大值比较大，所以判断长度是否在0-len(nums)之间\n    if target > nums[-1] * len(nums):\n        return 0\n    left = 0\n    right = 0\n    left_sum = 0\n    while right < len(nums):\n        right += 1\n        left_sum += nums[right]\n        if left_sum < target:\n            continue\n        while left_sum >= target and left <= right:\n            left +=", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 先排序，如果排序后，target是小于所有值的，则返回0\n    # 否则遍历每个数，计算当前数字加上累计和和target的差值，如果差值大于0，则说明当前数组和小于target\n    if nums is None or len(nums) == 0:\n        return 0\n    nums = sorted(nums)\n    # 因为排序后最大值比较大，所以判断长度是否在0-len(nums)之间\n    if target > nums[-1] * len(nums):\n        return 0\n    left = 0\n    right = 0\n    left_sum = 0\n    while right < len(nums):\n        right += 1\n        left_sum += nums[right]\n        if left_sum < target:\n            continue\n        while left_sum >= target and left <= right:\n            left +="}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    min_len = len(nums) + 1\n    start = 0\n    cur_sum = 0\n    for i, num in enumerate(nums):\n        cur_sum += num\n        while cur_sum >= target:\n            min_len = min(min_len, i - start + 1)\n            cur_sum -= nums[start]\n            start += 1\n    return 0 if min_len > len(nums) else min_len\n\n\ndef removeElement(nums, val):\n    '''\n    https://leetcode-cn.com/problems/remove-element/\n    给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    min_len = len(nums) + 1\n    start = 0\n    cur_sum = 0\n    for i, num in enumerate(nums):\n        cur_sum += num\n        while cur_sum >= target:\n            min_len = min(min_len, i - start + 1)\n            cur_sum -= nums[start]\n            start += 1\n    return 0 if min_len > len(nums) else min_len\n\n\ndef removeElement(nums, val):\n    '''\n    https://leetcode-cn.com/problems/remove-element/\n    给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成"}
{"task_id": "leetcode/209", "completion": "\n    _sum = 0\n    _length = len(nums)\n    _end = 0\n    _start = 0\n    _min = _length + 1\n    while _end < _length:\n        _sum += nums[_end]\n        while _sum >= target:\n            _min = min(_min, _end - _start + 1)\n            _sum -= nums[_start]\n            _start += 1\n        _end += 1\n    return _min if _min < _length + 1 else 0\n\n\nif __name__ == \"__main__\":\n    # print(maxProfit([7,1,5,3,6,4]))\n    print(minSubArrayLen(7, [2, 3,", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    _sum = 0\n    _length = len(nums)\n    _end = 0\n    _start = 0\n    _min = _length + 1\n    while _end < _length:\n        _sum += nums[_end]\n        while _sum >= target:\n            _min = min(_min, _end - _start + 1)\n            _sum -= nums[_start]\n            _start += 1\n        _end += 1\n    return _min if _min < _length + 1 else 0\n\n\nif __name__ == \"__main__\":\n    # print(maxProfit([7,1,5,3,6,4]))\n    print(minSubArrayLen(7, [2, 3,"}
{"task_id": "leetcode/209", "completion": "\n    if not nums:\n        return 0\n    left, sum_value = 0, 0\n    minlen = len(nums)+1\n    for i in range(len(nums)):\n        sum_value += nums[i]\n        while sum_value >= target:\n            minlen = min(minlen, i+1-left)\n            sum_value -= nums[left]\n            left += 1\n    return minlen if minlen < len(nums)+1 else 0\n\ndef minWindow(s, t):\n    '''\n    给定一个字符串 s 和一个字符串 t ，请在 s 中找出包含 t 所有字母的最小子串。\n    输入: s = \"ADOBECODEBANC\", t = \"ABC\"\n    输出: \"BANC\"\n    '''\n    if not s or not t:\n        return ''\n    counter = {k:0 for k in t}\n    r = 0\n    l = 0\n    ans = 0\n", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    if not nums:\n        return 0\n    left, sum_value = 0, 0\n    minlen = len(nums)+1\n    for i in range(len(nums)):\n        sum_value += nums[i]\n        while sum_value >= target:\n            minlen = min(minlen, i+1-left)\n            sum_value -= nums[left]\n            left += 1\n    return minlen if minlen < len(nums)+1 else 0\n\ndef minWindow(s, t):\n    '''\n    给定一个字符串 s 和一个字符串 t ，请在 s 中找出包含 t 所有字母的最小子串。\n    输入: s = \"ADOBECODEBANC\", t = \"ABC\"\n    输出: \"BANC\"\n    '''\n    if not s or not t:\n        return ''\n    counter = {k:0 for k in t}\n    r = 0\n    l = 0\n    ans = 0\n"}
{"task_id": "leetcode/209", "completion": "\n    # 滑动窗口 双指针\n    left = 0\n    right = 0\n    min_sub_array = len(nums)\n    sub_array = []\n    sum = 0\n    while right < len(nums):\n        sum += nums[right]\n        while sum >= target:\n            min_sub_array = min(min_sub_array, right-left+1)\n            sub_array.append(nums[left])\n            sum -= nums[left]\n            left += 1\n        right += 1\n    return min_sub_array if min_sub_array!= len(nums) else 0\n\n\ndef minWindow(s, t):\n    '''\n    给你一个字符串 s 、一个字符串 t 。返回 s 中字符串 t 的 最小子串 。如果字符串 t 是 s 的子串，那么返回 t 。\n    >>> minWindow('ADOBECODEBANC', 'ABC')\n    'BAN", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 滑动窗口 双指针\n    left = 0\n    right = 0\n    min_sub_array = len(nums)\n    sub_array = []\n    sum = 0\n    while right < len(nums):\n        sum += nums[right]\n        while sum >= target:\n            min_sub_array = min(min_sub_array, right-left+1)\n            sub_array.append(nums[left])\n            sum -= nums[left]\n            left += 1\n        right += 1\n    return min_sub_array if min_sub_array!= len(nums) else 0\n\n\ndef minWindow(s, t):\n    '''\n    给你一个字符串 s 、一个字符串 t 。返回 s 中字符串 t 的 最小子串 。如果字符串 t 是 s 的子串，那么返回 t 。\n    >>> minWindow('ADOBECODEBANC', 'ABC')\n    'BAN"}
{"task_id": "leetcode/209", "completion": "\n    # 缓存子数组的和\n    sub_array_sus = {}\n    sub_array_sum = 0\n    for i in range(len(nums)):\n        sub_array_sum = 0\n        # 遍历到 i 个元素的子数组\n        for j in range(i, len(nums)):\n            print(sub_array_sum)\n            # 子数组和大于等于 target\n            if sub_array_sum >= target:\n                print(i, j)\n                return j - i + 1\n\n            # 更新子数组和\n            sub_array_sum += nums[j]\n            if sub_array_sum not in sub_array_sus:\n                sub_array_sus[sub_array_sum] = j\n        print(sub_array_sus)\n\n    return 0\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2, 3, 1, 2, 4, 3", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    # 缓存子数组的和\n    sub_array_sus = {}\n    sub_array_sum = 0\n    for i in range(len(nums)):\n        sub_array_sum = 0\n        # 遍历到 i 个元素的子数组\n        for j in range(i, len(nums)):\n            print(sub_array_sum)\n            # 子数组和大于等于 target\n            if sub_array_sum >= target:\n                print(i, j)\n                return j - i + 1\n\n            # 更新子数组和\n            sub_array_sum += nums[j]\n            if sub_array_sum not in sub_array_sus:\n                sub_array_sus[sub_array_sum] = j\n        print(sub_array_sus)\n\n    return 0\n\n\nif __name__ == '__main__':\n    print(minSubArrayLen(7, [2, 3, 1, 2, 4, 3"}
{"task_id": "leetcode/209", "completion": "\n    i, j, sum, minLen = 0, 0, 0, len(nums) + 1\n    while j < len(nums) and i <= j:\n        sum += nums[j]\n        while sum >= target:\n            minLen = min(minLen, j - i + 1)\n            sum -= nums[i]\n            i += ", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    i, j, sum, minLen = 0, 0, 0, len(nums) + 1\n    while j < len(nums) and i <= j:\n        sum += nums[j]\n        while sum >= target:\n            minLen = min(minLen, j - i + 1)\n            sum -= nums[i]\n            i += "}
{"task_id": "leetcode/209", "completion": "\n    total = 0\n    start = 0\n    min_len = float('inf')\n    for end in range(len(nums)):\n        total += nums[end]\n        while total >= target:\n            min_len = min(min_len, end - start + 1)\n            total -= nums[start]\n            start += 1\n    return min_len if min_len!= float('inf') else 0\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n   给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n    请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1, 3], [2])\n    2.0\n    >>>", "allcode": "def minSubArrayLen(target, nums):\n    '''\n   给定一个含有 n 个正整数的数组和一个正整数 target 。\n    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，返回其长度。\n    如果不存在符合条件的子数组，返回 0 。\n    >>> minSubArrayLen(7, [2,3,1,2,4,3])\n    2\n    >>> minSubArrayLen(4, [1,4,4])\n    1\n    >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n    0\n    '''\n    total = 0\n    start = 0\n    min_len = float('inf')\n    for end in range(len(nums)):\n        total += nums[end]\n        while total >= target:\n            min_len = min(min_len, end - start + 1)\n            total -= nums[start]\n            start += 1\n    return min_len if min_len!= float('inf') else 0\n\n\ndef findMedianSortedArrays(nums1, nums2):\n    '''\n   给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n    请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n    你可以假设 nums1 和 nums2 不会同时为空。\n    >>> findMedianSortedArrays([1, 3], [2])\n    2.0\n    >>>"}
{"task_id": "leetcode/1", "completion": "\n    ans = []\n    num_dict = {}\n    for i in range(len(nums)):\n        if target - nums[i] in num_dict:\n            if num_dict[target-nums[i]] == i: # 不能重复出现\n                ans = [i, num_dict[target-nums[i]]]\n            else:\n                ans.append(num_dict[target-nums[i]])\n                ans.append(i)\n            break\n        else:\n            num_dict[nums[i]] = i\n    if len(ans) == 0:\n        return -1\n    return ans\n\n\ndef singleNum(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    :param nums:\n    :return:\n    >>> singleNum([4,1,2,1,2])", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    ans = []\n    num_dict = {}\n    for i in range(len(nums)):\n        if target - nums[i] in num_dict:\n            if num_dict[target-nums[i]] == i: # 不能重复出现\n                ans = [i, num_dict[target-nums[i]]]\n            else:\n                ans.append(num_dict[target-nums[i]])\n                ans.append(i)\n            break\n        else:\n            num_dict[nums[i]] = i\n    if len(ans) == 0:\n        return -1\n    return ans\n\n\ndef singleNum(nums):\n    '''\n    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n    :param nums:\n    :return:\n    >>> singleNum([4,1,2,1,2])"}
{"task_id": "leetcode/1", "completion": "\n    assert len(nums) > 1, 'nums must be more than one length'\n    assert len(nums) == len(set(nums)), 'nums do not contain duplicate numbers'\n\n    dict_nums = {num: idx for idx, num in enumerate(nums)}\n    for idx, num in enumerate(nums):\n        if num in dict_nums:\n            if dict_nums[num] == idx:\n                continue\n            else:\n                return [idx, dict_nums[num]]\n\n\nif __name__ == '__main__':\n    nums = [3,2,4]\n    target = 6\n    twoSum(nums, target)\n    # nums = [3,3]\n    # target = 6\n    # twoSum(nums, target)\n    # # nums = [2,2,2,2,2]\n    # # target = 8\n    # # twoSum(nums, target)\n    # # nums = [2,2,2,2,2,2]\n    # #", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    assert len(nums) > 1, 'nums must be more than one length'\n    assert len(nums) == len(set(nums)), 'nums do not contain duplicate numbers'\n\n    dict_nums = {num: idx for idx, num in enumerate(nums)}\n    for idx, num in enumerate(nums):\n        if num in dict_nums:\n            if dict_nums[num] == idx:\n                continue\n            else:\n                return [idx, dict_nums[num]]\n\n\nif __name__ == '__main__':\n    nums = [3,2,4]\n    target = 6\n    twoSum(nums, target)\n    # nums = [3,3]\n    # target = 6\n    # twoSum(nums, target)\n    # # nums = [2,2,2,2,2]\n    # # target = 8\n    # # twoSum(nums, target)\n    # # nums = [2,2,2,2,2,2]\n    # #"}
{"task_id": "leetcode/1", "completion": "\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n        else:\n            nums[i] = nums[i] - target\n            if nums[i] in nums:\n                return nums.index(nums[i]), i\n            else:\n                continue\n```\n```\npython 3.7.4\n\nPython 3.7.4 (default, May 27 2019, 09:28:24) \n[Clang 10.0.1 (clang-1001.0.41.4)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> twoSum([3,2,4], 6)\n[1, 2]\n>>> twoSum([3,3], 6)\n[0, 1]\n>>> \n```\n\n### 2.3 最长数对链\n```python\ndef findLongestChain(n):\n    '''\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n        else:\n            nums[i] = nums[i] - target\n            if nums[i] in nums:\n                return nums.index(nums[i]), i\n            else:\n                continue\n```\n```\npython 3.7.4\n\nPython 3.7.4 (default, May 27 2019, 09:28:24) \n[Clang 10.0.1 (clang-1001.0.41.4)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> twoSum([3,2,4], 6)\n[1, 2]\n>>> twoSum([3,3], 6)\n[0, 1]\n>>> \n```\n\n### 2.3 最长数对链\n```python\ndef findLongestChain(n):\n    '''\n"}
{"task_id": "leetcode/1", "completion": "\n    # 散列表\n    res = {}\n    for i in range(len(nums)):\n        k = target - nums[i]\n        if k in res:\n            return [res[k], i]\n        else:\n            res[nums[i]] = i\n\n\nif __name__ == '__main__':\n\n    import doctest\n    doctest.testmod(verbose=True)\n\n    arr = [3,2,4]\n    target = 8\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [3,2,4]\n    target = 6\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [0,0,3,4]\n    target = 0\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [3,3]\n    target = 6\n    res = twoSum(arr, target)\n    print(res", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    # 散列表\n    res = {}\n    for i in range(len(nums)):\n        k = target - nums[i]\n        if k in res:\n            return [res[k], i]\n        else:\n            res[nums[i]] = i\n\n\nif __name__ == '__main__':\n\n    import doctest\n    doctest.testmod(verbose=True)\n\n    arr = [3,2,4]\n    target = 8\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [3,2,4]\n    target = 6\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [0,0,3,4]\n    target = 0\n    res = twoSum(arr, target)\n    print(res)\n\n    arr = [3,3]\n    target = 6\n    res = twoSum(arr, target)\n    print(res"}
{"task_id": "leetcode/1", "completion": "\n    for i in range(len(nums)):\n        need = target - nums[i]\n        for j in range(i + 1, len(nums)):\n            if nums[j] == need:\n                return i, j\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    你可以按任意顺序返回答案。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    [", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    for i in range(len(nums)):\n        need = target - nums[i]\n        for j in range(i + 1, len(nums)):\n            if nums[j] == need:\n                return i, j\n\ndef twoSum2(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    你可以按任意顺序返回答案。\n    >>> twoSum2([3,2,4], 6)\n    [1, 2]\n    >>> twoSum2([3,3], 6)\n    ["}
{"task_id": "leetcode/1", "completion": "\n    cache = {}\n    for index, item in enumerate(nums):\n        if target - item in cache:\n            return [cache[target - item], index]\n        cache[item] = index\n\n\ndef maxInWindows(nums, size):\n    '''\n    给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n    返回滑动窗口中的最大值。\n    >>> maxInWindows([1,3,-1,-3,5,3,6,7], 3)\n    [3, 3, 5, 5, 6, 7]\n    '''\n    cache = [-sys.maxsize] * size\n    index = 0\n    res = []\n    for index, item in enumerate(nums):\n", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    cache = {}\n    for index, item in enumerate(nums):\n        if target - item in cache:\n            return [cache[target - item], index]\n        cache[item] = index\n\n\ndef maxInWindows(nums, size):\n    '''\n    给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n    返回滑动窗口中的最大值。\n    >>> maxInWindows([1,3,-1,-3,5,3,6,7], 3)\n    [3, 3, 5, 5, 6, 7]\n    '''\n    cache = [-sys.maxsize] * size\n    index = 0\n    res = []\n    for index, item in enumerate(nums):\n"}
{"task_id": "leetcode/1", "completion": "\n    dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in dict:\n            return [dict[complement], i]\n        dict[nums[i]] = i\n\na = twoSum([3,2,4], 6)\nprint(a)\n\na = twoSum([3,3], 6)\nprint(a)\n\nnums = [3,3]\ntarget = 6\n# 暴力解法\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in dict:\n            return [dict[complement], i]\n        dict[nums[i]] = i\n\na = twoSum([3,2,4], 6)\nprint(a)\n\na = twoSum([3,3], 6)\nprint(a)\n\nnums = [3,3]\ntarget = 6\n# 暴力解法\ndef twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。"}
{"task_id": "leetcode/1", "completion": "\n    if not nums or len(nums) <= 1:\n        return None\n    dic = {}\n    for i, num in enumerate(nums):\n        dic[num] = i\n    for i, num in enumerate(nums):\n        if num in dic:\n            return [i, dic[target-num]]\n    return None\n\n\nif __name__ == \"__main__\":", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    if not nums or len(nums) <= 1:\n        return None\n    dic = {}\n    for i, num in enumerate(nums):\n        dic[num] = i\n    for i, num in enumerate(nums):\n        if num in dic:\n            return [i, dic[target-num]]\n    return None\n\n\nif __name__ == \"__main__\":"}
{"task_id": "leetcode/1", "completion": "\n    nums = dict(zip(nums, range(len(nums))))\n    for index, n in enumerate(nums):\n        if target - n in nums and index!= nums[target - n]:\n            return [index, nums[target - n]]\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例：\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1])\n    1\n    >>> maxSubArray([1,-2,1])\n    2\n    '''\n    pre = 0\n    ans = nums[0]\n    for v in nums:\n        pre = max(0, pre) + v\n        ans = max(ans, pre)\n    return ans\n\n\ndef combination", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    nums = dict(zip(nums, range(len(nums))))\n    for index, n in enumerate(nums):\n        if target - n in nums and index!= nums[target - n]:\n            return [index, nums[target - n]]\n\n\ndef maxSubArray(nums):\n    '''\n    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n    示例：\n    >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    6\n    >>> maxSubArray([1])\n    1\n    >>> maxSubArray([1,-2,1])\n    2\n    '''\n    pre = 0\n    ans = nums[0]\n    for v in nums:\n        pre = max(0, pre) + v\n        ans = max(ans, pre)\n    return ans\n\n\ndef combination"}
{"task_id": "leetcode/1", "completion": "\n    t = sorted(nums)\n    for i, num in enumerate(t):\n        if t[i] > target:\n            pass\n        elif t[i] == target:\n            return i, i\n        else:\n            if t[i] + t[-1] > target:\n                continue\n            else:\n                for j in range(i + 1, len(t)):\n                    if t[i] + t[j] == target:\n                        return i, j\n\n\nif __name__ == \"__main__\":\n    '''\n    如果数组中有重复的元素，则任意两个下标都可能满足条件。\n    如果没有满足条件的元素，则返回[0, 0]。\n    '''\n    print(twoSum([3, 3], 6))\n    print(twoSum([2, 7, 11, 15], 9))\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, ", "allcode": "def twoSum(nums, target):\n    '''\n    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。\n    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n    按升序返回两个下标。\n    >>> twoSum([3,2,4], 6)\n    [1, 2]\n    >>> twoSum([3,3], 6)\n    [0, 1]\n    '''\n    t = sorted(nums)\n    for i, num in enumerate(t):\n        if t[i] > target:\n            pass\n        elif t[i] == target:\n            return i, i\n        else:\n            if t[i] + t[-1] > target:\n                continue\n            else:\n                for j in range(i + 1, len(t)):\n                    if t[i] + t[j] == target:\n                        return i, j\n\n\nif __name__ == \"__main__\":\n    '''\n    如果数组中有重复的元素，则任意两个下标都可能满足条件。\n    如果没有满足条件的元素，则返回[0, 0]。\n    '''\n    print(twoSum([3, 3], 6))\n    print(twoSum([2, 7, 11, 15], 9))\n    print(twoSum([3, 2, 4], 6))\n    print(twoSum([3, "}
{"task_id": "leetcode/409", "completion": "\n    # 判断回文串 - 时间复杂度 O(n^2)\n    def isPalindrome(s):\n        l = len(s)\n        for i in range(l // 2):\n            if s[i]!= s[l - 1 - i]:\n                return False\n        return True\n\n    # 返回回文子串最大长度\n    def maxLenPalindromeSub(s):\n        max_len = 0\n        for i in range(len(s)):\n            # + 2 是防止边界出现错误，因为我们只考虑包含中心的子串，因此如果是考虑 s[i:j] 中的子串，j 不得等于 n 位，此时中心压根就不在 s 中了\n            for j in range(i + 1, len(s) - 1):\n                if isPalindrome(s[i:j + 1]):\n                   ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 判断回文串 - 时间复杂度 O(n^2)\n    def isPalindrome(s):\n        l = len(s)\n        for i in range(l // 2):\n            if s[i]!= s[l - 1 - i]:\n                return False\n        return True\n\n    # 返回回文子串最大长度\n    def maxLenPalindromeSub(s):\n        max_len = 0\n        for i in range(len(s)):\n            # + 2 是防止边界出现错误，因为我们只考虑包含中心的子串，因此如果是考虑 s[i:j] 中的子串，j 不得等于 n 位，此时中心压根就不在 s 中了\n            for j in range(i + 1, len(s) - 1):\n                if isPalindrome(s[i:j + 1]):\n                   "}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    dp = [0] * len(s)\n    for i in range(len(s) - 1, -1, -1):\n        dp[i] = 1\n        j = i\n        while j < len(s) - 1:\n            if s[j + 1] == s[i]:\n                dp[i] += 2\n                j += 2\n            else:\n                break\n    return max(dp)\n\n\ndef find_all_anagrams(s, p):\n    '''\n    给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n    p 和 s 中仅包含英文小写字母。字符串答案中不可以包含重复的起始索引。\n    >>> find_all_anagrams('cba", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    dp = [0] * len(s)\n    for i in range(len(s) - 1, -1, -1):\n        dp[i] = 1\n        j = i\n        while j < len(s) - 1:\n            if s[j + 1] == s[i]:\n                dp[i] += 2\n                j += 2\n            else:\n                break\n    return max(dp)\n\n\ndef find_all_anagrams(s, p):\n    '''\n    给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n    p 和 s 中仅包含英文小写字母。字符串答案中不可以包含重复的起始索引。\n    >>> find_all_anagrams('cba"}
{"task_id": "leetcode/409", "completion": "\n    if len(s) < 2 :\n        return len(s)\n    dp = [0] * len(s)\n    l = 1\n    ans = 1\n    for i in range(len(s)):\n        for j in range(i+1):\n            if s[i] == s[j]:\n                if i-j < 2:\n                    dp[i] = 2\n                else:\n                    dp[i] = dp[i-1]+2\n        if l < dp[i]:\n            l = dp[i]\n            ans = i+1\n    return ans\n\n\n# 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n# 示例 1： 输入: \"babad\"\n# 输出: \"bab\"\n# 注意: \"aba\" 也是一个有效答案。\nfrom typing import List\n\ndef", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if len(s) < 2 :\n        return len(s)\n    dp = [0] * len(s)\n    l = 1\n    ans = 1\n    for i in range(len(s)):\n        for j in range(i+1):\n            if s[i] == s[j]:\n                if i-j < 2:\n                    dp[i] = 2\n                else:\n                    dp[i] = dp[i-1]+2\n        if l < dp[i]:\n            l = dp[i]\n            ans = i+1\n    return ans\n\n\n# 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n# 示例 1： 输入: \"babad\"\n# 输出: \"bab\"\n# 注意: \"aba\" 也是一个有效答案。\nfrom typing import List\n\ndef"}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    max_len = 0\n    for i in range(len(s)):\n        l = helper_longestPalindrome(s, i, i)\n        r = helper_longestPalindrome(s, i, i+1)\n        max_len = max(l, r, max_len)\n    return max_len\n\n\ns = \"bb\"\nprint(longestPalindrome(s))\n\n# ---\n# 下面是辅助函数\n\n\ndef helper_longestPalindrome(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\n\n# 测试用例:\ns = \"abccccdd\"\nprint(helper_longestPalindrome(s, 1, 2))\n# 输出 0 说明左右指针没有匹配上\nprint(helper_longest", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    max_len = 0\n    for i in range(len(s)):\n        l = helper_longestPalindrome(s, i, i)\n        r = helper_longestPalindrome(s, i, i+1)\n        max_len = max(l, r, max_len)\n    return max_len\n\n\ns = \"bb\"\nprint(longestPalindrome(s))\n\n# ---\n# 下面是辅助函数\n\n\ndef helper_longestPalindrome(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\n\n# 测试用例:\ns = \"abccccdd\"\nprint(helper_longestPalindrome(s, 1, 2))\n# 输出 0 说明左右指针没有匹配上\nprint(helper_longest"}
{"task_id": "leetcode/409", "completion": "\n    n = len(s)\n    if n < 2:\n        return n\n    dp = [0] * n\n    answer = 0\n    for i in range(n):\n        left, right = i, i\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n            if right - left - 1 > dp[right]:\n                dp[right] = right - left - 1\n        left, right = i, i + 1", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    n = len(s)\n    if n < 2:\n        return n\n    dp = [0] * n\n    answer = 0\n    for i in range(n):\n        left, right = i, i\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n            if right - left - 1 > dp[right]:\n                dp[right] = right - left - 1\n        left, right = i, i + 1"}
{"task_id": "leetcode/409", "completion": "\n    # 如果字符串长度小于2直接返回长度\n    if len(s) < 2: return len(s)\n    # 遍历所有字符串的每一个字符\n    max = 1\n    for i in range(len(s)):\n        start = 0\n        end = 0\n        while i - start >= 0 and i + end + 1 < len(s):\n            if s[i - start] == s[i + end + 1]:\n                start += 1\n                end += 1\n                if start > max:\n                    max = start\n            else:\n                break\n    return max\n\n\ndef findSubstring(s: str, t: str) -> List[int]:\n    '''\n    给定两个字符串s和t，找到s中所有t的子串，返回它们的起始和终止位置。如果没有这样的子串，返回空列表。\n    >>> findSubstring(\"ababacab", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 如果字符串长度小于2直接返回长度\n    if len(s) < 2: return len(s)\n    # 遍历所有字符串的每一个字符\n    max = 1\n    for i in range(len(s)):\n        start = 0\n        end = 0\n        while i - start >= 0 and i + end + 1 < len(s):\n            if s[i - start] == s[i + end + 1]:\n                start += 1\n                end += 1\n                if start > max:\n                    max = start\n            else:\n                break\n    return max\n\n\ndef findSubstring(s: str, t: str) -> List[int]:\n    '''\n    给定两个字符串s和t，找到s中所有t的子串，返回它们的起始和终止位置。如果没有这样的子串，返回空列表。\n    >>> findSubstring(\"ababacab"}
{"task_id": "leetcode/409", "completion": "\n    if len(s) < 2 or len(s) < 1: return 0\n    # 考虑一个特殊情况[见链接]\n    if s == s[::-1]: return len(s)\n    return 1 + min(longestPalindrome(s[1:]), longestPalindrome(s[:-1]))\n\n\ndef longestPalindrome_2(s: str) -> int:\n    '''\n    给你一个字符串 s，找到 s 中最长的回文子串。\n    输入: \"babad\"\n    输出: \"bab\"\n    解释: \"aba\" 同样是符合题意的答案。\n    '''\n    n = len(s)\n    if n < 2: return n\n    dp = [[False for _ in range(n)] for _ in range(n)]\n    # 注意这里是 n-1，而不是n\n    for i in range(n-1", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if len(s) < 2 or len(s) < 1: return 0\n    # 考虑一个特殊情况[见链接]\n    if s == s[::-1]: return len(s)\n    return 1 + min(longestPalindrome(s[1:]), longestPalindrome(s[:-1]))\n\n\ndef longestPalindrome_2(s: str) -> int:\n    '''\n    给你一个字符串 s，找到 s 中最长的回文子串。\n    输入: \"babad\"\n    输出: \"bab\"\n    解释: \"aba\" 同样是符合题意的答案。\n    '''\n    n = len(s)\n    if n < 2: return n\n    dp = [[False for _ in range(n)] for _ in range(n)]\n    # 注意这里是 n-1，而不是n\n    for i in range(n-1"}
{"task_id": "leetcode/409", "completion": "\n    if not s:\n        return 0\n    max_length = 0\n    for i in range(len(s)):\n        # 计算回文串的长度，但不含头\n        tmp_length = get_palindrome_length(s, i, i)\n        # 计算回文串长度，含头\n        tmp_length = max(get_palindrome_length(s, i, i + 1), tmp_length)\n        # 选择最长的回文串\n        max_length = max(max_length, tmp_length)\n        # 如果奇数长度，对中间字符进行回文串计算\n        if i < len(s) - 1:\n            mid_length = get_palindrome_length(s, i, i + 1)\n            max_length = max(mid_length, max_length)\n    return max_length\n\ndef get_palindrome_length(s, left, right):\n    '''\n    计算 [left, right]", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    if not s:\n        return 0\n    max_length = 0\n    for i in range(len(s)):\n        # 计算回文串的长度，但不含头\n        tmp_length = get_palindrome_length(s, i, i)\n        # 计算回文串长度，含头\n        tmp_length = max(get_palindrome_length(s, i, i + 1), tmp_length)\n        # 选择最长的回文串\n        max_length = max(max_length, tmp_length)\n        # 如果奇数长度，对中间字符进行回文串计算\n        if i < len(s) - 1:\n            mid_length = get_palindrome_length(s, i, i + 1)\n            max_length = max(mid_length, max_length)\n    return max_length\n\ndef get_palindrome_length(s, left, right):\n    '''\n    计算 [left, right]"}
{"task_id": "leetcode/409", "completion": "\n    # 双指针法\n    max_len = 0\n    for i in range(1, len(s)):\n        dp = [[False for _ in range(len(s))] for _ in range(len(s))]\n        for j in range(len(s)):\n            is_palindrome = True\n            for k in range(i, j):\n                if j - i < 3:\n                    is_palindrome = True\n                else:\n                    is_palindrome = is_palindrome and dp[i][k] and dp[k + 1][j]\n                dp[i][j] = is_palindrome\n        max_len = max(max_len, dp[i][len(s) - 1])\n    return max_len\n\n\ndef numSquares(n):\n    '''\n    Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16,...) which sum to n.\n    >>> numSquares(12)\n    ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    # 双指针法\n    max_len = 0\n    for i in range(1, len(s)):\n        dp = [[False for _ in range(len(s))] for _ in range(len(s))]\n        for j in range(len(s)):\n            is_palindrome = True\n            for k in range(i, j):\n                if j - i < 3:\n                    is_palindrome = True\n                else:\n                    is_palindrome = is_palindrome and dp[i][k] and dp[k + 1][j]\n                dp[i][j] = is_palindrome\n        max_len = max(max_len, dp[i][len(s) - 1])\n    return max_len\n\n\ndef numSquares(n):\n    '''\n    Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16,...) which sum to n.\n    >>> numSquares(12)\n    "}
{"task_id": "leetcode/409", "completion": "\n    return _longestPalindrome(s, 0, len(s) - 1)\n\ndef _longestPalindrome(s, start, end):\n    '''\n    以s中位置start和end为中心，返回一个回文串\n    '''\n    if start == end:\n        return 1\n\n    if start + 1 == end:\n        return 2 if s[start]==s[end] else 1\n\n    # 以start和end为中心，尝试着构造回文串，如果刚好能构造一个回文串，那么返回值为2，否则返回值为1\n    if s[start] == s[end]:\n        # 尝试着向两边扩展\n        return 2 + _longestPalindrome(s, start + 1, end - 1)\n    else:\n        return max(_longestPalindrome(s, start + 1, end), _longestPalindrome(s, start, end - ", "allcode": "def longestPalindrome(s):\n    '''\n    给你一个包含小写字母的字符串 's', 返回使用's'中的字符可以构造的最长回文串的长度。\n    >>> longestPalindrome(\"abccccdd\")\n    7\n    >>> longestPalindrome(\"a\")\n    1\n    >>> longestPalindrome(\"bb\")\n    2\n    '''\n    return _longestPalindrome(s, 0, len(s) - 1)\n\ndef _longestPalindrome(s, start, end):\n    '''\n    以s中位置start和end为中心，返回一个回文串\n    '''\n    if start == end:\n        return 1\n\n    if start + 1 == end:\n        return 2 if s[start]==s[end] else 1\n\n    # 以start和end为中心，尝试着构造回文串，如果刚好能构造一个回文串，那么返回值为2，否则返回值为1\n    if s[start] == s[end]:\n        # 尝试着向两边扩展\n        return 2 + _longestPalindrome(s, start + 1, end - 1)\n    else:\n        return max(_longestPalindrome(s, start + 1, end), _longestPalindrome(s, start, end - "}
{"task_id": "leetcode/121", "completion": "\n    maxProfit = 0\n    minPrice = prices[0]\n    for i in range(1,len(prices)):\n        # 判断是否应该买入股票，此时min为当日最低价，max为当日最高价\n        if prices[i] < minPrice:\n            minPrice = prices[i]\n        elif prices[i] - minPrice > maxProfit:\n            maxProfit = prices[i] - minPrice\n    return maxProfit\n\n\ndef maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    maxProfit = 0\n    minPrice = prices[0]\n    for i in range(1,len(prices)):\n        # 判断是否应该买入股票，此时min为当日最低价，max为当日最高价\n        if prices[i] < minPrice:\n            minPrice = prices[i]\n        elif prices[i] - minPrice > maxProfit:\n            maxProfit = prices[i] - minPrice\n    return maxProfit\n\n\ndef maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一"}
{"task_id": "leetcode/121", "completion": "\n    n = len(prices)\n    if n < 2:\n        return 0\n    profit = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            profit = max(profit, prices[j] - prices[i])\n    return profit\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利�", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    n = len(prices)\n    if n < 2:\n        return 0\n    profit = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            profit = max(profit, prices[j] - prices[i])\n    return profit\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利�"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) < 2:\n        return 0\n    res, min_price = 0, prices[0]\n    for price in prices[1:]:\n        res = max(res, price-min_price)\n        min_price = min(min_price, price)\n    return res\n\n\nif __name__ == \"__main__\":\n    import do", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) < 2:\n        return 0\n    res, min_price = 0, prices[0]\n    for price in prices[1:]:\n        res = max(res, price-min_price)\n        min_price = min(min_price, price)\n    return res\n\n\nif __name__ == \"__main__\":\n    import do"}
{"task_id": "leetcode/121", "completion": "\n    low = prices[0]\n    high = prices[0]\n    profit = 0\n    for num in prices:\n        low = min(low, num)\n        high = max(high, num)\n        profit = max(profit, num - low)\n    return profit\n\n\ndef minSubArrayLen(target, nums):\n    '''\n    给你一个含有 n 个正整数的数组和一个正整数 target 。\n    请你找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n    输入：target = 7, nums = [2,3,1,2,4,3]\n    输出：2\n    解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n    '''\n\n    low = 0\n    high", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    low = prices[0]\n    high = prices[0]\n    profit = 0\n    for num in prices:\n        low = min(low, num)\n        high = max(high, num)\n        profit = max(profit, num - low)\n    return profit\n\n\ndef minSubArrayLen(target, nums):\n    '''\n    给你一个含有 n 个正整数的数组和一个正整数 target 。\n    请你找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n    输入：target = 7, nums = [2,3,1,2,4,3]\n    输出：2\n    解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n    '''\n\n    low = 0\n    high"}
{"task_id": "leetcode/121", "completion": "\n    if not prices: return 0\n    max_profit, min_price = 0, prices[0]\n    for price in prices[1:]:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\ndef maxProfit1(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if not prices: return 0\n    max_profit, min_price = 0, prices[0]\n    for price in prices[1:]:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\ndef maxProfit1(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能"}
{"task_id": "leetcode/121", "completion": "\n    if not prices:\n        return 0\n    i = 0\n    minP = prices[0]\n    profit = 0\n    while i < len(prices):\n        if prices[i] < minP:\n            minP = prices[i]\n        elif prices[i]", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if not prices:\n        return 0\n    i = 0\n    minP = prices[0]\n    profit = 0\n    while i < len(prices):\n        if prices[i] < minP:\n            minP = prices[i]\n        elif prices[i]"}
{"task_id": "leetcode/121", "completion": "\n    n = len(prices)\n    if n <= 1:\n        return 0\n\n    # 第一天买入, 第二天卖出. 价格递减, 一次性卖出.\n    buy = prices[0]\n    sell = 0\n    for i in range(1, n):\n        if prices[i] - buy > sell:\n            sell = prices[i] - buy\n        if buy > prices[i]:\n            buy = prices[i]\n    return sell\n\n    # # 贪心方法, 遍历所有情况.\n    # profit = 0\n    # for i in range(n - 1):\n    #     if prices[i] < prices[i+1]:\n    #         profit += prices[i+1] - prices[i]\n    # return profit\n\n\ndef maxProfit2(self, prices: list) -> int:\n    n = len(prices)\n    if n < 2:\n        return", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    n = len(prices)\n    if n <= 1:\n        return 0\n\n    # 第一天买入, 第二天卖出. 价格递减, 一次性卖出.\n    buy = prices[0]\n    sell = 0\n    for i in range(1, n):\n        if prices[i] - buy > sell:\n            sell = prices[i] - buy\n        if buy > prices[i]:\n            buy = prices[i]\n    return sell\n\n    # # 贪心方法, 遍历所有情况.\n    # profit = 0\n    # for i in range(n - 1):\n    #     if prices[i] < prices[i+1]:\n    #         profit += prices[i+1] - prices[i]\n    # return profit\n\n\ndef maxProfit2(self, prices: list) -> int:\n    n = len(prices)\n    if n < 2:\n        return"}
{"task_id": "leetcode/121", "completion": "\n    # 先排序，再遍历即可，还是最容易想到的方法\n    if len(prices) < 2:\n        return 0\n    prices = sorted(prices)\n    min_price = prices[-1]\n    profit = 0\n    for p in range(len(prices) - 2, -1, -1):\n        if prices[p] > min_price:\n            profit = profit + prices[p] - min_price\n        else:\n            min_price = prices[p]\n    return profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 �", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    # 先排序，再遍历即可，还是最容易想到的方法\n    if len(prices) < 2:\n        return 0\n    prices = sorted(prices)\n    min_price = prices[-1]\n    profit = 0\n    for p in range(len(prices) - 2, -1, -1):\n        if prices[p] > min_price:\n            profit = profit + prices[p] - min_price\n        else:\n            min_price = prices[p]\n    return profit\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 �"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) < 2:\n        return 0\n    buy = prices[0]\n    sell = 0\n    for price in prices:\n        if price < buy:\n            buy = price\n        elif price - buy > sell:\n            sell = price - buy\n    return sell\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利��", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) < 2:\n        return 0\n    buy = prices[0]\n    sell = 0\n    for price in prices:\n        if price < buy:\n            buy = price\n        elif price - buy > sell:\n            sell = price - buy\n    return sell\n\n\ndef maxProfit2(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利��"}
{"task_id": "leetcode/121", "completion": "\n    if len(prices) == 0:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    print(\"hello world\")\n\n\nif __name__ == '", "allcode": "def maxProfit(prices):\n    '''\n    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n    >>> maxProfit([7,1,5,3,6,4])\n    5\n    >>> maxProfit([7,6,4,3,1])\n    0\n    '''\n    if len(prices) == 0:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    print(\"hello world\")\n\n\nif __name__ == '"}

